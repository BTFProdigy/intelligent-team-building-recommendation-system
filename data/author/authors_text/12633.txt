Coling 2008: Proceedings of the workshop on Grammar Engineering Across Frameworks, pages 41?48
Manchester, August 2008
          From Grammar-Independent Construction Enumeration to 
Lexical Types in Computational Grammars 
 Lars Hellan 
NTNU  
N-7491 Trondheim 
Norway 
lars.hellan@hf.ntnu.no 
 
 
Abstract 
The paper presents a code for enumerat-
ing verb-construction templates, from 
which lexical type inventories of compu-
tational grammars can be derived, and 
test suites can be systematically devel-
oped. The templates also serve for de-
scriptive and typological research. The 
code is string-based, with divisions into 
slots providing modularity and flexibility 
of specification.  
 
1 Introduction 
This paper presents a code for enumerating verb-
construction templates. The code is string-based, 
with divisions into slots providing modularity 
and flexibility of specification. The templates 
provide slots for specifying, relative to a con-
struction 
- part of speech (POS) of the head 
- grammatical relations exposed 
- valence bound items 
- thematic roles expressed 
- situation type 
- aspect (Aktionsart)  
- part of speech of valence-bound items. 
(These parameters altogether cover what is com-
monly referred to as 'argument structure' relative 
to the main predicate.) The code is outlined in 
sections 2-5, and 8. 
From the verb construction templates, lexical 
type inventories of computational grammars can 
                                                          
 ? 2008. Licensed under the Creative Commons Attri-
bution-Noncommercial-Share Alike 3.0 Unported 
license (http://creativecommons.org/licenses/by-nc-
sa/3.0/). Some rights reserved. 
 
be derived (section 6). The design offers a sys-
tematic way of organizing test suites, and here-
with improved means of defining intra- and 
cross-framework reference points of coverage 
and depth of analysis. The template code also 
lends itself for descriptive and typological re-
search (section 7). 
The design is not geared to any particular 
framework of computational grammar or linguis-
tics. Examples will be offered relative to HPSG- 
and LFG- grammars, and the actual conversions 
from templates to lexical types so far developed 
relate to HPSG grammars using the LKB plat-
form (cf. (Copestake 2002)), based on the 'HPSG 
Grammar Matrix' design ((Bender et al 2002)). 
Our exposition will be based on the design as it 
relates to the LKB-grammar NorSource (cf. 
(Beermann and Hellan 2004)) and a Verb-
Construction enumeration for Norwegian. 
The enterprise here presented has lines going 
back at least to the mid and late 80ies, both re-
garding test suite development (e.g., (Flickinger 
et al 1987), (Lehmann et al 1996)) and argu-
ment frame inventories ((Hellan et al 1889)).  
2 Code for Template Enumeration 
By a template for a verb construction we under-
stand a standardized way of exposing selected 
features of the construction. Exposed features are 
classificatory features, and in this respect, a tem-
plate may be regarded as a type.  
A system for enumerating templates should 
be designed such that they are, internal to a given 
language, complete and transparent, and across 
languages, comparable both in templates shared 
and in templates distinct. Technologically they 
should be as low level as possible, and platform 
independent, and be equally accessible to practis-
ing field linguists as to NLP researchers in com-
putational settings. With such desiderata in mind, 
41
we develop a code residing simply in strings of 
symbols with a minimum of internal syntax. 
The basic structural parts of such strings are 
referred to as slots. In the slot specification, the 
following conventions are observed: 
* Slots are interconnected by '-' (hyphen). 
* Distinct items inside a slot are interconnected 
by '_' (underline). 
* An item label containing neither ?-? nor ?_? is 
an uninterrupted string of letters. Internal com-
position is indicated by alternation between small 
and capital letters.  
The format can be applied also to non-verbal 
constructions, but we here focus exclusively on 
verbal ones. These have a template structure with 
five slots: 
Slot 1: POS of the head, and diathesis informa-
tion. 
Slot 2: Valency, or transitivity specification (e.g., 
intr, tr, ditr,... ). 
Slot 3: Dependents' specification (syntactic and 
referential properties of arguments). 
Slot 4: Participant roles. 
Slot 5: Situation type (written in SMALL CAPS). 
Slots 1 and 2 are always filled, the others need 
not be. A slot not specified is not displayed as 
empty; however, the sets of labels defined for the 
various slots are disjoint. Likewise, no labels are 
distinguished in terms of capital letter vs. not. (1) 
illustrates the composition, for a type instantiated 
by the clause Mary throws the ball: 
 
(1) v-tr-obDir-suAg_obEjct-EJECTION 
 
Slot 1 here says the head is Verb, slot 2 says that 
the construction is transitive, slot 3 says that the 
object har a directional function, slot 4 says that 
the thematic roles are 'agent', expressed by the 
subject, and 'ejected', expressed by the object, 
and slot 5 says that the situation type is one char-
acterizable as 'ejection'. 
We start with a survey of the labels used for 
slot 2, valence information. First, for the use of 
the notions intr, tr, ditr, the following defi-
nitions apply. By a direct syntactic argument of a 
verb, we understand a nominal constituent syn-
tactically related to the verb as subject-of, direct 
object-of, or indirect object-of, and any clausal 
constituent with either of these functions. (This 
includes expletive subjects and objects, and ex-
cludes clausal constituents in extraposed posi-
tion; it also excludes any NP or clause governed 
by a preposition or another relation-item.) An 
intransitive construction is then one with only 
SUBJECT as a direct syntactic argument, a transi-
tive construction has a SUBJECT and one OB-
JECT as direct syntactic arguments, and a ditran-
sitive construction has a SUBJECT and two OB-
JECTs as direct syntactic arguments. Any va-
lence-bound item other than those now described 
is represented by an extension of the above tran-
sitivity-strings, for instance, in the strings in-
trObl and trObl, Obl means 'oblique', that is, 
in addition to the number of arguments repre-
sented by intr/tr, there is a PP with 'selected' 
status. 
The valence slot includes information as to 
referential status of the arguments. We say that a 
direct syntactic argument is standardly linked 
when it has referential content and has a seman-
tic argument function relative to the verb. This 
excludes expletive subjects and expletive objects, 
as well as 'raised' full NPs. The following sub-
strings in slot 2 indicate the presence of items 
that are not standardly linked:  
Impers ('impersonal'), Presentational, Epon 
('extraposition'), Nrf ('non-referential'), Rais 
('item raised, i.e., non-argument'), Nrg ('non-
argument' - used in slot 3)). 
Specifications are sought to be non-redundant. 
For instance, the string intrEpon occurring in 
slot 2 entails that there is an expletive subject, 
and when used for a langauge like English, there 
is no need to say elsewhere that the subject is 
expletive. Since what is redundant relative to one 
language may not be so relative to another, ques-
tions of language-parametrized interpretation of 
code may arise; however, we do not have a basis 
yet for suggesting whether and how this would 
be accommodated. 
 
3 Valency labels 
The slot for valency, slot 2, has around 45 possi-
ble specifications relevant to Norwegian, and we 
state those in full, to give an impression of what 
may be the expected scope of this slot; an exam-
ple illustrates each type: 
 
intr = intransitive, i.e., with only SUBJECT as 
direct syntactic argument. 
intrImpers = impersonal intransitive, i.e., 
SUBJECT is an expletive not linked to any other 
item in the clause. (Ex.: det regner  'it rains') 
intrImpersPrtcl = impersonal intransitive 
with an aspectual particle. (Ex.: det klarner opp  
'it clears up') 
intrImpersObl = impersonal intransitive with 
an oblique argument. (Ex.: det synger i fjellene 
42
 'it sings in the mountains') 
intrPresentational = intransitive with a 
presentational structure, i.e., an expletive subject 
and an indefinite NP.  
intrDirPresentational = intrPresenta-
tional where the presented NP has a directional 
function. (Ex.: det springer en mann  'there runs a 
man') 
intrPresentationalLoc = intrPresenta-
tional with a locative constituent. (Ex.: det sitter 
en mann i stolen 'there sits a man in the chair') 
intrDir = intransitive where the subject has a 
directional function. (Ex.: gutten l?per  'the boy 
runs') 
intrAdv = intransitive with an obligatory ad-
verb. (Ex.: han fungerer godt  'he functions well') 
intrPrtcl = intransitive with an aspectual par-
ticle. (Ex.: regnet varer ved  'the rain lasts') 
intrObl = intransitive with an oblique argu-
ment. (Ex.: jeg snakker om Ola  'I talk about Ola') 
intrOblRais = intransitive with an oblique 
argument from which an NP has been 'raised'. 
(Ex.: han later til ? komme  'he appears [to] to come') 
intrScpr = intransitive with a secondary predi-
cate (Small Clause predicate). (Ex.: gutten virker 
syk 'the boy seems sick') 
intrEpon = intransitive with an 'extraposed' 
clause. (Ex.: det hender at han kommer 'it happens 
that he comes') 
intrPrtclEpon = intransitive with an 'extra-
posed' clause and an advparticle. (Ex.: det h?rer 
med at han kommer  Mock Eng: "it hears along that 
he comes") 
intrOblEpon = intransitive with an 'extraposed' 
clause and an oblique argument. (Ex.: det haster 
med ? rydde  Mock Eng: "it urges with to tiden up") 
intrPrtclOblEpon = intransitive with an 'ex-
traposed' clause, an oblique argument, and an 
advparticle. (Ex.: det ser ut til at han kommer Mock 
Eng: "it looks out to that he comes") 
intrPrtclOblRais = intransitive with an 
oblique argument from which an NP has been 
'raised', and an advparticle. (Ex.: han ser ut til ? 
komme Mock Eng: "he looks out to to come") 
intrImplicobjObl = intransitive with implicit 
object, followed by PP (Ex.: han s?lte p? seg 'he 
spilled on himself') 
tr = transitive, i.e., with SUBJECT and one OB-
JECT. 
trDir = transitive, where the subject is under-
stood in a directional function. (Ex.: Kari n?r top-
pen 'Kari reaches the top') 
trPrtcl = transitive with an advparticle. (Ex.: 
Kari fant ut svaret 'Kari found out the answer') 
trPresentational = presentational structure 
with an NP preceding the 'presented' NP. (Ex.: det 
venter ham en ulykke 'there awaits him an accident') 
trObl = transitive with an oblique. (Ex.: jeg 
sparker Ola i baken 'I kick Ola in the butt') 
trEponSu = transitive with an extraposed clause 
correlated with the subject, and an argument ob-
ject. (Ex.: det bekymrer meg at han kommer 'it wor-
ries me that he comes') 
trEponOb = transitive with an extraposed clause 
correlated with the object, and an argument sub-
ject.. (Ex.: vi muliggjorde det at han fikk innreisetil-
latelse 'we possible-made  it that he got entrance visa') 
trScpr = transitive with a secondary predicate 
(Small Clause predicate). (Ex.: han sparket ballen 
flat 'he kicked the ball flat') 
trNrf = transitive whose object is non-
referential. (Ex.: Kari skammer seg "Kari shamess 
herself" - 'Kari is ashamed') 
ditr = ditransitive, i.e., with SUBJECT and two 
OBJECTs (here referred to by the traditional 
terms 'indirect' ('iob') and 'direct' object, when 
distinction is necessary). 
ditrObl = ditransitive with oblique. (Ex.: jeg 
kaster Ola kakestykker i ansiktet  "I throw Ola cakes 
in the face" - 'I throw cakes in the face of Ola') 
ditrNrf = ditransitive whose indirect object is 
non-referential. (Ex.: han foresetter seg ? komme 
'he [foresetter] himself to come) 
copAdj = predicative copular construction with 
adjectival predicative. (Ex.: han er snill 'he is 
kind'). (Similarly: copN. (Ex.: han er bonde 'he is 
peasant'); copPP (Ex.: forestillingen var under 
enhver kritikk 'the perforrmance was below critique'); 
copPredprtcl (Ex.: Ola er som en gud  'Ola is 
like a god')) 
copIdN = identity copular construction with 
nominal predicative. (Ex.: dette er mannen 'this is 
the man'.) (Similarly: copIdAbsinf (Ex.: 
oppgaven er ? spise silden 'the task is to eat the her-
ring'.); copIdDECL (Ex.: problemet er at han spiser 
silden 'the problem is that he eats the herring'.); 
copIdYN (Ex.: problemet er om han spiser silden 
'the problem is whether he eats the herring'.); 
copIdWH (Ex.: sp?rsm?let er hvem som spiser silden 
'the question is who eats the herring'.)) 
copEponAdj =  predicative copular construction 
with adjectival predicative and the 'logical sub-
ject' extraposed. (Ex.: det er uvisst hvem som kom-
mer 'it is uncertain who that comes'.) Similarly: co-
pEponN (Ex.: det er et sp?rsm?l hvem som kommer 
'it is a question who comes'.); copEponPP (Ex.: det 
er hinsides diskusjon at han kommer 'it is beyond dis-
cussion that he comes'.); copEponPredprtcl 
43
(Ex.: det var som bestilt at han tapte igjen 'it was like 
booked that he lost again'.)) 
 
4 Dependents' labels 
The slot for dependents, slot 3, has around 40 
labels relevant for Norwegian. Each is built up 
with a first part indicating the grammatical func-
tion of the item specified (su, ob, iob, obl, 
sc, epon), and the remainder providing the 
specification, possibly also with some internal 
structure. The following lists most of them: 
suExpl = subject is an expletive. 
suDECL = subject is a declarative clause. (Simi-
larly: suYN = subject is a yes-no-interrogative 
clause; suWH = subject is a wh-interrogative 
clause; suAbsinf = subject is an infinitival 
clause with non-controlled interpretation.) 
suNrg = subject is a non-argument. 
obDir = object is understood in a directional 
capacity. 
obRefl = object is a reflexive. 
obReflExpl = object is an expletive reflexive. 
obDECL = object is a declarative clause. (Simi-
larly: obYN, obWH, obAbsInf) 
obEqInf = object is an infinitive equi-controlled 
by the only available possible controller. 
obEqSuInf = object is an infinitive equi-
controlled by subject. 
obEqIobInf =  object is an infinitive equi-
controlled by indirect object. 
obEqSuBareinf =  object is a bare infinitive 
equi-controlled by subject. 
obEqIobBareinf =  object is a bare infinitive 
equi-controlled by indirect object. 
iobRefl = indirect object is a reflexive. 
iobReflExpl = indirect object is an expletive 
reflexive. 
oblEqSuInf = the governee of the oblique is an 
infinitive equi-controlled by subject. 
oblEqObInf = the governee of the oblique is an 
infinitive equi-controlled by object. 
oblRaisInf =  the governee of the oblique is an 
infinitive which is raising-controlled by the sub-
ject. 
oblRefl = the governee of the oblique is a re-
flexive. 
oblDECL = the governee of the oblique is a de-
clarative clause. (Similarly: oblYN, oblWH, 
oblAbsinf) 
oblPRTOFsubj = the referent of the governee of 
the oblique is interpreted as part-of the referent 
of the subject. (Ex.: jeg fryser p? ryggen 'I freeze on 
the  back' - I'm cold on my back') 
oblPRTOFobj = the referent of the governee of 
the oblique is interpreted as part-of the referent 
of the object. . (Ex.: jeg sparker Ola i baken 'I kick 
Ola in the butt') 
oblPRTOFiobj = the referent of the governee 
of the oblique is interpreted as part-of the refer-
ent of the indirect object. (Ex.: jeg kaster Ola 
kakestykker i ansiktet  "I throw Ola cakes in the face" 
- 'I throw cakes in the face of Ola') 
oblEponAbsinf = extraposed is a non-
controlled infinitive occurring as governee of an 
oblique.  
oblEponDECL = extraposed is a declarative 
clause occurring as governee of an oblique.  
scSuNrg = the secondary predicate is predicated 
of a non-argument subject (i.e., a subject not 
serving as semantic argument of the matrix verb - 
i.e., a 'raising to subject' subject). 
scObNrg = the secondary predicate is predicated 
of a non-argument object (i.e., an object not serv-
ing as semantic argument of the matrix verb - i.e., 
a 'raising to object' object).  
scAdj = the secondary predicate is headed by an 
adjective. (Similarly: scN, scPP, 
scPredprtcl, scInf, scBareinf) 
eponDECL = extraposed is a declarative clause. 
(Similarly: eponYN, eponWH, eponCOND, epon-
EqInf, eponAbsinf) 
 
We illustrate with a use of the 'small clause' 
specification scSuNrg. One of the construction 
types it serves to qualify is exemplified by  
han synes syk 'he seems sick',  
which is a raising construction of the logical form 
'seem (he sick)', where the subject han does not 
have a semantic argument function relative to the 
verb. The label specifying this type is  
 v-intrScpr-scSuNrg_scAdj 
where intrScpr states that the only constituents 
syntactically present are a subject and a secon-
dary predicate, scSuNrg states that the subject 
lacks semantic argument status relative to the 
verb, and scAdj states that the secondary predi-
cate is headed by an adjective. The circumstance 
that the latter two specifications concern depend-
ents rather than over-all valence, is marked by an 
underscore interrelating them.  
A transitive counterpart to this type is exem-
plified by han synes meg syk 'he seems me sick', 
of the logical form 'seem-to-me (he sick)', where 
the subject han still does not have a semantic 
44
argument function relative to the verb. The label 
specifying this type is  
 v-trScpr-scSuNrg_scAdj 
where trScpr states that the constituents syn-
tactically present are a subject, an object and a 
secondary predicate, and the other specifications 
serve as in the previous example. 
With utilization of the slot 2 and slot 3 deter-
minants, around 200 templates have been defined 
for Norwegian (these can be viewed at the site 
typecraft.org (research/research projects). 
Deciding what is to go in slot 2 and what in 
slot 3 is in most cases starightforward, but not 
always. For instance, it will be noted that in the 
copula valence labels entered at the end of the 
list in section 3, specifications like 'YN'. 'DECL' 
etc are used which are otherwise used mainly in 
dependents' specifications. For one thing, in a 
case where an adverb or a PP is obligatory, and 
there is no relational 'super-term' available for 
specifying its presence, one will refer to the con-
stituent by head property directly, as in in-
trAdv. In the case of the copulas, one might 
have entered 'YN' etc tied to a grammatical rela-
tion 'identifier' for the identity copula, and 'predi-
cative' for  predicative copula, giving, e.g., v-
copPred-predAdj instead of v-copAdj for the 
predicative adjectival copula construction, and 
v-copID-idN instead of v-copIdN for the 
identity construction. Here it is essentially length 
of labels, and sparsity concerns concerning 
grammatical relations notions, which have 
counted in favor of the latter options - either op-
tion is in principle possible.  
Conversely, instead of writing 'trScpr-
scSuNrg_scAdj' in the example discussed, one 
could have written 'trScprAdj-scSuNrg', or 
'trScpr-scSuNrgAdj' - against the former is a 
wish to generally have POS of dependents being 
stated in the dependents' slot, and against the lat-
ter counts the circumstance that the secondary 
predicate specifications are in general rather 
complex already; this point will be further illus-
trated in section 8 below. 
 
5 Thematic roles and situation types 
In specifying semantic roles and situation types, 
classifications available are less robust than they 
are for the factors covered above, and for that 
reason, the notational system will not insist that 
they should be provided. Closest to practical 
consensus are core semantic role labels such as 
'agent', 'patient' and the like, and aspectual speci-
fications; much less established is a set of situa-
tion types covering the full range of construc-
tions in a language. In this section we do not 
provide any tentative list of values to be used, 
but comment only on how they are expressed. 
As exemplified in (1), each semantic role label 
is built up with a first part indicating the gram-
matical function of the item specified, and the 
remainder providing the specification - thus, 
suAg, obEjct.. Unlike the case with dependents' 
labels, the remaining part has no internal struc-
ture. 
Situation types may in principle cover any-
thing between Aktionsart and detailed situational 
specification, like in a FrameNet label (cf. 
http://framenet.icsi.berkeley.edu/). In the system 
currently implemented, the level of specification 
is somewhere between these two: Sitaution type 
labels can be decomposed into standard aspectual 
notions (like those proposed in Smith 1991, 
1997) and specifications uniquely identifying 
each type. An example is the possible situation 
label CAUSATION_WITH_CAUSINGEVENT, 
which means "causation where the cause is itself 
an event and its event type is linguistically iden-
tified", and which implies certain aspectual no-
tions, such as 'dynamic' and 'telic'. 
We illustrate the full specification of the ex-
ample han synes meg syk 'he seems me sick' dis-
cussed above, which is: 
 
(2) 
v-trScpr-scSuNrg_scAdj-
obCog_scThSit-PROPOSITIONALATTITUDE 
 
'obCog' here means that the object expresses a 
'cognizer', and 'scThSit' that the secondary 
predication expresses a 'situational theme'. It will 
be noted that, consistent with the non-argument 
status of the subject, there is no thematic role tied 
to the subject. 
With utilization of the slot 4 and slot 5 deter-
minants, around 280 templates are currently de-
fined for Norwegian. 
 
Slots 3 and 4 are both 'constituent oriented', 
and may provide specifications of one and the 
same item. For instance, in (2) all of scSuNrg, 
scAdj (slot 3),  and scThSit (slot 4) define the 
secondary predicate. In principle it would be 
possible to draw these different specifications 
together into a unitary, but more complex, speci-
fication. This was done, e.g., in the TROLL sys-
tem (cf. (Hellan et al 1989)), where arguments 
were specified as triples of (i) head's POS, (ii) 
45
grammatical function, and (iii) thematic role (in-
cluding possible non-argument status). Among 
possible advantages of the current system are that 
it better profiles 'global' properties of the con-
struction, that it better displays the profile of par-
ticipant roles, when entered, and makes omission 
of them practically more easy. Cf. (Lehmann et 
al. 1996) for further discussion.     
 
6 From Templates to Grammars 
The information encoded in the first three slots 
attains the same depth of argument structure de-
scription as is modeled in standard Matrix-HPSG 
grammars, and approximately as in standard 
LFG-Pargram grammars (cf. (Butt et al 1999)). 
Argument structure being what is generally en-
coded in lexical entries for verbs in such gram-
mars, we now address how the template system 
can be used as lexical types or macros.  
Minimally, templates could be imported as 'en 
bloc' type- or macro labels into computational 
grammars. However, the hyphenation and under-
score structure of the templates suggest more 
modular strategies, as we will now show for a 
typed feature structure design.  
For instance, for the template in (2) -  
v-trScpr-scSuNrg_scAdj-
obCog_scThSit-PROPOSITIONALATTITUDE 
one could see this as equivalent to a unification 
of syntactic types representing, resp., 'verb-
headed', 'transitive with a secondary predicate', 
'secondary predicate predicated of raised subject', 
and 'secondary predicate headed by an adjective', 
and the semantic types 'cognizer, as role of ob-
ject', and 'situational theme', as role of secondary 
predicate. In the tdl notation used in LKB gram-
mars, this would suggest (3) as one of its type 
definitions (ignoring the situation type label for 
now): 
 
(3)  
v-trScpr-scSuNrg_scAdj-obCog_scThSit   := 
v & trScpr & scSuNrg & scAdj & obCog & 
scThSit. 
 
Here, the type in line 1 is defined as the unifica-
tion of the types inter-connected with '&'. Me-
chanically speaking, in going from template to 
grammatical type, one simply replaces each hy-
phen or underline in the template label by a type 
unification symbol. As individual types (as is 
customary, mention of such types is done with 
italics) v, trScpr, scSuNrg, scAdj, obCog and 
scThSit will all be at 'sign' level. That is: when, 
in an LKB-like grammar, these types are to unify 
with each other, they must belong to a common 
supertype, and given that what they are compos-
ing together is the type of a verb lexeme, this is, 
in a Matrix-type grammar, an instance of the type 
sign. For instance, the type definition for scAdj, 
relative to NorSource, is (with PREDIC being an 
attribute introducing secondary predicates, and 
QVAL introducing grammatical relations in a 
non-list fashion, ? la LFG): 
 
(4)  scAdj := sign &  
[SYNSEM | LOCAL | CAT | QVAL | PREDIC | LO-
CAL | CAT | HEAD adj]. 
 
In what part of the over-all grammar will these 
types be introduced? A first question is if 'con-
struction' is a type of entity to be assumed among 
the building blocks of the grammar. In standard 
HPSG and LFG design, the tendency is to project 
construction types into the inventory of lexical 
types, so that verb-construction types enter the 
grammar through the subcategorization frames 
associated with verbs. On this view, a definition 
like (3) will be in an inventory of lexical type 
definitions. 
How do lexical items, in this case verbs, relate 
to these types? If we consider the more standard 
design in HPSG and LFG grammars, where a 
verb has as many entries as there are construction 
frames in which it can enter, most verbs can en-
ter more than one constructional environment.1 
Thus, in the typical case, a verb will be associ-
ated with a subset of the totality of types deriv-
able from the template collection, and thus have 
entries each one defined by one of these types. 
Some points of useful flexibility in this map-
ping may be noted, illustrated with the choice of 
head in secondary predicate constructions (cf. 
(4)): in constructions like those discussed, eligi-
ble such heads are in principle adjectives, ad-
verbs, prepositions, predicative particles and in-
finitivals. For a given verb, the full range of op-
tions need not be open, hence in defining the 
general verb type corresponding to the template 
v-trScpr-scSuNrg_scAdj-obCog_scThSit  
one may want to leave the sc-head open, and 
rather have a way of appending that information 
for each individual verb. By separating out the 
                                                          
1 We here ignore possible designs which might, for each 
verb, represent it with one single entry, and account for its 
many frames of occurrence either through a network of 
lexical rules, or through underspecifying each entry to yield, 
for each verb, exactly the range of environments it can oc-
cur in. 
46
relevant part (_scAdj, _scAdv...,), and defining v-
trScpr-sSubNrg_scAdj, v-trScpr-scSuNrg_scAdv, 
etc. as subtypes of  v-trScpr-sSubNrg, one can in 
an LKB grammar enter each verb in the lexicon 
with the appropriate last part provided (and leave 
them out when the verb actually can combine 
with all options). In such an approach one has to 
define all constellations in the relevant type file, 
the gain lies in the flexibility one has in the lexi-
cal entry specifications. The same advantages 
apply with regard to specification of semantic 
roles. 
 
7 Uses of the template inventories 
A first possible usage of a template inventory is 
that one can employ a set of example sentences 
illustrating the various templates as a test suite 
for the grammar. Given the systematic design of 
the template list, one is assured to have a system-
atic test suite in the respects covered by the tem-
plates. 
A second benefit of the design is as a basis for 
building cross-linguistically matching test-suites, 
to the extent that templates coincide cross-
linguistically.  
For linguistic typology, once one has template 
lists developed for many languages, comparison 
and systematization of differences can be facili-
tated. 
For linguistic description and grammar crea-
tion, having established template lists for related 
languages may enhance efficiency, in providing 
'check-list' starting and reference points. 
All of these points will presuppose that one 
can reach a commonly approved standard of no-
tation. (In principle, with different types of nota-
tion, but a one-to-one correlation between nota-
tions, similar effects may be gained, although 
there is then an extra step of identifying correla-
tions.) 
Currently, such a combined initiative of nota-
tion development and typological investigation is 
being pursued for a group of Ghanaian languages 
in consonance with the Norwegian system; cf. 
(Dakubu, 2008). (For both systems, full template 
and example lists can be viewed at the site type-
craft.org mentioned above.) 
As still another enterprise connected to the 
present template inventory may be mentioned a 
partial ontology of verb construction types devel-
oped with the LKB platform (in principle export-
able also to OWL), representing all of the tem-
plates in the Norwegian inventory and some 
more. For a partial description, see (Hellan 
2007). 
Relative to the present system, a verb class 
can be identified as a set of verbs which are ac-
commodated by the same set of construction 
types. (This notion of 'verb class' is related to 
that employed in (Levin 1993), which is based 
on alternations between construction types. An 
alternation, such as the 'spray-load alternation', 
can be viewed as a pair of construction types in 
which a number of verbs can participate, typi-
cally with rather similar semantics, highlighting 
? by a ?minimal pair? technique - semantic prop-
erties of the constructions chosen.)  
 
8 More complex types 
In its current version, the system does not in-
clude 'derived' constructions, of which in Nor-
wegian passive constructions would be the main 
instance. As a prerequisite for a notational sys-
tem for derivation, systems will first be made for 
selected Bantu and Ethio-Semitic languages (rep-
resenting future development) 
Possibly also of a derivational nature, but here 
treated as basic patterns, are 'Secondary predi-
cate' constructions, a few of which were dis-
cussed above. To indicate where the Norwegian 
label inventory probably reaches its peak of 
complexity, we give a brief resym? of the pa-
rameters involved in these constructions, and the 
more complex labels employed. 
The secondary predicate (henceforth: secpred) 
can relate to the main predicate either as the con-
tent of a propositional attitude or perception, or 
as concurring in time, or as the causee of a causa-
tion. In the latter case, either an event is por-
trayed as the cause (indicated by the substring 
?.Cse), or an entity. In the former case, the 
causing event can have from zero to two partici-
pants, and when one or two, one can be implicit. 
What can never be implicit is the entity of which 
the secpred is predicated: it may occur as subject 
or object, and in either case either realizing this 
grammatical function by itself (in which case the 
function is 'non-argument'), or sharing it with a 
participant of the causing event (in which case 
the function has 'argument' status). The following 
slot 3 labels serve to encode the various possi-
bilities:  
 
scObArgConcurr (he drank the coffee 
warm) 
47
scObNrgRes (he made me sick): Of the 
causing event, only the participant denoted 
by the subject is specified.  
scSuArgCse (kaffen koker bort 'the coffee 
boils away'): The matrix verb (together with 
its argument subject) expresses part of the 
description of the causing event.  
scObArgCse (han sparket ballen flat 'he 
kicked the ball flat'): The secondary predi-
cate is predicated of an argument object, 
and the matrix verb (together with its ob-
ject) expresses part of the causing event.  
scSuNrgCse (landsbyen sn?r ned 'the vil-
lage snows down'): The secondary predicate 
is predicated of a non-argument subject, 
and the matrix verb expresses part of the 
causing event. 
scObNrgCse (han sang rommet tomt 'he 
sang the room empty'): The secondary predi-
cate is predicated of a non-argument ob-
ject, and the matrix verb (together with its 
subject) expresses part of the causing 
event. 
 
In dealing with typologically different lan-
guages, it is not a priori given what construc-
tional template options may present them-
selves (see Dakubu op.cit. for  discussion of 
some Volta Basin languages). Whatever these 
additional types may be, in designing labels, 
one probably should not exceed the complex-
ity of the labels just presented. 
 
9 Conclusion 
With an encoding of a construction type's argu-
ment structure and semantics which is probably 
representative of what one may want to expose, 
each template in the system presented here is by 
itself as compressed as can be, which gives the 
template structure some interest by itself. How-
ever, it is through the totality of templates, and 
through the design by which they can be easily 
enumerated, compared and computed, that the 
system presented may be a contribution to 
grammar engineering and language typology 
alike. While the system reflects such ambitions, 
it is still in an initial state of deployment both in 
grammar engineering and typology, and its po-
tential value will reside in the extent to which it 
will be used, and receive feedback for usability. 
 
References 
Beermann, Dorothee and Lars Hellan. 2004. A treat-
ment of directionals in two implemented HPSG 
grammars. In St. M?ller (ed) Proceedings of the 
HPSG04 Conference, CSLI Publications 
/http://csli-publications.stanford.edu/ 
Bender, Emily M., Dan Flickinger, and Stephan 
Oepen. 2002. The Grammar Matrix: An open-
source starter kit for the rapid development of 
cross-linguistically consistent broad-coverage pre-
cision grammars. In Proceedings of the Workshop 
on Grammar Engineering and Evaluation, Coling 
2002, Taipei.  
Butt, Miriam, Tracy Holloway King, Maria-Eugenia 
Nini and Frederique Segond. 1999. A Grammar-
writer's Cookbook. Stanford: CSLI Publications. 
Copestake, Ann. 2002. Implementing Typed Feature 
Structure Grammars. CSLI Publications, Stanford.  
Dakubu, Mary E. K. 2008. The Construction label 
project: a tool for typological study. Presented at 
West African Languages Congress (WALC), Win-
neba, July 2008.  
Flickinger, Daniel, John Nerbonne, Ivan A. Sag, and 
Thomas Wassow. 1987. Toward Evaluation of 
NLP Systems. Technical report. Hewlett-Packard 
Laboratories. Distributed at the 24th Annual Meet-
ing of the Association for Computational Linguis-
tics (ACL).  
Hellan, Lars. 2007. On 'Deep Evaluation' for Individ-
ual Computational Grammars and for Cross-
Framework Comparison. In: T.H. King and E. M. 
Bender (eds) Proceedings of the GEAF 2007 
Workshop. CSLI Studies in Computational Lin-
guistics ONLINE. CSLI Publications. http://csli-
publications.stanford.edu/ 
Hellan, Lars., Lars Johnsen and Anneliese Pitz. 1989. 
TROLL. Ms., NTNU 
Lehmann, Sabine., S. Oepen, S. Regier-Prost, K. Net-
ter, V. Lux, J. Klein, K. Falkedal, F. Fouvry, D. Es-
tival, E. Dauphin, H. Compagnion ,J. Baur, L. Bal-
kan, D. Arnold. 1996. Test Suites for Natural Lan-
guage Processing. Proceedings of COLING 16, p. 
711-16. 
Levin, Beth. 1993. English Verb Classes and Alterna-
tions: A Preliminary Investigation. University of 
Chicago Press. 
Smith, Carlota. 1991, 1997. The Parameter of Aspect. 
Kluwer Publishers, Dordrecht. 
48
Proceedings of the Fourth Linguistic Annotation Workshop, ACL 2010, pages 172?176,
Uppsala, Sweden, 15-16 July 2010. c?2010 Association for Computational Linguistics
From Descriptive Annotation to Grammar Specification 
Lars Hellan 
NTNU 
Trondheim, Norway 
lars.hellan@hf.ntnu.no 
 
  
Abstract 
The paper presents an architecture for connecting 
annotated linguistic data with a computational gram-
mar system. Pivotal to the architecture is an annota-
tional interlingua ? called the Construction Labeling 
system (CL) - which is notationally very simple, de-
scriptively finegrained, cross-typologically applica-
ble, and formally well-defined enough to map to a 
state-of-the-art computational model of grammar. In 
the present instantiation of the architecture, the com-
putational grammar is an HPSG-based system called 
TypeGram.  Underlying the architecture is a research 
program of enhancing the interconnectivity between 
linguistic analytic subsystems such as grammar for-
malisms and text annotation systems. 
 
1 Introduction 
This paper advocates the view that all aspects of 
descriptive, theoretical, typological, and compu-
tational linguistics should hang together in over-
all precisely defined networks of terminologies 
and formalisms, but flexibly so such that each 
field can choose suitable formats, and different 
traditions can maintain their preferred terminol-
ogies and formalisms. Terms and symbols used 
for linguistic annotation are central in this enter-
prise, and the paper describes an algorithm by 
which a code suitable for sentence level annota-
tion can be aligned with a system of attribute-
value matrix (AVM) representations. An aim for 
further development is a similar alignment for 
PoS/morpheme annotation symbols.  
The alignment described has as its theoretical 
and computational reference point an HPSG-
based system, where, aside from AVMs, types 
play a crucial role. Most likely, alignment archi-
tectures with similar capacities to the one here 
described can have other formal frameworks in-
tegrated. For such alternatives the present system 
may serve as a roadmap, and hopefully more: the 
architecture is sought to be modular such that 
parts of it ? such as the formal framework, or an 
annotation tag system -  can be replaced while 
keeping other parts constant. At the present 
point, however, this is a demonstration tied to 
unique choices for each module in the architec-
ture. It serves as a feasibility demonstration of 
the design as such, and equally much to motivate 
the specific annotation code presented, which is 
pivotal to the system as a whole.  
This paper has two parts. The first part presents 
the sentence-level annotation code. It consists of 
strings of labels (connected by hyphens) where 
each label represents a possible property of a 
sentential sign, such as, e.g.,  ?has Argument 
structure X?, ?has Aspect Y?, ?has a Subject with 
properties Z?, ?expresses situation type S?, etc. 
The construction type specification in (1) is a 
first illustration of the code: 
 
(1) v-tr-suAg_obAffincrem-
COMPLETED_MONODEVMNT  
 (Ex.: English: the boy ate the cake) 
 
This reads: the sign is headed by verb; its syntac-
tic frame is transitive; it has a Subject (su) whose 
thematic role is agent, and an Object (ob) whose 
thematic role is incrementally affected; its aspec-
tual type is characterized as a combination of 
completed and monotonic development. 
Expressions like that in (1), characterizing a 
sentence from its ?global? perspective, are re-
ferred to as templates. The code is flexible in 
having no upward bound on the number of labels 
used in a template, and expressive in that each 
label represents a statement about some part or 
aspect of the sign. The code as such will be re-
ferred to as the Construction Labeling (CL) 
system; see section 2. 
The circumstance that each individual label has 
the logic of a statement, is essential to the trans-
parency of the code. This propositional character 
of a label also opens for the alignment of CL 
with a formal grammar system, which is ad-
dressed in the second part of the paper. Here we 
show how templates can be linked to AVMs, like 
the template in (1) to an AVM like (2) (in mixed 
HPSG/LFG style), 
 
172
(2) 
[ ]
[ ]
H E A D  verb
S U B J IN D X  1 R O LE  agen t
G F 
O B J IN D X  2 R O LE  aff-increm
IN D X  ref-index
A S P E C T  com pleted
A C T 1 1
A C T N T S  
A C T 2 2
S IT -T Y P E  m ono ton ic_developm en t
? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?
 
and in such a way that each individual label in the 
template can be seen as inducing its specific part 
of the AVM, as informally and partially indicated 
in (3): 
 
(3)  
v - - - [ ]HEAD verb  
tr - - - S U B J  IN D X  1
G F  
O B J  IN D X  2
A C T 1  1
A C T N T S  
A C T 2  2
? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?
 
suAg - - -  [ ]GF SUBJ INDX ROLE agent? ?? ?? ?? ?? ?? ?  
obAffincrem - - -  [ ]GF OBJ INDX ROLE aff-increm? ?? ?? ?? ?? ?? ? 
 
Thus, while the labels have a descriptive trans-
parency essential to the descriptive functionality 
of the over-all code, this transparency can be 
?cashed out? also in the definition of a linking 
between CL and grammar formalisms like that 
illustrated in (2) and (3). Section 3 describes a 
possible architecture for achieving this, centered 
around the computational grammar TypeGram. 
2 Construction Labeling  
In its first development, the coding system has 
been based on two typologically very diverse 
languages: Norwegian, and the West African lan-
guage Ga. An overview of the system is given in 
(Hellan and Dakubu 2010). The end product of 
its application to a language is called a construc-
tion profile of the language, abbreviated its c-
profile. This is an assembly of between 150 and 
250 templates encoding the span of variation of-
fered by the language in a fixed number of re-
spects, in a code immediately comparable to c-
profiles of other languages. A c-profile for both 
Ga and Norwegian is given in (Hellan and Da-
kubu op. cit.); see also (Hellan and Dakubu 2009, 
Dakubu 2008, Hellan 2008). 
The typical method of establishing c-profiles is 
through paradigm building, where, based on one 
sentence of the language, one establishes the 
various paradigms relative to which the sentence 
instantiates choices, and supplements these para-
digms with paradigms spun out of other sen-
tences or constructions, ultimately establishing a 
full network of construction types for the lan-
guage relative to the discriminants selected. 
(?Construction? is here used in a theory neutral 
way.)  
The creation of c-profiles is obviously an in-
cremental process, both in the building of tem-
plates instantiating possibilities defined by the 
range of discriminants recognized at any point, 
and in extending this range reflecting new phe-
nomena and new languages investigated. Thus, 
while the stage referred to above reflects in depth 
work on Germanic and Kwa, significant en-
hancements are currently made through work on 
Ethio-semitic (especially through the study 
(Wakjira, to appear) on Kistaninya), Bantu, 
Indic, and other language groups, mostly not yet 
having achieved full c-profiles. 
Although presentable as networks, in normal 
displays c-profiles are given as lists, with strict 
principles of ordering. Some c-profiles are also 
entered in the TypeCraft database 
(http://www.typecraft.org/), where one can 
search according to any labels serving as con-
stituents of templates. At present, the number of 
labels employed in the code is about 40 for va-
lence types, 90 for specifications relating to the 
syntactic form of specific constituents, 40 for 
thematic roles of specific constituents, 20 for 
aspect and Aktionsart values, and 60 for situation 
types. For valence and grammatical functions, 
language and framework independence in the 
code is made possible due to considerable agree-
ment across traditions, whereas for participant 
roles and situation types, there is much less of a 
consolidated basis, and in these areas code de-
velopment and evaluation is still a primary issue. 
3 TypeGram  
TypeGram is in most respects a normal HPSG-
based computational grammar built on the LKB 
platform (Copestake 2002). Crucial to the pre-
sent discussion, it has some components de-
signed for linking it up with the CL code, which 
makes it possible for it to 
- provide an AVM display of any CL template 
(like (2) above, for (1)); 
- provide a basis for a rapid development of a 
parsing grammar for any language for which a 
c-profile has been created; 
173
- provide an intermediate parsing facility for 
sentences of any language even when no gram-
mar specific to the language has been created, as 
long as the language has been assigned a c-
profile. 
We will refer to the ?basic? part of TypeGram 
as its Core. Relative to current grammar formal-
isms using AVMs, such as LFG and HPSG (cf.  
Bresnan 2001, Butt et al 1999, Pollard and Sag 
1994), the TypeGram Core borrows from LFG 
an inventory of grammatical functions, and from 
HPSG the use of types, and a design by which 
all components of a grammar are encoded in 
AVMs. Unlike most computational grammars, 
the Core defines analyses for phenomena not 
restricted to one language, but for the union of 
all languages for which c-profiles have been de-
fined. (In this respect it resembles the HPSG 
Grammar Matrix (?the Matrix? - see  Bender et. 
al, and http://www.delph-in.net/matrix/ ); we 
comment on its relationship to this system be-
low.) The mediation between the Core and the c-
profiles is induced by special type files: 
- one file for each c-profile (of which there are 
currently three, for Ga, Norwegian and Kistan-
inya) 
- one general file, called Labeltypes, for defin-
ing CL labels as types in terms of the Core types. 
This architecture can be summed up as follows 
(with ?Ga c-types? meaning ?types correspond-
ing to the templates constituting the c-profile for 
Ga?, and items in boldface being items defined 
inside the TypeGram system): 
 
(4) 
c-profile of Ga       Ga c-types   
 
c-profile of  
Norwegian    Norw.c-typ  Labeltypes  
 
c-profile of  
Kistaninya    Kistane c-types Core 
 
Thus, what communicates between the Core and 
the construction specifications in the CL code is 
Labeltypes, which in turn feeds into the lan-
guage specific template definition files. The lat-
ter files build only on Labeltypes, which in turn 
builds only on the Core. This allows for modu-
larity: the content of the Core can be changed, 
e.g., to the system of the Matrix (or even an 
LFG-based system), without affecting the c-
profiles or the c-type inventories. 
We now describe possibilities offered by the 
architecture. 
3.1 Providing AVM displays of templates 
In exemplifying this function, we use a template 
from Ga, along with a glossed example to illus-
trate the construction type: 
 
(5)  v-ditr-obPostp-
suAg_obEndpt_ob2Mover-PLACEMENT  
Am?-wo ts?ne  l?  mli  y?l? 
3P.AOR-put  vehicle DEF  inside  yam 
V  N Art N N 
?They put [vehicle?s inside] [yam]? = ?They 
put yams in the lorry.? 
 
Here the two objects represent a Mover (the 
yam) and where the Mover is finally placed (the 
lorry?s inside). This Endpoint is characterized as 
the inside of something, where the expression of 
this inside is structurally like a possessive NP 
construction.  
In the type-file ?Ga c-types?, the template in 
(5) is turned into a grammatical type by the type 
definition (6) (where ?:=? means ?is a subtype 
of? and ?&? is the operation of unification): 
 
(6)  
v-ditr-obPostp-suAg_obEndpt_ob2Th-
PLACEMENT    :=  
v & ditr & obPostp & suAg & obEndpt & ob2Th 
& PLACEMENT. 
 
The way in which the individual types v, ditr, 
obPostp, etc., are here unified to constitute a 
definition of the type corresponding to the full 
template, corresponds to the way in which, in 
(3), the constituent labels of the template (1) are 
portrayed as contributing to its full AVM. 
The defining types in (6) are in turn defined in 
labeltypes, by definitions whose defining terms 
are in turn defined in the Core.  
With such type definitions in the background, 
the template v-ditr-obPostp-
suAg_obEndpt_ob2Th-PLACEMENT is a type 
recognized in the grammar. Using the view type 
definition offered in a standard LKB interface, 
one sees the AVM assigned to this template. 
3.2 Developing a parsing grammar 
Suppose that we want to develop a grammar 
of Ga ? GaGram -, taking advantage of the type 
apparatus already described. (For Ga, the lexi-
con (Dakubu 2009) is partly informed by the c-
profile and is a resource in building the lexicon 
of the grammar.) What is missing is defining a 
lexicon, inflectional rules, derivational rules and 
174
syntactic combinatorial rules. The latter is partly 
deducible from the constructional templates, and 
for templates which reflect verb subcategoriza-
tion frames, lexical frame types are fairly di-
rectly derivable from the templates. What needs 
to be done in addition is specifying the lexical 
root items of Ga, and the inflectional and deriva-
tional formatives used in the language.    
This ?grammar construction kit? offered by 
TypeGram clearly resembles the HPSG Gram-
mar Matrix (?Matrix?; cf. Bender et al 2002). It 
differs from the Matrix most essentially through 
the way in which the grammar internal specifica-
tions are ?semi-automatically? updated as the c-
profile grows. This systematic linkage between a 
cross-linguistic descriptive classification code 
and a computational grammar code is not yet 
available in the Matrix. Nothing, though, pre-
cludes introducing the TypeGram architecture 
also there, in this respect. 
3.3 An intermediate parsing facility 
TypeGram has specifications which, in addition 
to the above, in principle enable it to parse the 
Ga string in (5) ? viz.,  
(7) Am?-wo ts?ne l? mli y?l? 
as a structure like (8) (AVM not shown): 
 
(8)   VP 
 
 V  NP  NP 
  NP  N 
 
         N           Art 
 
V3PputAor???Nvehicle???ArtDEF?? Ninside??Nyam 
 
We may informally refer to (8) as an ?x-ray? of 
(7). As terminal nodes in the parse tree, it has 
the English glosses corresponding to the Ga 
roots, and functional morph glosses for the ac-
tual formatives of the Ga string. This is achieved 
through having as input to the parser not the 
string (7) itself, but the standard gloss associated 
with the string ? (9a) ? suitably modified to stan-
dard LKB parse input format: 
 
(9) 
a.   
3P.AOR-put  vehicle  DEF  inside  yam 
V  N Art N N 
 
b.   V3PputAor?Nvehicle?ArtDEF?Ninside?Nyam 
 
This is achieved by having the TypeGram lexi-
con contain all those English roots which ever 
appear in the glosses of Ga sentences (obviously 
relative to a limited, but in principle expandable 
corpus), and having these roots be associated 
with exactly the frame types which the corre-
sponding Ga roots have relative to Ga. Thus, to 
produce (8), this lexicon would have to include 
an entry like (10) (using LKB style format), 
?put? being the counterpart to wo in this context: 
(10)  
put := v-ditr-obPostp-suAg_obEndpt_ob2Th-
PLACEMENT & [ ORTH <?put?>, 
    ACTANTS.PRED put_rel ]. 
 
What this facility amounts to is a parser dis-
playing the structure of sentences of a language 
for which one has designed a c-profile, but not 
yet a parsing grammar. It would be useful as a 
tool for typological comparison. To work, such a 
system would require a highly disciplined set of 
conventions for ?standard? glossing, and an in-
terface in addition to LKB where such a glossing 
would be ?read in? as a string-to-parse; the latter 
is a facility not yet implemented (the only exist-
ing candidate interface for this purpose, to our 
knowledge, would be TypeCraft (cf. Beermann 
and Mihaylov 2009), while the development of 
the former (presumably with reference to exist-
ing glossing conventions such as the Leipzig 
Glossing rules, see References) would be part of 
the over-all initiative described at the outset. 
4 Conclusion  
With the Construction Labeling code and its de-
ployment across languages as a basis, we have 
shown how this code can be mapped to a gram-
mar formalism, both formally and computation-
ally. We are thereby able to, at one and the same 
time, develop descriptive sentence level annota-
tions across typologically diverse languages with 
a unitary code, and derive from these annota-
tions facilities for automatic display of AVMs 
for any coded annotation, for rapid grammar de-
velopment for the language concerned, and ? so 
far less robustly - for intermediate ?gloss?-
reflecting parsing.  
We have thereby provided a system where de-
scriptive, theoretical, typological, and computa-
tional concerns are brought together in an over-
all precisely defined network of terminologies 
and formalisms, and flexibly so such that each 
field ? here annotation and grammar develop-
ment ? have their respective suitable formats. 
175
References 
Dorothee Beermann and Pavel Mihaylov 2009. Type-
Craft ? Glossing and Databasing for Linguists. 
Proceedings of the 23rd Scandinavian Conference 
of Linguistics, Uppsala, Sweden, October 2008. 
Emily M Bender, Dan Flickinger, and Stephan Oepen. 
2002. The Grammar Matrix: An open-source 
starter kit for the rapid development of cross-
linguistically consistent broad-coverage precision 
grammars. In Proceedings of the Workshop on 
Grammar Engineering and Evaluation, COLING 
2002, Taipei.  
Joan Bresnan. 2001. Lexical Functional Grammar. 
Oxford: Blackwell. 
Miriam Butt, Tracy Holloway King, Maria-Eugenia 
Nini and Frederique Segond. 1999. A Grammar-
writer's Cookbook. Stanford: CSLI Publications. 
Ann Copestake. 2002. Implementing Typed Feature 
Structure Grammars. CSLI Publications. 
Mary Esther Kropp Dakubu,. 2008. The Construction 
label project: a tool for typological study. Pre-
sented at West African Languages Congress 
(WALC), Winneba, July 2008.  
Mary Esther Kropp Dakubu. 2009. Ga-English Dic-
tionary.  Accra. 
Lars Hellan. 2008. Enumerating Verb Constructions 
Cross-linguistically. COLING Workshop on Gram-
mar Engineering Across frameworks. Manchester. 
http://www.aclweb.org/anthology-
new/W/W08/#1700   
Lars Hellan and Mary Esther Kropp Dakubu. 2009:  
A methodology for enhancing argument structure 
specification. In: Proceedings from the 4th Lan-
guage Technology Conference (LTC 2009), 
Poznan. 
Lars Hellan and Mary Esther Kropp Dakubu. 2010. 
Identifying Verb Constructions Cross-
linguistically. SLAVOB series, Univ. of Ghana 
(http://www.typecraft.org/w/images/d/db/1_Introla
bels_SLAVOB-final.pdf, 
http://www.typecraft.org/w/images/a/a0/2_Ga_app
endix_SLAVOB-final.pdf, 
http://www.typecraft.org/w/images/b/bd/3_Norweg
ian_Appendix_plus_3_SLAVOB-final.pdf ) 
Carl Pollard and Ivan Sag. 1994. Head-Driven Phrase 
Structure Grammar. Chicago University Press. 
Bedilu Debela Wakjira. To appear. Kistaninya Verb 
Morphology and Verb Constructions. PhD disserta-
tion. NTNU. 
 
 
 
Some web sites: 
Leipzig glossing rules: 
http://www.eva.mpg.de/lingua/resources/glossing-
rules.php  
TypeGram: 
http://www.typecraft.org/tc2wiki/TypeGram 
TypeCraft: 
http://www.typecraft.org/  
Construction Labeling site: 
http://www.typecraft.org/research/projects/Verbconstr
uctions/ 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
176
