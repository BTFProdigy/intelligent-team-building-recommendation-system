Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning, pages 308?319, Jeju Island, Korea, 12?14 July 2012. c?2012 Association for Computational Linguistics
Improving Transition-Based Dependency Parsing with Buffer Transitions
Daniel Ferna?ndez-Gonza?lez
Departamento de Informa?tica
Universidade de Vigo
Campus As Lagoas, 32004
Ourense, Spain
danifg@uvigo.es
Carlos Go?mez-Rodr??guez
Departamento de Computacio?n
Universidade da Corun?a
Campus de Elvin?a, 15071
A Corun?a, Spain
carlos.gomez@udc.es
Abstract
In this paper, we show that significant im-
provements in the accuracy of well-known
transition-based parsers can be obtained, with-
out sacrificing efficiency, by enriching the
parsers with simple transitions that act on
buffer nodes.
First, we show how adding a specific tran-
sition to create either a left or right arc of
length one between the first two buffer nodes
produces improvements in the accuracy of
Nivre?s arc-eager projective parser on a num-
ber of datasets from the CoNLL-X shared
task. Then, we show that accuracy can also be
improved by adding transitions involving the
topmost stack node and the second buffer node
(allowing a limited form of non-projectivity).
None of these transitions has a negative im-
pact on the computational complexity of the
algorithm. Although the experiments in this
paper use the arc-eager parser, the approach is
generic enough to be applicable to any stack-
based dependency parser.
1 Introduction
Dependency parsing has become a very active re-
search area in natural language processing in re-
cent years. The dependency representation of syn-
tax simplifies the syntactic parsing task, since no
non-lexical nodes need to be postulated by the
parsers; while being convenient in practice, since
dependency representations directly show the head-
modifier and head-complement relationships which
form the basis of predicate-argument structure. This
has led to the development of various data-driven
dependency parsers, such as those by Yamada and
Matsumoto (2003), Nivre et al2004), McDonald
et al2005), Martins et al2009), Huang and Sagae
(2010) or Tratz and Hovy (2011), which can be
trained directly from annotated data and produce ac-
curate analyses very efficiently.
Most current data-driven dependency parsers can
be classified into two families, commonly called
graph-based and transition-based parsers (Mc-
Donald and Nivre, 2011). Graph-based parsers (Eis-
ner, 1996; McDonald et al2005) are based on
global optimization of models that work by scoring
subtrees. On the other hand, transition-based parsers
(Yamada and Matsumoto, 2003; Nivre et al2004),
which are the focus of this work, use local training
to make greedy decisions that deterministically se-
lect the next parser state. Among the advantages of
transition-based parsers are the linear time complex-
ity of many of them and the possibility of using rich
feature models (Zhang and Nivre, 2011).
In particular, many transition-based parsers
(Nivre et al2004; Attardi, 2006; Sagae and Tsujii,
2008; Nivre, 2009; Huang and Sagae, 2010; Go?mez-
Rodr??guez and Nivre, 2010) are stack-based (Nivre,
2008), meaning that they keep a stack of partially
processed tokens and an input buffer of unread to-
kens. In this paper, we show how the accuracy of
this kind of parsers can be improved, without com-
promising efficiency, by extending their set of avail-
able transitions with buffer transitions. These are
transitions that create a dependency arc involving
some node in the buffer, which would typically be
considered unavailable for linking by these algo-
308
rithms. The rationale is that buffer transitions con-
struct some ?easy? dependency arcs in advance, be-
fore the involved nodes reach the stack, so that the
classifier?s job when choosing among standard tran-
sitions is simplified.
To test the approach, we use the well-known arc-
eager parser by (Nivre, 2003; Nivre et al2004) as
a baseline, showing improvements in accuracy on
most datasets of the CoNLL-X shared task (Buch-
holz and Marsi, 2006). However, the techniques dis-
cussed in this paper are generic and can also be ap-
plied to other stack-based dependency parsers.
The rest of this paper is structured as follows:
Section 2 is an introduction to transition-based
parsers and the arc-eager parsing algorithm. Section
3 presents the first novel contribution of this paper,
projective buffer transitions, and discusses their
empirical results on CoNLL-X datasets. Section 4
does the same for a more complex set of transitions,
non-projective buffer transitions. Finally, Section
5 discusses related work and Section 6 sums up the
conclusions and points out avenues for future work.
2 Preliminaries
We now briefly present some basic definitions for
transition-based dependency parsing; a more thor-
ough explanation can be found in (Nivre, 2008).
2.1 Dependency graphs
Let w = w1 . . . wn be an input string. A depen-
dency graph forw is a directed graphG = (Vw, A);
where Vw = {0, 1, . . . , n} is a set of nodes, and
A ? Vw ? L ? Vw is a set of labelled arcs. Each
node in Vw encodes the position of a token in w,
where 0 is a dummy node used as artificial root. An
arc (i, l, j) will also be called a dependency link la-
belled l from i to j. We say that i is the syntactic
head of j and, conversely, that j is a dependent of
i. The length of the arc (i, l, j) is the value |j ? i|.
Most dependency representations of syntax do not
allow arbitrary dependency graphs. Instead, they re-
quire dependency graphs to be forests, i.e., acyclic
graphs where each node has at most one head. In this
paper, we will work with parsers that assume depen-
dency graphs G = (Vw, A) to satisfy the following
properties:
? Single-head: every node has at most one in-
coming arc (if (i, l, j) ? A, then for every
k 6= i, (k, l?, j) 6? A).
? Acyclicity: there are no directed cycles in G.
? Node 0 is a root, i.e., there are no arcs of the
form (i, l, 0) in A.
A dependency forest with a single root (i.e., where
all the nodes but one have at least one incoming arc)
is called a tree. Every dependency forest can triv-
ially be represented as a tree by adding arcs from
the dummy root node 0 to every other root node.
For reasons of computational efficiency, many de-
pendency parsers are restricted to work with forests
satisfying an additional restriction called projectiv-
ity. A dependency forest is said to be projective
if the set of nodes reachable by traversing zero or
more arcs from any given node k corresponds to a
continuous substring of the input (i.e., is an interval
{x ? Vw | i ? x ? j}). For trees with a dummy
root node at position 0, this is equivalent to not al-
lowing dependency links to cross when drawn above
the nodes (planarity).
2.2 Transition systems
A transition system is a nondeterministic state ma-
chine that maps input strings to dependency graphs.
In this paper, we will focus on stack-based transi-
tion systems. A stack-based transition system is a
quadruple S = (C, T, cs, Ct) where
? C is a set of parser configurations. Each con-
figuration is of the form c = (?, ?,A) where ?
is a list of nodes of Vw called the stack, ? is a
list of nodes of Vw called the buffer, and A is a
set of dependency arcs,
? T is a finite set of transitions, each of which is
a partial function t : C ? C,
? cs is an initialization function, mapping a sen-
tence w1 . . . wn to an initial configuration
cs = ([0], [1, . . . , n], ?),
? Ct is the set of terminal configurations Ct =
(?, [], A) ? C.
Transition systems are nondeterministic devices,
since several transitions may be applicable to the
same configuration. To obtain a deterministic parser
309
from a transition system, a classifier is trained to
greedily select the best transition at each state. This
training is typically done by using an oracle, which
is a function o : C ? T that selects a single transi-
tion at each configuration, given a tree in the training
set. The classifier is then trained to approximate this
oracle when the target tree is unknown.
2.3 The arc-eager parser
Nivre?s arc-eager dependency parser (Nivre, 2003;
Nivre et al2004) is one of the most widely known
and used transition-based parsers (see for example
(Zhang and Clark, 2008; Zhang and Nivre, 2011)).
This parser works by reading the input sentence
from left to right and creating dependency links as
soon as possible. This means that links are created in
a strict left-to-right order, and implies that while left-
ward links are built in a bottom-up fashion, a right-
ward link a ? b will be created before the node b
has collected its right dependents.
The arc-eager transition system has the following
four transitions (note that, for convenience, we write
a stack with node i on top as ?|i, and a buffer whose
first node is i as i|?):
? SHIFT : (?, i|?,A)? (?|i, ?, A).
? REDUCE : (?|i, ?, A) ? (?, ?,A). Precondi-
tion: ?k, l? | (k, l?, i) ? A.
? LEFT-ARCl : (?|i, j|?,A) ? (?, j|?,A ?
{(j, l, i)}). Preconditions: i 6= 0 and 6 ?k, l? |
(k, l?, i) ? A (single-head)
? RIGHT-ARCl :
(?|i, j|?,A)? (?|i|j, ?,A ? {(i, l, j)}).
The SHIFT transition reads an input word by re-
moving the first node from the buffer and placing it
on top of the stack. The REDUCE transition pops
the stack, and it can only be executed if the topmost
stack node has already been assigned a head. The
LEFT-ARC transition creates an arc from the first
node in the buffer to the node on top of the stack,
and then pops the stack. It can only be executed if
the node on top of the stack does not already have
a head. Finally, the RIGHT-ARC transition creates
an arc from the top of the stack to the first buffer
node, and then removes the latter from the buffer
and moves it to the stack.
The arc-eager parser has linear time complex-
ity. In principle, it is restricted to projective depen-
dency forests, but it can be used in conjunction with
the pseudo-projective transformation (Nivre et al
2006) in order to capture a restricted subset of non-
projective forests. Using this setup, it scored as one
of the top two systems in the CoNLL-X shared task.
3 Projective buffer transitions
In this section, we show that the accuracy of stack-
based transition systems can benefit from adding one
of a pair of new transitions, which we call projective
buffer transitions, to their transition sets.
3.1 The transitions
The two projective buffer transitions are defined as
follows:
? LEFT-BUFFER-ARCl :
(?, i|j|?,A)? (?, j|?,A ? {(j, l, i)}).
? RIGHT-BUFFER-ARCl :
(?, i|j|?,A)? (?, i|?,A ? {(i, l, j)}).
The LEFT-BUFFER-ARC transition creates a left-
ward dependency link from the second node to
the first node in the buffer, and then removes the
first node from the buffer. Conversely, the RIGHT-
BUFFER-ARC transition creates a rightward depen-
dency link from the first node to the second node
in the buffer, and then removes the second node.
We call these transitions projective buffer transitions
because, since they act on contiguous buffer nodes,
they can only create projective arcs.
Adding one (or both) of these transitions to a
projective or non-projective stack-based transition
system does not affect its correctness, as long as
this starting system cannot generate configurations
(?, ?,A) where a buffer node has a head in A1: it
cannot affect completeness because we are not re-
moving existing transitions, and therefore any de-
pendency graph that the original system could build
1Most stack-based transition systems in the literature disal-
low such configurations. However, in parsers that allow them
(such as those defined by Go?mez-Rodr??guez and Nivre (2010)),
projective buffer transitions can still be added without affecting
correctness if we impose explicit single-head and acyclicity pre-
conditions on them. We have not included these preconditions
by default for simplicity of presentation.
310
will still be obtainable by the augmented one; and it
cannot affect soundness (be it for projective depen-
dency forests or for any superset of them) because
the new transitions can only create projective arcs
and cannot violate the single-head or acyclicity con-
straints, given that a buffer node cannot have a head.
The idea behind projective buffer transitions is to
create dependency arcs of length one (i.e., arcs in-
volving contiguous nodes) in advance of the stan-
dard arc-building transitions that need at least one of
the nodes to get to the stack (LEFT-ARC and RIGHT-
ARC in the case of the arc-eager transition system).
Our hypothesis is that, as it is known that
short-distance dependencies are easier to learn for
transition-based parsers than long-distance ones
(McDonald and Nivre, 2007), handling these short
arcs in advance and removing their dependent nodes
will make it easier for the classifier to learn how
to make decisions involving the standard arc tran-
sitions.
Note that the fact that projective buffer transitions
create arcs of length 1 is not explicit in the defini-
tion of the transitions. For instance, if we add the
LEFT-BUFFER-ARCl transition only to the arc-eager
transition system, LEFT-BUFFER-ARCl will only be
able to create arcs of length 1, since it is easy to see
that the first two buffer nodes are contiguous in all
the accessible configurations. However, if we add
RIGHT-BUFFER-ARCl, this transition will have the
potential to create arcs of length greater than 1: for
example, if two consecutive RIGHT-BUFFER-ARCl
transitions are applied starting from a configuration
(?, i|i + 1|i + 2|?,A), the second application will
create an arc i? i+ 2 of length 2.
Although we could have added the length-1 re-
striction to the transition definitions, we have cho-
sen the more generic approach of leaving it to the
oracle instead. While the oracle typically used for
the arc-eager system follows the simple principle of
executing transitions that create an arc as soon as
it has the chance to, adding projective buffer transi-
tions opens up new possibilities: we may now have
several ways of creating an arc, and we have to de-
cide in which cases we train the parser to use one of
the buffer transitions and in which cases we prefer
to train it to ignore the buffer transitions and dele-
gate to the standard ones. Following the hypothe-
sis explained above, our policy has been to train the
parser to use buffer transitions whenever possible for
arcs of length one, and to not use them for arcs of
length larger than one. To test this idea, we also
conducted experiments with the alternative policy
?use buffer transitions whenever possible, regardless
of arc length?: as expected, the obtained accuracies
were (slightly) worse.
The chosen oracle policy is generic and can be
plugged into any stack-based parser: for a given
transition, first check whether it is possible to build a
gold-standard arc of length 1 with a projective buffer
transition.2 If so, choose that transition, and if not,
just delegate to the original parser?s oracle.
3.2 Experiments
To empirically evaluate the effect of projective
buffer transitions on parsing accuracy, we have con-
ducted experiments on eight datasets of the CoNLL-
X shared task (Buchholz and Marsi, 2006): Arabic
(Hajic? et al2004), Chinese (Chen et al2003),
Czech (Hajic? et al2006), Danish (Kromann, 2003),
German (Brants et al2002), Portuguese (Afonso et
al., 2002), Swedish (Nilsson et al2005) and Turk-
ish (Oflazer et al2003; Atalay et al2003).
As our baseline parser, we use the arc-eager pro-
jective transition system by Nivre (2003). Table 1
compares the accuracy obtained by this system alone
with that obtained when the LEFT-BUFFER-ARC
and RIGHT-BUFFER-ARC transitions are added to
it as explained in Section 3.1.
Accuracy is reported in terms of labelled (LAS)
and unlabelled (UAS) attachment score. We used
SVM classifiers from the LIBSVM package (Chang
and Lin, 2001) for all languages except for Chinese,
Czech and German. In these, we used the LIB-
LINEAR package (Fan et al2008) for classifica-
tion, since it reduces training time in these larger
datasets. Feature models for all parsers were specif-
ically tuned for each language.3
2In this context, ?possible? means that we can create the arc
without losing the possibility of creating other gold-standard
arcs. In the case of RIGHT-BUFFER-ARC, this involves check-
ing that the candidate dependent node has no dependents in the
gold-standard tree (if it has any, we cannot remove it from the
stack or it would not be able to collect its dependents, so we do
not use the buffer transition).
3All the experimental settings and feature models used are
included in the supplementary material and also available at
http://www.grupolys.org/?cgomezr/exp/.
311
NE NE+LBA NE+RBA
Language LAS UAS LAS UAS LAS UAS
Arabic 66.43 77.19 67.78 78.26 63.87 74.63
Chinese 86.46 90.18 82.47 86.14 86.62 90.64
Czech 77.24 83.40 78.70 84.24 78.28 83.94
Danish 84.91 89.80 85.21 90.20 82.53 87.35
German 86.18 88.60 84.31 86.50 86.48 88.90
Portug. 86.60 90.20 86.92 90.58 85.55 89.28
Swedish 83.33 88.83 82.81 88.03 81.66 88.03
Turkish 63.77 74.35 57.42 66.24 64.33 74.73
Table 1: Parsing accuracy (LAS and UAS, excluding punctuation) of Nivre?s arc-eager parser without modification
(NE), with the LEFT-BUFFER-ARC transition added (NE+LBA) and with the RIGHT-BUFFER-ARC transition added
(NE+RBA). Best results for each language are shown in boldface.
As can be seen in Table 1, adding a projective
buffer transition improves the performance of the
parser in seven out of the eight tested languages. The
improvements in LAS are statistically significant at
the .01 level4 in the Arabic and Czech treebanks.
Note that the decision of which buffer transition
to add strongly depends on the dataset. In the
majority of the treebanks, we can see that when
the LEFT-BUFFER-ARC transition improves perfor-
mance the RIGHT-BUFFER-ARC transition harms it,
and vice versa. The exceptions are Czech, where
both transitions are beneficial, and Swedish, where
both are harmful. Therefore, when using projective
buffer transitions in practice, the language and anno-
tation scheme should be taken into account (or tests
should be made) to decide which one to use.
Table 2 hints at the reason for this treebank-
sensitiveness. By analyzing the relative frequency
of leftward and rightward dependency links (and,
in particular, of leftward and rightward links of
length 1) in the different treebanks, we see a rea-
sonably clear tendency: the LEFT-BUFFER-ARC
transition works better in treebanks that contain a
large proportion of rightward arcs of length 1, and
the RIGHT-BUFFER-ARC transition works better in
treebanks with a large proportion of leftward arcs of
length 1. Note that, while this might seem coun-
terintuitive at a first glance, it is coherent with the
hypothesis that we formulated in Section 3.1: the
4Statistical significance was assessed using Dan Bikel?s ran-
domized parsing evaluation comparator: http://www.cis.
upenn.edu/?dbikel/software.html#comparator
Language L% R% L1% R1% Best PBT
Arabic 12.3 87.7 6.5 55.1 LBA
Chinese 58.4 41.6 35.8 15.1 RBA
Czech 41.4 58.6 22.1 24.9 LBA*
Danish 17.1 82.9 10.9 43.0 LBA
German 39.8 60.2 20.3 19.9 RBA
Portug. 32.6 67.4 22.5 26.9 LBA
Swedish 38.2 61.8 24.1 21.8 LBA*
Turkish 77.8 22.2 47.2 10.4 RBA
Table 2: Analysis of the datasets used in the experiments
in terms of: percentage of leftward and rightward links
(L%, R%), percentage of leftward and rightward links
of length 1 (L1%, R1%), and which projective buffer
transition works better for each dataset according to the
results in Table 1 (LBA = LEFT-BUFFER-ARC, RBA
= RIGHT-BUFFER-ARC). Languages where both tran-
sitions are beneficial (Czech) or harmful (Swedish) are
marked with an asterisk.
advantage of projective buffer transitions is not that
they build arcs more accurately than standard arc-
building transitions (in fact the opposite might be
expected, since they work on nodes while they are
still on the buffer and we have less information about
their surrounding nodes in our feature models), but
that they make it easier for the classifier to decide
among standard transitions. The analysis on Table
2 agrees with that explanation: LEFT-BUFFER-ARC
improves performance in treebanks where it is not
used too often but it can filter out leftward arcs of
length 1, making it easier for the parser to be accu-
rate on rightward arcs of length 1; and the converse
happens for RIGHT-BUFFER-ARC.
312
NE NE+LBA NE+RBA NE+LBA+RBA
Language LA RA LA* RA LBA LA RA* RBA LA* RA* LBA RBA
Arabic 58.28 67.77 42.61 68.65 77.46 55.88 60.63 79.70 37.40 62.28 66.78 75.94
Chinese 85.69 85.79 80.92 84.19 89.00 85.96 84.77 88.01 81.08 79.46 87.72 86.33
Czech 85.73 76.44 80.79 78.34 91.07 86.25 76.62 82.58 79.49 75.98 90.26 81.97
Danish 89.47 83.92 88.65 84.16 91.72 86.27 78.04 92.30 90.23 77.52 88.79 92.10
German 89.15 87.11 83.75 87.23 94.30 89.55 84.38 95.98 79.26 81.60 91.66 90.73
Portuguese 94.77 84.91 90.83 85.11 97.07 93.84 81.86 92.29 88.72 79.86 96.02 89.26
Swedish 87.75 80.74 84.62 81.30 92.83 87.12 74.77 90.73 78.10 72.50 90.86 89.89
Turkish 59.68 74.21 53.02 74.01 72.78 60.23 69.23 73.91 49.34 48.48 65.57 41.94
Table 3: Labelled precision of the arcs built by each transition of Nivre?s arc-eager parser without modification (NE),
with a projective buffer transition added (NE+LBA, NE+RBA) and with both projective buffer transitions added
(NE+LBA+RBA). We mark a standard LEFT-ARC (LA) or RIGHT-ARC (LA) transition with an asterisk (LA*, RA*)
when it is acting only on a ?hard? subset of leftward (rightward) arcs, and thus its precision is not directly comparable
to that of (LA, RA). Best results for each language and transition are shown in boldface.
To further test this idea, we computed the la-
belled precision of each individual transition of the
parsers with and without projective buffer transi-
tions, as shown in Table 3. As we can see, projec-
tive buffer transitions achieve better precision than
standard transitions, but this is not surprising since
they act only on ?easy? arcs of length 1. There-
fore, this high precision does not mean that they ac-
tually build arcs more accurately than the standard
transitions, since it is not measured on the same set
of arcs. Similarly, adding a projective buffer tran-
sition decreases the precision of its corresponding
standard transition, but this is because the standard
transition is then dealing only with ?harder? arcs of
length greather than 1, not because it is making more
errors. A more interesting insight comes from com-
paring transitions that are acting on the same tar-
get set of arcs: we see that, in the languages where
LEFT-BUFFER-ARC is beneficial, the addition of
this transition always improves the precision of the
standard RIGHT-ARC transition; and the converse
happens with RIGHT-BUFFER-ARC with respect to
LEFT-ARC. This further backs the hypothesis that
the filtering of ?easy? links achieved by projective
buffer transitions makes it easier for the classifier to
decide among standard transitions.
We also conducted experiments adding both tran-
sitions at the same time (NE+LBA+RBA), but the
results were worse than adding the suitable transi-
tion for each dataset. Table 3 hints at the reason: the
precision of buffer transitions noticeably decreases
when both of them are added at the same time, pre-
sumably because it is difficult for the classifier to
NE+LBA/RBA NE+PP (CoNLL X)
Language LAS UAS LAS UAS
Arabic 67.78 78.26 66.71 77.52
Chinese 86.62 90.64 86.92 90.54
Czech 78.70 84.24 78.42 84.80
Danish 85.21 90.20 84.77 89.80
German 86.48 88.90 85.82 88.76
Portug. 86.92 90.58 87.60 91.22
Swedish 82.81 88.03 84.58 89.50
Turkish 64.33 74.73 65.68 75.82
Table 4: Comparison of the parsing accuracy (LAS
and UAS, excluding punctuation) of Nivre?s arc-eager
parser with projective buffer transitions (NE+LBA/RBA)
and the parser with the pseudo-projective transformation
(Nivre et al2006)
decide between both with the restricted feature in-
formation available for buffer nodes.
To further put the obtained results into context,
Table 4 compares the performance of the arc-eager
parser with the projective buffer transition most suit-
able for each dataset with the results obtained by the
parser with the pseudo-projective transformation by
Nivre et al2006) in the CoNLL-X shared task, one
of the top two performing systems in that event. The
reader should be aware that the purpose of this ta-
ble is only to provide a broad idea of how our ap-
proach performs with respect to a well-known refer-
ence point, and not to make a detailed comparison,
since the two parsers have not been tuned in homo-
geneous conditions: on the one hand, we had access
to the CoNLL-X test sets which were unavailable
313
System Arabic Danish
Nivre et al2006) 66.71 84.77
McDonald et al2006) 66.91 84.79
Nivre (2009) 67.3 84.7
Go?mez-Rodr??guez and Nivre (2010) N/A 83.81
NE+LBA/RBA 67.78 85.21
Table 5: Comparison of the Arabic and Danish LAS ob-
tained by the arc-eager parser with projective buffer tran-
sitions in comparison to other parsers in the literature that
report results on these datasets.
for the participants in the shared task; on the other
hand, we did not fine-tune the classifier parameters
for each dataset like Nivre et al2006), but used de-
fault values for all languages.
As can be seen in the table, even though the
pseudo-projective parser is able to capture non-
projective syntactic phenomena, the algorithm with
projective buffer transitions (which is strictly pro-
jective) outperforms it in four of the eight treebanks,
including non-projective treebanks such as the Ger-
man one.
Furthermore, to our knowledge, our LAS results
for Arabic and Danish are currently the best pub-
lished results for a single-parser system on these
datasets, not only outperforming the systems partic-
ipating in CoNLL-X but also other parsers tested on
these treebanks in more recent years (see Table 5).
Finally, it is worth noting that adding projective
buffer transitions has no negative impact on effi-
ciency, either in terms of computational complex-
ity or of empirical runtime. Since each projective
buffer transition removes a node from the buffer, no
more than n such transitions can be executed for
a sentence of length n, so adding these transitions
cannot increase the complexity of a transition-based
parser. In the particular case of the arc-eager parser,
using projective buffer transitions reduces the aver-
age number of transitions needed to obtain a given
dependency forest, as some nodes can be dispatched
by a single transition rather than being shifted and
later popped from the stack. In practice, we ob-
served that the training and parsing times of the arc-
eager parser with projective buffer transitions were
slightly faster than without them on the Arabic, Chi-
nese, Swedish and Turkish treebanks, and slightly
slower than without them on the other four tree-
banks, so adding these transitions does not seem to
noticeably degrade (or improve) practical efficiency.
4 Non-projective buffer transitions
We now present a second set of transitions that still
follow the idea of early processing of some depen-
dency arcs, as in Section 3; but which are able to
create arcs skipping over a buffer node, so that they
can create some non-projective arcs. For this reason,
we call them non-projective buffer transitions.
4.1 The transitions
The two non-projective buffer transitions are defined
as follows:
? LEFT-NONPROJ-BUFFER-ARCl :
(?|i, j|k|?,A) ? (?, j|k|?,A ? {(k, l, i)}).
Preconditions: i 6= 0 and 6 ?m, l? | (m, l?, i) ?
A (single-head)
? RIGHT-NONPROJ-BUFFER-ARCl :
(?|i, j|k|?,A)? (?|i, j|?,A ? {(i, l, k)}).
The LEFT-NONPROJ-BUFFER-ARC transition
creates a leftward arc from the second buffer node
to the node on top of the stack, and then pops the
stack. It can only be executed if the node on top of
the stack does not already have a head. The RIGHT-
NONPROJ-BUFFER-ARC transition creates an arc
from the top of the stack to the second node in the
buffer, and then removes the latter from the buffer.
Note that these transitions are analogous to projec-
tive buffer transitions, and they use the second node
in the buffer in the same way, but they create arcs
involving the node on top of the stack rather than
the first buffer node. This change makes the pre-
condition that checks for a head necessary for the
transition LEFT-NONPROJ-BUFFER-ARC to respect
the single-head constraint, since many stack-based
parsers can generate configurations where the node
on top of the stack has a head.
We call these transitions non-projective buffer
transitions because, as they act on non-contiguous
nodes in the stack and buffer, they allow the creation
of a limited set of non-projective dependency arcs.
This means that, when added to a projective parser,
they will increase its coverage.5 On the other hand,
5They may also increase the coverage of parsers allowing
restricted forms of non-projectivity, but that depends on the par-
314
NE NE+LNBA NE+RNBA
Language LAS UAS LAS UAS LAS UAS
Arabic 66.43 77.19 67.13 77.90 67.21 77.92
Chinese 86.46 90.18 87.71 91.39 86.98 90.76
Czech 77.24 83.40 78.88 84.72 78.12 83.78
Danish 84.91 89.80 85.17 90.10 84.25 88.92
German 86.18 88.60 86.96 88.98 85.56 88.30
Portug. 86.60 90.20 86.78 90.34 86.07 89.92
Swedish 83.33 88.83 83.55 89.30 83.17 88.59
Turkish 63.77 74.35 63.04 73.99 65.01 75.70
Table 6: Parsing accuracy (LAS and UAS, excluding punctuation) of Nivre?s arc-eager parser without modifica-
tion (NE), with the LEFT-NONPROJ-BUFFER-ARC transition added (NE+LNBA) and with the RIGHT-NONPROJ-
BUFFER-ARC transition added (NE+RNBA). Best results for each language are shown in boldface.
adding these transitions to a stack-based transition
system does not affect soundness under the same
conditions and for the same reasons explained for
projective buffer transitions in Section 3.1.
Note that the fact that non-projective buffer tran-
sitions are able to create non-projective dependency
arcs does not mean that all the arcs that they build
are non-projective, since an arc on non-contiguous
nodes in the stack and buffer may or may not cross
other arcs. This means that non-projective buffer
transitions serve a dual purpose: not only they
increase coverage, but they also can create some
?easy? dependency links in advance of standard
transitions, just like projective buffer transitions.
Contrary to projective buffer transitions, we do
not impose any arc length restrictions on non-
projective buffer transitions (either as a hard con-
straint in the transitions themselves or as a policy in
the training oracle), since we would like the increase
in coverage to be as large as possible. We wish to
allow the parsers to create non-projective arcs in a
straightforward way and without compromising effi-
ciency. Therefore, to train the parser with these tran-
sitions, we use an oracle that employs them when-
ever possible, and delegates to the original parser?s
oracle otherwise.
4.2 Experiments
We evaluate the impact of non-projective buffer tran-
sitions on parsing accuracy by using the same base-
ticular subset of non-projective structures captured by each such
parser.
line parser, datasets and experimental settings as for
projective buffer transitions in Section 3.2. As can
be seen in Table 6, adding a non-projective buffer
transition to the arc-eager parser improves its per-
formance on all eight datasets. The improvements in
LAS are statistically significant at the .01 level (Dan
Bikel?s comparator) for Chinese, Czech and Turk-
ish. Note that the Chinese treebank is fully projec-
tive, this means that non-projective buffer transitions
are also beneficial when creating projective arcs.
While with projective buffer transitions we ob-
served that each of them was beneficial for about
half of the treebanks, and we related this to the
amount of leftward and rightward links of length 1 in
each; in the case of non-projective buffer transitions
we do not observe this tendency. In this case, LEFT-
NONPROJ-BUFFER-ARC works better than RIGHT-
NONPROJ-BUFFER-ARC in all datasets except for
Turkish and Arabic.
As with the projective transitions, we gathered
data about the individual precision of each of the
transitions. The results were similar to those for
the projective transitions, and show that adding a
non-projective buffer transition improves the preci-
sion of the standard transitions. We also experimen-
tally checked that adding both non-projective buffer
transitions at the same time (NE+LNBA+RNBA)
achieved worse performance than adding only the
most suitable transition for each dataset.
Table 7 compares the performance of the arc-
eager parser with the best non-projective buffer tran-
sition for each dataset with the results obtained by
315
NE+LNBA/RNBA NE+PP (CoNLL X)
Language LAS UAS LAS UAS
Arabic 67.21 77.92 66.71 77.52
Chinese 87.71 91.39 86.92 90.54
Czech 78.88 84.72 78.42 84.80
Danish 85.09 89.98 84.77 89.80
German 86.96 88.98 85.82 88.76
Portug. 86.78 90.34 87.60 91.22
Swedish 83.55 89.30 84.58 89.50
Turkish 65.01 75.70 65.68 75.82
Table 7: Comparison of the parsing accuracy (LAS
and UAS, excluding punctuation) of Nivre?s arc-
eager parser with non-projective buffer transitions
(NE+LNBA/RNBA) and the parser with the pseudo-
projective transformation (Nivre et al2006).
System PP PR NP NR
NE 80.40 80.76 - -
NE+LNBA/RNBA 80.96 81.33 58.87 15.66
NE+PP (CoNLL-X) 80.71 81.00 50.72 29.57
Table 8: Comparison of the precision and recall for pro-
jective (PP, PR) and non-projective (NP, NR) arcs, av-
eraged over all datasets, obtained by Nivre?s arc-eager
parser with and without non-projective buffer transitions
(NE+LNBA/RNBA, NE) and the parser with the pseudo-
projective transformation (Nivre et al2006).
the parser with the pseudo-projective transformation
by Nivre et al2006) in the CoNLL-X shared task.
Note that, like the one in Table 4, this should not
be interpreted as a homogeneous comparison. We
can see that the algorithm with non-projective buffer
transitions obtains better LAS in five out of the eight
treebanks. Precision and recall data on projective
and non-projective arcs (Table 8) show that, while
our parser does not capture as many non-projective
arcs as the pseudo-projective transformation (unsur-
prisingly, as it can only build non-projective arcs in
one direction: that of the particular non-projective
buffer transition used for each dataset); it does so
with greater precision and is more accurate than that
algorithm in projective arcs.
Like projective buffer transitions, non-projective
transitions do not increase the computational com-
plexity of stack-based parsers. The observed train-
ing and parsing times for the arc-eager parser with
non-projective buffer transitions showed a small
overhead with respect to the original arc-eager
(7.1% average increase in training time, 17.0% in
parsing time). For comparison, running the arc-
eager parser with the pseudo-projective transforma-
tion (Nivre et al2006) on the same machine pro-
duced a 23.5% increase in training time and a 87.5%
increase in parsing time.
5 Related work
The approach of adding an extra transition to a
parser to improve its accuracy has been applied in
the past by Choi and Palmer (2011). In that pa-
per, the LEFT-ARC transition from Nivre?s arc-eager
transition system is added to a list-based parser.
However, the goal of that transition is different
from ours (selecting between projective and non-
projective parsing, rather than building some arcs in
advance) and the approach is specific to one algo-
rithm while ours is generic ? for example, the LEFT-
ARC transition cannot be added to the arc-standard
and arc-eager parsers, or to extensions of those like
the ones by Attardi (2006) or Nivre (2009), because
these already have it.
The idea of creating dependency arcs of length 1
in advance to help the classifier has been used by
Cheng et al2006). However, their system creates
such arcs in a separate preprocessing step rather than
dynamically by adding a transition to the parser, and
our approach obtains better LAS and UAS results on
all the tested datasets.
The projective buffer transitions presented here
bear some resemblance to the easy-first parser by
Goldberg and Elhadad (2010), which allows cre-
ation of dependency arcs between any pair of con-
tiguous nodes and is based on the idea of ?easy? de-
pendency links being created first. However, while
the easy-first parser is an entirely new O(n log(n))
algorithm, our approach is a generic extension for
stack-based parsers that does not increase their com-
plexity (so, for example, applying it to the arc-eager
system as in the experiments in this paper yields
O(n) complexity).
Non-projective transitions that create dependency
arcs between non-contiguous nodes have been used
in the transition-based parser by Attardi (2006).
However, the transitions in that parser do not use
the second buffer node, since they are not intended
316
to create some arcs in advance. The non-projective
buffer transitions presented in this paper can also be
added to Attardi?s parser.
6 Discussion
We have presented a set of two transitions, called
projective buffer transitions, and showed that adding
one of them to Nivre?s arc-eager parser improves its
accuracy in seven out of eight tested datasets from
the CoNLL-X shared task. Furthermore, adding one
of a set of non-projective buffer transitions achieves
accuracy improvements in all of the eight datasets.
The obtained improvements are statistically signif-
icant for several of the treebanks, and the parser
with projective buffer transitions surpassed the best
published single-parser LAS results on two of them.
This comes at no cost either on computational com-
plexity or (in the case of projective transitions) on
empirical training and parsing times with respect to
the original parser.
While we have chosen Nivre?s well-known arc-
eager parser as our baseline, we have shown that
these transitions can be added to any stack-based de-
pendency parser, and we are not aware of any spe-
cific property of arc-eager that would make them
work better in practice on this parser than on others.
Therefore, future work will include an evaluation of
the impact of buffer transitions on more transition-
based parsers. Other research directions involve in-
vestigating the set of non-projective arcs allowed
by non-projective buffer transitions, defining dif-
ferent variants of buffer transitions (such as non-
projective buffer transitions that work with nodes lo-
cated deeper in the buffer) or using projective and
non-projective buffer transitions at the same time.
Acknowledgments
This research has been partially funded by the
Spanish Ministry of Economy and Competitive-
ness and FEDER (projects TIN2010-18552-C03-01
and TIN2010-18552-C03-02), Ministry of Educa-
tion (FPU Grant Program) and Xunta de Galicia
(Rede Galega de Recursos Lingu???sticos para unha
Sociedade do Con?ecemento).
References
Susana Afonso, Eckhard Bick, Renato Haber, and Diana
Santos. 2002. ?Floresta sinta?(c)tica?: a treebank for
Portuguese. In Proceedings of the 3rd International
Conference on Language Resources and Evaluation
(LREC 2002), pages 1968?1703, Paris, France. ELRA.
Nart B. Atalay, Kemal Oflazer, and Bilge Say. 2003. The
annotation process in the Turkish treebank. In Pro-
ceedings of EACL Workshop on Linguistically Inter-
preted Corpora (LINC-03), pages 243?246, Morris-
town, NJ, USA. Association for Computational Lin-
guistics.
Giuseppe Attardi. 2006. Experiments with a multilan-
guage non-projective dependency parser. In Proceed-
ings of the 10th Conference on Computational Natural
Language Learning (CoNLL), pages 166?170.
Sabine Brants, Stefanie Dipper, Silvia Hansen, Wolfgang
Lezius, and George Smith. 2002. The tiger treebank.
In Proceedings of the Workshop on Treebanks and Lin-
guistic Theories, September 20-21, Sozopol, Bulgaria.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings of the 10th Conference on Computational
Natural Language Learning (CoNLL), pages 149?164.
Chih-Chung Chang and Chih-Jen Lin, 2001. LIBSVM: A
Library for Support Vector Machines. Software avail-
able at http://www.csie.ntu.edu.tw/?cjlin/libsvm.
K. Chen, C. Luo, M. Chang, F. Chen, C. Chen, C. Huang,
and Z. Gao. 2003. Sinica treebank: Design criteria,
representational issues and implementation. In Anne
Abeille?, editor, Treebanks: Building and Using Parsed
Corpora, chapter 13, pages 231?248. Kluwer.
Yuchang Cheng, Masayuki Asahara, and Yuji Mat-
sumoto. 2006. Multi-lingual dependency parsing at
NAIST. In Proceedings of the Tenth Conference on
Computational Natural Language Learning, CoNLL-
X ?06, pages 191?195, Stroudsburg, PA, USA. Asso-
ciation for Computational Linguistics.
Jinho D. Choi and Martha Palmer. 2011. Getting the
most out of transition-based dependency parsing. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies: short papers - Volume 2, HLT
?11, pages 687?692, Stroudsburg, PA, USA. Associ-
ation for Computational Linguistics.
Jason M. Eisner. 1996. Three new probabilistic models
for dependency parsing: An exploration. In Proceed-
ings of the 16th International Conference on Compu-
tational Linguistics (COLING), pages 340?345.
R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang, and
C.-J. Lin. 2008. LIBLINEAR: A library for large lin-
ear classification. Journal of Machine Learning Re-
search, 9:1871?1874.
317
Yoav Goldberg and Michael Elhadad. 2010. An effi-
cient algorithm for easy-first non-directional depen-
dency parsing. In Human Language Technologies:
The 2010 Annual Conference of the North American
Chapter of the Association for Computational Linguis-
tics (NAACL HLT), pages 742?750.
Carlos Go?mez-Rodr??guez and Joakim Nivre. 2010. A
transition-based parser for 2-planar dependency struc-
tures. In Proceedings of the 48th Annual Meeting of
the Association for Computational Linguistics, ACL
?10, pages 1492?1501, Stroudsburg, PA, USA. Asso-
ciation for Computational Linguistics.
Jan Hajic?, Otakar Smrz?, Petr Zema?nek, Jan S?naidauf, and
Emanuel Bes?ka. 2004. Prague Arabic Dependency
Treebank: Development in data and tools. In Proceed-
ings of the NEMLAR International Conference on Ara-
bic Language Resources and Tools.
Jan Hajic?, Jarmila Panevova?, Eva Hajic?ova?, Jarmila
Panevova?, Petr Sgall, Petr Pajas, Jan S?te?pa?nek, Jir???
Havelka, and Marie Mikulova?. 2006. Prague Depen-
dency Treebank 2.0. CDROM CAT: LDC2006T01,
ISBN 1-58563-370-4. Linguistic Data Consortium.
Liang Huang and Kenji Sagae. 2010. Dynamic program-
ming for linear-time incremental parsing. In Proceed-
ings of the 48th Annual Meeting of the Association
for Computational Linguistics, ACL ?10, pages 1077?
1086, Stroudsburg, PA, USA. Association for Compu-
tational Linguistics.
Matthias T. Kromann. 2003. The Danish dependency
treebank and the underlying linguistic theory. In Pro-
ceedings of the 2nd Workshop on Treebanks and Lin-
guistic Theories (TLT), pages 217?220, Va?xjo?, Swe-
den. Va?xjo? University Press.
Andre Martins, Noah Smith, and Eric Xing. 2009. Con-
cise integer linear programming formulations for de-
pendency parsing. In Proceedings of the Joint Confer-
ence of the 47th Annual Meeting of the ACL and the 4th
International Joint Conference on Natural Language
Processing of the AFNLP (ACL-IJCNLP), pages 342?
350.
Ryan McDonald and Joakim Nivre. 2007. Charac-
terizing the errors of data-driven dependency parsing
models. In Proceedings of the 2007 Joint Conference
on Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learning
(EMNLP-CoNLL), pages 122?131.
Ryan McDonald and Joakim Nivre. 2011. Analyzing
and integrating dependency parsers. Comput. Lin-
guist., 37:197?230.
Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajic?. 2005. Non-projective dependency pars-
ing using spanning tree algorithms. In Proceedings
of the Human Language Technology Conference and
the Conference on Empirical Methods in Natural Lan-
guage Processing (HLT/EMNLP), pages 523?530.
Ryan McDonald, Kevin Lerman, and Fernando Pereira.
2006. Multilingual dependency analysis with a two-
stage discriminative parser. In Proceedings of the
10th Conference on Computational Natural Language
Learning (CoNLL), pages 216?220.
Jens Nilsson, Johan Hall, and Joakim Nivre. 2005.
MAMBA meets TIGER: Reconstructing a Swedish
treebank from Antiquity. In Peter Juel Henrichsen, ed-
itor, Proceedings of the NODALIDA Special Session
on Treebanks.
Joakim Nivre, Johan Hall, and Jens Nilsson. 2004.
Memory-based dependency parsing. In Proceedings
of the 8th Conference on Computational Natural Lan-
guage Learning (CoNLL-2004), pages 49?56, Morris-
town, NJ, USA. Association for Computational Lin-
guistics.
Joakim Nivre, Johan Hall, Jens Nilsson, Gu?lsen Eryig?it,
and Svetoslav Marinov. 2006. Labeled pseudo-
projective dependency parsing with support vector ma-
chines. In Proceedings of the 10th Conference on
Computational Natural Language Learning (CoNLL),
pages 221?225.
Joakim Nivre. 2003. An efficient algorithm for projec-
tive dependency parsing. In Proceedings of the 8th In-
ternational Workshop on Parsing Technologies (IWPT
03), pages 149?160. ACL/SIGPARSE.
Joakim Nivre. 2008. Algorithms for Deterministic Incre-
mental Dependency Parsing. Computational Linguis-
tics, 34(4):513?553.
Joakim Nivre. 2009. Non-projective dependency parsing
in expected linear time. In Proceedings of the Joint
Conference of the 47th Annual Meeting of the ACL and
the 4th International Joint Conference on Natural Lan-
guage Processing of the AFNLP (ACL-IJCNLP), pages
351?359.
Kemal Oflazer, Bilge Say, Dilek Zeynep Hakkani-Tu?r,
and Go?khan Tu?r. 2003. Building a Turkish treebank.
In Anne Abeille?, editor, Treebanks: Building and Us-
ing Parsed Corpora, pages 261?277. Kluwer.
Kenji Sagae and Jun?ichi Tsujii. 2008. Shift-reduce de-
pendency DAG parsing. In Proceedings of the 22nd
International Conference on Computational Linguis-
tics (COLING), pages 753?760.
Stephen Tratz and Eduard Hovy. 2011. A fast, accurate,
non-projective, semantically-enriched parser. In Pro-
ceedings of the 2011 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1257?
1268, Edinburgh, Scotland, UK., July. Association for
Computational Linguistics.
Hiroyasu Yamada and Yuji Matsumoto. 2003. Statisti-
cal dependency analysis with support vector machines.
318
In Proceedings of the 8th International Workshop on
Parsing Technologies (IWPT), pages 195?206.
Yue Zhang and Stephen Clark. 2008. A tale of two
parsers: Investigating and combining graph-based and
transition-based dependency parsing. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing (EMNLP), pages 562?571.
Yue Zhang and Joakim Nivre. 2011. Transition-based
dependency parsing with rich non-local features. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies: short papers - Volume 2, HLT
?11, pages 188?193, Stroudsburg, PA, USA. Associ-
ation for Computational Linguistics.
319
Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, pages 66?76,
Avignon, France, April 23 - 27 2012. c?2012 Association for Computational Linguistics
Dependency Parsing with Undirected Graphs
Carlos Go?mez-Rodr??guez
Departamento de Computacio?n
Universidade da Corun?a
Campus de Elvin?a, 15071
A Corun?a, Spain
carlos.gomez@udc.es
Daniel Ferna?ndez-Gonza?lez
Departamento de Informa?tica
Universidade de Vigo
Campus As Lagoas, 32004
Ourense, Spain
danifg@uvigo.es
Abstract
We introduce a new approach to transition-
based dependency parsing in which the
parser does not directly construct a depen-
dency structure, but rather an undirected
graph, which is then converted into a di-
rected dependency tree in a post-processing
step. This alleviates error propagation,
since undirected parsers do not need to ob-
serve the single-head constraint.
Undirected parsers can be obtained by sim-
plifying existing transition-based parsers
satisfying certain conditions. We apply this
approach to obtain undirected variants of
the planar and 2-planar parsers and of Cov-
ington?s non-projective parser. We perform
experiments on several datasets from the
CoNLL-X shared task, showing that these
variants outperform the original directed al-
gorithms in most of the cases.
1 Introduction
Dependency parsing has proven to be very use-
ful for natural language processing tasks. Data-
driven dependency parsers such as those by Nivre
et al(2004), McDonald et al(2005), Titov and
Henderson (2007), Martins et al(2009) or Huang
and Sagae (2010) are accurate and efficient, they
can be trained from annotated data without the
need for a grammar, and they provide a simple
representation of syntax that maps to predicate-
argument structure in a straightforward way.
In particular, transition-based dependency
parsers (Nivre, 2008) are a type of dependency
parsing algorithms which use a model that scores
transitions between parser states. Greedy deter-
ministic search can be used to select the transition
to be taken at each state, thus achieving linear or
quadratic time complexity.
0          1          2          3
Figure 1: An example dependency structure where
transition-based parsers enforcing the single-head con-
straint will incur in error propagation if they mistak-
enly build a dependency link 1 ? 2 instead of 2 ? 1
(dependency links are represented as arrows going
from head to dependent).
It has been shown by McDonald and Nivre
(2007) that such parsers suffer from error prop-
agation: an early erroneous choice can place the
parser in an incorrect state that will in turn lead to
more errors. For instance, suppose that a sentence
whose correct analysis is the dependency graph
in Figure 1 is analyzed by any bottom-up or left-
to-right transition-based parser that outputs de-
pendency trees, therefore obeying the single-head
constraint (only one incoming arc is allowed per
node). If the parser chooses an erroneous transi-
tion that leads it to build a dependency link from
1 to 2 instead of the correct link from 2 to 1, this
will lead it to a state where the single-head con-
straint makes it illegal to create the link from 3 to
2. Therefore, a single erroneous choice will cause
two attachment errors in the output tree.
With the goal of minimizing these sources of
errors, we obtain novel undirected variants of
several parsers; namely, of the planar and 2-
planar parsers by Go?mez-Rodr??guez and Nivre
(2010) and the non-projective list-based parser
described by Nivre (2008), which is based on
Covington?s algorithm (Covington, 2001). These
variants work by collapsing the LEFT-ARC and
66
RIGHT-ARC transitions in the original parsers,
which create right-to-left and left-to-right depen-
dency links, into a single ARC transition creating
an undirected link. This has the advantage that
the single-head constraint need not be observed
during the parsing process, since the directed no-
tions of head and dependent are lost in undirected
graphs. This gives the parser more freedom and
can prevent situations where enforcing the con-
straint leads to error propagation, as in Figure 1.
On the other hand, these new algorithms have
the disadvantage that their output is an undirected
graph, which has to be post-processed to recover
the direction of the dependency links and generate
a valid dependency tree. Thus, some complexity
is moved from the parsing process to this post-
processing step; and each undirected parser will
outperform the directed version only if the simpli-
fication of the parsing phase is able to avoid more
errors than are generated by the post-processing.
As will be seen in latter sections, experimental re-
sults indicate that this is in fact the case.
The rest of this paper is organized as follows:
Section 2 introduces some notation and concepts
that we will use throughout the paper. In Sec-
tion 3, we present the undirected versions of the
parsers by Go?mez-Rodr??guez and Nivre (2010)
and Nivre (2008), as well as some considerations
about the feature models suitable to train them. In
Section 4, we discuss post-processing techniques
that can be used to recover dependency trees from
undirected graphs. Section 5 presents an empir-
ical study of the performance obtained by these
parsers, and Section 6 contains a final discussion.
2 Preliminaries
2.1 Dependency Graphs
Let w = w1 . . . wn be an input string. A de-
pendency graph for w is a directed graph G =
(Vw, E), where Vw = {0, . . . , n} is the set of
nodes, and E ? Vw ? Vw is the set of directed
arcs. Each node in Vw encodes the position of
a token in w, and each arc in E encodes a de-
pendency relation between two tokens. We write
i ? j to denote a directed arc (i, j), which will
also be called a dependency link from i to j.1 We
1In practice, dependency links are usually labeled, but
to simplify the presentation we will ignore labels throughout
most of the paper. However, all the results and algorithms
presented can be applied to labeled dependency graphs and
will be so applied in the experimental evaluation.
say that i is the head of j and, conversely, that j
is a syntactic dependent of i.
Given a dependency graph G = (Vw, E), we
write i ?? j ? E if there is a (possibly empty)
directed path from i to j; and i ?? j ? E if
there is a (possibly empty) path between i and j in
the undirected graph underlying G (omitting the
references to E when clear from the context).
Most dependency-based representations of syn-
tax do not allow arbitrary dependency graphs, in-
stead, they are restricted to acyclic graphs that
have at most one head per node. Dependency
graphs satisfying these constraints are called de-
pendency forests.
Definition 1 A dependency graph G is said to be
a forest iff it satisfies:
1. Acyclicity constraint: if i ?? j, then not
j ? i.
2. Single-head constraint: if j ? i, then there
is no k 6= j such that k ? i.
A node that has no head in a dependency for-
est is called a root. Some dependency frame-
works add the additional constraint that depen-
dency forests have only one root (or, equivalently,
that they are connected). Such a forest is called a
dependency tree. A dependency tree can be ob-
tained from any dependency forest by linking all
of its root nodes as dependents of a dummy root
node, conventionally located in position 0 of the
input.
2.2 Transition Systems
In the framework of Nivre (2008), transition-
based parsers are described by means of a non-
deterministic state machine called a transition
system.
Definition 2 A transition system for dependency
parsing is a tuple S = (C, T, cs, Ct), where
1. C is a set of possible parser configurations,
2. T is a finite set of transitions, which are par-
tial functions t : C ? C,
3. cs is a total initialization function mapping
each input string to a unique initial configu-
ration, and
4. Ct ? C is a set of terminal configurations.
To obtain a deterministic parser from a non-
deterministic transition system, an oracle is used
to deterministically select a single transition at
67
each configuration. An oracle for a transition sys-
tem S = (C, T, cs, Ct) is a function o : C ? T .
Suitable oracles can be obtained in practice by
training classifiers on treebank data (Nivre et al
2004).
2.3 The Planar, 2-Planar and Covington
Transition Systems
Our undirected dependency parsers are based
on the planar and 2-planar transition systems
by Go?mez-Rodr??guez and Nivre (2010) and the
version of the Covington (2001) non-projective
parser defined by Nivre (2008). We now outline
these directed parsers briefly, a more detailed de-
scription can be found in the above references.
2.3.1 Planar
The planar transition system by Go?mez-
Rodr??guez and Nivre (2010) is a linear-time
transition-based parser for planar dependency
forests, i.e., forests whose dependency arcs do not
cross when drawn above the words. The set of
planar dependency structures is a very mild ex-
tension of that of projective structures (Kuhlmann
and Nivre, 2006).
Configurations in this system are of the form
c = ??, B,A? where ? and B are disjoint lists of
nodes from Vw (for some input w), and A is a set
of dependency links over Vw. The list B, called
the buffer, holds the input words that are still to
be read. The list ?, called the stack, is initially
empty and is used to hold words that have depen-
dency links pending to be created. The system
is shown at the top in Figure 2, where the nota-
tion ? | i is used for a stack with top i and tail ?,
and we invert the notation for the buffer for clarity
(i.e., i | B as a buffer with top i and tail B).
The system reads the input sentence and creates
links in a left-to-right order by executing its four
transitions, until it gets to a terminal configura-
tion. A SHIFT transition moves the first (leftmost)
node in the buffer to the top of the stack. Transi-
tions LEFT-ARC and RIGHT-ARC create leftward
or rightward link, respectively, involving the first
node in the buffer and the topmost node in the
stack. Finally, REDUCE transition is used to pop
the top word from the stack when we have fin-
ished building arcs to or from it.
2.3.2 2-Planar
The 2-planar transition system by Go?mez-
Rodr??guez and Nivre (2010) is an extension of
the planar system that uses two stacks, allowing
it to recognize 2-planar structures, a larger set
of dependency structures that has been shown to
cover the vast majority of non-projective struc-
tures in a number of treebanks (Go?mez-Rodr??guez
and Nivre, 2010).
This transition system, shown in Figure 2, has
configurations of the form c = ??0,?1, B,A? ,
where we call ?0 the active stack and ?1 the in-
active stack. Its SHIFT, LEFT-ARC, RIGHT-ARC
and REDUCE transitions work similarly to those
in the planar parser, but while SHIFT pushes the
first word in the buffer to both stacks; the other
three transitions only work with the top of the ac-
tive stack, ignoring the inactive one. Finally, a
SWITCH transition is added that makes the active
stack inactive and vice versa.
2.3.3 Covington Non-Projective
Covington (2001) proposes several incremen-
tal parsing strategies for dependency representa-
tions and one of them can recover non-projective
dependency graphs. Nivre (2008) implements a
variant of this strategy as a transition system with
configurations of the form c = ??1, ?2, B,A?,
where ?1 and ?2 are lists containing partially pro-
cessed words and B is the buffer list of unpro-
cessed words.
The Covington non-projective transition sys-
tem is shown at the bottom in Figure 2. At each
configuration c = ??1, ?2, B,A?, the parser has
to consider whether any dependency arc should
be created involving the top of the buffer and the
words in ?1. A LEFT-ARC transition adds a link
from the first node j in the buffer to the node in the
head of the list ?1, which is moved to the list ?2
to signify that we have finished considering it as a
possible head or dependent of j. The RIGHT-ARC
transition does the same manipulation, but creat-
ing the symmetric link. A NO-ARC transition re-
moves the head of the list ?1 and inserts it at the
head of the list ?2 without creating any arcs: this
transition is to be used where there is no depen-
dency relation between the top node in the buffer
and the head of ?1, but we still may want to cre-
ate an arc involving the top of the buffer and other
nodes in ?1. Finally, if we do not want to create
any such arcs at all, we can execute a SHIFT tran-
sition, which advances the parsing process by re-
moving the first node in the bufferB and inserting
it at the head of a list obtained by concatenating
68
?1 and ?2. This list becomes the new ?1, whereas
?2 is empty in the resulting configuration.
Note that the Covington parser has quadratic
complexity with respect to input length, while the
planar and 2-planar parsers run in linear time.
3 The Undirected Parsers
The transition systems defined in Section 2.3
share the common property that their LEFT-ARC
and RIGHT-ARC have exactly the same effects ex-
cept for the direction of the links that they create.
We can take advantage of this property to define
undirected versions of these transition systems, by
transforming them as follows:
? Configurations are changed so that the arc set
A is a set of undirected arcs, instead of di-
rected arcs.
? The LEFT-ARC and RIGHT-ARC transitions
in each parser are collapsed into a single ARC
transition that creates an undirected arc.
? The preconditions of transitions that guaran-
tee the single-head constraint are removed,
since the notions of head and dependent are
lost in undirected graphs.
By performing these transformations and leaving
the systems otherwise unchanged, we obtain the
undirected variants of the planar, 2-planar and
Covington algorithms that are shown in Figure 3.
Note that the transformation can be applied
to any transition system having LEFT-ARC and
RIGHT-ARC transitions that are equal except for
the direction of the created link, and thus col-
lapsable into one. The above three transition sys-
tems fulfill this property, but not every transition
system does. For example, the well-known arc-
eager parser of Nivre (2003) pops a node from the
stack when creating left arcs, and pushes a node
to the stack when creating right arcs, so the trans-
formation cannot be applied to it.2
2One might think that the arc-eager algorithm could still
be transformed by converting each of its arc transitions into
an undirected transition, without collapsing them into one.
However, this would result into a parser that violates the
acyclicity constraint, since the algorithm is designed in such
a way that acyclicity is only guaranteed if the single-head
constraint is kept. It is easy to see that this problem cannot
happen in parsers where LEFT-ARC and RIGHT-ARC transi-
tions have the same effect: in these, if a directed graph is not
parsable in the original algorithm, its underlying undirected
graph cannot not be parsable in the undirected variant.
3.1 Feature models
Some of the features that are typically used to
train transition-based dependency parsers depend
on the direction of the arcs that have been built up
to a certain point. For example, two such features
for the planar parser could be the POS tag associ-
ated with the head of the topmost stack node, or
the label of the arc going from the first node in the
buffer to its leftmost dependent.3
As the notion of head and dependent is lost in
undirected graphs, this kind of features cannot be
used to train undirected parsers. Instead, we use
features based on undirected relations between
nodes. We found that the following kinds of fea-
tures worked well in practice as a replacement for
features depending on arc direction:
? Information about the ith node linked to a
given node (topmost stack node, topmost
buffer node, etc.) on the left or on the right,
and about the associated undirected arc, typi-
cally for i = 1, 2, 3,
? Information about whether two nodes are
linked or not in the undirected graph, and
about the label of the arc between them,
? Information about the first left and right
?undirected siblings? of a given node, i.e., the
first node q located to the left of the given node
p such that p and q are linked to some common
node r located to the right of both, and vice
versa. Note that this notion of undirected sib-
lings does not correspond exclusively to sib-
lings in the directed graph, since it can also
capture other second-order interactions, such
as grandparents.
4 Reconstructing the dependency forest
The modified transition systems presented in the
previous section generate undirected graphs. To
obtain complete dependency parsers that are able
to produce directed dependency forests, we will
need a reconstruction step that will assign a direc-
tion to the arcs in such a way that the single-head
constraint is obeyed. This reconstruction step can
be implemented by building a directed graph with
weighted arcs corresponding to both possible di-
rections of each undirected edge, and then finding
an optimum branching to reduce it to a directed
3These example features are taken from the default model
for the planar parser in version 1.5 of MaltParser (Nivre et
al., 2006).
69
Planar initial/terminal configurations: cs(w1 . . . wn) = ?[], [1 . . . n], ??, Cf = {??, [], A? ? C}
Transitions: SHIFT ??, i|B,A? ? ??|i, B,A?
REDUCE ??|i, B,A? ? ??, B,A?
LEFT-ARC ??|i, j|B,A? ? ??|i, j|B,A ? {(j, i)}?
only if @k | (k, i) ? A (single-head) and i?? j 6? A (acyclicity).
RIGHT-ARC ??|i, j|B,A? ? ??|i, j|B,A ? {(i, j)}?
only if @k | (k, j) ? A (single-head) and i?? j 6? A (acyclicity).
2-Planar initial/terminal configurations: cs(w1 . . . wn) = ?[], [], [1 . . . n], ??, Cf = {??0,?1, [], A? ? C}
Transitions: SHIFT ??0,?1, i|B,A? ? ??0|i,?1|i, B,A?
REDUCE ??0|i,?1, B,A? ? ??0,?1, B,A?
LEFT-ARC ??0|i,?1, j|B,A? ? ??0|i,?1, j|B,A ? {j, i)}?
only if @k | (k, i) ? A (single-head) and i?? j 6? A (acyclicity).
RIGHT-ARC ??0|i,?1, j|B,A? ? ??0|i,?1, j|B,A ? {(i, j)}?
only if @k | (k, j) ? A (single-head) and i?? j 6? A (acyclicity).
SWITCH ??0,?1, B,A? ? ??1,?0, B,A?
Covington initial/term. configurations: cs(w1 . . . wn) = ?[], [], [1 . . . n], ??, Cf = {??1, ?2, [], A? ? C}
Transitions: SHIFT ??1, ?2, i|B,A? ? ??1 ? ?2|i, [], B,A?
NO-ARC ??1|i, ?2, B,A? ? ??1, i|?2, B,A?
LEFT-ARC ??1|i, ?2, j|B,A? ? ??1, i|?2, j|B,A ? {(j, i)}?
only if @k | (k, i) ? A (single-head) and i?? j 6? A (acyclicity).
RIGHT-ARC ??1|i, ?2, j|B,A? ? ??1, i|?2, j|B,A ? {(i, j)}?
only if @k | (k, j) ? A (single-head) and i?? j 6? A (acyclicity).
Figure 2: Transition systems for planar, 2-planar and Covington non-projective dependency parsing.
Undirected Planar initial/term. conf.: cs(w1 . . . wn) = ?[], [1 . . . n], ??, Cf = {??, [], A? ? C}
Transitions: SHIFT ??, i|B,A? ? ??|i, B,A?
REDUCE ??|i, B,A? ? ??, B,A?
ARC ??|i, j|B,A? ? ??|i, j|B,A ? {{i, j}}?
only if i?? j 6? A (acyclicity).
Undirected 2-Planar initial/term. conf.: cs(w1 . . . wn) = ?[], [], [1 . . . n], ??, Cf = {??0,?1, [], A? ? C}
Transitions: SHIFT ??0,?1, i|B,A? ? ??0|i,?1|i, B,A?
REDUCE ??0|i,?1, B,A? ? ??0,?1, B,A?
ARC ??0|i,?1, j|B,A? ? ??0|i,?1, j|B,A ? {{i, j}}?
only if i?? j 6? A (acyclicity).
SWITCH ??0,?1, B,A? ? ??1,?0, B,A?
Undirected Covington init./term. conf.: cs(w1 . . . wn) = ?[], [], [1 . . . n], ??, Cf = {??1, ?2, [], A? ? C}
Transitions: SHIFT ??1, ?2, i|B,A? ? ??1 ? ?2|i, [], B,A?
NO-ARC ??1|i, ?2, B,A? ? ??1, i|?2, B,A?
ARC ??1|i, ?2, j|B,A? ? ??1, i|?2, j|B,A ? {{i, j}}?
only if i?? j 6? A (acyclicity).
Figure 3: Transition systems for undirected planar, 2-planar and Covington non-projective dependency parsing.
70
tree. Different criteria for assigning weights to
arcs provide different variants of the reconstruc-
tion technique.
To describe these variants, we first introduce
preliminary definitions. Let U = (Vw, E) be
an undirected graph produced by an undirected
parser for some string w. We define the follow-
ing sets of arcs:
A1(U) = {(i, j) | j 6= 0 ? {i, j} ? E},
A2(U) = {(0, i) | i ? Vw}.
Note that A1(U) represents the set of arcs ob-
tained from assigning an orientation to an edge
in U , except arcs whose dependent is the dummy
root, which are disallowed. On the other hand,
A2(U) contains all the possible arcs originating
from the dummy root node, regardless of whether
their underlying undirected edges are in U or not;
this is so that reconstructions are allowed to link
unattached tokens to the dummy root.
The reconstruction process consists of finding
a minimum branching (i.e. a directed minimum
spanning tree) for a weighted directed graph ob-
tained from assigning a cost c(i, j) to each arc
(i, j) of the following directed graph:
D(U) = {Vw, A(U) = A1(U) ?A2(U)}.
That is, we will find a dependency tree T =
(Vw, AT ? A(U)) such that the sum of costs of
the arcs in AT is minimal. In general, such a min-
imum branching can be calculated with the Chu-
Liu-Edmonds algorithm (Chu and Liu, 1965; Ed-
monds, 1967). Since the graph D(U) has O(n)
nodes and O(n) arcs for a string of length n, this
can be done in O(n log n) if implemented as de-
scribed by Tarjan (1977).
However, applying these generic techniques is
not necessary in this case: since our graph U is
acyclic, the problem of reconstructing the forest
can be reduced to choosing a root word for each
connected component in the graph, linking it as
a dependent of the dummy root and directing the
other arcs in the component in the (unique) way
that makes them point away from the root.
It remains to see how to assign the costs c(i, j)
to the arcs of D(U): different criteria for assign-
ing scores will lead to different reconstructions.
4.1 Naive reconstruction
A first, very simple reconstruction technique can
be obtained by assigning arc costs to the arcs in
A(U) as follows:
c(i, j)
{
1 if (i, j) ? A1(U),
2 if (i, j) ? A2(U) ? (i, j) 6? A1(U).
This approach gives the same cost to all arcs
obtained from the undirected graph U , while also
allowing (at a higher cost) to attach any node to
the dummy root. To obtain satisfactory results
with this technique, we must train our parser to
explicitly build undirected arcs from the dummy
root node to the root word(s) of each sentence us-
ing arc transitions (note that this implies that we
need to represent forests as trees, in the manner
described at the end of Section 2.1). Under this
assumption, it is easy to see that we can obtain the
correct directed tree T for a sentence if it is pro-
vided with its underlying undirected tree U : the
tree is obtained in O(n) as the unique orientation
of U that makes each of its edges point away from
the dummy root.
This approach to reconstruction has the advan-
tage of being very simple and not adding any com-
plications to the parsing process, while guarantee-
ing that the correct directed tree will be recovered
if the undirected tree for a sentence is generated
correctly. However, it is not very robust, since the
direction of all the arcs in the output depends on
which node is chosen as sentence head and linked
to the dummy root. Therefore, a parsing error af-
fecting the undirected edge involving the dummy
root may result in many dependency links being
erroneous.
4.2 Label-based reconstruction
To achieve a more robust reconstruction, we use
labels to encode a preferred direction for depen-
dency arcs. To do so, for each pre-existing label
X in the training set, we create two labels Xl and
Xr. The parser is then trained on a modified ver-
sion of the training set where leftward links orig-
inally labelled X are labelled Xl, and rightward
links originally labelled X are labelled Xr. Thus,
the output of the parser on a new sentence will be
an undirected graph where each edge has a label
with an annotation indicating whether the recon-
struction process should prefer to link the pair of
nodes with a leftward or a rightward arc. We can
then assign costs to our minimum branching algo-
rithm so that it will return a tree agreeing with as
many such annotations as possible.
71
To do this, we call A1+(U) ? A1(U) the set
of arcs in A1(U) that agree with the annotations,
i.e., arcs (i, j) ? A1(U) where either i < j and
i, j is labelledXr inU , or i > j and i, j is labelled
Xl in U . We callA1?(U) the set of arcs inA1(U)
that disagree with the annotations, i.e.,A1?(U) =
A1(U)\A1+(U). And we assign costs as follows:
c(i, j)
?
?
?
1 if (i, j) ? A1+(U),
2 if (i, j) ? A1?(U),
2n if (i, j) ? A2(U) ? (i, j) 6? A1(U).
where n is the length of the string.
With these costs, the minimum branching algo-
rithm will find a tree which agrees with as many
annotations as possible. Additional arcs from the
root not corresponding to any edge in the output
of the parser (i.e. arcs inA2(U) but not inA1(U))
will be used only if strictly necessary to guarantee
connectedness, this is implemented by the high
cost for these arcs.
While this may be the simplest cost assignment
to implement label-based reconstruction, we have
found that better empirical results are obtained if
we give the algorithm more freedom to create new
arcs from the root, as follows:
c(i, j)
?
?
?
1 if (i, j) ? A1+(U) ? (i, j) 6? A2(U),
2 if (i, j) ? A1?(U) ? (i, j) 6? A2(U),
2n if (i, j) ? A2(U).
While the cost of arcs from the dummy root is
still 2n, this is now so even for arcs that are in the
output of the undirected parser, which had cost 1
before. Informally, this means that with this con-
figuration the postprocessor does not ?trust? the
links from the dummy root created by the parser,
and may choose to change them if it is conve-
nient to get a better agreement with label anno-
tations (see Figure 4 for an example of the dif-
ference between both cost assignments). We be-
lieve that the better accuracy obtained with this
criterion probably stems from the fact that it is bi-
ased towards changing links from the root, which
tend to be more problematic for transition-based
parsers, while respecting the parser output for
links located deeper in the dependency structure,
for which transition-based parsers tend to be more
accurate (McDonald and Nivre, 2007).
Note that both variants of label-based recon-
struction have the property that, if the undirected
parser produces the correct edges and labels for a
0        1       2        3       4        5
R
R L L L
0        1       2        3       4        5
0        1       2        3       4        5
a.
b.
c.
Figure 4: a) An undirected graph obtained by the
parser with the label-based transformation, b) and c)
The dependency graph obtained by each of the variants
of the label-based reconstruction (note how the second
variant moves an arc from the root).
given sentence, then the obtained directed tree is
guaranteed to be correct (as it will simply be the
tree obtained by decoding the label annotations).
5 Experiments
In this section, we evaluate the performance of the
undirected planar, 2-planar and Covington parsers
on eight datasets from the CoNLL-X shared task
(Buchholz and Marsi, 2006).
Tables 1, 2 and 3 compare the accuracy of the
undirected versions with naive and label-based re-
construction to that of the directed versions of
the planar, 2-planar and Covington parsers, re-
spectively. In addition, we provide a comparison
to well-known state-of-the-art projective and non-
projective parsers: the planar parsers are com-
pared to the arc-eager projective parser by Nivre
(2003), which is also restricted to planar struc-
tures; and the 2-planar parsers are compared with
the arc-eager parser with pseudo-projective trans-
formation of Nivre and Nilsson (2005), capable of
handling non-planar dependencies.
We use SVM classifiers from the LIBSVM
package (Chang and Lin, 2001) for all the lan-
guages except Chinese, Czech and German. In
these, we use the LIBLINEAR package (Fan et
al., 2008) for classification, which reduces train-
ing time for these larger datasets; and feature
models adapted to this system which, in the case
of German, result in higher accuracy than pub-
lished results using LIBSVM.
72
The LIBSVM feature models for the arc-eager
projective and pseudo-projective parsers are the
same used by these parsers in the CoNLL-X
shared task, where the pseudo-projective version
of MaltParser was one of the two top performing
systems (Buchholz and Marsi, 2006). For the 2-
planar parser, we took the feature models from
Go?mez-Rodr??guez and Nivre (2010) for the lan-
guages included in that paper. For all the algo-
rithms and datasets, the feature models used for
the undirected parsers were adapted from those of
the directed parsers as described in Section 3.1.4
The results show that the use of undirected
parsing with label-based reconstruction clearly
improves the performance in the vast majority of
the datasets for the planar and Covington algo-
rithms, where in many cases it also improves upon
the corresponding projective and non-projective
state-of-the-art parsers provided for comparison.
In the case of the 2-planar parser the results are
less conclusive, with improvements over the di-
rected versions in five out of the eight languages.
The improvements in LAS obtained with label-
based reconstruction over directed parsing are sta-
tistically significant at the .05 level5 for Danish,
German and Portuguese in the case of the pla-
nar parser; and Czech, Danish and Turkish for
Covington?s parser. No statistically significant de-
crease in accuracy was detected in any of the al-
gorithm/dataset combinations.
As expected, the good results obtained by the
undirected parsers with label-based reconstruc-
tion contrast with those obtained by the variants
with root-based reconstruction, which performed
worse in all the experiments.
6 Discussion
We have presented novel variants of the planar
and 2-planar transition-based parsers by Go?mez-
Rodr??guez and Nivre (2010) and of Covington?s
non-projective parser (Covington, 2001; Nivre,
2008) which ignore the direction of dependency
links, and reconstruction techniques that can be
used to recover the direction of the arcs thus pro-
duced. The results obtained show that this idea
of undirected parsing, together with the label-
4All the experimental settings and feature models used
are included in the supplementary material and also available
at http://www.grupolys.org/?cgomezr/exp/.
5Statistical significance was assessed using Dan Bikel?s
randomized comparator: http://www.cis.upenn.
edu/?dbikel/software.html
based reconstruction technique of Section 4.2, im-
proves parsing accuracy on most of the tested
dataset/algorithm combinations, and it can out-
perform state-of-the-art transition-based parsers.
The accuracy improvements achieved by re-
laxing the single-head constraint to mitigate er-
ror propagation were able to overcome the er-
rors generated in the reconstruction phase, which
were few: we observed empirically that the dif-
ferences between the undirected LAS obtained
from the undirected graph before the reconstruc-
tion and the final directed LAS are typically be-
low 0.20%. This is true both for the naive and
label-based transformations, indicating that both
techniques are able to recover arc directions accu-
rately, and the accuracy differences between them
come mainly from the differences in training (e.g.
having tentative arc direction as part of feature
information in the label-based reconstruction and
not in the naive one) rather than from the differ-
ences in the reconstruction methods themselves.
The reason why we can apply the undirected
simplification to the three parsers that we have
used in this paper is that their LEFT-ARC and
RIGHT-ARC transitions have the same effect ex-
cept for the direction of the links they create.
The same transformation and reconstruction tech-
niques could be applied to any other transition-
based dependency parsers sharing this property.
The reconstruction techniques alone could po-
tentially be applied to any dependency parser
(transition-based or not) as long as it can be some-
how converted to output undirected graphs.
The idea of parsing with undirected relations
between words has been applied before in the
work on Link Grammar (Sleator and Temperley,
1991), but in that case the formalism itself works
with undirected graphs, which are the final out-
put of the parser. To our knowledge, the idea of
using an undirected graph as an intermediate step
towards obtaining a dependency structure has not
been explored before.
Acknowledgments
This research has been partially funded by the Spanish
Ministry of Economy and Competitiveness and FEDER
(projects TIN2010-18552-C03-01 and TIN2010-18552-
C03-02), Ministry of Education (FPU Grant Program) and
Xunta de Galicia (Rede Galega de Recursos Lingu???sticos
para unha Soc. do Con?ec.). The experiments were conducted
with the help of computing resources provided by the Su-
percomputing Center of Galicia (CESGA). We thank Joakim
Nivre for helpful input in the early stages of this work.
73
Planar UPlanarN UPlanarL MaltP
Lang. LAS(p) UAS(p) LAS(p) UAS(p) LAS(p) UAS(p) LAS(p) UAS(p)
Arabic 66.93 (67.34) 77.56 (77.22) 65.91 (66.33) 77.03 (76.75) 66.75 (67.19) 77.45 (77.22) 66.43 (66.74) 77.19 (76.83)
Chinese 84.23 (84.20) 88.37 (88.33) 83.14 (83.10) 87.00 (86.95) 84.51* (84.50*) 88.37 (88.35*) 86.42 (86.39) 90.06 (90.02)
Czech 77.24 (77.70) 83.46 (83.24) 75.08 (75.60) 81.14 (81.14) 77.60* (77.93*) 83.56* (83.41*) 77.24 (77.57) 83.40 (83.19)
Danish 83.31 (82.60) 88.02 (86.64) 82.65 (82.45) 87.58 (86.67*) 83.87* (83.83*) 88.94* (88.17*) 83.31 (82.64) 88.30 (86.91)
German 84.66 (83.60) 87.02 (85.67) 83.33 (82.77) 85.78 (84.93) 86.32* (85.67*) 88.62* (87.69*) 86.12 (85.48) 88.52 (87.58)
Portug. 86.22 (83.82) 89.80 (86.88) 85.89 (83.82) 89.68 (87.06*) 86.52* (84.83*) 90.28* (88.03*) 86.60 (84.66) 90.20 (87.73)
Swedish 83.01 (82.44) 88.53 (87.36) 81.20 (81.10) 86.50 (85.86) 82.95 (82.66*) 88.29 (87.45*) 82.89 (82.44) 88.61 (87.55)
Turkish 62.70 (71.27) 73.67 (78.57) 59.83 (68.31) 70.15 (75.17) 63.27* (71.63*) 73.93* (78.72*) 62.58 (70.96) 73.09 (77.95)
Table 1: Parsing accuracy of the undirected planar parser with naive (UPlanarN) and label-based (UPlanarL)
postprocessing in comparison to the directed planar (Planar) and the MaltParser arc-eager projective (MaltP)
algorithms, on eight datasets from the CoNLL-X shared task (Buchholz and Marsi, 2006): Arabic (Hajic? et al
2004), Chinese (Chen et al 2003), Czech (Hajic? et al 2006), Danish (Kromann, 2003), German (Brants et
al., 2002), Portuguese (Afonso et al 2002), Swedish (Nilsson et al 2005) and Turkish (Oflazer et al 2003;
Atalay et al 2003). We show labelled (LAS) and unlabelled (UAS) attachment score excluding and including
punctuation tokens in the scoring (the latter in brackets). Best results for each language are shown in boldface,
and results where the undirected parser outperforms the directed version are marked with an asterisk.
2Planar U2PlanarN U2PlanarL MaltPP
Lang. LAS(p) UAS(p) LAS(p) UAS(p) LAS(p) UAS(p) LAS(p) UAS(p)
Arabic 66.73 (67.19) 77.33 (77.11) 66.37 (66.93) 77.15 (77.09) 66.13 (66.52) 76.97 (76.70) 65.93 (66.02) 76.79 (76.14)
Chinese 84.35 (84.32) 88.31 (88.27) 83.02 (82.98) 86.86 (86.81) 84.45* (84.42*) 88.29 (88.25) 86.42 (86.39) 90.06 (90.02)
Czech 77.72 (77.91) 83.76 (83.32) 74.44 (75.19) 80.68 (80.80) 78.00* (78.59*) 84.22* (84.21*) 78.86 (78.47) 84.54 (83.89)
Danish 83.81 (83.61) 88.50 (87.63) 82.00 (81.63) 86.87 (85.80) 83.75 (83.65*) 88.62* (87.82*) 83.67 (83.54) 88.52 (87.70)
German 86.28 (85.76) 88.68 (87.86) 82.93 (82.53) 85.52 (84.81) 86.52* (85.99*) 88.72* (87.92*) 86.94 (86.62) 89.30 (88.69)
Portug. 87.04 (84.92) 90.82 (88.14) 85.61 (83.45) 89.36 (86.65) 86.70 (84.75) 90.38 (87.88) 87.08 (84.90) 90.66 (87.95)
Swedish 83.13 (82.71) 88.57 (87.59) 81.00 (80.71) 86.54 (85.68) 82.59 (82.25) 88.19 (87.29) 83.39 (82.67) 88.59 (87.38)
Turkish 61.80 (70.09) 72.75 (77.39) 58.10 (67.44) 68.03 (74.06) 61.92* (70.64*) 72.18 (77.46*) 62.80 (71.33) 73.49 (78.44)
Table 2: Parsing accuracy of the undirected 2-planar parser with naive (U2PlanarN) and label-based (U2PlanarL)
postprocessing in comparison to the directed 2-planar (2Planar) and MaltParser arc-eager pseudo-projective
(MaltPP) algorithms. The meaning of the scores shown is as in Table 1.
Covington UCovingtonN UCovingtonL
Lang. LAS(p) UAS(p) LAS(p) UAS(p) LAS(p) UAS(p)
Arabic 65.17 (65.49) 75.99 (75.69) 63.49 (63.93) 74.41 (74.20) 65.61* (65.81*) 76.11* (75.66)
Chinese 85.61 (85.61) 89.64 (89.62) 84.12 (84.02) 87.85 (87.73) 86.28* (86.17*) 90.16* (90.04*)
Czech 78.26 (77.43) 84.04 (83.15) 74.02 (74.78) 79.80 (79.92) 78.42* (78.69*) 84.50* (84.16*)
Danish 83.63 (82.89) 88.50 (87.06) 82.00 (81.61) 86.55 (85.51) 84.27* (83.85*) 88.82* (87.75*)
German 86.70 (85.69) 89.08 (87.78) 84.03 (83.51) 86.16 (85.39) 86.50 (85.90*) 88.84 (87.95*)
Portug. 84.73 (82.56) 89.10 (86.30) 83.83 (81.71) 87.88 (85.17) 84.95* (82.70*) 89.18* (86.31*)
Swedish 83.53 (82.76) 88.91 (87.61) 81.78 (81.47) 86.78 (85.96) 83.09 (82.73) 88.11 (87.23)
Turkish 64.25 (72.70) 74.85 (79.75) 63.51 (72.08) 74.07 (79.10) 64.91* (73.38*) 75.46* (80.40*)
Table 3: Parsing accuracy of the undirected Covington non-projective parser with naive (UCovingtonN) and
label-based (UCovingtonL) postprocessing in comparison to the directed algorithm (Covington). The meaning
of the scores shown is as in Table 1.
74
References
Susana Afonso, Eckhard Bick, Renato Haber, and Di-
ana Santos. 2002. ?Floresta sinta?(c)tica?: a tree-
bank for Portuguese. In Proceedings of the 3rd In-
ternational Conference on Language Resources and
Evaluation (LREC 2002), pages 1968?1703, Paris,
France. ELRA.
Nart B. Atalay, Kemal Oflazer, and Bilge Say. 2003.
The annotation process in the Turkish treebank.
In Proceedings of EACL Workshop on Linguisti-
cally Interpreted Corpora (LINC-03), pages 243?
246, Morristown, NJ, USA. Association for Com-
putational Linguistics.
Sabine Brants, Stefanie Dipper, Silvia Hansen, Wolf-
gang Lezius, and George Smith. 2002. The tiger
treebank. In Proceedings of the Workshop on Tree-
banks and Linguistic Theories, September 20-21,
Sozopol, Bulgaria.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings of the 10th Conference on Computa-
tional Natural Language Learning (CoNLL), pages
149?164.
Chih-Chung Chang and Chih-Jen Lin, 2001.
LIBSVM: A Library for Support Vec-
tor Machines. Software available at
http://www.csie.ntu.edu.tw/?cjlin/libsvm.
K. Chen, C. Luo, M. Chang, F. Chen, C. Chen,
C. Huang, and Z. Gao. 2003. Sinica treebank: De-
sign criteria, representational issues and implemen-
tation. In Anne Abeille?, editor, Treebanks: Building
and Using Parsed Corpora, chapter 13, pages 231?
248. Kluwer.
Y. J. Chu and T. H. Liu. 1965. On the shortest arbores-
cence of a directed graph. Science Sinica, 14:1396?
1400.
Michael A. Covington. 2001. A fundamental algo-
rithm for dependency parsing. In Proceedings of
the 39th Annual ACM Southeast Conference, pages
95?102.
Jack Edmonds. 1967. Optimum branchings. Journal
of Research of the National Bureau of Standards,
71B:233?240.
R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang, and
C.-J. Lin. 2008. LIBLINEAR: A library for large
linear classification. Journal of Machine Learning
Research, 9:1871?1874.
Carlos Go?mez-Rodr??guez and Joakim Nivre. 2010.
A transition-based parser for 2-planar dependency
structures. In Proceedings of the 48th Annual Meet-
ing of the Association for Computational Linguis-
tics, ACL ?10, pages 1492?1501, Stroudsburg, PA,
USA. Association for Computational Linguistics.
Jan Hajic?, Otakar Smrz?, Petr Zema?nek, Jan S?naidauf,
and Emanuel Bes?ka. 2004. Prague Arabic Depen-
dency Treebank: Development in data and tools. In
Proceedings of the NEMLAR International Confer-
ence on Arabic Language Resources and Tools.
Jan Hajic?, Jarmila Panevova?, Eva Hajic?ova?, Jarmila
Panevova?, Petr Sgall, Petr Pajas, Jan S?te?pa?nek,
Jir??? Havelka, and Marie Mikulova?. 2006.
Prague Dependency Treebank 2.0. CDROM CAT:
LDC2006T01, ISBN 1-58563-370-4. Linguistic
Data Consortium.
Liang Huang and Kenji Sagae. 2010. Dynamic pro-
gramming for linear-time incremental parsing. In
Proceedings of the 48th Annual Meeting of the As-
sociation for Computational Linguistics, ACL ?10,
pages 1077?1086, Stroudsburg, PA, USA. Associa-
tion for Computational Linguistics.
Matthias T. Kromann. 2003. The Danish dependency
treebank and the underlying linguistic theory. In
Proceedings of the 2nd Workshop on Treebanks and
Linguistic Theories (TLT), pages 217?220, Va?xjo?,
Sweden. Va?xjo? University Press.
Marco Kuhlmann and Joakim Nivre. 2006. Mildly
non-projective dependency structures. In Proceed-
ings of the COLING/ACL 2006 Main Conference
Poster Sessions, pages 507?514.
Andre Martins, Noah Smith, and Eric Xing. 2009.
Concise integer linear programming formulations
for dependency parsing. In Proceedings of the
Joint Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference on
Natural Language Processing of the AFNLP (ACL-
IJCNLP), pages 342?350.
Ryan McDonald and Joakim Nivre. 2007. Character-
izing the errors of data-driven dependency parsing
models. In Proceedings of the 2007 Joint Confer-
ence on Empirical Methods in Natural Language
Processing and Computational Natural Language
Learning (EMNLP-CoNLL), pages 122?131.
Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajic?. 2005. Non-projective dependency pars-
ing using spanning tree algorithms. In Proceedings
of the Human Language Technology Conference
and the Conference on Empirical Methods in Nat-
ural Language Processing (HLT/EMNLP), pages
523?530.
Jens Nilsson, Johan Hall, and Joakim Nivre. 2005.
MAMBA meets TIGER: Reconstructing a Swedish
treebank from Antiquity. In Peter Juel Henrichsen,
editor, Proceedings of the NODALIDA Special Ses-
sion on Treebanks.
Joakim Nivre and Jens Nilsson. 2005. Pseudo-
projective dependency parsing. In Proceedings of
the 43rd Annual Meeting of the Association for
Computational Linguistics (ACL), pages 99?106.
Joakim Nivre, Johan Hall, and Jens Nilsson. 2004.
Memory-based dependency parsing. In Proceed-
ings of the 8th Conference on Computational Nat-
ural Language Learning (CoNLL-2004), pages 49?
56, Morristown, NJ, USA. Association for Compu-
tational Linguistics.
75
Joakim Nivre, Johan Hall, and Jens Nilsson. 2006.
MaltParser: A data-driven parser-generator for de-
pendency parsing. In Proceedings of the 5th In-
ternational Conference on Language Resources and
Evaluation (LREC), pages 2216?2219.
Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
8th International Workshop on Parsing Technolo-
gies (IWPT), pages 149?160.
Joakim Nivre. 2008. Algorithms for Deterministic
Incremental Dependency Parsing. Computational
Linguistics, 34(4):513?553.
Kemal Oflazer, Bilge Say, Dilek Zeynep Hakkani-Tu?r,
and Go?khan Tu?r. 2003. Building a Turkish tree-
bank. In Anne Abeille?, editor, Treebanks: Build-
ing and Using Parsed Corpora, pages 261?277.
Kluwer.
Daniel Sleator and Davy Temperley. 1991. Pars-
ing English with a link grammar. Technical Re-
port CMU-CS-91-196, Carnegie Mellon University,
Computer Science.
R. E. Tarjan. 1977. Finding optimum branchings.
Networks, 7:25?35.
Ivan Titov and James Henderson. 2007. A latent vari-
able model for generative dependency parsing. In
Proceedings of the 10th International Conference
on Parsing Technologies (IWPT), pages 144?155.
76
