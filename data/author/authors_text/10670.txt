Proceedings of the 22nd International Conference on Computational Linguistics (Coling 2008), pages 673?680
Manchester, August 2008
Recent Advances in a Feature-rich Framework for Treebank Annotation
Petr Pajas
Charles Univ. in Prague, MFF
?
UFAL
Malostransk?e n?am. 25
118 00 Prague 1 ? Czech Rep.
pajas@ufal.ms.mff.cuni.cz
Jan
?
St
?
ep
?
anek
Charles Univ. in Prague, MFF
?
UFAL
Malostransk?e n?am. 25
118 00 Prague 1 ? Czech Rep.
stepanek@ufal.ms.mff.cuni.cz
Abstract
This paper presents recent advances in
an established treebank annotation frame-
work comprising of an abstract XML-
based data format, fully customizable ed-
itor of tree-based annotations, a toolkit
for all kinds of automated data process-
ing with support for cluster computing, and
a work-in-progress database-driven search
engine with a graphical user interface built
into the tree editor.
1 Introduction
Constructing a treebank is a complicated process.
Among other things it requires a good choice of
tools, varying from elementary data conversion
scripts over annotation tools and tools for consis-
tency checking, to tools used for semi-automatic
treebank building (POS taggers, syntactic parsers).
If no existing tool fits the needs, a new one has to
be developed (or some existing tool adapted or ex-
tended, which, however, seldom happens in prac-
tice). The variety of tools that exist and emerged
from various treebanking projects shows that there
is no simple solution that would fit all. It is some-
times a small missing feature or an incompati-
ble data format that disqualifies certain otherwise
well-established tools in the eyes of those who de-
cide which tools to use for their annotation project.
This paper presents an annotation framework
that was from its very beginning designed to be
extensible and independent of any particular anno-
tation schema. While reflecting the feedback from
several treebanking projects, it evolved into a set
c
? 2008. Licensed under the Creative Commons
Attribution-Noncommercial-Share Alike 3.0 Unported li-
cense (http://creativecommons.org/licenses/by-nc-sa/3.0/).
Some rights reserved.
of generic tools that is open to all kinds of anno-
tations that involve tree structures. By this paper
we would like not only to promote this framework,
but also show that due to its open nature, it may
be easily extended to fit new requirements. The
first three sections describe base components of
the framework, an abstract data format, a versatile
annotation tool for tree-oriented annotations, and
a framework for automatic annotation processing;
some of these components have been mentioned
in earlier publications, but the framework has nei-
ther been published in its integrity nor described
in much detail. The last section describes a query
engine that is a newest addition to the framework,
first presented by this paper.
2 Data format
The base data format selected for the present an-
notation framework, both for data exchange and
as a memory-model reference, is PML (Pajas and
?
St?ep?anek, 2006). PML is an abstract XML-based
format intended to be generally applicable to all
types of annotation purposes, and especially suit-
able for multi-layered treebank annotations fol-
lowing the stand-of principles. A notable fea-
ture that distinguishes PML from other encoding
schemes, like Tiger-XML (Mengel and Lezius,
2000), XCES (Ide and Romary, 2003), or maybe
even SynAF by ISO TC37/SC4 (Declerck, 2006),
is its generic and open nature. Rather than being
targeted to one particular annotation schema or be-
ing a set of specifically targeted encoding conven-
tions, PML is an open system, where a new type
of annotation can be introduced easily by creating
a simple XML file called PML schema, which de-
scribes the annotation by means of declaring the
relevant data types and possibly assigning certain
roles to these data types. The roles in the con-
673
text of PML are just labels from a pre-defined set
that can be used to mark the declarations accord-
ing to their purpose. For instance, the roles indi-
cate which data structures represent the nodes of
the trees, how the node data structures are nested
to form a tree, which field in a data structure car-
ries its unique ID (if any), or which field carries
a link to the annotated data or other layers of an-
notation, and so on. PML schema can define all
kinds of annotations varying from linear annota-
tions through constituency or dependency trees, to
complex graph-oriented annotation systems. The
PML schema provides information for validating
the annotation data as well as for creating a rel-
evant data model for their in-memory representa-
tion.
To give an example, the annotation of the Prague
Dependency Treebank 2.0 (PDT) (Haji?c and oth-
ers, 2006), which was published in the PML for-
mat, consists of four annotation layers, each de-
fined by its own PML schema: a lowest word-form
layer consisting of tokenized text segmented just
into documents and paragraphs; a morphological
layer segmenting the token stream of the previ-
ous layer to sentences and attaching morphological
form, lemma, and tag to each token; an analytical
layer building a morpho-syntactic dependency tree
from the words of each sentence (morphologically
analyzed on the previous layer); and a tectogram-
matical layer consisting of deep-syntactic depen-
dency trees interlinked in a N :M manner with the
analytical layer and a valency lexicon and carrying
further relational annotation, such as coreference
and quotation sets. All these features are formally
described by the respective PML schemas.
The fundamental toolkit for PML comprises of
a validator (based on compiling PML schemas to
RelaxNG grammars accompanied by Schematron
rules), and API, consisting of a Perl library (ba-
sic interfaces for Java and C++ are planned). The
input/output functions of the library are modular
and can work with local files as well as with re-
mote resources accessible via HTTP, FTP or SSH
protocols (with pluggable support for other pro-
tocols). Additionally, the library supports on-
the-fly XSLT-based format conversions that can
be easily plugged in via a simple configuration
file. Consequently, the API can transparently
handle even non-PML data formats. Currently
there are about a dozen input/output conversion fil-
ters available, covering various existing data for-
mats including the TigerXML format, the for-
mats of the Penn Treebank (Marcus et al, 1994),
the CoNLL-X shared task format (Buchholz and
Marsi, 2006), and the formats of the Latin Depen-
dency (Bamman and Crane, 2006), Sinica (Chu-
Ren et al, 2000), Slovene Dependency (D?zeroski
et al, 2006) (SDT), and Alpino (van der Beek et
al., 2002) treebanks. Support for XCES formats
is planned as soon as a final release of XCES is
available.
This basic toolkit is further supplemented by
various auxiliary tools, such as pmlcopy which
allows one to copy, move, rename, or GZip sets
of interconnected PML data files without breaking
the internal URL-based references.
3 Tree Editor
The heart of the annotation framework is a multi-
platform graphical tree editor called TrEd, (Haji?c
et al, 2001).
TrEd was from the beginning designed to be
annotation-schema independent, extensible and
configurable. TrEd can work with any PML data
format whose PML schema correctly defines (via
roles) at least one sequence of trees. Beside PML
format, TrEd can work with many other data for-
mats, either by means of the modular input/output
interface of the PML library or using its own in-
put/output backends.
The basic editing capabilities of TrEd allow the
user to easily modify the tree structure with drag-
and-drop operations and to easily edit the asso-
ciated data. Although this is sufficient for most
annotation tasks, the annotation process can be
greatly accelerated by a set of custom extension
functions, called macros, written in Perl. Macros
are usually created to simplify the most common
tasks done by the annotators. They can be called
either from menu or by keyboard shortcuts.
Although TrEd ensures that the result of the an-
notation is in accord with the related PML schema,
there is still a chance that an annotator errs in some
other aspect of the annotation. For this reason
TrEd offers the possibility to write macros that in-
corporate custom consistency tests into the built-in
editing commands of TrEd. Such tests can prevent
the user from making accidental mistakes (like as-
signing a case to a verb or subordinating a Subject
to a particle). Macros can also completely disable
some dangerous editing commands (for example,
the PDT annotation modes in TrEd disable the pos-
674
sibility to add or delete tokens or trees).
While macros provide means to extend, accel-
erate and control the annotation capabilities of
TrEd, the concept of style-sheets gives users con-
trol over the visual presentation of the annotated
data. Style-sheets, among other, offer the possi-
bility to: visually differentiate nodes and edges by
color, shape, size or line style according to arbi-
trary criteria; assemble the data associated with
nodes and edges to node and edge labels; alter
node positioning and padding; visualize additional
edges and cross-structure relations by means of
arrows or other types of connections; control the
content and styling of the text (usually the an-
notated sentence) displayed in a box above the
tree. TrEd can also balance trees, visualize dis-
connected groups of nodes, zoom the tree view ar-
bitrarily, and display trees in a vertical mode, see
Fig. 1.
Figure 1: The same tree displayed using horizontal
and vertical display mode in TrEd
Due to model/view separation, TrEd provides
means for controlling which nodes are actually dis-
played (it is thus possible to write modes that col-
lapse subtrees, hide auxiliary nodes, completely
skip some levels of the tree, display multiple trees
at once (Fig. 2), or even display additional ?vir-
tual? nodes and edges that are not actually present
in the underlying data structures).
So far, TrEd has been selected as annotation
tool for PDT and several similarly structured tree-
banking projects like Slovene (D?zeroski et al,
2006), Croatian (Tadi?c, 2007), or Greek Depen-
dency Treebanks (Prokopidis et al, 2005), but also
for Penn-style Alpino Treebank (van der Beek et
al., 2002), the semantic annotation in the Dutch
Figure 2: The main window visualizing node-to-
node alignment of trees in the TectoMT project
(
?
Zabokrtsk?y et al, 2008); side-bar shows data as-
sociated with the selected node.
language Corpus Initiative project (Trapman and
Monachesi, 2006), as well as for annotation of
morphology using so-called MorphoTrees (Smr?z
and Pajas, 2004) in the Prague Arabic Depen-
dency Treebank (where it was also used for anno-
tation of the dependency trees in the PDT style).
While most other projects use off-line conversion
Figure 3: One possible way of displaying Penn
Treebank data in TrEd
to some format directly supported by TrEd, for
Alpino Treebank a better approach has been se-
lected: the PML library has been configured to
convert between Alpino XML format and PML
transparently on-the-fly using two simple XSLT
stylesheets created for this purpose.
Like some other annotation tools, for example
DepAnn (Kakkonen, 2006), TrEd provides means
for comparing two (or more) annotations and vi-
675
sually marking the differences. This functionality
is currently provided by macros tailored especially
for the PDT annotations. Modifying these macros
for specific needs of other tree-based annotations
should be easy.
4 Automated processing
The same code-base that runs TrEd (except for the
GUI) is used in a command-line tool for automated
processing of the annotated data called BTrEd.
This tool allows one to search, transform or mod-
ify the data by means of small programs written in
Perl known from TrEd as macros. Given a list of
files, the tool opens the files one after another and
applies a given macro on each of them (or, if one
chooses, to each tree or each node). With the pow-
erful API of TrEd and the expressiveness of the
Perl programming language at hand, one can very
easy prepare scripts that gather information, create
reports, or automate some parts of the annotation
process; in some cases the script can be as short to
fit on the command-line.
It is often the case that one has to process a
large amount of data repeatedly with one or more
scripts. To avoid the need of reading the data
into memory upon each execution, BTrEd is aug-
mented by a client-server interface and a client
tool called NTrEd. NTrEd, given a list of com-
puter hostnames or IP addresses and a list of files,
starts remotely on each of the computers a server-
mode instance of BTrEd and distributes the sup-
plied data among these servers (either equally or
according to CPU load). Since only file-names are
transferred in the communication, some form of
shared data storage is assumed. The BTrEd servers
read their respective share of the treebank, keep it
in their RAM and await client connections. Once
the servers are started in this way, one can pass a
script to NTrEd as one would do with BTrEd; the
tool forwards the script to the servers and collect-
ing the results, outputs them in the same way as
a stand-alone BTrEd would. If the script modifies
the data, the user can send a request to the servers
to either save the changed files or reload them, dis-
carding all modifications. Security of NTrEd is
achieved by means of SHA-based authentication
(completely transparent to the user) and, option-
ally, by SSH tunneling.
Since one machine can run multiple instances of
BTrEd server, each user of a computer cluster can
run its own set of BTrEd servers without interfer-
ing with other users. Concurrent work of several
users on the same data is supported by TrEd and
BTrEd by a simple system of file locks, similar to
that of GNU Emacs.
This kind of processing was exploited heav-
ily during the post-annotation checking phases of
PDT 2.0 production (
?
St?ep?anek, 2006). Employing
a cluster consisting from about ten computers, a
typical consistency-checking script processed the
whole amount of PDT 2.0 (1.5 million analytical
nodes and 700 thousand tectogrammatical nodes)
in just a few seconds. This was particularly help-
ful for rapid prototyping or testing hypotheses and
it accelerated the whole process enormously.
The NTrEd system, keeping the data in RAM of
the servers, is sufficient for small to medium-sized
corpora. For huge corpora in scale of terabytes it
may not be the case. For processing such huge
amounts of data, another tool called JTrEd was re-
cently added to the framework. JTrEd is a wrapper
script that simplifies distribution of BTrEd tasks
over a computer cluster controlled by the Sun Grid
Engine (SGE).
The BTrEd machinery is not intended just for
small scripts. A project building a full MT en-
gine on top of this framework is in progress
(
?
Zabokrtsk?y et al, 2008).
5 Data-base driven query engine
One of the reasons for which tree-banks are cre-
ated is that they cover and capture a representa-
tive number of syntactic constructions of the par-
ticular language. However, to be able to identify
them effectively, one has to employ some query-
ing system, consisting of a sufficiently expressive
query language and an engine that can search the
treebank and present the user with all occurrences
matching the constraints of the query.
While for complex queries the tools described
in the previous section serve well to users with
basic programming skills,?every-day? querying by
linguistic public requires a more accessible user-
interface. In this section we describe a working
prototype of a new query engine and its user inter-
face, based on the data representation and tools de-
scribed in the preceding sections. First, however,
we briefly review some existing solutions.
For searching over PDT a tool called Net-
Graph (M??rovsk?y, 2006) is traditionally used. This
tool?s graphical interface allows the users to for-
mulate their queries in a very natural way, namely
676
as trees whose structures correspond to the struc-
tures of the desired search results (although one
may specify, for example, that an edge in the query
tree should actually match a path in the result tree).
Each node in the query tree can carry a set of at-
tributes that match or otherwise constrain the at-
tributes of the corresponding node in the result
tree. The query can further put some cardinality
constraints on the matching nodes; these are for-
mulated using a special set of labels on the query
tree. A great advantage of NetGraph is its web-
enabled user interface (Java applet). The under-
lying query engine is written in C, and although
relatively simplistic (i.e. no indexing or planning
techniques are used), for PDT-sized corpus it of-
fers reasonable speed for the interactive use. Cer-
tain disadvantages of the NetGraph system in our
view are: lack of support for querying relations
between two or more trees; no support for multi-
layered annotations; limited means of expressing
attribute constraints and their boolean combina-
tions; restriction to a limited legacy data format.
Probably the best-known query languages for
tree structures nowadays are XPath and XQuery,
promoted by (and in case of the latter bound to)
the XML technology. The advantage of these
query languages is that there are several implemen-
tations to choose from. Beside searching, some
tools (e.g. XSH2 (Pajas, 2005)) provide means for
XPath-based data modification. For these reasons,
XPath searches over XML-encoded treebank data
are promoted (Bouma and Kloosterman, 2002).
The disadvantage is, however, that being restricted
to the XML data model, users of such tools have
to query over a particular XML encoding of the
data which often in some way or other obscures
the actual annotation schema and relations the an-
notation represents. Besides, it can be argued that
XPath alone does not provide sufficient expres-
siveness for typical linguistic queries.
As a remedy for the last deficiency, Steven Bird
et al (Bird et al, 2006) proposed a concise query
language named LPath, which, while extending
core XPath, was designed with the needs of lin-
guistic queries in mind. Their query system is
powered by a relational database in which the
queries are translated from LPath to SQL. To en-
able efficient evaluation of constraints on horizon-
tal and vertical relationships between two nodes
of a tree by the relational database, the database
representation of the trees uses a simple labeling
scheme which labels each node with several inte-
gers so that the relationship constraints translate in
SQL to simple comparisons of the respective inte-
ger labels.
It has been shown (Lai and Bird, 2005) that fur-
ther extension to the LPath language, known as
LPath+, is already 1st-order complete. It should,
however, be noted that 1st-order completeness has
little to do with the practical expressiveness of the
language; certain queries, easily expressed in 1st-
order logic, only translate to LPath+ at the cost of
combinatorial explosion in the size of the query.
For example, like XPath, the only way LPath+ of-
fers to match two non-identical sibling nodes is
to reach one by the child axis and the other us-
ing the following-sibling or preceding-sibling axes
from the first one; thus for a query with n sibling
nodes whose constraints do not necessarily imply
inequality and which can appear in the tree in ar-
bitrary order, the LPath+ query must, in general,
enumerate a disjunction of all the n! possible per-
mutations. This may not be a problem when query-
ing over English treebanks, but is a serious handi-
cap for querying over treebanks for languages with
free word-order.
There are several other tools for querying over
treebanks, we are aware at least of TIGERSearch
(Lezius, 2002) for annotations in the TigerXML
format, and TGrep2 (Rohde, 2001) for Penn Tree-
bank and similar, which we shall not describe here
in detail as they are well known.
For the PML-based annotation system presented
in this paper, we have developed a prototype of a
new querying system, referred to, just for the pur-
poses of this paper, as PML Tree Query (PML-
TQ). The new system attempts to equal the qual-
ities of the above mentioned systems and addition-
ally provide
? a query language with sufficient expressive-
ness yet without complex formalisms
? unified treatment of structural and non-
structural, inter- and cross-layer relationships
? basic reporting capabilities (computing num-
ber or distribution of occurrences, etc.)
? a graphical query editor built into TrEd
? a scriptable and extensible interface
At the current stage, PML-TQ provides a proto-
type query language supporting arbitrary logical
677
conditions on attributes of nodes and their inter-
and cross-layer relations, optional nodes, and ba-
sic cardinality constraints. A result of an evalua-
tion of a PML-TQ can be either a set of matches,
each match being a set of nodes in the treebank
corresponding to the nodes in the query, or a re-
port with some information computed from these
node sets. The reporting capabilities of PML-TQ
allow one to perform various aggregations on the
result node sets and compute statistics over the
aggregated groups. Thus, one may easily formu-
late queries such as ?what is the maximum, mini-
mum, and average depth of a tree in the treebank?,
?what preposition forms correspond on the surface
layer to tectogrammatical nodes with the functor
DIR3 and what is their distribution?, ?what is the
most common functor for a child node of a node
with functor PRED?, ?what is the joint distribution
of functors for nodes in the parent-child relation?,
etc.
In the graphical representation of PML-TQ, re-
lations between nodes are represented by arrows.
Each PML-TQ query forms a tree or forest whose
edges represent basic relations between nodes and
possibly nesting of subqueries and whose nodes
can be interconnected by additional arrows repre-
senting further relations.
a-layer t-layer
? ?
xx
?

?

ff
a-layer t-layer
Obj
?
?
a/lex.rf
oo
AuxP
?

?

a/lex.rf
yy
a/aux.rf
oo
Obj
?

Figure 4: Examples of cross-layer queries in PML-
TQ. Query on the left finds dependency that got
reversed on the PDT tectogrammatical layer com-
pared to the analytical layer; the query on the right
finds tectogrammatical nodes corresponding to an
analytical object governing a prepositional object.
Apart from the graphical representation, PML-
TQ queries can be formulated in a textual form
with syntax resembling XPath (but substantially
more expressive). A query is parsed from this syn-
tax into a syntactic tree encoded in PML; in this
representation the queries can be stored, visual-
ized, and graphically manipulated in TrEd.
There are presently two engines that can eval-
uate PML-TQ queries. To utilize the modern
RDBMS technology for performance and scalabil-
ity, we have created a translator of PML-TQ to
SQL. One can thus query over a static treebank
stored in a database (for encoding tree-structures
into database tables, we have adopted a label-
ing system similar to that described in (Bird et
al., 2006)). For querying over data that change
(e.g. a file currently open in TrEd or a bunch of
files with annotation in progress), we have imple-
mented a simple, yet still relatively fast, evaluator
in Perl with a basic planner that can perform PML-
TQ searches over PML data sequentially in either
TrEd, BTrEd, NTrEd, or JTrEd.
Having two engines behind our query interface
in TrEd has several benefits. The annotators will
be able to perform identical queries over a cor-
pus stored in a remote SQL database as well as to
search in their own locally stored data. The devel-
opers of scripts for BTrEd will be able to formulate
parts of their scripts briefly as PML-TQ queries
whose correctness they will be able to verify in-
dependently on a treebank using the SQL backend
using an interactive environment.
The SQL-based execution system has currently
two database backends for feature and perfor-
mance comparison: Oracle Express 10g and Post-
gres SQL. We use Perl DBI modules to intercon-
nect these backends with the TrEd toolkit.
Figure 5: PML-TQ interface in TrEd. Top: the
query as text, bottom left the query tree, bottom
right a matching tree from PDT 2.0.
The search results can be presented in TrEd in
one of several ways. Results of queries that make
use of the report-generating facilities of PML-TQ
are displayed simply as tables in a text window.
Most PML-TQ queries, however, return matching
nodes or trees. To display them, TrEd retrieves
678
corresponding URLs and node positions from the
database and reads the actual data from the PML
files that must currently be accessible locally or re-
motely via HTTP, FTP or SSH. Since there are sit-
uations when the original data cannot be accessed
in this way, we are working on a solution that
would allow TrEd to fetch and reconstruct the trees
directly from the database.
For populating the database system with tree-
banks, we have developed a tool that can transfer
arbitrary PML-encoded data into a set of database
tables suitable for PML-TQ querying. The in-
formation about available inter-layer and cross-
layer relations is automatically extracted from the
PML schema and can be further adjusted by a few
command-line parameters.
We have evaluated our database search engine
using queries obtained by several means. We had
the luck that the developer of NetGraph kindly pro-
vided us with all queries collected from real Net-
Graph users over the past few years in the server
logs. We thus obtained almost 9000 queries for
the analytical layer and about 5000 queries for the
tectogrammatical layer of PDT 2.0. By translat-
ing them to PML-TQ with a simple Perl script,
we obtained a large collection for testing the ba-
sic functionality and performance of our system.
To that we added a set of queries that test more
advanced PML-TQ features and, for comparison,
several queries analogous to the LPath query ex-
amples given in (Bird et al, 2006).
When we first run our complete query collec-
tion on the Oracle database with 1.5 million nodes
and about 88 thousand trees from the analytical
layer of PDT, we were surprised to see that out
of 8188 queries, 8102 computes in a fraction of
second, further 33 in less then 2 seconds, further
36 in less than 10 seconds, 14 in less than 20 sec-
onds and only 5 in more than one minute. Four
of these, however, took extremely long time to
compute (from hours to days). We observed that
all these time-consuming queries were rather simi-
lar: they imposed either no or too week constraints
on the nodes and sometimes the query tree had
a rather large number of auto-morphisms (there
was a query consisting of a node with six iden-
tical child-nodes none of which carried any con-
straints). We then found a tree in our data set
that contained a node with 85 children. This gives
roughly 10
12
solutions to the query with six sib-
lings on this tree alone.
In some cases the queries can be rewritten us-
ing cardinality constraints (?find all nodes with at
least 6 children?), which avoids the combinatorial
explosion. Since we felt this may not always be
possible, we also tried to remove from our data
set al trees with more than 20 siblings (44 trees
from 70K) that turned out to be mostly TV listings
anyway. After that, the performance for the four
of the problematic queries improved dramatically:
first 100 matches were found in a few seconds and
fist 10
6
matches in less than 10 minutes.
Although we have modified the query compiler
to suggest cardinality constraints were it seems
appropriate and to automatically eliminate some
types of automorphisms on the query tree by im-
posing a strict ordering on the permutable query
nodes, we think it is neither possible to completely
secure the query system against time-exhaustive
queries nor to reliably detect such queries auto-
matically. The querying interface therefore gives
the users the option to select a reasonable maxi-
mum number of results and allows them to cancel
the query evaluation at any time.
6 Conclusion
Over last few years our annotation framework
made a considerable leap, from a simple annota-
tion tool to a feature-rich system with several inter-
operating components. The complete framework
is publicly available, either under the General Pub-
lic License License (GPL), the Perl Artistic Li-
cense or other GPL-compatible free license. A
public release of the tree query interface described
in the previous section is scheduled for mid to end
of 2008.
7 Acknowledgment
This paper as well as the development of the
framework is supported by the grant Informa-
tion Society of GA AV
?
CR under contract
1ET101120503.
References
Bamman, David and Gregory Crane. 2006. The design
and use of a Latin dependency treebank. In Proceed-
ings of the Fifth International Workshop on Tree-
banks and Linguistic Theories (TLT 2006), pages
67?78, Prague.
Bird, Steven, Yi Chen, Susan B. Davidson, Haejoong
Lee, and Yifeng Zheng. 2006. Designing and eval-
uating an XPath dialect for linguistic queries. In
679
ICDE ?06: Proceedings of the 22nd International
Conference on Data Engineering, page 52, Washing-
ton, DC, USA. IEEE Computer Society.
Bouma, Gosse and Geert Kloosterman. 2002. Query-
ing dependency treebanks in XML. In Proceedings
of the Third international conference on Language
Resources and Evaluation (LREC), Gran Canaria.
Buchholz, Sabine and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings CoNLL-X.
Chu-Ren, Huang, Keh-Jiann Chen, Feng-Yi Chen, Keh-
Jiann Chen, Zhao-Ming Gao, and Kuang-Yu Chen.
2000. Sinica treebank: Design criteria, annotation
guidelines, and on-line interface. In Proceedings of
2nd Chinese Language Processing Workshop (Held
in conjunction with ACL-2000), pages 29?37, Hong
Kong, October 7.
Declerck, Thierry. 2006. Synaf: Towards a stan-
dard for syntactic annotation. In Proceedings of
the 5th International Conference on Language Re-
sources and Evaluation (LREC 2006), pages 209?
232.
D?zeroski, Sa?so, Toma?z Erjavec, Nina Ledinek, Petr Pa-
jas, Zden?ek
?
Zabokrtsk?y, and Andreja
?
Zele. 2006.
Towards a slovene dependency treebank. In Pro-
ceedings of the 5th International Conference on
Language Resources and Evaluation (LREC 2006),
pages 1388?1391.
Haji?c, Jan, Barbora Vidov?a-Hladk?a, and Petr Pajas.
2001. The Prague Dependency Treebank: Anno-
tation Structure and Support. In Proceedings of
the IRCS Workshop on Linguistic Databases, pages
105?114, Philadelphia, USA. University of Pennsyl-
vania.
Haji?c, Jan et al 2006. The Prague Dependency Tree-
bank 2.0. CD-ROM. CAT: LDC2006T01.
Ide, Nancy and R. Romary. 2003. Encoding syntactic
annotation. In Abill?e, A., editor, Building and Using
Parsed Corpora. Kluwer, Dordrecht.
Kakkonen, Tuomo. 2006. Depann - an annotation tool
for dependency treebanks. In Proceedings of the
11th ESSLLI Student Session at the 18th European
Summer School in Logic, Language and Information,
pages 214?225, Malaga, Spain.
Lai, Catherine and Steven Bird. 2005. LPath+: A first-
order complete language for linguistic tree query. In
Proceedings of the 19th Pacific Asia Conference on
Language (PACLIC), Information and Computation,
pages 1?12, Taipei, Taiwan. Academia Sinica.
Lezius, Wolfgang. 2002. Ein Suchwerkzeug f?ur syn-
taktisch annotierte Textkorpora. Ph.D. thesis, IMS,
University of Stuttgart, December. Arbeitspapiere
des Instituts f?ur Maschinelle Sprachverarbeitung
(AIMS), volume 8, number 4.
Marcus, Mitchell P., Grace Kim, Mary Ann
Marcinkiewicz, Robert MacIntyre, Ann Bies,
Mark Ferguson, Karen Katz, and Britta Schasberger.
1994. The penn treebank: Annotating predicate
argument structure. In HLT. Morgan Kaufmann.
Mengel, A. and W. Lezius. 2000. An XML-based rep-
resentation format for syntactically annotated cor-
pora.
M??rovsk?y, Ji?r??. 2006. Netgraph: A tool for search-
ing in prague dependency treebank 2.0. In Haji?c,
Jan and Joakim Nivre, editors, Proceedings of the
Fifth Workshop on Treebanks and Linguistic Theo-
ries (TLT), pages 211?222, Prague, Czech Republic.
Pajas, Petr and Jan
?
St?ep?anek. 2006. XML-based repre-
sentation of multi-layered annotation in the PDT 2.0.
In Proceedings of the LREC Workshop on Merging
and Layering Linguistic Information (LREC 2006),
pages 40?47.
Pajas, Petr. 2005. XSH - XML Editing Shell (an intro-
duction). In Proceedings of XMLPrague conference
on XML 2005, pages 69?78, Prague.
Prokopidis, P, E Desypri, M Koutsombogera, H Papa-
georgiou, and S Piperidis. 2005. Theoretical and
practical issues in the construction of a greek depen-
dency treebank. In In Proc. of the 4th Workshop on
Treebanks and Linguistic Theories (TLT, pages 149?
160.
Rohde, D. 2001. TGrep2 the next-generation search
engine for parse trees. http://tedlab.mit.edu/ dr/-
Tgrep2/.
Smr?z, Otakar and Petr Pajas. 2004. MorphoTrees
of Arabic and Their Annotation in the TrEd Envi-
ronment. In Nikkhou, Mahtab, editor, Proceedings
of the NEMLAR International Conference on Ara-
bic Language Resources and Tools, pages 38?41,
Cairo. ELDA.
?
St?ep?anek, Jan. 2006. Post-annotation checking of
prague dependency treebank 2.0 data. In Proceed-
ings of the 9th International Conference, TSD 2006,
number 4188 in Lecture Notes In Computer Science,
pages 277?284. Springer-Verlag Berlin Heidelberg.
Tadi?c, Marko. 2007. Building the croatian dependency
treebank: the initial stages. In Contemporary Lin-
guistics, volume 63, pages 85?92.
Trapman, Jantine and Paola Monachesi. 2006. Manual
for the. annotation of semantic roles in D-Coi. Tech-
nical report, University of Utrecht.
van der Beek, Leonoor, Gosse Bouma, Robert Malouf,
and Gertjan van Noord. 2002. The alpino depen-
dency treebank. In Computational Linguistics in the
Netherlands CLIN 2001, Rodopi.
?
Zabokrtsk?y, Zden?ek, Jan Pt?a?cek, and Petr Pajas. 2008.
TectoMT: Highly modular hybrid MT system with
tectogramatics used as transfer layer. (To appear).
680
Proceedings of the ACL-IJCNLP 2009 Software Demonstrations, pages 33?36,
Suntec, Singapore, 3 August 2009.
c?2009 ACL and AFNLP
System for Querying Syntactically Annotated Corpora
Petr Pajas
Charles Univ. in Prague, MFF
?
UFAL
Malostransk?e n?am. 25
118 00 Prague 1 ? Czech Rep.
pajas@ufal.mff.cuni.cz
Jan
?
St
?
ep
?
anek
Charles Univ. in Prague, MFF
?
UFAL
Malostransk?e n?am. 25
118 00 Prague 1 ? Czech Rep.
stepanek@ufal.mff.cuni.cz
Abstract
This paper presents a system for querying
treebanks. The system consists of a pow-
erful query language with natural support
for cross-layer queries, a client interface
with a graphical query builder and visual-
izer of the results, a command-line client
interface, and two substitutable query en-
gines: a very efficient engine using a re-
lational database (suitable for large static
data), and a slower, but paralel-computing
enabled, engine operating on treebank files
(suitable for ?live? data).
1 Introduction
Syntactically annotated treebanks are a great re-
source of linguistic information that is available
hardly or not at all in flat text corpora. Retrieving
this information requires specialized tools. Some
of the best-known tools for querying treebanks
include TigerSEARCH (Lezius, 2002), TGrep2
(Rohde, 2001), MonaSearch (Maryns and Kepser,
2009), and NetGraph (M??rovsk?y, 2006). All these
tools dispose of great power when querying a sin-
gle annotation layer with nodes labeled by ?flat?
feature records.
However, most of the existing systems are little
equipped for applications on structurally complex
treebanks, involving for example multiple inter-
connected annotation layers, multi-lingual par-
allel annotations with node-to-node alignments,
or annotations where nodes are labeled by at-
tributes with complex values such as lists or nested
attribute-value structures. The Prague Depen-
dency Treebank 2.0 (Haji?c and others, 2006), PDT
2.0 for short, is a good example of a treebank with
multiple annotation layers and richly-structured
attribute values. NetGraph was a tool tradition-
ally used for querying over PDT, but still it does
not directly support cross-layer queries, unless the
layers are merged together at the cost of loosing
some structural information.
The presented system attempts to combine and
extend features of the existing query tools and re-
solve the limitations mentioned above. We are
grateful to an anonymous referee for pointing us
to ANNIS2 (Zeldes and others, 2009) ? another
system that targets annotation on multiple levels.
2 System Overview
Our system, named PML Tree Query (PML-TQ),
consists of three main components (discussed fur-
ther in the following sections):
? an expressive query language supporting
cross-layer queries, arbitrary boolean com-
binations of statements, able to query com-
plex data structures. It also includes a sub-
language for generating listings and non-
trivial statistical reports, which goes far be-
yond statistical features of e.g. TigerSearch.
? client interfaces: a graphical user inter-
face with a graphical query builder, a cus-
tomizable visualization of the results and a
command-line interface.
? two interchangeable engines that evaluate
queries: a very efficient engine that requires
the treebank to be converted into a rela-
tional database, and a somewhat slower en-
gine which operates directly on treebank files
and is useful especially for data in the process
of annotation and experimental data.
The query language applies to a generic data
model associated with an XML-based data format
called Prague Markup Language or PML (Pajas
and
?
St?ep?anek, 2006). Although PML was devel-
oped in connection with PDT 2.0, it was designed
as a universally applicable data format based on
abstract data types, completely independent of a
33
particular annotation schema. It can capture sim-
ple linear annotations as well as annotations with
one or more richly structured interconnected an-
notation layers. A concrete PML-based format for
a specific annotation is defined by describing the
data layout and XML vocabulary in a special file
called PML Schema and referring to this schema
file from individual data files.
It is relatively easy to convert data from other
formats to PML without loss of information. In
fact, PML-TQ is implemented within the TrEd
framework (Pajas and
?
St?ep?anek, 2008), which
uses PML as its native data format and already of-
fers all kinds of tools for work with treebanks in
several formats using on-the-fly transformation to
PML (for XML input via XSLT).
The whole framework is covered by an open-
source license and runs on most current platforms.
It is also language and script independent (operat-
ing internally with Unicode).
The graphical client for PML-TQ is an exten-
sion to the tree editor TrEd that already serves as
the main annotation tool for treebank projects (in-
cluding PDT 2.0) in various countries. The client
and server communicate over the HTTP protocol,
which makes it possible to easily use PML-TQ en-
gine as a service for other applications.
3 Query Language
A PML-TQ query consists of a part that selects
nodes in the treebank, and an optional part that
generates a report from the selected occurrences.
The selective part of the query specifies condi-
tions that a group of nodes must satisfy to match
the query. The conditions can be formulated as
arbitrary boolean combinations of subqueries and
simple statements that can express all kinds of re-
lations between nodes and/or attribute values. This
part of the query can be visualized as a graph with
vertices representing the matching nodes, con-
nected by various types of edges. The edges (vi-
sualized by arrows of different colors and styles)
represent various types of relations between the
nodes. There are four kinds of these relations:
? topological relations (child, descendant
depth-first-precedes, order-precedes, same-
tree-as, same-document-as) and their
reversed counterparts (parent, ancestor,
depth-first-follows, order-follows)
? inter- or cross-layer ID-based references
? user-implemented relations, i.e. relations
whose low-level implementation is provided
by the user as an extension to PML-TQ
1
(for example, we define relations eparent and
echild for PDT 2.0 to distinguish effective de-
pendency from technical dependency).
? transitive closures of the preceding two types
of relations (e.g. if coref text.rf is a re-
lation representing textual coreference, then
coref text.rf{4,} is a relation rep-
resenting chains of textual coreference of
length at least 4).
The query can be accompanied by an optional
part consisting of a chain of output filters that can
be used to extract data from the matching nodes,
compute statistics, and/or format and post-process
the results of a query.
Let us examine these features on an example
of a query over PDT 2.0, which looks for Czech
words that have a patient or effect argument in in-
finitive form:
t-node $t := [
child t-node $s := [
functor in { "PAT", "EFF" },
a/lex.rf $a ] ];
a-node $a := [
m/tag
?
??Vf?,
0x child a-node [ afun = ?AuxV? ] ];
>> for $s.functor,$t.t_lemma
give $1, $2, count()
sort by $3 desc
The square brackets enclose conditions regarding
one node, so t-node $t := [...] is read
?t-node $t with . . . ?. Comma is synonymous with
logical and. See Fig. 3 for the graphical represen-
tation of the query and one match.
This particular query selects occurrences of a
group of three nodes, $t, $s, and $a with the
following properties: $t and $s are both of type
t-node, i.e. nodes from a tectogrammatical tree
(the types are defined in the PML Schema for the
PDT 2.0); $s is a child of $t; the functor at-
tribute of $s has either the value PAT or EFF; the
node $s points to a node of type a-node, named
$a, via an ID-based reference a/lex.rf (this
expression in fact retrieves value of an attribute
lex.rf from an attribute-value structure stored
in the attribute a of $s); $a has an attribute m car-
rying an attribute-value structure with the attribute
1
In some future version, the users will also be able to de-
fine new relations as separate PML-TQ queries.
34
0xt-node $s functor in { "PAT", "EFF" }
t-node $t 
Output filters:  >>  for $s.functor,$t.t_lemma     give $1,$2,count()     sort by $3 desc
a-node afun = 'AuxV'
a-node $a m/tag ~ '^Vf'
a/lex.rfchild
#PersPronACTn.pron.def.pers
zapomenout enuncPREDv
#CorACTqcomplex
d?chatPATv
.
a-lnd94103-087-p1s3AuxS
Zapomn?liPred
jsmeAuxV d?chatObj
.AuxK
Zapomn?eli jsme d?ychat. [We-forgot (aux) to-breathe.]
Figure 1: Graphical representation of a query (left) and a result spanning two annotation layers
tagmatching regular expression ?Vf (in PDT 2.0
tag set this indicates that $a is an infinitive); $a
has no child node that is an auxiliary verb (afun
= ?AuxV?). This last condition is expressed as a
sub-query with zero occurrences (0x).
The selective part of the query is followed by
one output filter (starting with >>). It returns three
values for each match: the functor of $s, the tec-
togrammatical lemma of $t, and for each distinct
pair of these two values the number of occurrences
of this pair counted over the whole matching set.
The output is ordered by the 3rd column in the de-
scending order. It may look like this:
PAT mo?znost 115
PAT schopn?y 110
EFF a 85
PAT #Comma 83
PAT rozhodnout_se 75
In the PML data model, attributes (like a of
$t, m of $a in our example) can carry com-
plex values: attribute-value structures, lists, se-
quences of named elements, which in turn may
contain other complex values. PML-TQ addresses
values nested within complex data types by at-
tribute paths whose notation is somewhat similar
to XPath (e.g. m/tag or a/[2]/aux.rf). An
attribute path evaluated on a given node may re-
turn more than one value. This happens for ex-
ample when there is a list value on the attribute
path: the expression m/w/token=?a? where m
is a list of attribute-value structures reads as some
one value returned by m/w/token equals ?a?.
By prefixing the path with a
*
, we may write
all values returned by m/w/token equal ?a? as
*
m/w/token=?a?.
We can also fix one value returned by an at-
tribute path using the member keyword and query
it the same way we query a node in the treebank:
t-node $n:= [
member bridging [
type = "CONTRAST",
target.rf t-node [ functor="PAT" ]]]
where bridging is an attribute of t-node con-
taining a list of labeled graph edges (attribute-
value structures). We select one that has type
CONTRAST and points to a node with functor PAT.
4 Query Editor and Client
Figure 2: The PML-TQ graphical client in TrEd
The graphical user interface lets the user to
build the query graphically or in the text form; in
both cases it assists the user by offering available
node-types, applicable relations, attribute paths,
and values for enumerated data types. It commu-
nicates with the query engine and displays the re-
sults (matches, reports, number of occurrences).
35
Colors are used to indicate which node in the
query graph corresponds to which node in the re-
sult. Matches from different annotation layers are
displayed in parallel windows. For each result, the
user can browse the complete document for con-
text. Individual results can be saved in the PML
format or printed to PostScript, PDF, or SVG. The
user can also bookmark any tree from the result
set, using the bookmarking features of TrEd. The
queries are stored in a local file.
2
5 Engines
For practical reasons, we have developed two en-
gines that evaluate PML-TQ queries:
The first one is based on a translator of PML-
TQ to SQL. It utilizes the power of modern re-
lational databases
3
and provides excellent perfor-
mance and scalability (answering typical queries
over a 1-million-word treebank in a few seconds).
To use this engine, the treebank must be, simi-
larly to (Bird and others, 2006), converted into
read-only database tables, which makes this en-
gine more suitable for data that do not change too
often (e.g. final versions of treebanks).
For querying over working data or data not
likely to be queried repeatedly, we have devel-
oped an index-less query evaluator written in Perl,
which performs searches over arbitrary data files
sequentially. Although generally slower than the
database implementation (partly due to the cost
of parsing the input PML data format), its perfor-
mance can be boosted up using a built-in support
for parallel execution on a computer cluster.
Both engines are accessible through the identi-
cal client interface. Thus, users can run the same
query over a treebank stored in a database as well
as their local files of the same type.
When implementing the system, we periodi-
cally verify that both engines produce the same
results on a large set of test queries. This testing
proved invaluable not only for maintaining con-
sistency, but also for discovering bugs in the two
implementations and also for performance tuning.
6 Conclusion
We have presented a powerful open-source sys-
tem for querying treebanks extending an estab-
2
The possibility of storing the queries in a user account
on the server is planned.
3
The system supports Oracle Database (version 10g or
newer, the free XE edition is sufficient) and PostgreSQL (ver-
sion at least 8.4 is required for complete functionality).
lished framework. The current version of the sys-
tem is available at http://ufal.mff.cuni.
cz/
?
pajas/pmltq.
Acknowledgments
This paper as well as the development of the sys-
tem is supported by the grant Information Society
of GA AV
?
CR under contract 1ET101120503 and
by the grant GAUK No. 22908.
References
Steven Bird et al 2006. Designing and evaluating an
XPath dialect for linguistic queries. In ICDE ?06:
Proceedings of the 22nd International Conference
on Data Engineering, page 52. IEEE Computer So-
ciety.
Jan Haji?c et al 2006. The Prague Dependency Tree-
bank 2.0. CD-ROM. Linguistic Data Consortium
(CAT: LDC2006T01).
Wolfgang Lezius. 2002. Ein Suchwerkzeug f?ur syn-
taktisch annotierte Textkorpora. Ph.D. thesis, IMS,
University of Stuttgart, December. Arbeitspapiere
des Instituts f?ur Maschinelle Sprachverarbeitung
(AIMS), volume 8, number 4.
Hendrik Maryns and Stephan Kepser. 2009.
Monasearch ? querying linguistic treebanks with
monadic second-order logic. In Proceedings of the
7th International Workshop on Treebanks and Lin-
guistic Theories (TLT 2009).
Ji?r?? M??rovsk?y. 2006. Netgraph: A tool for searching
in Prague Dependency Treebank 2.0. In Proceed-
ings of the 5th Workshop on Treebanks and Linguis-
tic Theories (TLT 2006), pages 211?222.
Petr Pajas and Jan
?
St?ep?anek. 2008. Recent advances
in a feature-rich framework for treebank annotation.
In The 22nd International Conference on Computa-
tional Linguistics - Proceedings of the Conference,
volume 2, pages 673?680. The Coling 2008 Orga-
nizing Committee.
Petr Pajas and Jan
?
St?ep?anek. 2006. XML-based repre-
sentation of multi-layered annotation in the PDT 2.0.
In Proceedings of the LREC Workshop on Merging
and Layering Linguistic Information (LREC 2006),
pages 40?47.
Douglas L.T. Rohde. 2001. TGrep2 the
next-generation search engine for parse trees.
http://tedlab.mit.edu/
?
dr/Tgrep2/.
Amir Zeldes et al 2009. Information structure in
african languages: Corpora and tools. In Proceed-
ings of the Workshop on Language Technologies for
African Languages (AFLAT), 12th Conference of the
European Chapter of the Association for Computa-
tional Linguistics (EACL-09), Athens, Greece, pages
17?24.
36
Proceedings of the Third Workshop on Statistical Machine Translation, pages 167?170,
Columbus, Ohio, USA, June 2008. c?2008 Association for Computational Linguistics
TectoMT: Highly Modular MT System
with Tectogrammatics Used as Transfer Layer?
Zdene?k Z?abokrtsky?, Jan Pta?c?ek, Petr Pajas
Institute of Formal and Applied Linguistics
Charles University, Prague, Czech Republic
{zabokrtsky,ptacek,pajas}@ufal.mff.cuni.cz
Abstract
We present a new English?Czech machine
translation system combining linguistically
motivated layers of language description (as
defined in the Prague Dependency Treebank
annotation scenario) with statistical NLP ap-
proaches.
1 Introduction
We describe a new MT system (called Tec-
toMT) based on the conventional analysis-transfer-
synthesis architecture. We use the layers of language
description defined in the Prague Dependency Tree-
bank 2.0 (PDT for short, (Hajic? and others, 2006)),
namely (1) word layer ? raw text, no linguistic
annotation, (2) morphological layer ? sequence of
tagged and lemmatized tokens, (3) analytical layer
? each sentence represented as a surface-syntactic
dependency tree, and (4) tectogrammatical layer ?
each sentence represented as a deep-syntactic de-
pendency tree in which only autosemantic words do
have nodes of their own; prefixes w-, m-, a-, or t-
will be used for denoting these layers.1
We use ?Praguian? tectogrammatics (introduced
in (Sgall, 1967)) as the transfer layer because
we believe that, first, it largely abstracts from
language-specific (inflection, agglutination, func-
tional words. . . ) means of expressing non-lexical
?The research reported in this paper is financially supported
by grants GAAV C?R 1ET101120503 and MSM0021620838.
1In addition, we use also p-layer (phrase structures) as an
a-layer alternative, the only reason for which is that we do not
have a working a-layer parser for English at this moment.
meanings, second, it allows for a natural transfer
factorization, and third, local tree contexts in t-trees
carry more information (esp. for lexical choice) than
local linear contexts in the original sentences.
In order to facilitate separating the transfer of lex-
icalization from the transfer of syntactization, we in-
troduce the concept of formeme. Each t-node?s has
a formeme attribute capturing which morphosyntac-
tic form has been (in the case of analysis) or will
be (synthesis) used for the t-node in the surface sen-
tence shape. Here are some examples of formemes
we use for English: n:subj (semantic noun (sn) in
subject position), n:for+X (sn with preposition for),
n:X+ago (sn with postposition ago), n:poss (posses-
sive form of sn), v:because+fin (semantic verb (sv)
as a subordinating finite clause introduced by be-
cause), v:without+ger (sv as a gerund after without),
adj:attr (semantic adjective (sa) in attributive posi-
tion), adj:compl (sa in complement position).
The presented system intensively uses the PDT
technology (data formats, software tools). Special
attention is paid to modularity: the translation is im-
plemented (in Perl) as a long sequence of processing
modules (called blocks) with relatively tiny, well-
defined tasks, so that each module is independently
testable, improvable, or substitutable. TectoMT al-
lows to easily combine blocks based on different
approaches, from blocks using complex probabilis-
tic solutions (e.g., B2, B6, B35, see the next section),
through blocks applying simpler Machine Learning
techniques (e.g., B69) or empirically based heuris-
tics (e.g., B7, B25, B36, B71), to blocks implementing
?crisp? linguistic rules (e.g., B48-B51, B59). There are
also blocks for trivial technical tasks (e.g., B33, B72).
167
English m-layerSheshe PRP hashave VBZ nevernever RB laughedlaugh VBN inin IN herher PRP$ newnew JJ bossboss NN 's's POS officeoffice NN .. .
NPBShe has
English p-layerS
ADVPnever
VP
laughedin
VP
her new
PP
NPBboss 's
NPB
office .
English a-layer
She has neverlaughedin
her newboss's
office.
English t-layer
#PersPronn:subj neveradv:
laughv:fin
#PersPronn:poss newadj:attr
bossn:poss
officen:in+X
Czech t-layer
#PersPronn:1 nikdyadv:
sm?t_sev:fin ??adn:v+6
#PersPronadj:attr nov?adj:attr
??fn:2
Czech a-layer
NikdyD........1A... seP7
nesm?laVpFS...3..NA..vR??aduN.IS6.....A...
sv?hoP8MS2......... nov?hoAAMS2....1A...
??faN.MS2.....A...
.Z
Figure 1: MT ?pyramid? as implemented in TectoMT. All the representations are rooted with artificial nodes, serving
only as labels. Virtually, the pyramid is bottomed with the input sentence on the source side (She has never laughed in
her new boss?s office.) and its automatic translation on the target side (Nikdy se nesma?la v u?r?adu sve?ho nove?ho s?e?fa.).
2 Translation Procedure
The structure of this section directly renders the se-
quence of blocks currently used for English-Czech
translation in TectoMT. The intermediate stages of
the translation process are illustrated in Figure 1;
identifiers of the blocks affecting on the translation
of the sample sentence are typeset in bold.
2.1 From English w-layer to English m-layer
B1: Segment the source English text into sentences.
B2: Split the sentences into sequences of tokens,
roughly according to Penn Treebank (PTB for short;
(Marcus et al, 1994)) conventions. B3: Tag the
tokens with PTB-style POS tags using a tagger
(Brants, 2000). B4: Fix some tagging errors sys-
tematically made by the tagger using a rule-based
corrector. B5: Lemmatize the tokens using morpha,
(Minnen et al, 2000).
2.2 From English m-layer to English p-layer
B6: Build PTB-style phrase-structure tree for each
sentence using a parser (Collins, 1999).
2.3 From English p-layer to English a-layer
B7: In each phrase, mark the head node (using a set
of heuristic rules). B8: Convert phrase-structure trees
to a-trees. B9: Apply some heuristic rules to fix ap-
position constructions. B10: Apply another heuris-
tic rules for reattaching incorrectly positioned nodes.
B11: Unify the way in which multiword prepositions
(such as because of ) and subordinating conjunctions
(such as provided that) are treated. B12: Assign an-
alytical functions (only if necessary for a correct
treatment of coordination/apposition constructions).
2.4 From English a-layer to English t-layer
B13: Mark a-nodes which are auxiliary (such as
prepositions, subordinating conjunctions, auxiliary
verbs, selected types of particles, etc.) B14: Mark not
as an auxiliary node too (but only if it is connected to
a verb form). B15: Build t-trees. Each a-node cluster
formed by an autosemantic node and possibly sev-
eral associated auxiliary nodes is ?collapsed? into a
single t-node. T-tree dependency edges are derived
from a-tree edges connecting the a-node clusters.
B16: Explicitely distinguish t-nodes that are mem-
bers of coordination (conjuncts) from shared modi-
fiers. It is necessary as they all are attached below
the coordination conjunction t-node. B17: Modify
t-lemmas in specific cases. E.g., all kinds of per-
sonal pronouns are represented by the ?artificial? t-
lemma #PersPron. B18: Assign functors that are nec-
essary for proper treatment of coordination and ap-
position constructions. B19: Distribute shared auxil-
iary words in coordination constructions. B20: Mark
t-nodes that are roots of t-subtrees corresponding to
finite verb clauses. B21: Mark passive verb forms.
B22: Assign (a subset of) functors. B23: Mark t-nodes
corresponding to infinitive verbs. B24: Mark t-nodes
which are roots of t-subtrees corresponding to rel-
ative clauses. B25: Identify coreference links be-
tween relative pronouns (or other relative pronom-
inal word) and their nominal antecedents. B26: Mark
168
t-nodes that are the roots of t-subtrees correspond-
ing to direct speeches. B27: Mark t-nodes that are
the roots of t-subtrees corresponding to parenthe-
sized expressions. B28: Fill the nodetype attribute
(rough classification of t-nodes). B29: Fill the sem-
pos attribute (fine-grained classification of t-nodes).
B30: Fill the grammateme attributes (semantically in-
dispensable morphological categories, such as num-
ber for nouns, tense for verbs). B31: Determine the
formeme of each t-node. B32: Mark personal names,
distinguish male and female first names if possible.
2.5 From English t-layer to Czech t-layer
B33: Initiate the target-side t-trees, simply by cloning
the source-side t-trees. B34: In each t-node, trans-
late its formeme.2 B35: Translate t-lemma in each
t-node as its most probable target-language counter-
part (which is compliant with the previously chosen
formeme), according to a probabilistic dictionary.3
B36: Apply manual rules for fixing the formeme and
lexeme choices, which are otherwise systematically
wrong and are reasonably frequent. B37: Fill the gen-
der grammateme in t-nodes corresponding to deno-
tative nouns (it follows from the chosen t-lemma).4
B38: Fill the aspect grammateme in t-nodes corre-
sponding to verbs. Information about aspect (perfec-
tive/imperfective) is necessary for making decisions
about forming complex future tense in Czech. B39:
Apply rule-based correction of translated date/time
expressions (several templates such as 1970?s, July
1, etc.). B40: Fix grammateme values in places where
the English-Czech grammateme correspondence is
not trivial (e.g., if an English gerund expression
is translated using Czech subordinating clause, the
2The translation mapping from English formemes to Czech
formemes was obtained as follows: we analyzed 10,000 sen-
tence pairs from the WMT?08 training data up to the t-layer
(using a tagger shipped with the PDT and parser (McDonald et
al., 2005) for Czech), added formemes to t-trees on both sides,
aligned the t-trees (using a set of weighted heuristic rules, simi-
larly to (Menezes and Richardson, 2001)), and from the aligned
t-node pairs extracted for each English formeme its most fre-
quent Czech counterpart.
3The dictionary was created by merging the translation dic-
tionary from PCEDT ((Cur???n and others, 2004)) and a trans-
lation dictionary extracted from a part of the parallel corpus
Czeng ((Bojar and Z?abokrtsky?, 2006)) aligned at word-level by
Giza++ ((Och and Ney, 2003)).
4Czech nouns have grammatical gender which is (among
others) important for resolving grammatical agreement.
tense grammateme has to be filled). B41: Negate
verb forms where some arguments of the verbs bear
negative meaning (double negation in Czech). B42:
Verb t-nodes in active voice that have transitive t-
lemma and no accusative object, are turned to re-
flexives. B43: The t-nodes with genitive formeme
or prepositional-group formeme, whose counterpart
English t-nodes are located in pre-modification po-
sition, are moved to post-modification position. B44:
Reverse the dependency orientation between nu-
meric expressions and counted nouns, if the value
of the numeric expression is greater than four and
the noun without the numeral would be expressed in
nominative or accusative case. B45: Find coreference
links from personal pronouns to their antecedents,
if the latter are in subject position (needed later for
reflexivization).
2.6 From Czech t-layer to Czech a-layer
B46: Create initial a-trees by cloning t-trees. B47:
Fill the surface morphological categories (gender,
number, case, negation, etc.) with values derived
from values of grammatemes, formeme, seman-
tic part of speech etc. B48: Propagate the values
of gender and number of relative pronouns from
their antecedents (along the coreference links). B49:
Propagate the values of gender, number and person
according to the subject-predicate agreement (i.e.,
from subjects to the finite verbs). B50: Resolve agree-
ment of adjectivals in attributive positions (copying
gender/number/case from their governing nouns).
B51: Resolve complement agreement (copying gen-
der/number from subject to adjectival complement).
B52: Apply pro-drop ? deletion of personal pronouns
in subject positions. B53: Add preposition a-nodes
(if implied by the t-node?s formeme). B54: Add a-
nodes for subordinating conjunction (if implied by
the t-node?s formeme). B55: Add a-nodes corre-
sponding to reflexive particles for reflexiva tantum
verbs. B56: Add an a-node representing the auxiliary
verb by?t (to be) in the case of compound passive
verb forms. B57: Add a-nodes representing modal
verbs, accordingly to the deontic modality gram-
mateme. B58: Add the auxiliary verb by?t in imperfec-
tive future-tense complex verb forms. B59: Add verb
forms such as by/bys/bychom expressing conditional
verb modality. B60: Add auxiliary verb forms such
as jsem/jste in past-tense complex verb forms. B61:
169
Partition a-trees into finite clauses (a-nodes belong-
ing to the same clause are coindexed). B62: In each
clause, a-nodes which represent clitics are moved to
the so called second position in the clause (accord-
ing to Wackernagel?s law). B63: Add a-nodes cor-
responding to sentence-final punctuation mark. B64:
Add a-nodes corresponding to commas on bound-
aries between governing and subordinated clauses.
B65: Add a-nodes corresponding to commas in front
of conjunction ale and also commas in multiple co-
ordinations. B66: Add pairs of parenthesis a-nodes.
B67: Choose morphological lemmas in a-nodes cor-
responding to personal pronouns. B68: Generate
the resulting word forms (derived from lemmas and
tags) using Czech word form generator described in
(Hajic?, 2004). B69: Vocalize prepositions k, s, v, and
z (accordingly to the prefix of the following word).
B70: Capitalize the first word in each sentence as well
as in each direct speech.
2.7 From Czech a-layer to Czech w-layer
B71: Create the resulting sentences by flattening the
a-trees. Heuristic rules for proper spacing around
punctuation marks are used. B72: Create the resulting
text by concatenating the resulting sentences.
3 Final remarks
We believe that the potential contribution of tec-
togrammatical layer of language representation for
MT is the following: it abstracts from many
language-specific phenomena (which could reduce
the notorious data-sparsity problem) and offers a
natural factorization of the translation task (which
could be useful for formulating independence as-
sumptions when building probabilistic models). Of
course, the question naturally arises whether these
properties can ever outbalance the disadvantages, es-
pecially cumulation and interference of errors made
on different layers, considerable technical complex-
ity, and the need for detailed linguistic insight. In
our opinion, this question still remains open. On
one hand, the translation quality offered now by Tec-
toMT is below the state-of-the-art system according
to the preliminary evaluation of the WMT08 Shared
Task. But on the other hand, the potential of tec-
togrammatics has not been used fully, and more-
over there are still many components with only pilot
heuristic implementation which increase the number
of translation errors and which can be relatively eas-
ily substituted by corpus-based solutions. In the near
future, we plan to focus especially on the transfer
blocks, which are currently based on the naive as-
sumption of isomorphism of the source and target
t-trees and which do not make use of the target lan-
guage model, so far.
References
Ondr?ej Bojar and Zdene?k Z?abokrtsky?. 2006. CzEng:
Czech-English Parallel Corpus, Release version 0.5.
Prague Bulletin of Mathematical Linguistics, 86:59?
62.
Thorsten Brants. 2000. TnT - A Statistical Part-of-
Speech Tagger . pages 224?231, Seattle.
Michael Collins. 1999. Head-driven Statistical Models
for Natural Language Parsing. Ph.D. thesis, Univer-
sity of Pennsylvania, Philadelphia.
Jan Cur???n et al 2004. Prague Czech - English Depen-
dency Treebank, Version 1.0. CD-ROM, Linguistics
Data Consortium, LDC Catalog No.: LDC2004T25,
Philadelphia.
Jan Hajic? et al 2006. Prague Dependency Treebank 2.0.
CD-ROM, Linguistic Data Consortium, LDC Catalog
No.: LDC2006T01, Philadelphia.
Jan Hajic?. 2004. Disambiguation of Rich Inflection ?
Computational Morphology of Czech. Charles Uni-
versity ? The Karolinum Press, Prague.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1994. Building a Large Annotated
Corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313?330.
Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajic?. 2005. Non-Projective Dependency Pars-
ing using Spanning Tree Algorithms. In Proceedings
of HTL/EMNLP, pages 523?530, Vancouver, Canada.
Arul Menezes and Stephen D. Richardson. 2001. A best-
first alignment algorithm for automatic extraction of
transfer mappings from bilingual corpora. In Proceed-
ings of the workshop on Data-driven methods in ma-
chine translation, volume 14, pages 1?8.
Guido Minnen, John Carroll, and Darren Pearce. 2000.
Robust Applied Morphological Generation. In Pro-
ceedings of the 1st International Natural Language
Generation Conference, pages 201?208, Israel.
Franz Josef Och and Hermann Ney. 2003. A Systematic
Comparison of Various Statistical Alignment Models.
Computational Linguistics, 29(1):19?51.
Petr Sgall. 1967. Generativn?? popis jazyka a c?eska? dek-
linace. Academia, Prague.
170
Proceedings of the Third Linguistic Annotation Workshop, ACL-IJCNLP 2009, pages 108?111,
Suntec, Singapore, 6-7 August 2009. c?2009 ACL and AFNLP
The Coding Scheme for Annotating Extended Nominal Coreference 
and Bridging Anaphora in the Prague Dependency Treebank 
Anna Nedoluzhko,  Ji?? M?rovsk?,  Petr Pajas
Charles University in Prague
Institute of Formal and Applied Linguistics
{nedoluzko, mirovsky, pajas}@ufal.mff.cuni.cz
Abstract
The present paper outlines an ongoing project 
of annotation of the extended nominal corefer-
ence and the bridging anaphora in the Prague 
Dependency Treebank. We describe the anno-
tation  scheme  with  respect  to  the  linguistic 
classification of coreferential and bridging re-
lations and focus also on details of the annota-
tion process from the technical point of view. 
We present methods of helping the annotators 
?  by  a  pre-annotation  and  by  several  useful 
features  implemented  in  the  annotation  tool. 
Our method of the inter-annotator agreement 
is focused on the improvement of the annota-
tion  guidelines;  we  present  results  of  three 
subsequent measurements of the agreement.
1 Introduction
The Prague Dependency Treebank (PDT 2.0) is a 
large collection  of linguistically  annotated  data 
and documentation (Haji?  et al, 2006). In PDT 
2.0,  Czech  newspaper  texts  are  annotated  on 
three  layers.  The most abstract  (tectogrammati-
cal) layer includes the annotation of coreferential 
links of two types: grammatical coreference (typ-
ically within a single sentence) and textual coref-
erence (for pronominal and zero anaphora). The 
current paper focuses on the present annotation 
of  extended  textual  coreference,  where  the 
anaphoric  expression  is  neither  personal  pro-
noun, nor zero. Also the annotation of bridging 
anaphora on PDT is discussed.
In the last few years, a number of annotation 
schemes have been released, three of which are 
to be shortly presented here. The MUC is consid-
ered to be the most standard annotation scheme 
(Hirschman, 1997) and it  is  used in more than 
one  application  (MUC-6,  MUC-7,  ACE).  The 
advantage of this scheme is its simplicity and a 
very  detailed  linguistically  oriented  coding 
scheme.  It  has  been  however  criticized  for  its 
vague interpretation of the notion of coreference 
and for  the  limited  coverage of  relations  (only 
identical  relation  between  nouns  is  annotated). 
One of the most well known later approaches is 
MATE (Poesio, 2004)  and its  extension on the 
GNOME  corpus.  The  project  is  meant  to  be 
multi-functional. The annotation scheme was pri-
marily  developed  for  dialog  acts  analyses,  but 
may be easily  adapted  for  any other  investiga-
tion. In the extended GNOME scheme, the iden-
tical  coreference  is  annotated  along with  some 
bridging  relations,  such  as  ELEMENT,  SUB-
SET,  POSSession  and  OTHER for  underspeci-
fied relations. In PoCoS (Krasavina and Chiar-
chos, 2007), a two layer coreference annotation 
scheme was suggested: the Core Layer is general 
and reusable, while the Extended Layer supports 
a wider range of specific extensions.
In this document, we present the application of 
coreference  annotation  on  a  slavonic  language 
(Czech).  Czech  has  no  definite  article,  so  in 
many cases, an anaphoric relation cannot be eas-
ily identified. That's why we concentrated solely 
on coreference, i.e. on the case when two expres-
sions denote the same entity. Anaphoric relation 
between  non-coreferential  objects  is  annotated 
separately,  together  with  some  other  types  of 
bridging anaphora (see 2.1).
2 Methods of coreference and bridging 
anaphora annotation
Subject to annotation are pairs of coreferring ex-
pressions, the preceding expression is called an-
tecedent, the subsequent one is called anaphor.
The  (mostly  manual)  annotation  of  the  ex-
tended  coreference  and  bridging  anaphora  pro-
ceeds  basically  in  one  phase.  Unlike 
MUC/MATE/PoCoS projects,  where  annotation 
is divided into two phases (identifying  elements 
that can come in coreference relation (so called 
?markables?) and  establishing  anaphoric  rela-
tion), we do not make preliminary annotation of 
?markables?. Realizing the disadvantage of diffi-
cult agreement comparison, we still think that to 
separate identifying ?markables? is unnecessary 
in case of a language without grammatical cate-
gory of definiteness.
108
2.1 The annotation scheme
For the time being, we annotate textual corefer-
ence and bridging anaphora. In what follows, we 
briefly  present  the  classification  of  these  two 
types of context-dependences.
The  cases  where  anaphor  is  a  personal, 
demonstrative or zero pronoun are already anno-
tated in PDT. In the present annotation, the most 
cases of anaphoric expressions are expressed by 
NP with  nominal  head,  in  some cases  also  by 
pronominal  demonstrative  adverbs  (there,  then 
etc.),  adjectives  (by  named  entities  (e.g.  Ger-
many ? German) and possessive forms)), numer-
als or verbs (own ? ownership), see ex. (1).
Textual coreference is further classified into 
two types ? coreference of NPs with specific  or 
generic coreference. This decision is made on the 
basis of the expectation, that generic coreferen-
tial  chains  have  different  anaphoric  rules  from 
the specific ones. Into this group, there is also in-
cluded  a  big number  of  abstract  nouns,  whose 
coreference is not quite clear in every particular 
case. So, the generic type of textual coreference 
serves as the ambiguity group too. 
In  bridging anaphora we distinguish PART, 
SUBSET and FUNCT traditional  relations  (see 
e.g. Clark 1977), CONTRAST for coherence rel-
evant  discourse  opposites  (e.g.  People don't  
chew, it's cows who chew) and further underspec-
ified group REST, which is  used  for capturing 
bridging references ? potential  candidates for  a 
new bridging group (e.g. location ? resident, rel-
atives, event ? argument and some others).
2.2 Annotation Principles
In order to develop maximally consistent annota-
tion scheme, we follow a number of basic princi-
ples. Some of them are presented below: 
Chain principle: coreference relations in text 
are organized in ordered chains.  The most recent 
mention  of  a referent  is  marked  as  antecedent. 
This  principle  is  controlled  automatically  (see 
3.1.2). Chain principle does not concern bridging 
anaphora.
Principle of the maximum length of corefer-
encial  chains also  concerns  only  the  case  of 
coreference.  It  says  that  in  case  of  multiple 
choice, we prefer to continue the existing coref-
erence chain, rather than to begin a new one. To 
satisfy  this  principle,  grammatical  coreferential 
chains are being continued by textual ones, and 
already annotated  textual  coreferences  are con-
tinued  by  currently  annotated   non-pronominal 
links in turn.
The principle of maximal size of an anaforic 
expression:  subject  to annotation is always the 
whole  subtree  of  the  antecedent/anaphor.  This 
principle is partially directed by the dependency 
structure  of tectogrammatical trees  and may be 
sometimes counter-intuitive. See ex. (1):
(1)Henry's brother Nicholas has owned the 
Hall  for  27  years.  On  Nicholas'  death,  it 
passed  into  the  ownership  of  his  nephew, 
Yarburgh Greame
The principle of cooperation with the syntac-
tic structure of a given dependency tree: we do 
not annotate relations, which are already caught 
up by the  syntactic  structure  of  the  tectogram-
matical tree. So, unlike most schemes, we do not 
annotate predication and apposition relations.
Preference  of  coreference  over  bridging 
anaphora: in case of multiple choice, we prefer 
coreference.
3 The Tool and Data Format
The primary format of PDT 2.0 is called PML. It 
is  an  abstract  XML-based  format  designed  for 
annotation of treebanks. For editing and process-
ing data in PML format, a fully customizable tree 
editor  TrEd  has  been  implemented  (Pajas  & 
?t?p?nek 2008).
TrEd  can  be  easily  customized  to  a  desired 
purpose by extensions that are included into the 
system as modules. In this section, we describe 
some features of an extension that has been im-
plemented for our purposes.
The data  scheme used  in  PDT 2.0 has  been 
slightly extended to support the annotation of the 
extended textual  coreference (that  has ? unlike 
the originally annotated textual coreference ? a 
type)  and  the  bridging  anaphora  (that  has  not 
been annotated before and also has a type). Tech-
nically,  various  kinds  of  non-dependency  rela-
tions between nodes in PDT 2.0 use dedicated re-
ferring  attributes  that  contain unique identifiers 
of the nodes they refer to.
3.1 Helping the Annotators
We employ two ways of helping the annotators 
in their  tedious  task. First,  we pre-annotate the 
data with highly probable coreference relations. 
The annotators check these links and can remove 
them  if  they  are  wrong.  This  approach  has 
proved to be faster than letting the annotators an-
notate  the  data  from scratch.  Second,  we have 
implemented several supporting features into the 
annotation  tool  (the  TrEd  extension)  that  help 
during the annotation process.
109
3.1.1 Pre-Annotation
We use a list of pairs of words that with a high 
probability  form  a  coreferential  pair  in  texts. 
Most of the pairs in the list consist of a noun and 
a derived adjective, which are different in Czech, 
e.g.  Praha  ?  pra?sk?  (in  English:  Prague  ? 
Prague,  like  in  the  sentence:  He  arrived  in  
Prague and found the Prague atmosphere quite  
casual).  The rest  of the list  is formed by pairs 
consisting  of  an abbreviation  and its  one-word 
expansion, e.g. ?R ? ?esko (similarly in English: 
USA ? States).  The whole list consists of more 
than  6  thousand  pairs  obtained  automatically 
from  the  morphological  synthesizer  for  Czech, 
manually checked and slightly extended.
3.1.2 Annotation
Several features have been implemented in the 
annotation tool to help with the annotation.
Manual  pre-annotation: If  the  annotator 
finds a word in the text that appears many times 
in the document and its occurrences seem to co-
refer,  he can create a coreferential chain out of 
these  words  by  a  single  key-stroke.  All  nodes 
that  have  the  same  tectogrammatical  lemma 
(t_lemma) become a part of the chain.
Finding the nearest antecedent: The annota-
tion  instructions  require  that  the  nearest  an-
tecedent is always selected for the coreferential 
link.  The  tool  automatically  re-directs  a  newly 
created coreferential arrow to the nearest one (in 
the already existing coreferential chain) if the an-
notator  selects  a farther  antecedent  by mistake. 
However, the rule of the nearest antecedent can 
be broken in less clear situations. For example, if 
there are three coreferential words in the text, A, 
B and C (ordered from left to right), and the an-
notator connects A and C (overlooking B), and 
later realizes that B is also coreferential with A 
and creates the arrow from B to A, the tool re-
connects  the  C?A arrow  to  C?B.  Thus,  the 
chain C?B?A is correctly created.
Preserving the coreferential chain: If the an-
notator  removes  an  arrow  and  a  coreferential 
chain is thus interrupted, the tool asks the anno-
tator whether it should re-connect the chain.
Text highlighting: The annotation of the ex-
tended  textual  coreference  and  the  bridging 
anaphora is  performed on the tectogrammatical 
layer of PDT. However, the annotators prefer to 
work on the surface form of the text, using the 
tectogrammatical trees only as a supporting de-
piction of the relations. After selecting a word in 
the sentences (by clicking on it), the tool deter-
mines  to  which  node  in  the  tectogrammatical 
trees the word belongs. Then, the projection back 
to the surface is performed and all words on the 
surface that belong to the selected node are high-
lighted. Only one word of the highlighted words 
is a lexical counterpart of the tectogrammatical 
node  (which  is  usually  the  word  the  annotator 
clicked on ? only in cases such as if the annotator 
clicks on a preposition or other auxiliary word, 
the lexical counterpart of the corresponding tec-
togrammatical  node  differs  from  the  word 
clicked  on).  Using  this  information,  also  all 
words  in  the  sentences  that  have  the  same 
t_lemma (again, we use only the lexical counter-
parts)  as  the  selected  word,  are  underlined. 
Words that are connected with the selected word 
via a coreferential chain are highlighted in such 
colors that indicate whether the last connecting 
relation in the chain was textual or grammatical. 
Moreover,  all  words  that  are  connected  via  a 
bridging anaphora with any word of this corefer-
ential chain, are highlighted in a specific color.
4 Application and Evaluation
The annotation of the extended textual  corefer-
ence  and  the  bridging  anaphora  started  in  No-
vember 2008. Two annotators work on different 
texts  (each document  is  annotated only by one 
annotator),  except  for  a small  overlap  used for 
measuring the inter-annotator agreement.
As of April 2009, about one fifth of PDT 2.0 
data  has been  annotated.  The detailed  numbers 
are summed in Table 1:
number of annotated documents 611
total number of sentences 9,425
total number of words 157,817
total number of tectogrammatical nodes 
(excl. the technical root) 127,954
number of newly annotated co-referring 
nodes  (bridging  relations  and  textual 
coreference)
16,874
number of co-referring nodes including 
the textual coreference originally anno-
tated in PDT 2.0
20,532
% of co-referring nodes 16 %
Table 1. Annotation statistics
Figure 1 presents the proportion of  types of 
coreferential  and  bridging  relations  in  the  cur-
rently annotated part of PDT1. TK_0 is used for 
textual coreference of specific NPs, TK_NR for 
textual  coreference  of  non-specific  NPs,  other 
abbreviations are believed to be self-explaining. 
1  Including the originally annotated textual coreference 
in PDT 2.0.
110
Inter-annotator agreement: For the purposes 
of checking and improving the annotation guide-
lines,  we  require  a  more  strict  inter-annotator 
agreement than agreement  on sets  (for  corefer-
ence),  often  used  in  other  projects  (e.g.  Pas-
soneau  2004).  For  both  the  extended  textual 
coreference  and the  bridging anaphora,  we use 
F1-measure for the agreement on the antecedent, 
and Cohen's  ? (Cohen 1960) for the agreement 
on the type of the link. In Table 2, the results of 
the three performed measurements of the inter-
annotator agreement are presented:
arrows 
TC (F1)
arrows 
TC + 
types 
(F1)
TC 
types 
only 
(?)
arrows
bridging 
(F1)
arrows
bridging
+ 
types (F1)
bridging 
types 
only
(?)
1st measure-
ment 
(40 sent.) 0.76 0.67 0.54 0.49 0.42 0.79
2nd measure-
ment
(40 sent.) 0.64 0.41 0.33 0.52 0.52 1
3rdmeasure-
ment 
(100 sent.) 0.80 0.68 0.67 0.59 0.57 0.88
Table 2. Evaluation of the inter-annotator agreement
5 Conclusion
We have presented the annotation scheme and 
principles  for  the  extended  textual  coreference 
and the bridging anaphora in PDT 2.0.
Pre-annotation and features of the annotation 
tool that help the annotators have been described 
in detail. We have presented basic statistics about 
the  annotation  completed  so  far  and  results  of 
first  measurements of the inter-annotator agree-
ment (which are difficult to compare to other ap-
proaches, as we do not use "markables"). 
Improvement of the inter-annotator agreement 
is  in  our  focus  for  the  upcoming  stage  of  the 
project. The experience shows that the agreement 
is greatly affected by parameters of the text as a 
whole. Short texts are generally far less demand-
ing for their interpretation than longer ones, texts 
with  many  abstract  and  general  notions  allow 
more  possibilities  of  interpretation  and  so  on. 
Frequent  problems  causing  inter-annotator  dis-
agreement  are  of  two  types  -  different  under-
standing  of  the  content  and  inaccuracy  of  the 
coding  scheme.  The  first  case  is  hardly  to  be 
solved entirely. The problems of the second type 
are  being  worked  on:  we  prepare  the  detailed 
classification of the inter-annotator disagreement 
and regularly specify the annotation guidelines.
Acknowledgment 
We gratefully  acknowledge  the support  of the 
Czech  Ministry  of  Education  (grant  MSM-
0021620838),  the  Czech  Grant  Agency  (grant 
405/09/0729), the European Union (project Com-
panions  ?  FP6-IST-5-034434),  and  the  Grant 
Agency  of  the  Academy  of  Sciences  of  the 
Czech Republic (project 1ET101120503).
References 
Clark, H. 1977. Bridging. In Johnson-Laird and Wa-
son, editors,  Thinking: Readings in Cognitive Sci-
ence. Cambridge. 411-420.
Cohen, J. 1960. A coefficient of agreement for nomi-
nal  scales.  Educational  and  Psychological  Mea-
surement, 20(1), 37-46.
Haji?,  J.  et  al.  2006.  Prague  Dependency  Treebank 
2.0.CD-ROM,  Linguistic  Data  Consortium,  LDC 
Catalog No.: LDC2006T01, Philadelphia.
Hirschman, L. 1997. MUC-7 coreference task defini-
tion. Version 3.0.
Krasavina, O. and  Ch. Chiarcos. 2007. PoCoS ? Pots-
dam  Coreference  Scheme.  Proc.  of  ACL  2007, 
Prague, Czech Republic
Ku?ov? L. and E. Haji?ov?. 2004. Coreferential Rela-
tions in the Prague Dependency Treebank. In 5th 
Discourse Anaphora and Anaphor Resolution Col-
loquium. Edi??es Colibri.
Pajas, P. and J. ?t?p?nek 2008. Recent advances in a 
feature-rich framework for treebank annotation. In 
The 22nd Interntional Conference on Computatio-
nal  Linguistics  ?  Proceedings  of  the  Conference. 
Manchester, pp. 673-680.
Passonneau, R. 2004. Computing Reliability for Core-
ference. In Proceedings of LREC, vol. 4, Lisbon, 
pp. 1503-1506.
Poesio, M. 2004 The MATE/GNOME Proposals for 
Anaphoric  Annotation,  Revisited.  Proc.  of  SIG-
DIAL.
Figure 1. Types of  relations
111
