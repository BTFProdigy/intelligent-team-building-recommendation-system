DOGHED: A Template-Based Generator for Multimodal Dialog Systems
Targeting Heterogeneous Devices?
Songsak Channarukul and Susan W. McRoy and Syed S. Ali
Natural Language and Knowledge Representation Research Group
Department of Electrical Engineering and Computer Science
University of Wisconsin-Milwaukee
{songsak,mcroy,syali}@uwm.edu
1 Introduction
This paper describes DOGHED (Dialog Output Gener-
ator for HEterogeneous Devices), a multimodal genera-
tion component which is a part of a dialog system that
supports adaptation of multimodal content based on user
preferences and their current device. Existing dialog sys-
tems focus on generating output for a single device that
might not be suitable when users access the system us-
ing different devices. Multimedia presentation systems
can be built that support several device types. However,
most content presentation and layout is done off-line and
defined at the document level.
Dialog facilitates the process of tailoring the interac-
tion to the dynamically changing needs of the user. With
support for dialog, a computer can regulate the pace at
which users receive content, help focus the user?s atten-
tion, and interleave actions that will help the system mon-
itor (and adjust) to the user?s understanding or satisfac-
tion. Minimally, dialog systems should adapt the interac-
tion to the user?s ability to understand. However, dialog
systems should also be able to adapt to the user?s comput-
ing environment, because people access computers not
only through traditional workstations and terminals, but
also through personal digital assistants and cellular tele-
phones. Each of these devices has a distinct set of phys-
ical capabilities, as well as a distinct set of functions for
which it is typically used.
2 DOGHED
DOGHED is a template-based multimodal output gen-
erator for dialog systems that need to support hetero-
geneous devices. It enables dialog systems to create
multimodal presentations for different devices in real-
time. DOGHED extends YAG (Yet Another Generator),
?We acknowledge the financial support of the National
Science Foundation (under grants IRI-9701617 and DUE-
9952703), Wright State University, and Intel Corporation.
a template-based text realization system (Channarukul et
al., 2000; Channarukul et al, 2001; McRoy et al, 2003)
by providing a pre-defined set of multimodal templates.
It employs JYAG (Channarukul et al, 2002), the Java im-
plementation of YAG, to realize those templates for fur-
ther display by appropriate browsers. It provides output
in the Synchronized Multimedia Integration Language
(SMIL) which can be presented on any SMIL player such
as RealOne Player and X-SMILES (Pihkala et al, 2001);
or any capable web browser.
DOGHED is a generic and domain-independent com-
ponent for generating multimodal presentations in that it
accepts a feature structure as input. These feature struc-
tures can also embed other feature structures to represent
a more complicated input specification. Moreover, an ap-
plication can specify content, user preferences, and de-
vice constraints (e.g., multimedia capabilities, screen size
and resolution, and network bandwidth) using this uni-
form formalism. Natural language can also be inserted
by embedding a feature structure that calls for realization
using one or more YAG?s English syntactic templates.
3 Multimodal Templates
There are two types of multimodal templates. The first
type is for generating individual SMIL tags and struc-
tures. The other type is more abstract and captures the
semantics of multimodal presentation. A semantic tem-
plate can be authored so that an application only needs to
specify its selected content, intended presentation style,
and other constraints. Output will then be generated to
best suit the given style and constraints. For example, an
application might want to compare two diagrams or items
that are related. On large display devices, both items can
be displayed side-by-side. However, on smaller display
devices, like PDAs, such presentation is not possible; it
would be better to display one item at a time and switch
between the two items being compared.
                                                               Edmonton, May-June 2003
                                                              Demonstrations , pp. 5-6
                                                         Proceedings of HLT-NAACL 2003
Figure 1: A Screenshot of IDEY with an Integrated SMIL Player.
4 Template Authoring Tool
In addition to the pre-defined multimodal template set,
application developers can write their own templates to
suit their needs. These new templates can be written from
scratch or built on top of existing ones. We facilitate
the task of template authoring by providing a graphical
development environment. IDEY (Integrated Develop-
ment Environment for YAG) provides support for author-
ing, testing, and managing templates (Channarukul et al,
2002). Its graphical interface reduces the amount of time
needed for syntax familiarization through direct manip-
ulation and template visualization. It also allows a de-
veloper to test newly constructed templates easily. Mul-
timodal output can be immediately displayed and veri-
fied on an integrated SMIL player (Figure 1). Moreover,
the interface also helps prevent errors by constraining the
way in which templates may be constructed or modified.
For example, values of slots in templates are constrained
by context-sensitive pop-up menu choices.
References
Songsak Channarukul, Susan W. McRoy, and Syed S.
Ali. 2000. Enriching Partially-Specified Representa-
tions for Text Realization using An Attribute Grammar.
In Proceedings of The First International Natural Lan-
guage Generation Conference, pages 163?170, Israel,
June.
Songsak Channarukul, Susan McRoy, and Syed Ali.
2001. YAG: A Template-Based Text Realization Sys-
tem for Dialog. Journal of Uncertainty, Fuzziness, and
Knowledge-Based Systems, 9(6):649?659.
Songsak Channarukul, Susan W. McRoy, and Syed S.
Ali. 2002. JYAG and IDEY: a Template-Based Nat-
ural Language Generator and Its Authoring Tool. In
Companion Volume to the Proceedings of the 40th
Meeting of the Association for Computational Linguis-
tics (ACL), pages 89?90, July.
Susan W. McRoy, Songsak Channarukul, and Syed S.
Ali. 2003. An Augmented Template-Based Approach
to Text Realization. Natural Language Engineering,
9(2):1?40.
Kari Pihkala, Niklas von Knorring, and Petri Vuorimaa.
2001. SMIL for X-SMILES. In Proceedings of the
Seventh International Conference on Distributed Mul-
timedia Systems, Tamkang University, Taipei, Taiwan,
September.
Enriching Partial ly-Specif ied Representations for Text Real izat ion 
Using an Attr ibute Grammar * 
Songsak Channarukul Susan W. McRoy Syed S. Ali 
{ songsak, mcroy, syali} @cs.uwm. edu 
Naturat.,L~,ng~uage,and:J4rmwledge:,Rep~esentation.Research Group. ?  
http ://tigger. ca. uwm. edu/ ~lkrrg 
Elect r ica l  Eng ineer ing  and Computer  Science Depar tment  
Un ivers i ty  of Wiscons in -M i lwaukee  
Abst rac t  
We present a new approach to enriching under- 
specified representations of content to be realized 
as text. Our approach uses an attribute gram- 
mar to propagate missing information where needed 
in a tree that represents the text to be realized. 
This declaratively-specified grammar mediates be- 
tween application-produced output and the input to 
a generation system and, as a consequence, can eas- 
ily augment an existing generation system. End- 
applications that use this approach can produce high 
quality text without a fine-grained specification of 
the text to be realized, thereby reducing the bur- 
den to the application. Additionally, representations 
used by the generator are compact, because values 
that can be constructed from the constraints en- 
coded by the grammar will be propagated where nec- 
essary. This approach is more flexible than default- 
ing or making a statistically good choice because it 
can deal with long-distance dependencies ( uch as 
gaps and reflexive pronouns). Our approach differs 
from other approaches that use attribute grammars 
in that we use the grammar to enrich the represen- 
tations of the content to be realized, rather than 
to generate the text itself. We illustrate the ap- 
proach with examples from our template-based text- 
realizer, YAG. 
1 In t roduct ion  
Typically, a text realization system requires a great 
deal of syntactic information from an application 
in order to generate a high quality text; however, 
an application might not have this information (un- 
less it has been built with text generation in mind). 
This problem has been referred to as the Genera- 
tion Gap (Meteer, 1990). Meteer first identified the 
generation gap problem as arising at the text plan- 
ning stage. A text planner must decide what content 
needs to be expressed and creates a corresponding 
text plan for generating it. A sentence planner is 
then used to select an appropriate syntactic struc- 
?Th is  work was supported by a gift from Intel Corporation; 
and by the National Science Foundation, under grants IRI- 
9701617 and IRI-9523666. 
ture for a given plan. Typically, neither a text plan- 
ner nor a sentence planner is concerned with fine- 
grained syntactic issues, such as whether the subject 
of the sentence is a singular or plural noun. Thus, 
it becomes the responsibility of a text realizer to in- 
fer the missing information and to generate the best 
possible text from a given input. 
Most generation systems (such as FUF/SURGE 
(Elhadad, 1992), Penman (Mann, 1983), Real- 
Pro (Lavoie and Rainbow, 1997), TG/2 (Busemann, 
1996), and YAG (Channarukul, 1999; McRoy et al, 
1999)) alleviate this problem by using defaulting, 
in which a grammar writer specifies a default for 
each syntactic onstraint. This approach is inflexi- 
ble and prone to errors, because there might not be 
one default that suits all applications or situations. 
Another approach that has been proposed is to fill 
in the missing information on the basis of word co- 
occurrence data collected from a large corpus of text 
(see Nitrogen (Knight and Hatzivassiloglou, 1995)). 
However, statistical approaches have difficulty when 
there are long-distance dependencies among con- 
stituents in a text. 
In this paper, we present a new approach to re- 
solving the so-called generation gap that uses an At- 
tribute Grammar (Knuth, 1968) to enrich partially- 
specified inputs to a realization system to pro- 
duce high quality texts. Attribute Grammars are a 
declarative formalism for defining rules for attribute 
propagation (see Section 3). They have been used 
primarily for specifying the .semantics of program- 
ruing languages, although a few researchers have also 
used them to drive a text generator (see (Levison 
and Lessard, 1990), for exaanple). The main advan- 
tage of our approach is that it allows a generator 
to enjoy the computational efficiency of a template- 
based realization system, while reducing the linguis- 
tic burden on an application and increasing the qual- 
ity of the generated texts. 
Our work differs from previous uses of attribute 
grammars in natural language generation, which 
are similar to Levison and Lessard (Levison and 
Lessard, 1990)in that they apply attribute gram- 
mars directly to text realization. For example, Lev- 
163 
L 
((template CLAUSE) 
(process-type MENTAL) 
(process "want") 
(processor ((template NOUN-PNRASE) 
(head ((template CONJUNCTION) 
(first ((template NOUN-PHRASE) 
(head "Jack") 
(np-type PROPER) 
,~(gender .MASCULINE) : 
(definite NOART))) 
(second ((template PRONOUN)) ))) 
(person SECOND) 
(number PLURAL)) ) 
(phenomenon ((template NOUN-PHRASE) 
(head "dog") 
(definite NOART) 
(possessor ((template NOUN-PHRASE) 
(head "sister") 
(gender FEMININE) 
(definite NOART) 
(possessor ((template NOUN-PHRASE) 
(rear-circum ((template CLAUSE) 
(mood T0-INFINITIVE) 
(process-type MATERIAL) 
(process "swim")) ) ) 
Figure 1: A Feature Structure for 
(head "Jack") 
(np-type PROPER) 
(gender MASCULINE) 
(pronominal YES) 
(definite NOART)) ))))) 
the Sentence "Jack and I want his sister's dog to swim." 
ison and Lessard extend a context-free grammar 
with attributes and semantic rules similar to classi- 
cal attribute grammars presented by Knuth (Knuth, 
1968). Attributes in their system assist the realiza- 
tion by propagating information down a tree that 
specifies the complete syntactic structure of the out- 
put text. By contrast, our work employs attribute 
grammars, not to realize a text, but to perform a 
generation gap analysis prior to actual realization. 
We use both inherited and synthesized attributes 
(i.e., propagating information both down and up a 
tree) to share information and to determine appro- 
priate values for any missing features. 
2 An  Overv iew o f  YAG 
YAG (Yet Another Generator) (Channarukul, 1999; 
McRoy et al, 1999) is a template-based text- 
realization system that generates text in real-time. 
YAG uses templates to express text. structures corre- 
sponding to fragments of the target language. Tem- 
plates in YAG are declarative and modular. Coln- 
plex texts can be generated 173" embedding templates 
inside other tenlplates. 
Values for the tenlplates are provided by an appli- 
cation; inputs can include either,a conceptual repre- 
sentation of content or a feature structure. When an 
input is only partially specified, defaults defined in a 
template will be applied. Figure I shows an example 
of YAG's feature-structure based input; YAG would 
realize this example as "Jack and I want his sister's 
dog to swim. ". This input is partially specified, and 
thus is more compact and easier for an application 
to specify, than a complete specification. Figure 2 
shows the features that have been omitted and the 
defaults used t75 YAG to realize the sentence from 
tile input. 
Although the input is already more compact han 
a full specification, further simplification of the in- 
put provided from an application would have been 
possible, if certain inferences could be made. For ex- 
ample, Figure 3 shows an input structure that could 
replace the one given in Figure 1. In Figure 3, it was 
not necessary for the application to specify that the 
conjunction of two noun phrases is a phlral noun 
phrase, nor that component noun phrases (proper 
nouns, pronouns, and possessives) hould not, con- 
tain an article. In the case of conjunctions, there is 
no default that would provide the correct outputs in 
all cases, because the same conjunction template is 
used to conjoin adjectives and clauses. Instead, our 
approach uses an attribute grammar to make the 
appropriate inferences and enrich the feature struc- 
164 
Template Name \] Template Slot Default Allowed VMues 
CLAUSE sentence 
NOUN-PHRASE 
mood 
process-type 
?mode 
tense 
future 
progressive 
perfective 
voice 
quality 
np-type 
person 
number 
gender 
definite 
regular-noun 
countable 
inflected 
pronominal 
YES 
DECLARATIVE 
type 
ASCRIPTIVE 
.nil 
"PRESENT 
NO 
NO 
NO 
ACTIVE 
POSITIVE 
COMMON 
THIRD 
SINGULAR 
NEUTRAL 
NO 
YES 
YES 
YES 
NO 
YES, NO 
DECLARATIVE, YES-N0, WH, IMPERATIVE, 
T0-INFINITIVE 
ASCRIPTIVE, MENTAL, MATERIAL, 
COMPOSITE, POSSESSIVE, LOCATIVE, 
TEMPORAL, VERBAL, EXISTENTIAL 
ATTRIBUTI~E,,EQUATIVE,.CAUSATIVE 
PRESENT, PAST 
YES, NO 
YES, N0 
YES, N0 
ACTIVE, PASSIVE 
POSITIVE, NEGATIVE 
COMMON, PROPER 
FIRST, SECOND, THIRD 
SINGULAR, PLURAL 
NEUTRAL, MASCULINE, FEMININE 
YES, N0, NOART 
YES, NO 
YES, NO 
YES, NO 
YES, NO 
POSSESSOR pronominal YES YES, NO 
PRONOUN PERSONAL 
FIRST 
SINGULAR 
NEUTRAL 
person 
number 
gender 
PERSONAL, OBJECTIVE, REFLEXIVE, 
POSSESSIVE-PRONOUN, 
POSSESSIVE-DETERMINER, 
RELATIVE, DEMONSTRATIVE 
FIRST, SECOND, THIRD 
SINGULAR, PLURAL 
NEUTRAL, MASCULINE, FEMININE 
CONJUNCTION sentence NO YES, NO 
Figure 2: Some Defaults from YAG's Syntactic Templates. 
((template CLAUSE) 
(process-type MENTAL) 
(process "want") 
(processor ((template CONJUNCTION) 
(first ((template NOUN-PHRASE) 
(head "Jack") 
(np-type PROPER) 
(gender MASCULINE) )) 
(second ((template PRONOUN)) ))) 
(phenomenon ((template NOUN-PHRASE) 
(head "dog") 
(possessor ((template NOUN-PHRASE) 
(head "sister") 
(gender FEMININE) 
? ~(possessor<(template NOUN-PHRASE) 
(head "Jack") 
(np-type PROPER) 
(gender MASCULINE) 
(pronominal YES)) ))))) 
(rear-circum ((template CLAUSE) 
(mood T0-INFINITIVE) 
(process-type MATERIAL) 
(process "swim")) ) ) 
Figure 3: A (shorter) Feature Struclur() of the Sentence "Jack and I want his ._zste7 s dog to swim.". 
165 
ture input  so that neither the appl ication, nor the 
templates  need to be altered to handle dependencies, 
like conjunctions, correctly. 
3 At t r ibute  Grammars  
An at t r ibute  grammar  consists of a context-free 
grammar ,  a finite set of at t r ibutes,  and a set of se- 
mant ic  rules. The ,.C-,on.~eezt-Free :Grammar (CFG) 
specifies the syntax of a language by expressing how 
to construct  a syntax tree from non-terminal  and ter- 
minal  symbols  defined in a language. The Attributes 
and Semantic Rules specify the semantics. A finite 
set of at t r ibutes  is associated with each non-terminal  
symbol.  Each of these sets is divided into two dis- 
jo int  subsets, namely Inherited Attributes and Syn- 
thesized Attributes. Inher i ted att r ibutes propagate 
down a syntax tree whereas synthesized at t r ibutes  
propagate  upward. A semant ic  rule specifies how to 
compute the value of an a t t r ibute  from others. This 
specif ication implicitly defines dependencies among 
at t r ibutes  in an at t r ibute grammar ,  locally (within a 
product ion)  and globally (among product ions) .  At- 
tribute Evaluation is the process of comput ing values 
for every attr ibute instance in the tree according to 
the semant ic  rules defined for each product ion.  
An example of an a t t r ibute  grammar  and its com- 
ponents is given in F igure 4 (adapted from (Alblas, 
1991)). This  attr ibute grammar  consists of two non- 
terminals,  two terminals, andthree  product ion rules. 
The inherited attr ibutes of the non-terminal  A are a 
and b. Its synthesized at t r ibutes  are x and y. No 
at t r ibutes  are assigned to the non-terminal  S. 
nonterminals: S, A. 
terminals: s, t. 
start symbol: S. 
description of attributes: 
a, b: integer, inh of A; 
x, y: integer, syn of A; 
productions and semantic rules: 
1) S -> A. 
A.a := A.x 
2) AO -> AI s. 
Al.a := AO.a; Al.b := Al.y; 
AO.x := Al.x; AO.y := l 
3) A -> t .  
A.y := A.a; A.x := A.b 
Figure 4: An Example Att r ibute Grammar .  
As mentioned earlier, semantic rules define depen- 
dencies among attr ibutes? Figure 5 shows depen- 
dency graphs corresponding to the semantic rules of 
Figure 4. In the graphs, a dotted line represents a 
der ivat ion of a production rule, 'while an arrow de i- 
notes an att r ibute dependency. Thus. .4 ~ B means 
S abAxy  abAxy  
(% I 
abAxy  abAxy  s t 
(1) (2) (3) 
? . . F igure5:  Dependency Graphs.  
B is dependent  on A, but not the other way around. 
In other words, we cannot know B before we know 
A. 
4 Extend ing  a Grammar  to  Enab le  
Generat ion  Gap Ana lys i s  
To make a generation gap analysis possible, a gram- 
mar wr i ter  must first extend the grammar  of his 
or her exist ing generator to capture the propaga- 
tion semant ics of a target language. This extension 
involves defining attr ibutes (synthesized and inher- 
ited) and associated semantic rules. Next, a small 
program must  be built to construct  a tree from 
a given input  and retrieve semantic rules and at- 
t r ibutes from associated grammar  units. 
A t t r ibute  evaluation begins by instant iat ing each 
inherited at t r ibute  with values from the input and 
then the remaining at t r ibutes  are evaluated. This 
process is incremental in the sense that  new infor- 
mat ion gained from previous evaluat ions might lead 
to the discovery of addit ional  information. When 
all a t t r ibutes  remain unchanged, or there is a con- 
flict detected in the input, the process terminates. 
The generator  then passes the enriched input to the 
real izat ion component. 
Consider the following f ragment of input from 
Figure 3 that  uses the CONJUNCTION template to 
join a noun phrase and a pronoun.  
( ( template  CONJUNCTION) 
( : f i r s t  ( ( template  NOUN-PHRASE) 
(head " Jack" )  
(np- type  PROPER) 
(gender  MASCULINE) )) 
( second ( ( template  PRONOUN))  )) 
This f ragment is the subject  of the sentence, there- 
fore features uch as person  and number  would be 
required to enforce tile subject-verb agreement of En- 
glish. F igure 6 shows a dependency graph ~ for this 
i The notatio, used in the dependency graph is the fol- 
lowing: 
The oval represents a template slot that is bound to an atomic 
value. The rectangle denotes a slot that is bound to another 
feature structure. The top text in a rectangle specifies a slot 
name, and the bottom text is the name of a template ~kssigned 
to this slot,. A value with an underline'means a default of the 
above slot. The bold fdnt represents a value yielded from 
attribute valuations. 
166 
J CONJUNCTION 
sentence , ' ' '= : : - . .  oetson number gender definite sentence error 
first secood  , 1I 1/  / - ._o. \ 
definite , ' , T , ' ,  person umber gender definite sentence 
PROPER "Jack" THIRD SINGULAR MASCULINE NOART 
@ @ @ @  
PERSONAL FIRST SINGULAR NEUTRAL 
Figure 6: A Dependency Graph of the CONJUNCTION Template corresponding to the text "Jack and I". 
fragment. The dependencies are based on the se- 
mantic rules given in F igure 7 (Section 6 describes 
syntax of these rules.). 
The semantic rules in F igure 7 give constraint  
information for the CONJUNCTION template,  the 
NOUN-PHRASE template,  and the PRONOUN template.  
For the CONJUNCTION template ,  the grammar  will: 
e Use the sentence  feature of the current tem- 
plate (which is NO by default). 
o Pass up the person  feature found by compar-  
ing the person  features associated with tile two 
conjuncts (i.e., pass up second person whenever 
the conjuncts combine either first person and 
second or third person, or they combine second 
person and third person; pass up third person if 
both conjuncts use th ird person; otherwise pass 
tip nil); 
? Constrain the number  feature to be PLURAL, 
the gender  feature to be NEUTRAL, the de f in i te  
feature to be NOART, and the sentence  feature 
to the same as the sentence feature of the con- 
junets. 
For tile NOUN-PHRASE teinplate,  the grammar  will 
Require this template  to enforce the inherited 
values of the de f in i te ,  number ,  and np- type  
features. 
Require the (embedded) DETERMINER template 
enforce the number  feature of the current tem- 
plate. 
Pass up four features (def in i te ,  number ,  per -  
son,  and np- type)  to any templates that  use 
this noun phrase, where the fotlcrwJng con- 
straints apply: 
The  definiteness feature that  is passed is 
YES whenever the current template has in- 
herited YES for this value or there is a pos- 
sessor or a determiner and one of them 
passes up YES for this feature. (If there is 
neither possessor nor determiner then the 
grammar considers the np- type:  if it is 
COMMON, it uses NO (for indefinite) and if it 
is PROPER, it uses NOART 
The  number  feature  passed is the value 
passed from the determiner, if there is one, 
or the value from the current template.  
The  person  feature  passed is the one from 
the current template. 
The  r ip - type  feature  passed is COMMON if the 
value of definite is NO and PROPER if the 
value is NOART. 
For tile PRONOUN template, the grammar  will: 
o Pass tip the person ,  number ,  and gender  val- 
ues fl'om the current template (possibly using 
default  values), along with the constraint hat  
ttle string realized for it not be a sentence and 
not be preceded by an article. 
In - the example shown in Figure 6, inherited at- 
tr ibutes 2 have been initialized to the associated val- 
ues given in an input. If the input does not specify a 
value for an inherited attr ibute,  then the value n i l  
is used. 
The attr ibute evaluation is depth-first, and re- 
quires nmltiple traversals. Here, the NOUN-PHRASE 
sub-tree is evaluated twice, as we discover that  the 
de f in i te  feature must be NOART. Since tile PRONOUN 
2 Inherited attributes are placed on the left side of each 
node. Synthesized attributes are on the right. 
167 
Template Name Semantic Rules 
CONJUNCTION 
NOUN-PHRASE 
PRONOUN 
((this sentence) (this inh sentence)) 
((this syn person) (CASE (UNION (first syn person) 
(second syn person)) OF 
((first nil) 
(second nil) 
((first second) second). 
((first third) second) 
((second third) second) 
(third third)) )) 
((this syn number) PLURAL) 
((this syn gender) NEUTRAL) 
((this syn definite) NOART) 
((this syn sentence) (UNION (first syn sentence) (second syn sentence))) 
((this definite) (this inh definite)) 
((this number) (this inh number)) 
((this np-type) (this inh np-type)) 
((determiner inh number) (this inh number)) 
((this syn definite) (IF (AND (NULL (this possessor)) 
(NULL (this determiner))) THEN 
(UNION (this definite) 
(CASE (this np-type) OF 
((common NO) 
(proper NOART))) ) 
ELSE 
(UNION (this definite) 
(possessor syn definite) 
(determiner syn definite)) )) 
((this syn number) (UNION (determiner syn number) (this number)) ) 
((this syn person) (this person)) 
((this syn np-type) (CASE (this definite) OF 
( (NO COMMON) 
(NOART PROPER)) )) 
((this syn person) (this person)) 
((this syn number) (this number)) 
((this syn gender) (this gender)) 
((this syn sentence) NO) 
((this syn definite) NOART) 
Figure 7: Semantic  Rules of the CONJUNCTION, NOUN-PHRASE, and PRONOUN template.  
template has no inherited attr ibutes,  a single evalua- 
tion would be sufficient. The CONJUNCTION sub-tree 
is also traversed twice because the sentence  feature 
is re-assigned once (from n i l  to NO). 
Figure 8 shows the tree and dependencies, for the 
fragment, "his sister's dog". It shows how the deft- 
niteness of a noun phrase is dependent on the ex- 
istence of a possessor. For example, if a posses- 
sor (such as "his" or "Jack's") is specified, a noun 
phrase will not need an article. 
Note that this feature structure can be generated 
differently as "'Jack's sister's dog". "her dog". "the 
dog o~ Jack's sister". "'the do q o/ h.is sister", and 
"the dog o/ hens". \Vhile some of these variations 
require further investigation to determine how to 
transform a tree so that it reflects a new ordering 
of constituents,  some can be implemented using se- 
mantic rules. For example , - - to -avo id- /anawkward 
construct ion such as ",lack's sister's do q" in the sen- 
oo<  .... 
~ f--nml~nal 
PROPER 'Jack THIRD SINGULAR f',IASCU LIN E NIl%R1 YES 
Figure 8: A Dependency Graph of the NOUN-PHRASE 
-Template  corresponding to  the text, "his sister's 
dog ". 
168 
tence "Jack and I want Jack's sister's dog to swim. ", 
in favor of "his sister's dog", without he application 
having to request a pronoun explicitly, as in the ex- 
ample shown above, we could add a rule to force 
the pronomina l  feature of the inner most posses- 
sor to be YES, whenever a (repeated) noun phrase is 
a possessor of a possessor of the primary noun. 
5 The Use of the  Gehei-ation Gap ........... 
Analysis to Resolve Conflicting 
In fo rmat ion  
One side benefit of the use of attribute grammars 
is that they can help resolve inconsistencies in the 
input provided from an application. Previously, a 
generation system might not be able to recognize 
such conflicts, and therefore might generate a text 
that is ungrammatical, or it might simply fail to 
produce an output at all. 
The following is an example input that has a 
conflict; the values of the number  feature in the 
NOUN-PHRASE and PRONOUN templates are inconsis- 
tent. 
( (template NOUN-PHRASE) 
(head "book" ) 
(number PLURAL) 
(determiner ((template PRONOUN) 
(type DEMONSTRATIVE) 
(distance NEAR) 
(number SINGULAR)) ) 
) 
Executed literally, a generator would produce 
the phrase "this books", rather than "this book" or 
"these books". Figure 9 shows a dependency graph 
corresponding to the above input. 
/-2> 
number number error 
number ~ number error 
DEMONSTRATIVE NEAR SINGULAR 
Figure 9: A Dependency Graph corresponding to 
the text "this book" or "these books". 
With the use of an appropriate attribute gram- 
mar, an analysis of this structure would detect a con- 
flict when the vahm SINGULAR o f the -number  fea- 
ture propagates upward and conflicts with the value 
PLURAL of the number  feature of the NOUN-PIIRASE 
template. In this case, a generator can choose to 
override one of the conflicting features and generate 
a text from the revised input. 
6 Imp lementat ion  
,~Gy.ammars,.in_~a.:tem.plate-hased. syst m differ suf- 
ficiently from phrase-based systems so that tradi- 
tional attribute grammars pecifications cannot be 
used without changes. In particular, grammars in 
a template-based system are not restricted to syn- 
tactic text structure as they are in phrase-based 
systems, but mw include either syntactic specifica- 
tions, semantic specifications, or a mixture of both. 
Therefore template-based grammars do not restrict 
derivations on the right side of a production to some 
specific non-terminals, as they would be in a phrase- 
based grammar. 
In our approach, a template is equivalent to the 
non-terminal on the left side of a production. Tem- 
plate slots are equivalent o terminals and non- 
terminals on the right side depending on their value 
at the time of generation. Slots that are bound to 
a simple value are considered terminals, while those 
that are bound to a feature structure are considered 
non-terminals. The evaluation function of terminals 
is actually a constant function whose return value is 
the value to which the terminal has been bound. 
We have defined a small language sufficient to 
specify attribute grammars in a template as given 
in Figure 10. Additional keywords are also defined. 
The keyword th i s  refers to the current template. 
The keywords inh and syn indicate an inherited at- 
tribute and a synthesized attribute, respectively. 
We have implemented an attribute grammar- 
based propagation analysis program in Lisp as 
an extension to YAG. Some templates have been 
augmented with semantic propagation rules. It 
was not necessary to define attributes for YAG's 
template-based grammar because template slots al- 
ready served as attributes. The program has been 
able to identify missing information (using the de- 
fined semantic propagation rules) and to reject in- 
puts that have a conflict. 
Other generation systems that intend to use an at- 
tribute grammar approach to enrich their partially- 
specified input will need to analyze the character- 
istics of their grammar formalism. Basically, one 
needs to identify the smallest unit of a grammar 
(e.g., a category (cat) in FUF/SURGE), and then 
define semantic rules similar to those presented in 
this paper for each grammar unit. From a given 
input, a generator should be able to pick semantic 
rules associated with information provided in an ill- 
put. .~n attribute valuation is then executed as 
described. 
169 
AttributeGrammar ::- EvalRules 
EvalRules ::- "(" EvalRule EvalRules ")" I nil 
EvalRule ::- "(" Attr ibute Stmt ")" 
Stmt ::- Expr \[ CaseStmt \[ IfStmt 
Expr ::- At t r ibute  \[ constant \[ 
"( .... UNION" Stmt Stmt ")" I 
,,(. ,,TNTEKSECTirSN,,.~Simrt.Stmt ,,). 
Attribute ::- inherited \[ synthesized 
CaseStmt ::- "( .... CASE" Expr "OF" Alters ")" 
Alters ::- "(" Alter Alters ")" I nil 
Alter ::- "(" value result ")" 
result ::- Expr 
I fS tmt  : : -  "(  . . . .  IF"  Cond "THEN" Strut " ) "  \[ 
" (  . . . .  I F "  Cond "THEN" Strut 
"ELSE" Strut " ) "  
Cond : : -  "(  . . . .  NULL" Expr  " ) "  I 
" (  . . . .  ECIUAL" Expr  Expr " ) "  I 
"(" "NOT" Cond ")" \[ 
"(" "AND" Cond Cond ")" l 
" ( "  "OR" Cond Cond " ) "  
Figure 10: The Syntax of YAG's Attribute Gram- 
mars Specification. 
7 Conc lus ion  
We have presented a new approach to enriching 
under-specified representations of content to be 
realized as text using attribute grammars with 
semantic propagation rules. Our approach is not 
intended to replace defaulting mechanisms used in 
the current generation systems. Instead it improves 
the quality of input to the generator for better 
realization. Defaults are still used if the analysis 
fails to discover useful information. 
Acknowledgement  
The authors are indebted to John T. Boyland for 
his helpful comments and suggestions. 
Re ferences  
Henk Alblas. 1991. hltroduction to attribute gram- 
mars. In Henk Alblas and Bo~ivoj Melichar, edi- 
tors, Attribute Grammars, Applications and Sys- 
tems, vohune 545 of Lecture Notes in Computer 
Science, pages 1 15. Springer-Verlag, New York-- 
Heidelberg-Berlin. June. Prague. 
Stephan Busemalm. 1996. Best-first surface realiza- 
tion. In Donia Scott. editor. Proceedings of the 
Eighth International Workshop o?~ Natural Lan- 
guage Gencration. pages 101-110. 
Songsak Channavnkul. i999. YAG: A Natural Lan- 
guage Generator for Real-Time Systems. Mas- 
ter's thesis, University of Wisconsin-Milwaukee, 
December. 
Michael Elhadad. 1992. Using argumentation to 
control lexical choice: A functional unification- 
based approach. Ph.D. thesis, Computer Science 
Department, Columbia University. 
Keven Knight and Vasileios Hatzivassiloglou. 1995. 
T.wo~level, many-paths generation..In:Proceedings.. 
? of ACL. 
Donald E. Knuth. 1968. Semantics of context- 
free languages. Mathematical Systems Theory, 
2(2):127-145, June. Correction: Mathematical 
Systems Theory 5, 1, pp. 95-96 (March 1971). 
Benoit Lavoie and Owen Rambow. 1997. A fast 
and portable realizer for text generation systems. 
In Proceedings o/ the Fifth Conference on Ap- 
plied Natural Language Processing, pages 265-268, 
Washington. 
Michael Levison and Gregory Lessard. 1990. Ap- 
plication of attribute grammars to natural lan- 
guage sentence generation. In Pierre Deransart 
and Martin Jourdan, editors, Attribute Gram- 
mars and their Applications (WAGA), volume 
461 of Lecture Notes in Computer Science, pages 
298-312. Springer-Verlag, New York-Heidelberg- 
Berlin, September. Paris. 
William C. Mann. 1983. An overview of the 
Penman text generation system. In Proceedings 
of the Third National Conference on Artificial 
Intelligence (AAA\[-83), pages 261-265, Wash- 
ington, DC, August 22-26,. Also appears as 
USC/Information Sciences Institute Tech Report 
RR-83-114. 
Susan W. McRoy, Songsak Channarukul, and 
Syed S. Ali. 1999. A Natural Language Gener- 
ation Component for Dialog Systems. In Working 
Notes of the AAAI  Workshop on Mixed-Initiative 
Intelligence, at the 1999 Meeting of the American 
Association for Artificial Intelligence, Orlando, 
FL. 
Marie W. Meteer. 1990. The "Generation Gap" The 
Problem of Exprcssibility in Text Planning. Ph.D. 
thesis, University of Massachusetts. 
170 
YAG : A Template-Based Generator for Real-T ime Systems* 
Susan W. McRoy Songsak Channarukul 
{ mcroy, songsak, syali} @cs. uwm. edu 
Syed S. All 
Natural Language and Knowledge Representation Research Group 
~.: ..... aht~pg/ . / t igger .cs ,  uwmaedu/7n lk r rg  
Electrical Engineering and Computer Science Department 
University of Wisconsin-Milwaukee 
1 Introduction 
YAG (Yet Another Generator) is a real-time, 
general-purpose, template-based generation system 
that will enable interactive applications to adapt 
natural language output to the interactive context 
without requiring developers to write all possible 
output strings ahead of time or to embed extensive 
knowledge of the grammar of the target language 
in the application. Currently, designers of interac- 
tive systems who might wish to include dynamically 
generated text face a number of barriers; for exam- 
ple designers must decide (1) How hard will it be 
to link the application to the generator? (2) Will 
the generator be fast enough? (3) How much lin- 
guistic information will the application eed to pro- 
vide in order to get reasonable quality output? (5) 
How much effort will be required to write a genera- 
tion grammar that covers all the potential outputs of 
the application? The design and implementation of
YAG is intended to address each of these concerns. 
In particular, YAG offers the following benefits to 
applications and application designers: 
Suppor t  for Underspec i f ied  Inputs  YAG sup- 
ports knowledge-based systems by accepting 
two types of inputs: applications can either 
provide a feature structure (a set of feature- 
value pairs) or provide a syntactically under- 
specified semantic structure that YAG will map 
onto a feature-based representation for realiza- 
tion. YAG also provides an opportunity for an 
application to add syntactic constraints, such 
as whether to express a proposition as a ques- 
tion rather than a statement, as a noun-phrase 
rather than as a sentence, or as a pronoun rather 
than a full noun phrase. 
Speed YAG has been designed to work in real- 
time. The YAG ten,plate processing engine 
does not use search to realize text. thus the 
speed of generation depends oi1 the complex- 
ity of the template that the application selects. 
?This  work ha~s been supported by the National Science 
Foundation, under grants, I RI-97016 l 7 and ,,I,RI=9523666, and 
by lntel Corporation. 
not on the size of the grammar. Short, sim- 
ple utterances are always realized faster than 
longer ones. (In many other approaches, peed 
is a function of the grammar size, because it 
is searched uring realization (Elhadad, 1992; 
Elhadad, 1993; Mann, 1983; McKeown, 1982; 
McKeown, 1985).) 
Robustness  In YAG, the realization of a template 
cannot fail. Even if there are inconsistencies in
its input (such as subject-verb disagreement), 
the generator will produce an understandable 
(if not grammatical) output. Applications that 
need to enforce grammaticality can use the 
YAG preprocessor to detect missing or conflict- 
ing features and to supply acceptable values. 
The preprocessor makes use of a declarative 
specification of slot constraints, based on an 
attribute grammar (Channarukul et al, 2000). 
This specification is modifiable and extensible 
by the application designer. 
Express iveness  YAG offers an expressive language 
for specifying a generation grammar. This lan- 
guage can express units as small as a word o1" 
as large as a document equally well. Unlike 
the typical template-based approach, the valu(~s 
used to instantiate slots are not limited to sim- 
ple strings, but can include a variety of struc- 
tures, including conditional expressions oi ref- 
erences to other templates. (This paper will 
include a more detailed discussion in the next 
section.) Any declarative grammar, such as one 
based oll feature structures, would be express- 
ible in YAG. 
Coverage  The coverage of YAG depends oil the 
number of templates that have been defined in 
its specification language. In theory, any sen- 
tence may be realized given an appropriate tem- 
plate. In practice, an application builder must 
be concerned with whether it is possible to re- 
use existing templates or whether it is necessary 
to create new ones. YAG simplifies the task 
of specifying a generation grammar in several 
ways :  
264 
e It provides an expressive, declarative lan- 
guage for specifying templates. This lan- 
guage supports template re-use by allowing 
template slots to be filled by other tem- 
plates. 
o It includes a general-purpose, template- 
based grammar for a core fragment of En- 
The  Cond i t ion  rule is similar to the cond state- 
ment in LISP, returning a result when one of its 
antecedent conditions is true. 
The  Inser t ion  rule returns the result of interleav- 
ing the results of two template rules. 
The  A l te rnat ion  rule selects one alternative 
glish. These templates ;include .default val- 
ues for many of the ?slots, so an application 
may omit a feature if it has no informa- 
tion about it. Currently, the YAG distribu- 
tion includes about 30 domain-independent 
syntactic templates, along with some se- 
mantic templates. 
o It offers a tool for helping people edit tem- 
plates and see what text would be realized 
from a template, given a set of values for 
its slots. 
YAG itself comes in two versions, one in CLISP, 
one in JAVA, both of which run on a wide variety of 
platforms, including Unix and Windows 95/98. 
In the remainder of this paper, we will describe 
YAG's template specification language, and some 
examples that illustrate the use of YAG from an 
application. More details can be found in (Chan- 
narukul, 1999). 
2 YAG's  Template  Spec i f i ca t ion  
Language 
A template is a pre-defined form with parameters 
that are specified by either the user or the applica- 
tion at run-time. In YAG, each template is com- 
posed of two main parts: template slots and tem- 
plate rules. Template slots are parameters or vari- 
ables that applications or users can fill with values. 
Template rules express how to realize a surface con- 
stituent. Templates are realized as strings by replac- 
ing slots in each rule with values from the application 
and then evaluating the rule. YAG template rules 
support nested and recursive templates. There are 
ten types of template rules. 
The  Str ing rule returns a pre-defined string as a 
result. 
The  Evaluat ion rule evaluates the value of a rein- 
plate slot? If the value of the slot is another 
feature structure, then that structure is evalu- 
ated recursively. If the value of the specified 
slot is not a feature structure, this rule returns 
the value without any further processing. 
The  Template  rule returns the result of instanti- 
ating a template with a given set of slot-vahle 
? pairs. 
The  I f  rule is similar to an (f-then statement in 
most prograanming_languages, r turning a re- 
sult when {he antecedent of the rule is true. 
template rule to be realized based on a uniform 
prob'ability-dis~ri-bution~-t hereby adding variety 
into a generated text. 
The  Punctuat ion  rule concatenates a punctua- 
tion mark to the specified end of adjacent 
strings. The position of a punctuation mark 
is either le f t ,  r ight ,  or both.  
The Concatenat ion  rule appends the the result 
of one template rule with the results of a second 
rule. 
The  Word  rule is used in association with pre- 
defined functions and a lexicon to realize expres- 
sions that should not be "hard-coded" in a tem- 
plate, such as the inflected forms of a word from 
the dictionary or the cardinal/ordinal number 
corresponding to an integer. 
Figure 1 shows the template rules that would 
be used to express propositions of the form 
has-property(agent, pname, pval), such as 
has-property(John, age, 20), which corre- 
sponds to John's age is 20). These rules are part of 
((COND (IF (equal pname nil) 
(EVAL agent) 
) 
(IF (not (equal pname nil)) 
((C0NCAT (EVAL agent) 
(S " 's" ) )  
(EVAL pname)) 
)) 
(TEMPLATE verb-form 
((verb "be") 
(person (agent person)) 
(number (agent number)) 
(gender (agent gender)) 
(tense present)) ) 
(COND (IF (not (equal property nil)) 
(EVAL property) 
) 
(IF (not (equal pval nil)) 
(EVAL pval) 
)) 
(PUNC " " left) 
) 
Figure 1: Examples of Template Rules 
265 
the 0BJECT-PROPERTY semantic template. The rules 
use the template slots agent,  pname,  pval,  and 
property and the template rule types IF, CONCAT, 
S, TEMPLATE, COND, EVAL, and  PUNC. If agent  = 
"John", pname = "age",  and pval  = "20", the 
surface text will be "John's age is 20." 
((EVAL member) 
(TEMPLATE verb-form 
((process "be") 
(person (member person)) 
(number (member number)) 
3 Examples  of  YAG in use 
YAG provides facilities for generation from two 
types of inputs, a feature structure or a knowledge 
representation. The latter is accomplished by the 
use of a knowledge representation specific compo- 
nent that must be defined for the particular knowl- 
edge representation language to be used. 
3.1 Generat ion  f rom a Knowledge  
Representation Structure 
Example 1, shows a knowledge representation i put 
to YAG. ~ It contains two propositions and a list of 
control features. In this representation, M2 is the 
proposition that the discourse ntity B2 is a member 
of class "dog". M5 is the proposition that the name 
of the discourse ntity B2 is "Pluto". Thus, we can 
read the whole proposition as "Pluto is a member of 
class dog." or simply "Pluto is a dog. ". The control 
features tate that the output should be generated 
as a declarative sentence with "be" as the main verb. 
Example  1 Pluto is a dog. 
(((M2 (CLASS "dog") 
(MEMBER B2) ) 
(M5 (OBJECT B2) 
(PROPERNAME "Pluto") ) ) 
((form decl) 
(attitude be) ) 
) 
\Vhen processing this input ,  YAG treats the first 
proposition as the primary proposition to be real- 
ized. YAG will map the MEMBER-CLASS proposition 
to the template shown in Figure 2. 
The control features, fo rm = decl  and a t t i tude  
= be, are also used in selecting the template. (If 
the form had been in ter rogat ive ,  a template for 
generating a yes-no question would have been used.) 
Example 2 shows an example where prominaliza- 
tion is specified as part of the control features. The 
primary proposition says that the agent (B4) is doing 
the action "take" on the object (B6). This proposi- 
tion. along with the selected control features ( form 
IThe knowledge representatimr language used in these ex- 
amples follows the definition of SNePS case frames described 
in (Shapiro et al, 1996). SNePS is a semantic network pro- 
cessing system (Shapiro and Rapaport, 1992). llowever, in- 
puts to YAG are parenthesized lists of symbols,, not SNePS 
data strllCl tires. 
(gender  (member  gender ) ) )  ) 
. . . . . . . . . . . . . .  (EVAL 'c lass )  
(PUNC .... left) ) 
Figure 2: A member-c lass  Template. 
= dec l  and a t t i tude  = act ion) ,  allows YAG to se- 
lect the c lause  template. 
Example  2 "He takes it." 
(((M2 (AGENT B4) 
(ACT (MI (ACTION "take") 
(DOBJECT B6) ) ) ) 
(MS (OBJECT B4) 
(PROPERNAME "George") ) 
(MIi (CLASS "book") 
(MEMBER B6) ) 
( (form decl) 
(attitude action) 
(pronominal YES (B6 B4)) 
(gender MASCULINE B4) ) ) 
) 
To override the gender  default (NEUTRAL) of B4 
and generate "He" instead of "It", Example 2 spec- 
ifies B4's gender  as MASCULINE. To override tile de- 
fault expression type (full noun phrase) for both B4 
and B6, Example 2 specifies (pronominal  YES (B6 
B4)) which forces pronominalization. 
3.2 Generat ion  f rom a Feature  S t ructure  
Example 3 shows a complete feature structure that 
would be used to realize the text "Blood pressure in- 
volves your heart and blood vessels.". Within a fea- 
ture structure, the name of the template that YAG 
should use is given by the template feature. Thus, in 
this example, YAG retrieves the c lause  template 2 
which is shown in Figure 3. 
In the clause template, the agent  slot is bound 
to "blood pressure" since its value is another fea- 
ture structure representing the noun-phrase ten> 
plate. The Eva luat ion  rule then realizes it as "blood 
pressure". The Template  rule realizes the verb "in- 
volves", by evaluating the verb - fo rm template with 
the process  value taken from the c lause  template. 
The other slots (which woukt normally be taken from 
2This template has:been simplified to fadilitate explana- 
tion. 
266 
Example 3 "Blood pressure involves your heart and 
blood vessels." 
((TEMPLATE CLAUSE) 
(PROCESS "involve") 
(AGENT 
((TEMPLATE NOUN-PHRASE) 
(HEAD "blood pressure") 
(DEFINITE NOART))) 
(AFFECTED 
((TEMPLATE NOUN-PHRASE) 
(HEAD ((TEMPLATE CONJUNCTION) 
(SENTENCE NO) 
(FIRST ((TEMPLATE NOUN-PHRASE) 
(HEAD "heart") 
(DEFINITE NOART))) 
(SECOND ((TEMPLATE NOUN-PHRASE) 
(HEAD "blood vessel") 
(NUMBER PLURAL) 
(DEFINITE NOART))))) 
(POSSESSOR ((TEMPLATE PRONOUN) 
(PERSON SECOND)))))) 
the agent slot, if its value were available) are filled 
by defaults (the defaults for number ,  person,  and 
gender are SINGULAR, THIRD, and NEUTRAL, respec- 
tively.) within the verb-form template. The next 
Eva luat ion  rule realizes "your heart and blood ves- 
sels", which is the result of realizing the affected 
slot (its value is a feature structure representing the 
noun-phrase template). Finally, the surface string 
is concatenated with a punctuation ".". 
((EVAL agent) 
(TEMPLATE verb-form 
( (process  "process) 
(person (agent person)) 
(number (agent number)) 
(gender (agent gender))) ) 
(EVAL affected) 
(PUNC "." left) ) 
Figure 3: A simplified template rule of the c lause 
template. 
4 Conclusion 
We have presented a natural language generation 
component, called YAG (Yet Another Generator), 
that has been designed to meet the needs of real- 
time, interactive systems. YAG combines a fast, 
tenlplate-based approach for the representation of
text structures with knowledge-I)asod methods for 
tel)resenting content. Its inputs can include concel)tS 
or propositions along :with. optional-annotations to 
specify syntactic onstraints. YAG can also realize 
267 
text from a feature-based representation f syntac- 
tic structure. YAG can detect and correct missing 
or conflicting features by using a preprocessor based 
on attribute grammars. (One can also specify de- 
fault values in the grammar itself.) YAG uses an 
expressive, declarative language for specifying a gen- 
eration grammar. The YAG distribution includes a 
,graphigaLtool for.extendingand testing templates.  
In these ways, YAG provides the speed, robustness, 
flexibility, and maintainability needed by real-time 
natural anguage dialog systems. 
References 
Songsak Channarukul, Susan W. McRoy, and 
Syed S. All. 2000. Enriching Partially-Specified 
Representations for Text Realization. In Proceed- 
ings of The First International Natural Language 
Generation Conference, Israel. 
Songsak Channarukul. 1999. YAG: A Natural Lan- 
guage Generator for Real-Time Systems. Mas- 
ter's thesis, University of Wisconsin-Milwaukee, 
December. 
Michael Elhadad. 1992. Using argumentation to 
control lexical choice: A .functional unification- 
baged approach. Ph.D. thesis, Computer Science 
Department, Columbia University. 
Michael Elhadad. 1993. FUF: The universal uni- 
fier - user manual, version 5.2. Technical Report 
CUCS-038-91, Columbia University. 
Barbara J. Grosz, Karen Sparck-Jones, and Bon- 
nie Lynn Webber. 1986. Readings in Natural Lan- 
guage Processing. Morgan Kaufmann Publishers, 
Los Altos, CA. 
William C. Mann. 1983. An overview of the 
Penman text generation system. In Proceedings 
of the Third National Conference on Artificial 
Intelligence (AAAI-83), pages 261-265, Wash- 
ington, DC, August 22-26,. Also appears as 
USC/Information Sciences Institute Tech Report 
RR-83-114. 
Kathleen R. McKeown. 1982. The TEXT system 
for natural language generation : An overview. 
In Proceedings of the 20th Annual Meeting of the 
ACL, pages 113-120, University of Toronto, On- 
tario, Canada, June 16-18,. 
Kathleen R. McKeown. 1985. Discourse strrategies 
for generating natural-language t xt. Artificial 
Intelligence, 27(1):1-42. Also appears in (Grosz 
et al, 1986)~ pages 479-499. 
Stuart C. Shapiro and William J. Rapaport. 1992. 
The SNePS family. Computers ~:t Mathematics 
with Applications, 23(2-5). 
Stuart C. Shapiro, William J. Rapaport, Sung-Hye 
Cho. ,J. Choi. E. Felt, Susai1 Hailer..l. Kankiewicz. 
and Deepak Kumar, 1996..4 Dictionary o/SNePS 
Case Frames. Department of Computer Science, 
SUNY at Buffalo. 
BioNLP 2008: Current Trends in Biomedical Natural Language Processing, pages 92?93,
Columbus, Ohio, USA, June 2008. c?2008 Association for Computational Linguistics
 
A Pilot Annotation to Investigate Discourse Connectivity in Biomedical Text  
 
 
 
Hong Yu, Nadya Frid, Susan McRoy Rashmi Prasad, Alan Lee, Aravind Joshi 
University of Wisconsin-Milwaukee University of Pennsylvania 
P.O.Box 413 3401 Walnut Street 
Milwaukee, WI 53201 Philadelphia, PA 19104, USA 
Hongyu,frid,mcroy@uwm.edu Rjprasad,aleewk,joshi@seas.upenn.edu
 
 
 
 
 
 
Abstract 
The goal of the Penn Discourse Treebank 
(PDTB) project is to develop a large-scale cor-
pus, annotated with coherence relations marked 
by discourse connectives. Currently, the primary 
application of the PDTB annotation has been to 
news articles. In this study, we tested whether 
the PDTB guidelines can be adapted to a differ-
ent genre. We annotated discourse connectives 
and their arguments in one 4,937-token full-text 
biomedical article. Two linguist annotators 
showed an agreement of 85% after simple con-
ventions were added. For the remaining 15% 
cases, we found that biomedical domain-specific 
knowledge is needed to capture the linguistic 
cues that can be used to resolve inter-annotator 
disagreement. We found that the two annotators 
were able to reach an agreement after discussion. 
Thus our experiments suggest that the PDTB an-
notation can be adapted to new domains by mini-
mally adjusting the guidelines and by adding 
some further domain-specific linguistic cues. 
1 Introduction 
Large scale annotated corpora, e.g., the Penn 
TreeBank (PTB) project (Marcus et al 1993), 
have played an important role in text-mining. 
The Penn Discourse Treebank (PDTB) 
(http://www.seas.upenn.edu/~pdtb) (Prasad et al 
2008a) annotates the argument structure, seman-
tics, and attribution of discourse connectives and 
their arguments. The current release of PDTB-
2.0 contains the annotations of 1,808 Wall Street 
Journal articles (~1 million words) from the 
Penn TreeBank (Marcus et al 1993) II distribu-
tion and a total of 40,600 discourse connective  
tokens (Prasad et al 2008b). This work exam-
ines whether the PDTB annotation guidelines 
can be adapted to a different genre, the biomedi-
cal literature.  
2 Notation 
A discourse connective can be defined as a 
word or multiword expression that signals a 
discourse relation. Discourse connectives 
can be subordinating conjunctions (e.g., be-
cause, when, although), coordinating con-
junctions (e.g., but, or, nor) and adverbials 
(e.g., however, as a result, for example). A 
discourse connective takes in two argu-
ments, Arg1 and Arg2. Arg2 is the argument 
that appears in the clause that is syntacti-
cally bound to the connective and Arg1 is 
the other argument. In the sentence ?John 
failed the exam because he was lazy? the dis-
course connective is underlined, Arg1 ap-
pears in italics and Arg2 appears in bold. 
3 A Pilot Annotation 
Following the PDTB annotation manual (Prasad 
et al 2008b), we conducted a pilot annotation of 
discourse connectivity in biomedical text. As an 
initial step, we only annotated the three most 
92
important components of a discourse relation; 
namely, a discourse connective and its two ar-
guments; we did not annotate attribution. Two 
linguist annotators independently annotated one 
full-text biomedical article (Verpy et al 1999) 
that we randomly selected. The article is 4,937 
tokens long. When the annotation work was 
completed, we measured the inter-annotator 
agreement, following the PDTB exact match 
criterion (Miltsakaki et al 2004). According to 
this criterion, a discourse relation is in dis-
agreement if there is disagreement on any text-
span (i.e., the discourse connective or any of its 
two arguments). In addition, we also measured 
the agreement in the components (i.e., discourse 
connectives and the arguments). We discussed 
the annotation results and made suggestions to 
adapt the PDTB guidelines to biomedical text.  
4 Results and Discussion 
The first annotator identified 74 discourse con-
nectives, and the second annotator identified 75, 
68 of which were the same as those identified by 
the first annotator. The combined total number 
of discourse connectives was 81. The overall 
agreement in discourse connective identification 
was 68/81=84%.  
 
Of the 68 discourse connectives that were anno-
tated by both annotators, 31 were an exact 
match, 31 had an exact match for Arg1, and 54 
had an exact match for Arg2. The overall 
agreement for the 68 discourse relations is 
45.6% for exact match, 45.6% for Arg1, and 
79.4% for Arg2. The PDTB also reported a 
higher level of agreement in annotating Arg2 
than in annotating Arg1 (Miltsakaki et al 2004). 
We manually analyzed the cases with disagree-
ment. We found the disagreements are nearly all 
related to the annotation of citation references, 
supplementary clauses, and other conventions. 
When a few conventions for these cases were 
added, the inter-annotator agreement went up to 
85%. We also found that different interpretation 
of a relation and its arguments by annotators 
plays an important role for the remaining 15% 
inconsistency, and domain-specific knowledge 
is necessary to resolve such cases.   
 
5 New Conventions 
After the completion of the pilot annotation and 
the discussion, we decided to add the following 
conventions to the PDTB annotation guidelines 
to address the characteristics of biomedical text: 
 
i. Citation references are to be annotated as 
a part of an argument because the inclu-
sion will benefit many text-mining tasks 
including identifying the semantic rela-
tions among citations. 
ii. Clausal supplements (e.g., relative or 
parenthetical constructions) that modify  
arguments but are not minimally 
necessary for the interpretation of the 
relation,  are annotated as part of the 
arguments. 
iii. We will annotate a wider variety of 
nominalizations as arguments than 
allowed by the PDTB guidelines. 
 
We anticipate that these changes will both de-
crease the amount of effort required for annota-
tion and increase the reliability of the 
annotation. 
6 References 
Marcus M, Santorini B, Marcinkiewicz M (1993) 
Building a Large Annotated Corpus of Eng-
lish: The Penn Treebank. Computational 
Linguistics 19 
Miltsakaki E, Prasad R, Joshi A, Webber B (2004) 
Annotating discourse connectives and their 
arguments. Paper presented at Proceedings 
of the NAACL/HLT Workshop: Frontiers in 
Corpus Annotation 
Prasad R, Dinesh N, Lee A, Miltsakaki E, Robaldo L, 
Joshi A, Webber B (2008a) The Penn Dis-
course Treebank 2.0. Paper presented at The 
6th International Conference on Language 
Resources and Evaluation (LREC). Marra-
kech, Morroco 
Prasad R, Miltsakaki E, Dinesh N, Lee A, Joshi A, 
Robaldo L, Webber B (2008b) The Penn 
Discourse TreeBank 2.0 Annotation Manual. 
Technical Report: IRCS-08-01 
Verpy E, Leibovici M, Petit C (1999) Characteriza-
tion of otoconin-95, the major protein of 
murine otoconia, provides insights into the 
formation of these inner ear biominerals. 
Proc Natl Acad Sci U S A 96:529-534 
 
 
93
