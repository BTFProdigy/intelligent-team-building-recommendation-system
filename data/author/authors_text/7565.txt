The OLAC Metadata Set and Controlled Vocabularies
Steven Bird
Linguistic Data Consortium
University of Pennsylvania
3615 Market Street, Suite 200
Philadelphia, PA 19104-2608, USA
sb@ldc.upenn.edu
Gary Simons
SIL International
7500 West Camp Wisdom Road
Dallas, TX 75236, USA
Gary Simons@sil.org
Abstract
As language data and associated
technologies proliferate and as the
language resources community rapidly
expands, it has become difficult to
locate and reuse existing resources.
Are there any lexical resources for
such-and-such a language? What
tool can work with transcripts in
this particular format? What is a
good format to use for linguistic data
of this type? Questions like these
dominate many mailing lists, since
web search engines are an unreliable
way to find language resources.
This paper describes a new digital
infrastructure for language resource
discovery, based on the Open Archives
Initiative, and called OLAC ? the
Open Language Archives Community.
The OLAC Metadata Set and the
associated controlled vocabularies
facilitate consistent description and
focussed searching. We report progress
on the metadata set and controlled
vocabularies, describing current issues
and soliciting input from the language
resources community.
1 Introduction
Language technology and the linguistic sciences
are confronted with a vast array of language
resources, richly structured, large and diverse.
Multiple communities depend on language
resources, including linguists, engineers,
teachers and actual speakers. Many individuals
and institutions provide key pieces of the
infrastructure, including archivists, software
developers, and publishers. Today we have
unprecedented opportunities to connect these
communities to the language resources they
need. First, inexpensive mass storage technology
permits large resources to be stored in digital
form, while the Extensible Markup Language
(XML) and Unicode provide flexible ways
to represent structured data and ensure its
long-term survival. Second, digital publication
? both on and off the world wide web ? is the
most practical and efficient means of sharing
language resources. Finally, a standard resource
description model, the Dublin Core Metadata Set,
together with an interchange method provided
by the Open Archives Initiative (OAI), make
it possible to construct a union catalog over
multiple repositories and archives.
In December 2000, an NSF-funded workshop
on Web-Based Language Documentation and
Description, held in Philadelphia, brought
together a group of nearly 100 language
software developers, linguists, and archivists
who are responsible for creating language
resources in North America, South America,
Europe, Africa, the Middle East, Asia and
Australia http://www.ldc.upenn.edu/
exploration/expl2000/. The outcome
of the workshop was the founding of the Open
Language Archives Community (OLAC), an
application of the OAI to digital archives of
language resources, with the following purpose:
OLAC, the Open Language Archives
Community, is an international
partnership of institutions and
individuals who are creating a
worldwide virtual library of language
resources by: (i) developing consensus
on best current practice for the digital
archiving of language resources,
and (ii) developing a network of
interoperating repositories and services
for housing and accessing such
resources.
This paper will describe the leading ideas
that motivate OLAC, before focussing on
the metadata set and the controlled vocabularies
which implement part (ii) of OLAC?s statement of
purpose. Metadata elements of special interest to
the language resources community include such
things as language identification and language
resource type. The corresponding controlled
vocabularies ensure consistent description.
For example, French language resources are
specified using an official RFC-3066 designation
(Alvestrand, 2001), instead of multiple distinct
text strings like ?French?, ?Francais? and
?Franc?ais?. A separate controlled vocabulary
exists for resource type, and has items such
as annotation/phonetic and description/grammar.
Services for end-users can map controlled
vocabularies onto convenient terminology for
any target language. (A live demonstration
accompanies this presentation.)
2 Locating Data, Tools and Advice
We can observe that the individuals who use
and create language resources are looking
for three things: data, tools, and advice. By
DATA we mean any information that documents
or describes a language, such as a published
monograph, a computer data file, or even
a shoebox full of hand-written index cards.
The information could range in content from
unanalyzed sound recordings to fully transcribed
and annotated texts to a complete descriptive
grammar. By TOOLS we mean computational
resources that facilitate creating, viewing,
querying, or otherwise using language data.
Tools include not just software programs, but also
Figure 1: In reality the user can?t always get there
from here
the digital resources that the programs depend
on, such as fonts, stylesheets, and document
type definitions. By ADVICE we mean any
information about what data sources are reliable,
what tools are appropriate in a given situation,
what practices to follow when creating new data,
and so forth. In the context of OLAC, the term
language resource is broadly construed to include
all three of these: data, tools and advice.
Unfortunately, today?s user does not have ready
access to the resources that are needed. Figure 1
offers a diagrammatic view of the reality. Some
archives (e.g. Archive 1) do have a site on the
internet which the user is able to find, so the
resources of that archive are accessible. Other
archives (e.g. Archive 2) are on the internet, so
the user could access them in theory, but the user
has no idea they exist so they are not accessible in
practice. Still other archives (e.g. Archive 3) are
not even on the internet. And there are potentially
hundreds of archives (e.g. Archive n) that the user
needs to know about. Tools and advice are out
there as well, but are at many different sites.
There are many other problems inherent in the
current situation. For instance, the user may not
be able to find all the existing data about the
language of interest because different sites have
called it by different names (low recall). The
user may be swamped with irrelevant resources
because search terms have important meanings in
other domains (low precision). The user may not
be able to use an accessible data file for lack of
being able to match it with the right tools. The
user may locate advice that seems relevant but
have no basis for judging its merits.
2.1 Bridging the gap
2.1.1 Why improved web-indexing is not
enough
As the internet grows and web-indexing
technologies improve one might hope that
a general-purpose search engine should be
sufficient to bridge the gap between people
and the resources they need, but this is a vain
hope. The first reason is that many language
resources, such as audio files and software, are
not text-based. The second reason concerns
language identification, the single most important
property for describing language resources.
If a language has a canonical name which is
distinctive as a character string, then the user
has a chance of finding any online resources
with a search engine. However, the language
may have multiple names, possibly due to the
vagaries of Romanization, such as a language
known variously as Fadicca, Fadicha, Fedija,
Fadija, Fiadidja, Fiyadikkya, and Fedicca (giving
low recall). The language name may collide with
a word which has other interpretations that are
vastly more frequent, e.g. the language names
Mango and Santa Cruz (giving low precision).
The third reason why general-purpose search
engines are inadequate is the simple fact that
much of the material is not, and will not, be
documented in free prose on the web. Either
people will build systematic catalogues of their
resources, or they won?t do it at all. Of course,
one can always export a back-end database
as HTML and let the search engines index
the materials. Indeed, encouraging people to
document resources and make them accessible
to search engines is part of our vision. However,
despite the power of web search engines, there
remain many instances where people still prefer
to use more formal databases to house their data.
This last point bears further consideration. The
challenge is to build a system for ?bringing like
things together and differentiating among them?
(Svenonius, 2000). There are two dominant
storage and indexing paradigms, one exemplified
by traditional databases and one exemplified
by the web. In the case of language resources,
the metadata is coherent enough to be stored in
a formal database, but sufficiently distributed
and dynamic that it is impractical to maintain it
centrally. Language resources occupy the middle
ground between the two paradigms, neither of
which will serve adequately. A new framework
is required that permits the best of both worlds,
namely bottom-up, distributed initiatives, along
with consistent, centralized finding aids. The
Dublin Core (DC) and the Open Archives
Initiative provide the framework we need to
?bridge the gap.?
2.1.2 The Dublin Core Metadata Initiative
The Dublin Core Metadata Initiative began in
1995 to develop conventions for resource discov-
ery on the web [dublincore.org]. The Dublin
Core metadata elements represent a broad, inter-
disciplinary consensus about the core set of ele-
ments that are likely to be widely useful to sup-
port resource discovery. The Dublin Core consists
of 15 metadata elements, where each element
is optional and repeatable: Title, Creator, Subject,
Description, Publisher, Contributor, Date, Type, For-
mat, Identifier, Source, Language, Relation, Coverage,
Rights. This set can be used to describe resources
that exist in digital or traditional formats.
In ?Dublin Core Qualifiers? (DCMI, 2000a)
two kinds of qualifications are allowed: encoding
schemes and refinements. An encoding scheme
specifies a particular controlled vocabulary or
notation for expressing the value of an element.
The encoding scheme serves to aid a client system
in interpreting the exact meaning of the element
content. A refinement makes the meaning of the
element more specific. For example, a Language
element can be encoded using the conventions
of RFC 3066 to unambiguously identify the
language in which the resource is written (or
spoken). A Subject element can be given a
language refinement to restrict its interpretation
to concern the language the resource is about.
2.1.3 The Open Archives Initiative
The Open Archives Initiative (OAI) was
launched in October 1999 to provide a common
framework across electronic preprint archives,
and it has since been broadened to include digital
repositories of scholarly materials regardless of
their type [www.openarchives.org] (Lagoze and
de Sompel, 2001).
Figure 2: Bridging the gap through community
infrastructure
In the OAI infrastructure, each participating
archive implements a repository ? a network
accessible server offering public access to
archive holdings. The primary object in an
OAI-conformant repository is called an item,
having a unique identifier and being associated
with one or more metadata records. Each
metadata record describes an archive holding,
which is any kind of primary resource such as
a document, raw data, software, a recording,
a physical artifact, a digital surrogate, and so
forth. Each metadata record will usually contain
a reference to an entry point for the holding, such
as a URL or a physical location, as shown in
Figure 2.
To implement the OAI infrastructure, a
participating archive must comply with two
standards: the OAI shared metadata set (Dublin
Core), which facilitates interoperability across
all repositories participating in the OAI, and the
OAI metadata harvesting protocol, which allows
software services to query a repository using
HTTP requests.
OAI archives are called ?data providers,?
though they are strictly just metadata providers.
Typically, data providers will also have a
submission procedure, together with a long-term
storage system, and a mechanism permitting
users to obtain materials from the archive. An
OAI ?service provider? is a third party that
provides end-user services (such as search
functions over union catalogs) based on metadata
harvested from one or more OAI data providers.
Figure 3 illustrates a single service provider
accessing three data providers (using the OAI
metadata harvesting protocol). End-users only
interact with service providers.
Figure 3: A Service Provider Accessing Multiple
Data Providers
Over the past decade, the Linguist List has
become the primary source of online informa-
tion for the linguistics community, reaching out
to over 13,000 subscribers worldwide, and having
four complete mirror sites. The Linguist List will
be augmenting its service by hosting the primary
service provider for OLAC, and permitting end-
users to browse distributed language resources at
a single place.
2.2 Applying the OAI to language resources
The OAI infrastructure is a new invention; it has
the bottom-up, distributed character of the web,
while simultaneously having the efficient, struc-
tured nature of a centralized database. This com-
bination is well-suited to the language resource
community, where the available data is growing
rapidly and where a large user-base is fairly con-
sistent in how it describes its resource needs.
The primary outcome of the Philadelphia work-
shop was the founding of the Open Language
Archives Community, and with it the identifica-
tion of an advisory board, alpha testers and mem-
ber archives. Details of these groups are available
from the OLAC site [www.language-archives.
org].
Recall that the OAI community is defined by
the archives which comply with the OAI metadata
harvesting protocol and that register with the OAI.
Any compliant repository can register as an Open
Archive, and the metadata provided by an Open
Archive is open to the public. OAI data providers
may support metadata standards in addition to
the Dublin Core. Thus, a specialist community
can define a metadata format which is specific
to its domain. Service providers, data providers
and users that employ this specialized metadata
format constitute an OAI subcommunity. The
workshop participants agreed unanimously that
the OAI provides a significant piece of the infras-
tructure needed for the language resources com-
munity.
In the same way that OLAC represents a
specialized subcommunity with respect to the
entire Open Archives community, there are
specialized subcommunities within the scope
of OLAC. For instance, the ISLE Meta Data
Initiative is developing a detailed metadata
scheme for corpora of recorded speech events
and their associated descriptions (MPI ISLE
Team, 2000). Similarly, the language data centers
? the Linguistic Data Consortium (LDC) and
the European Language Resources Association
(ELRA) ? are using OLAC metadata as the
basis of a joint catalog, and will add elements
and vocabularies for their specialized needs
(price, rights, and categories of membership
and use). For archived language resources that
are of this kind, such a metadata scheme would
support a richer description. This specialized
subcommunity can implement its own service
provider that offers focused searching based on
its own rich metadata set. At the same time, the
data providers will exposing OLAC and Dublin
Core versions of the metadata, permitting the
resources to be discovered by users of OLAC and
OAI service providers.
2.3 Federation and integration of language
resource archives
The OAI framework permits archives to
interoperate. OAI archives support the Dublin
Core metadata format and metadata harvesting
protocol. OLAC archives additionally support the
OLAC metadata format. Widespread adoption
of these standards will permit language resource
archives to be federated and integrated.
First, a collection of archives which support
the same metadata format can be federated, in
the sense that a virtual meta-archive can collect
all the information into a single place, and end-
users can query multiple archives simultaneously.
To demonstrate this, the Linguistic Data Consor-
tium has harvested the catalogs of three language
resource archives (LDC, ELRA, DFKI) and cre-
ated a prototype service provider. A search for
language=Bulgarian returns records from all three
archives, as shown in Figure 4 (Ba?nik and Bird,
2001).
Second, a collection of archives which support
the same metadata format can be integrated, in the
sense that relational joins can be performed across
different archives. This permits queries such as:
?find all lexicon tools that understand a format for
which Hungarian data is available.?
3 A Core Metadata Set for Language
Resources
The OLAC Metadata Set extends the Dublin
Core set only to the minimum degree required
to express basic properties of language resources
which are useful as finding aids.
All fifteen Dublin Core elements are used in the
OLAC Metadata Set. In order to suit the specific
needs of the language resources community, the
elements have been qualified following principles
articulated in ?Dublin Core Qualifiers? (DCMI,
2000a) and exemplified in (DCMI, 2000b).
This section describes some of the attributes,
elements and controlled vocabularies of the
OLAC Metadata Set. Before launching into
this discussion, we first review some XML
terminology and explain some aspects of the
OLAC representation which follow directly from
our choice of XML.
3.1 Aside: XML representation
The Extensible Markup Language (XML) is the
universal format for structured documents and
data on the Web [www.w3.org/XML]. The key
building block of an XML document is the ele-
ment. An element has a name, attributes and con-
tent. Here is an example of an element Language
with attributes refine and code, and free-text con-
tent:
<Language refine="OLAC" code="x-sil-BAN">
Foreke Dschang</Language>
In general, XML elements may contain other
elements, or they may be empty. XML Docu-
ment Type Definitions (DTDs) and XML schemas
are grammars that define the structure of a valid
XML document, and they limit the arrangement
of XML elements in a document. We believe it
oai:ldc:LDC94T5
Date: 1994
Title: ECI Multilingual Text
Type: text
Identifier: 1-58563-033-3
Subject.language: Albanian, Bulgarian, Chinese, Czech, Dutch, English, Estonian,
French, Gaelic, German, Greek, Italian, Japanese, Latin, Lithuanian,
Malay, Spanish, Danish, Uzbek, Norwegian, Portuguese, Russian,
Serbian, Swedish, Turkish, Tibetan
Identifier: http://www.ldc.upenn.edu/Catalog/LDC94T5.html
Description: Recommended Applications: information retrieval, machine transla-
tion, language modeling
oai:elra:L0030
Title: Bulgarian Morphological Dictionary
Date: 1998
Subject.language: Bulgarian
Description: 67,500 entries divided into 242 inflectional types (including proper
nouns), morphosyntactic information for each entry, and a morpho-
logical engine (MS DOS and WINDOWS 95/NT) for morphological
analysis and generation
Identifier: http://www.icp.inpg.fr/ELRA/cata/text det.html#bulmodic
oai:dfki:KPML
Title: KPML
Creator: Bateman and many others
Subject.language: Spanish, Russian, Japanese, Greek, German, French, English, Czech,
Bulgarian
Format.os: Windows NT, Windows 98, Windows 95/98, Solaris
Type.functionality: Software: Annotation Tools, Grammars, Lexica, Development Tools,
Formalisms, Theories, Deep Generation, Morphological Generation,
Shallow Generation
Description: Natural Language Generation Linguistic Resource Development and
Maintenance workbench for large scale generation grammar devel-
opment, teaching, and experimental generation. Based on systemic-
functional linguistics. Descendent of the Penman NLG system.
Identifier: http://www.purl.org/net/kpml
Description: Contact: bateman@uni-bremen.de
Relation.requires: Windows: none; Solaris: CommonLisp + CLIM
Figure 4: Querying the Prototype Service Provider for Bulgarian Resources
is important to use a formal mechanism for vali-
dating a metadata record. Following the OAI, we
use XML schemas to specify the OLAC metadata
format.
XML schemas make it possible for element
content and attribute values to be constrained
according to the element name. However, XML
schemas do not permit element content to be
constrained on the basis of the attribute value.
Accordingly, in implementing qualified Dublin
Core using XML, we are limited to using one
encoding scheme (or controlled vocabulary) per
element.
There are two cases we need to consider here.
In the case where all refinements of an element
employ the same encoding scheme, we use the
element name as is and add a refine attribute with
a fixed value. This documents that the particu-
lar encoding scheme has been used, and ensures
that the element cannot be confused with a cor-
responding unqualified Dublin Core element (see
the above example). In the case where differ-
ent refinements of an element employ different
encoding schemes, then a unique element must
be defined. Following (DCMI, 2000b), we define
such elements by concatenating the Dublin Core
element name and the refinement name with an
intervening dot. An example is shown below:
<Format.encoding code="iso-8859-1"/>
3.2 Attributes used in implementing the
OLAC Metadata Set
Three attributes ? refine, code, and lang ? are
used throughout the metadata set to handle most
qualifications to Dublin Core. Some elements in
the OLAC Metadata Set use the refine attribute
to identify element refinements. These quali-
fiers make the meaning of an element narrower
or more specific. A refined element shares the
meaning of the unqualified element, but with a
more restricted scope (DCMI, 2000a).
Some elements in the OLAC Metadata Set use
the code attribute to hold metadata values that are
taken from a specific encoding scheme. When an
element may take this attribute, the attribute value
specifies a precise value for the element taken
from a controlled vocabulary or formal notation
(x3.4). In such cases, the element content may
also be used to specify a freeform elaboration of
the coded value.
Every element in the OLAC Metadata Set may
use the lang attribute. It specifies the language
in which the text in the content of the element is
written. The value for the attribute comes from
a controlled vocabulary OLAC-Language. By
default, the lang attribute has the value ?en?, for
English. Whenever the language of the element
content is other than English, the lang attribute
should be used to identify the language. By
using multiple instances of the metadata elements
tagged for different languages, data providers
may offer their metadata records in multiple
languages.
In addition, there is a lang attribute on the
<olac> element that contains the metadata
elements for a given metadata record. It lists
the languages in which the metadata record
is designed to be read. This attribute holds
a space-delimited list of language codes. By
default, this attribute has the value ?en?, for
English, indicating that the record is aimed only
at English readers. If an explicit value is given for
the attribute, then the record is aimed at readers
of all the languages listed.
Service providers should use this information
in order to offer multilingual views of the meta-
data. When a metadata record lists only one alter-
native language, then all elements are displayed
(regardless of their individual languages), unless
the user has requested to suppress all records in
that language. When a metadata record has mul-
tiple alternative languages, the user should be able
to select one and have display of elements in the
other languages suppressed. An element in a
language not included in the list of alternatives
should always be displayed (for instance, the ver-
nacular title of a work).
3.3 The elements of the OLAC Metadata Set
In this section we present a synopsis of the
elements of the OLAC metadata set. For each
element, we provide a one sentence definition
followed by a brief discussion, systematically
borrowing and adapting the definitions provided
by the Dublin Core Metadata Initiative (DCMI,
1999). Each element is optional and repeatable.
Contributor: An entity responsible for making
contributions to the content of the
resource. Examples of a Contributor
include a person, an organization, or a
service. The refine attribute is optionally
used to specify the role played by the named
entity in the creation of the resource, using
the controlled vocabulary OLAC-Role.
Coverage: The extent or scope of the content
of the resource. Coverage will typically
include spatial location or temporal period.
Where the geographical information is pre-
dictable from the language identification, it
is not necessary to specify geographic cov-
erage.
Creator: An entity primarily responsible for
making the content of the resource. The
refine attribute is optionally used to specify
the role played by the named entity in the
creation of the resource, using the controlled
vocabulary OLAC-Role.
Date: A date associated with an event in the life
cycle of the resource. The refine attribute is
optionally used to refine the meaning of the
date using values from a controlled vocab-
ulary (for instance, date of creation versus
date of issue versus date of modification, and
so on). The vocabulary for refinements to
Date is defined in (DCMI, 2000a).
Description: An account of the content of the
resource. Description may include but is not
limited to: an abstract, table of contents, ref-
erence to a graphical representation of con-
tent, or a free-text account of the content.
Format: The physical or digital manifestation
of the resource. Typically, Format may
include the media-type or dimensions of the
resource. Format may be used to determine
the software, hardware or other equipment
needed to use the resource. The code
attribute identifies the format using the
controlled vocabulary OLAC-Format.
Format.cpu: The CPU required to use a soft-
ware resource. The code attribute identi-
fies the CPU using the controlled vocabulary
OLAC-CPU.
Format.encoding: An encoded character set
used by a digital resource. For a digitally
encoded text, Format.encoding names the
encoded character set it uses. For a font,
Format.encoding names an encoded character
set that it is able to render. For a software
application, Format.encoding names an
encoded character set that it can read or
write. The code attribute is used to identify
the character set using the controlled
vocabulary OLAC-Encoding.
Format.markup: The OAI identifier for the
definition of the markup format.
Format.markup provides an OAI identifier
for an XML DTD, schema or some other
definition of the markup format. (This has
the side-effect of ensuring that the format
definition is archived somewhere). For a
software resource, Format.markup names a
markup scheme that it can read or write.
The code attribute identifies the markup
scheme using the controlled vocabulary
OLAC-Markup.
Format.os: The operating system required to
use a software resource. The code attribute
is used to identify the operating system
using the controlled vocabulary OLAC-OS.
Additional restrictions for operating system
version, may be specified using the element
content.
Format.sourcecode: The programming lan-
guage(s) of software distributed in source
form. The code attribute identifies the
language using the controlled vocabulary
OLAC-Sourcecode.
Identifier: An unambiguous reference to
the resource within a given context.
Recommended best practice is to identify
the resource by means of a string or number
conforming to a globally-known formal
identification system (e.g. URIs, ISBNs).
For non-digital archives, Identifier may use
the existing scheme for locating a resource
within the collection.
Language: A language of the intellectual
content of the resource. Language is
used for a language the resource is in, as
opposed to the language it describes (see
Subject.language). It identifies a language
that the creator of the resource assumes
that its eventual user will understand. The
code attribute is used to make a precise
identification of the language using the
controlled vocabulary OLAC-Language.
Publisher: An entity responsible for making the
resource available. Examples of a publisher
include a person, an organization, or a ser-
vice.
Relation: A reference to a related resource. This
element is used to document relationships
between resources. The refine attribute is
used to refine the nature of the relationship
using values from a controlled vocabulary
(for instance, is replaced by, requires, is
part of, and so on). The vocabulary for
refinements to Relation is defined in (DCMI,
2000a).
Rights: Information about rights held in and
over the resource. Typically, a Rights ele-
ment will contain a rights management state-
ment for the resource, or reference a service
providing such information. Rights informa-
tion often encompasses intellectual property
rights (IPR), copyright, and various property
rights. The code attribute is used to make
a summary statement about rights using the
controlled vocabulary OLAC-Rights.
Rights.software: Information about rights held
in and over a software resource. A rights
statement pertaining to software, using the
controlled vocabulary OLAC-Software-
Rights.
Source: A reference to a resource from which
the present resource is derived. For
instance, it may be the bibliographic
information about a printed book of which
this is the electronic encoding or from which
the information was extracted.
Subject: The topic of the content of the
resource. Typically, a Subject will be
expressed as keywords, key phrases or
classification codes that describe a topic of
the resource. Recommended best practice
is to select a value from a controlled
vocabulary or formal classification scheme.
Subject.language: A language which the content
of the resource describes or discusses. As
with the Language element, a code attribute
is used to identify the language precisely.
Title: A name given to the resource. Typically,
a title will be a name by which the resource
is formally known. A translation of the title
can be supplied in a second Title element.
The lang attribute is used to identify the lan-
guage of these elements.
Type: The nature or genre of the content of
the resource. The code attribute is used to
identify the type using the Dublin Core con-
trolled vocabulary DC-Type.
Type.data: The nature or genre of the content of
the resource, from a linguistic standpoint.
Type includes terms describing general cate-
gories, functions, genres, or aggregation lev-
els for content. The code attribute is used to
identify the type using the controlled vocab-
ulary OLAC-Data.
Type.functionality: The functionality of a
software resource. The code attribute
is used to identify the type using the
controlled vocabulary OLAC-Functionality.
Observe that some elements, such as Format,
Format.encoding and Format.markup are applicable
to software as well as to data. Service providers
can exploit this feature to match data with appro-
priate software tools.
3.4 The controlled vocabularies
Controlled vocabularies are enumerations of legal
values for the code attribute. In some cases, more
than one value applies, in which case the corre-
sponding element must be repeated, once for each
applicable value. In other cases, no value is appli-
cable ands the corresponding element is simply
omitted. In yet other cases, the controlled vocab-
ulary may fail to provide a suitable item, in which
case a similar item can be optionally specified and
a prose comment included in the element content.
3.4.1 OLAC-Language
Language identification is an important
dimension of language resource classification.
However, the character-string representation
of language names is problematic for several
reasons: different languages (in different parts
of the world) may have the same name; the
same language may have a different name in
each country where it is spoken; within the
same country, the preferred name for a language
may change over time; in the early history of
discovering new languages (before names were
standardized), different people referred to the
same language by different names; and for
languages having non-Roman orthographies,
the language name may have several possible
romanizations. Together, these facts suggest that
a standard based on names will not work. Instead,
we need a standard based on unique identifiers
that do not change, combined with accessible
documentation that clarifies the particular speech
variety denoted by each identifier.
The information technology community has a
standard for language identification, namely, ISO
639 (ISO, 1998). Part 1 of this standard lists
two-letter codes for identifying 160 of the world?s
major languages; part 2 of the standard lists three-
letter codes for identifying about 400 languages.
ISO 639 in turn forms the core of another stan-
dard, RFC 3066 (formerly RFC 1766), which is
the standard used for language identification in
the xml:lang attribute of XML and in the language
element of the Dublin Core metadata set. RFC
3066 provides a mechanism for users to register
new language identification codes for languages
not covered by ISO 639, but very few additional
languages have been registered.
Unfortunately, the existing standard falls
far short of meeting the needs of the language
resources community since it fails to account for
more than 90% of the world?s languages, and
it fails to adequately document what languages
the codes refer to (Simons, 2000). However,
SIL?s Ethnologue (Grimes, 2000) provides a
complete system of language identifiers which
is openly available on the Web. OLAC will
employ the RFC 3066 extension mechanism
to build additional language identifiers based
on the Ethnologue codes. For the 130-plus
ISO-639-1 codes having a one-to-one mapping
onto Ethnologue codes, OLAC will support both.
Where an ISO code is ambiguous ? such as mhk
for ?other Mon Khmer languages? ? OLAC will
require the Ethnologue code. New identifiers
for ancient languages, currently being developed
by LINGUIST List, will be incorporated. These
language identifiers are expressed using the code
attribute of the Language and Subject.language
elements. The free-text content of these elements
may be used to specify an alternative human-
readable name for the language (where the name
specified by the standard is unacceptable for
some reason) or to specify a dialect (where the
resource is dialect-specific).
3.4.2 OLAC-Data
After language identification, another dimen-
sion of central importance is the linguistic type of
a resource. Notions such as ?lexicon? and ?gram-
mar? are fundamental to OLAC, and the discourse
of the language resources community depends on
shared assumptions about what these types mean.
We believe that it is helpful to distinguish at
least four top-level types: transcription, annota-
tion, description and lexicon, each defined broadly
as proposed below. A transcription is any time-
ordered symbolic representation of a linguistic
event. An annotation is any kind of structured
linguistic information that is explicitly aligned to
some spatial and/or temporal extent of a linguistic
record (such as a recorded signal or an image).
A description is any description or analysis of a
language; unlike a transcription or an annotation,
the structure of a description is independent of the
structure of the linguistic events that it describes.
A lexicon is any record-structured inventory of lin-
guistic forms.
For each of these top-level types we envision a
more specific vocabulary to facilitate greater pre-
cision. For example, an orthographic transcrip-
tion would have the code transcription/orthographic.
Other subtypes could include: phonetic, prosodic,
morphological, gestural, part-of-speech, syntactic, dis-
course, musical. The annotation type would include
these subtypes, and add others to cover spatial
annotation of images (e.g. for OCR annotation
of textual images or for isogloss maps).
The description type could have subtypes for
grammatical, phonological, orthographic, paradigms,
pedagogical, dialectal and comparative. The lexi-
con type could also carry subtypes to distinguish
wordlists, wordnets, thesauri and so forth.
3.4.3 Other controlled vocabularies
OLAC-CPU: A vocabulary for identifying the
CPU(s) for which the software is available,
in the case of binary distributions: x86, mips,
alpha, ppc, sparc, 680x0.
OLAC-Encoding: A vocabulary for identifying
the character encoding used by a digital
resource, e.g. iso-8859-1, ...
<?xml version="1.0" encoding="UTF-8"?>
<olac
xmlns="http://www.language-archives.org/OLAC/0.3/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.language-archives.org/OLAC/0.3/
http://www.language-archives.org/OLAC/olac-0.3b1.xsd">
<Title>KPML</Title>
<Identifier>http://www.purl.org/net/kpml/</Identifier>
<Creator refine="Author">Bateman, John</Creator>
<Subject.language code="es"/> <Subject.language code="ru"/>
<Subject.language code="ja"/> <Subject.language code="el"/>
<Subject.language code="de"/> <Subject.language code="fr"/>
<Subject.language code="en"/> <Subject.language code="cs"/>
<Subject.language code="bg"/>
<Format.os code="MSWindows/winNT"/> <Format.os code="MSWindows/win95"/>
<Format.os code="MSWindows/win98"/> <Format.os code="Unix/Solaris"/>
<Type.functionality>Annotation Tools, Grammars, Lexica, Development Tools,
Formalisms, Theories, Deep Generation, Morphological Generation,
Shallow Generation</type.functionality>
<Relation refine="Requires">Windows: none; Solaris: CommonLisp + CLIM</Relation>
<Description>Natural Language Generation Linguistic Resource Development and
Maintenance workbench for large scale generation grammar development,
teaching, and experimental generation. Based on systemic-functional
linguistics. Descendent of the Penman NLG system.</Description>
</olac>
Figure 5: OLAC Metadata Record for KPML
OLAC-Format: A vocabulary for identifying
the manifestation of the resource. The
representation is inspired by MIME types,
e.g. text/sf for SIL standard format.
(Format.markup is used to identify the
particular tagset.) It may be necessary
to add new types and subtypes to cover
non-digital holdings, such as manuscripts,
microforms, and so forth and we expect to be
able to incorporate an existing vocabulary.
OLAC-Functionality: A vocabulary for clas-
sifying the functionality of software, again
using the MIME style of representation,
and using the HLT Survey as a source of
categories (Cole, 1997) as advocated by
the ACL/DFKI Natural Language Software
Registry. For example, written/OCR would
cover ?written language input, print or
handwriting optical character recognition.?
OLAC-OS: A vocabulary for identifying the
operating system(s) for which the software
is available: Unix, MacOS, OS2, MSDOS,
MSWindows. Each of these has optional
subtypes, e.g. Unix/Linux, MSWindows/winNT.
OLAC-Rights: A vocabulary for classifying
the rights held over a resource, e.g.: open,
restricted, ...
OLAC-Role: A vocabulary for identifying
the role of a contributor or creator of the
resource, e.g.: author, editor, translator,
transcriber, sponsor, ...
OLAC-Software-Rights: A vocabulary for
classifying the rights held over a resource,
e.g.: open-source, royalty-free-library, royalty-
free-binary, commercial, ...
OLAC-Sourcecode: A vocabulary for identify-
ing the programming language(s) used by
software which is distributed in source form,
e.g.: C++, Java, Python, Tcl, VB, ...
4 XML Representation
The OLAC metadata format consists of an XML
schema for the element set, and a set of schemas
for the controlled vocabularies. The latest ver-
sions are available from the OLAC website.
Figure 5 shows the OLAC metadata record cor-
responding to the KPML display from Figure 4.
The top element is olac; this references the XML
namespace for version 0.3b1 of the schema. The
contents of the olac element are the OLAC meta-
data elements, which are optional and repeatable,
and can occur in any order, as in Dublin Core.
Some elements employ the optional code or
refine attributes, and/or free-text content. The
third attribute, lang, is not used here since the free-
text content is in English (specified in the XML
schema as the default). For the Creator element,
the refine attribute narrows the meaning of cre-
ator to Author. For the Subject.language elements,
the code attribute specifies nine languages using
Ethnologue codes. A service provider would map
these codes to human-readable names.
The Format.os element illustrates a two-level
coding scheme, consisting of an OS ?family?,
followed by a specific operating system. Further
details can be included in the free-text content
if necessary. If a piece of software runs on all
members of an OS family, then the more detailed
designation can be omitted, e.g. code=?Unix?.
The Type.functionality element is specified using
free-text content, since the details of the
controlled vocabulary OLAC-Functionality are
still being worked out.
5 Conclusions
The OLAC Metadata Set and controlled vocabu-
laries are works in progress, and are continuing to
be revised with input from participating archives
and members of the wider language resources
community. We hope to have provided sufficient
motivation and exemplification for our choices so
that readers will easily be able to contribute to
ongoing developments.
Even once OLAC is completely in place, there
will still be documentation tasks which the cre-
ators of language resources will have to under-
take, and new habits to acquire. It will always be
necessary to identify and manually correct incon-
sistent or erroneous metadata. The OLAC con-
trolled vocabularies will need to be refined indef-
initely in response to changes in the world around
us. The creators of language resources will need
to generate metadata with each new resource and
place the resource in a suitable archive. The
communities will need to adopt best practices for
archival storage formats.
Despite these intrinsic limitations, the OLAC
Metadata Set and controlled vocabularies offer a
template for resource description, providing two
clear benefits over traditional full-text descrip-
tion and retrieval. First, the template guides the
resource creator in giving a complete description
of the resource, in contrast to prose descriptions
which may omit important details. And second,
the template associates a resource with standard
labels, such as creator and title, permitting users
to do focussed searching. Resources and reposi-
tories can proliferate, yet common metadata and
vocabularies will support centralized services giv-
ing users easy access to language resources.
References
Harald Alvestrand. 2001. RFC 3066: Tags for the
identification of languages (replaces 1766).
ftp://ftp.isi.edu/in-notes/rfc3066.txt.
?Eva Ba?nik and Steven Bird. 2001. LDC experimental
OLAC service provider. http://wave.ldc.upenn.
edu/OLAC/sp-0.2/sp.php4.
Ronald Cole, editor. 1997. Survey of the State of the Art in
Human Language Technology. Studies in Natural Language
Processing. Cambridge University Press.
http://cslu.cse.ogi.edu/HLTsurvey/.
DCMI. 1999. Dublin Core Metadata Element Set, version
1.1: Reference description. http://dublincore.
org/documents/1999/07/02/dces/.
DCMI. 2000a. Dublin Core qualifiers.
http://dublincore.org/documents/2000/07/
11/dcmes-qualifiers/.
DCMI. 2000b. Recording qualified Dublin Core metadata
in HTML. http://dublincore.org/documents/
2000/08/15/dcq-html/.
Barbara F. Grimes, editor. 2000. Ethnologue: Languages of
the World. Dallas: Summer Institute of Linguistics, 14th
edition. http//www.sil.org/ethnologue/.
ISO. 1998. ISO 639: Codes for the representation of names
of languages-part 2: Alpha-3 code.
http://lcweb.loc.gov/standards/
iso639-2/langhome.html.
Carl Lagoze and Herbert Van de Sompel. 2001. The Open
Archives Initiative: Building a low-barrier interoperability
framework. http://www.cs.cornell.edu/
lagoze/papers/oai-jcdl.pdf.
MPI ISLE Team. 2000. ISLE meta data elements for
session descriptions proposal.
http://www.mpi.nl/world/ISLE/documents/
draft/ISLE_Metadata_2.0.pdf.
Gary Simons. 2000. Language identification in metadata
descriptions of language archive holdings. In Steven Bird
and Gary Simons, editors, Proceedings of the Workshop on
Web-Based Language Documentation and Description.
http://www.ldc.upenn.edu/exploration/
expl2000/papers/simons/.
Elaine Svenonius. 2000. The Intellectual Foundation of
Information Organization. The MIT Press.
The semantics of markup: Mapping legacy markup schemas to a common 
semantics 
Gary F. Simons 
SIL International  
7500 W. Camp Wisdom Road 
Dallas TX 75236, USA  
Gary_Simons@sil.org 
 
 
Scott O. Farrar 
Faculty of Linguistics and Literary Sciences 
University of Bremen  
Bibliothekstr. 1 
D-28359 Bremen, Germany  
farrar@uni-bremen.de  
 
Brian Fitzsimons 
Department of Linguistics 
University of Arizona  
P. O. Box 210028 
Tucson AZ 85721, USA  
 fitzsimo@u.arizona.edu  
William D. Lewis 
Department of Linguistics 
California State University, Fresno 
5245 North Backer Avenue 
Fresno CA 93740, USA   
wlewis@csufresno.edu 
 
D. Terence Langendoen 
Department of Linguistics 
University of Arizona  
P. O. Box 210028 
Tucson AZ 85721, USA  
langendt@u.arizona.edu 
 
Hector Gonzalez 
Department of Linguistics 
California State University, Fresno 
5245 North Backer Avenue 
Fresno CA 93740, USA   
hexgonzo@csufresno.edu 
 
Abstract 
A method for mapping linguistic descrip-
tions in plain XML into semantically rich 
RDF/OWL is outlined and demonstrated. 
Starting with Simons?s (2003) original 
proof of concept of this method, we extend 
his Semantic Interpretation Language (SIL) 
for creating metaschemas to carry out the 
mapping, employ the General Ontology for 
Linguistic Description (GOLD) of Farrar 
and Langendoen (2003) as the target se-
mantic schema, and make use of SeRQL, 
an RDF-aware search engine. This data 
migration effort is in keeping with the vi-
sion of a Semantic Web; it is part of an ef-
fort to build a ?community of practice? 
around semantically rich linguistic re-
sources. 
1 Introduction 
Machine-readable structured linguistic docu-
ments (comparative word lists, lexicons, annotated 
texts, audio and audio-video recordings aligned 
with transcriptions (possibly annotated), gram-
matical descriptions, etc.) are being made available 
in a wide variety of formats on the Web. Until re-
cently, the linguistics community has not been par-
ticularly concerned about the ease with which 
those structures can be accessed by other users, nor 
about the comparability of the structures that can 
be accessed. Now that community is beginning to 
realize that XML encoding provides relatively 
straightforward access to the intended structures 
and at the same time insures that the documents 
will continue be accessible for the foreseeable fu-
ture.  
However, XML encoding by itself does not in-
sure comparability. To achieve that goal, the com-
munity must either adopt standards for encoding 
particular structures, or methods need to be devel-
oped for interpreting structures that are differently 
encoded. This paper reports on an effort to do the 
latter: to migrate XML documentation of linguistic 
structure to a semantically interoperable format. 
One of the most compelling reasons to do so is to 
enable intelligent search: the ability to query 
documents based on their semantics, rather than on 
strings of characters that may occur in them or on 
their document syntax. Facilitating intelligent 
searching is also one of the major goals of the Se-
mantic Web. We are making the first steps towards 
a Semantic Web for linguistics by showing how to 
migrate a significant amount of language resources 
to a format that makes them semantically compa-
rable. 
2 Background 
The work reported in this paper was carried out 
as part of the Electronic Metastructure for Endan-
gered Language Data (EMELD) project 
[emeld.org] (NSF grant 0094934) and the Data-
Driven Linguistic Ontology project (NSF grant 
0411348). One of the objectives of the EMELD 
project is the ?formulation and promulgation of 
best practice in linguistic markup of texts and lexi-
con.? Underlying this objective is the goal of en-
suring that the digital language documentation 
produced by linguists will be truly portable in the 
sense of Bird and Simons (2003): that it will tran-
scend computer environments, scholarly communi-
ties, domains of application, and the passage of 
time. The project was undertaken on the basis of 
the following principles: 
1. 
2. 
3. 
1. 
2. 
3. 
4. 
1. 
2. 
3. 
XML markup provides the best format for 
the interchange and archiving of endangered 
language description and documentation. 
No single schema or set of schemas for 
XML markup can be imposed on all lan-
guage resources. 
The resources must nevertheless be compa-
rable for searching, drawing inferences, etc.  
Simons (2003) points out the conflict between 
the second and third principles, and describes the 
following set of actions for reconciling them. 
Develop a community consensus on shared 
ontologies of linguistic concepts that can 
serve as the basis for interoperation. 
Define the semantics of any particular 
markup schema by mapping its elements and 
attributes to the concepts in the shared on-
tology that they represent. 
Map each individual language resource onto 
its (partial) semantic interpretation by apply-
ing the mapping of its markup schema. 
Perform queries and other knowledge-based 
operations across resources over these se-
mantic interpretations rather than the origi-
nal XML documents. 
The EMELD project has already begun work on 
the first of these action items, the creation of a 
sharable ontology for language documentation and 
description, a General Ontology for Linguistic De-
scription (GOLD) [emeld.org/gold] (Farrar and 
Langendoen, 2003), which is intended to be 
grounded in a suitable upper ontology such as 
SUMO (Niles and Pease, 2001) or DOLCE (Ma-
solo et al, 2002). GOLD is itself being written in 
OWL, the Ontology Web Language (McGuinness 
and van Harmelen, 2004), for use in Semantic Web 
applications. Simons (2003, 2004) also provides a 
?proof of concept? for an implementation of the 
remaining three action items as follows. 
Beginning with three dictionaries that used 
similar but distinct markup based on the 
Text Encoding Initiative (TEI) guidelines 
(Sperberg-McQueen and Burnard, 2002), 
Simons created mappings from their differ-
ent markup schemas to a common semantics 
as defined by an RDF Schema (Brickley and 
Guha, 2004). Such a semantic schema pro-
vides a ?formal definition ... of the concepts 
in a particular domain, including types of re-
sources that exist, the properties that can re-
late pairs of resources, and the properties 
that can describe a single resource in terms 
of literal values? (Simons, 2004). This map-
ping he called a metaschema, a formal defi-
nition of how the elements and attributes of 
a markup schema are to be interpreted in 
terms of the concepts of the semantic 
schema. He called the ?language? for writing 
metaschemas (defined via an XML DTD) a 
Semantic Interpretation Language (SIL).  
Simons performed the semantic interpreta-
tion operation in a two-step process using 
XSLT, first to create an interpreter for a par-
ticular metaschema and then to apply it 
against a source document to yield the RDF 
document (repository) that is its semantic in-
terpretation. 
Simons then loaded the RDF repositories 
into a Prolog system to create a merged da-
tabase of RDF triples and used Prolog?s in-
ference engine to query the semantic inter-
pretations. 
Simons (2003) describes this implementation as 
providing a semantics of markup, rather than as 
devising yet another markup language for seman-
tics. As such, it is in the spirit of efforts such as 
Sperberg-McQueen et al (2000), who define the 
meaning of markup as the set of inferences li-
censed by it. However, their model does not pro-
vide for the general comparison of documents. It is 
also in the spirit of the proposal for a Linguistic 
Annotation Framework (LAF) under development 
by Working Group 1-1 of ISO TC 37 SC 4 
[www.tc37sc4.org] (Ide and Romary, 2003; Ide, 
Romary and de la Clergerie, 2003), but differs 
from it in some significant ways. For example, our 
strategy does not require that the source annota-
tions be mapped to an XML ?pivot format?. On the 
other hand, the LAF does not require that the 
source annotations be in XML to begin with. The 
?data categories? of the LAF correspond to the 
concepts in GOLD; however the ?creation of an 
ontology of annotation classes and types? is not yet 
part of the LAF (Ide, Romary and de la Clergerie 
2003). Moreover, the LAF data model is confined 
to feature structures, whereas GOLD plans to offer 
feature structures as one of several data structuring 
alternatives. Finally, through its connection with 
an upper ontology, GOLD will also be related to 
the ?rest of the world?, whereas the LAF ontology 
is apparently intended for linguistic structure only. 
3 Goals of this paper 
In this paper we extend Simons? proof of con-
cept for the use of metaschemas in the following 
ways. 
1. 
2. 
3. 
4. 
GOLD itself is used as the semantic schema. 
SIL is extended to include the ability to map 
the content of designated elements and at-
tributes in source documents to the semantic 
schema, not just the markup itself. 
We devise metaschemas for lexicons that 
use distinct XML markup schemas: one of 
the lexicons that Simons (2003) originally 
used, for Sikaiana (Solomon Islands) with 
about 3000 entries; a Hopi (Arizona) dic-
tionary with about 30,000 entries, for which 
Kenneth Hill?s original encoding using a 
proprietary and no longer supported data-
base program was converted to XML by 
Lewis and Gonzalez; and a Potawatomi 
(Great Lakes region, US and Canada) lexi-
con being created by Laura Buszard-
Welcher using the EMELD FIELD tool. 
The Prolog query engine is replaced by 
SeRQL, an SQL-like query language for 
Sesame, an RDF database program (Broek-
stra, Kampman and van Harmelen 2002; 
User Guide for Sesame 2004). It is our in-
tention to couple Sesame with an inference 
engine that reads OWL documents, such as 
Racer (Haarslev and Moller 2001). 
In carrying out the migration of such language 
resources to the Semantic Web, we are guided by 
the principle of preserving the original analyses as 
much as possible. At the same time, since the mi-
grated resources are to be rendered mutually inter-
operable and transparent to the tools that are de-
signed to work over them, the migration process 
has the potential to greatly increase the precision 
of the original analyses, to reveal inconsistencies 
in them, and ultimately to result in enriched re-
sources. For example, the comparison of two de-
scriptions of the same language that has been made 
possible by migration could reveal errors in one or 
the other. Similarly, a single resource could be 
checked for consistency with accumulated linguis-
tic knowledge represented in an ontology. The mi-
gration process thus provides two sources of new 
knowledge. First is the knowledge brought in from 
the document interpretation process itself, i.e. by 
the linguist, not necessarily the one who performed 
the original analysis. Second when the migrated 
documents are added to the knowledge base, new 
inferences can be automatically generated based on 
the general knowledge of linguistics captured in 
the ontology. The type of new knowledge gener-
ated is however constrained, for example, by the 
type of search to be done over the resulting knowl-
edge base (see section 6). 
However the migration process can also skew or 
misinterpret the intentions underlying the original 
documentation. To minimize this risk, the migra-
tion tools should be as non-intrusive as possible. 
Even so, some steps are necessary to add structure 
where structure is lacking in the original XML 
documentation and to interpret the meaning of the 
original elements where their meanings are unde-
fined or unclear. For the ontology the implication 
is that theory-laden concepts either should be 
avoided or less encumbered alternatives should be 
made available.  
4 GOLD 
An important guiding principle used in the con-
struction of GOLD is to distinguish between those 
concepts that represent the content of linguistic 
data and those that pertain to the structuring of 
those data (cf. Ide and Romary 2003 who also dis-
tinguish between data content and data structure). 
A particular entry in a lexicon, for example, is a 
data structure used to organize lexical data in a 
particular fashion. Entries usually contain actual 
data instances, e.g., the Hopi word nahalayvi?yma 
or its phonological properties. The process of data 
migration is made much easier if a separation be-
tween data and data structure is upheld in the se-
mantic schema. 
4.1 Data content 
Linguistic data content includes linguistic ex-
pressions, the physical manifestations of language, 
also known as ?morphs?, or simply ?forms?, which 
may be written, spoken or signed. In GOLD, writ-
ten linguistic expressions are represented as 
ORTHOGRAPHICEXPRESSION with the subclasses 
ORTHOGRAPHICPART, ORTHOGRAPHICWORD, and 
ORTHOGRAPHICSENTENCE. These are defined as 
special types of strings. In order to analyze linguis-
tic data further, abstract counterparts of linguistic 
expressions are proposed called LINGUISTICUNIT. 
The abstract units are the main objects of interest 
in formal linguistics. In some theories, the various 
subclasses of LINGUISTICUNIT correspond to 
?morphemes?, ?constituents?, or ?constructions?. No 
assumptions are made about whether these have 
any mental significance, e.g. whether they are un-
derlying forms. The class hierarchy for 
LINGUISTICUNIT is presented in Farrar, Lewis and 
Langendoen (2002), and can be viewed in GOLD 
using Prot?g? 2.0 [protege.stanford.edu]. 
The LINGUISTICUNIT hierarchy is organized ac-
cording to how its components are realized as 
forms, and not according to their formal linguistic 
features, which are theory specific. So, for exam-
ple, LEXICALUNIT is simply a formal unit that can 
appear in isolation in its realized form, and not 
necessarily something that can be a constituent of 
larger syntactic constructions. The methodology 
leaves open the question of whether, for example, 
a SUBLEXICALUNIT can also be a phrasal constitu-
ent, as appears to be the case with CLITIC. Yet an-
other alternative would be to organize LINGUISTIC-
UNIT according to semantic features, e.g., a 
SUBLEXICALUNIT would be something which usu-
ally represents a grammaticized notion. But, since 
this varies from language to language, a different 
taxonomy would be needed for every type of lan-
guage encountered. To sum up, adhering to strictly 
formal features necessitates theory-specific tax-
onomies, while adhering to semantic features leads 
to language-specific taxonomies. Instead a neutral 
approach is taken in which LINGUISTICUNIT is or-
ganized according to how instances are realized as 
linguistic expressions. 
ORTHOGRAPHICEXPRESSION is related to LIN-
GUISTICUNIT by the predicate REALIZES. The par-
ticular sort of LINGUISTICUNIT is further defined 
according to what kinds of attributes it can take. 
So, a MORPHOSYNTACTICUNIT has attributes of 
the sort MORPHOSYNTACTICATTRIBUTE. Instances 
of particular attributes are PASTTENSE, SINGULAR-
NUMBER, and PROGRESSIVEASPECT. The class of 
attributes pertaining to linguistic units parallels 
other kinds of non-linguistic attributes such as 
SHAPEATTRIBUTE and PHYSICALSTATE. 
There are several varieties of attributes which 
linguists find useful for language description, in-
cluding phonological and semantic features. Se-
mantic attributes contrast with morphosyntactic 
attributes in that the former correspond to the no-
tional characteristics of linguistic form that have 
some manifestation in the grammar. 
4.2 Data structures 
A linguistic data structure is defined as an ab-
stract information container which provides a way 
to package elements of linguistic data. The two 
main types of data structures contained in GOLD 
at the moment are LEXICALITEM and FEATURE-
STRUCTURE. Our characterization of LEXICALITEM 
extends that of Bell and Bird (2000). At a mini-
mum, a LEXICALITEM should contain an instance 
of LEXICALUNIT or of SUBLEXICALUNIT. Special 
relations are given in GOLD which pertain only to 
data structures, e.g., HASLEXICALUNIT relates a 
LEXICALITEM to a LEXICALUNIT. Instances of 
LEXICALITEM typically include glosses either in 
the same language in the case of a monolingual 
lexicon, or in some other language in the case of a 
bilingual lexicon. Glosses are simply instances of 
ORTHOGRAPHICEXPRESSION related to the entry 
via the relation GLOSS. Entries relate to one an-
other via relations such as SYNONYMOF and 
ANTONYMOF. 
If a LEXICALITEM contains extensive morpho-
logical information, we may represent this in the 
form of a FEATURESTRUCTURE. The FEATURE-
STRUCTURE class is part of a more extensive set of 
data structures known as a FEATURESYSTEM (Lan-
gendoen and Simons, 1995; Maxwell, Simons and 
Hayashi, 2002). A FEATURESPECIFICATION is a 
data structure that contains a subclass and an in-
stance of MORPHOSYNTACTICATTRIBUTE (i.e. an 
ordered pair), for example, [TENSE: PASTTENSE]. 
The implementation of the FEATURESYSTEM con-
struct allows for recursive FEATURESPECIFICA-
TIONs in which, for example, a subclass of 
MORPHOSYNTACTICATTRIBUTE is paired with an 
instance of FEATURESTRUCTURE. 
One criticism that could be raised against the in-
clusion of data structures in a semantic resource 
such as GOLD is that they are superfluous. Why 
not simply leave it up to the source markup to de-
scribe the elements of data structure, e.g., in the 
form of an XML Schema? This is certainly a rea-
sonable criticism, since excluding data structures 
from GOLD would make the ontological model-
ling process much simpler. However, they are in-
cluded because we envision that subsequent appli-
cations will need to be able to reason, not only 
about the data itself, but also about how it is struc-
tured. For example, it might be necessary to com-
pare elements of a LEXICALITEM to that of 
FEATURESTRUCTURE. This is actually an essential 
step in achieving the vision of the Semantic Web, 
namely, constraining the source data in such a way 
as to preserve structure where structure is defined 
and to enrich structure where structure is left un-
specified. 
5 Semantic Interpretation Language 
The Semantic Interpretation Language (SIL) was 
originally created to define the meaning of the 
elements and attributes declared in an XML 
markup schema, as well as the relationships be-
tween them. An SIL metaschema is an XML 
document that formally maps the elements and 
attributes of an XML encoded resource to concepts 
in an OWL ontology or an RDF Schema. Further-
more, the metaschema formally interprets the 
original markup structure by declaring what the 
dominance and linking relations in the XML 
document structure represent. For example, con-
sider the extract from the Hopi lexicon shown in 
Figure 1. 
The dominance relation between the elements 
<MSI> (for ?morphosyntactic information?) and 
<POS> (for ?part of speech?) in the original XML 
is implicitly something like ?has?. This can be 
made more explicit by mapping it to HAS-
MORPHOSYNTACTICPROPERTY, a formally defined 
relation in the ontology. This relation is formally 
defined in the ontology by specifying its signature, 
i.e. what kinds of arguments it can take. Thus, a 
better defined, more exact, relationship between 
elements of markup is achieved. 
<Lexeme id="L3"> 
 <Headword>naheva</Headword> 
 <MSI> 
  <POS> 
<Feature name = "type">vt 
</Feature> 
  </POS> 
Figure 1. Extract from Hopi Lexicon 
SIL has been extended to formalize the resolu-
tion of content in addition to markup. For example, 
the semantics of the gram vt in the XML structure 
<POS>vt</POS> can be specified via a mapping 
to the ontology as an instance of VERB-
TRANSITIVE, in addition to defining the semantics 
of the POS element itself. 
An SIL metaschema, as described in detail in 
Simons (2004), is an XML document built from 
metaschema directives, which are essentially proc-
essing instructions expressed as XML elements. 
Directives like resource, property, lit-
eral and translate generate elements of the 
resulting semantic interpretation. Part of the SIL 
DTD is shown in Figure 2. 
<!ELEMENT metaschema (namespace+, 
(interpret | ignore)+)> 
<!ELEMENT namespace (#PCDATA)> 
<!ATTLIST namespace prefix CDATA 
#REQUIRED> 
<!ELEMENT interpret (resource | 
translate | property | 
literal)*> 
<!ATTLIST interpret markup CDATA 
#REQUIRED> 
<!ELEMENT resource (property | 
translate | literal | embed)*> 
<!ATTLIST resource concept CDATA 
#REQUIRED> 
<!ELEMENT property (resource | 
resourceRef | embed)> 
<!ATTLIST property concept CDATA 
#REQUIRED> 
<!ELEMENT translate EMPTY> 
<!ATTLIST translate concept CDATA 
#REQUIRED mapping CDATA 
#REQUIRED> 
Figure 2. SIL DTD fragment 
The interpret directive performs the pri-
mary mapping function from markup elements of 
the input resource to the enriched output, as dem-
onstrated in Figure 3. The tag <form> is inter-
preted as a LINGUISTICFORM, specifically as an 
ORTHOGRAPHICREPRESENTATION of that form. 
Input document: 
<form>ahali</form> 
Metaschema directive: 
<interpret markup="form"> 
<property concept = 
"gold:form"> 
<resource concept = 
"gold:LinguisticForm"> 
<literal concept = 
"gold:orthographicRepre
sentation"/> 
</resource> 
</property> 
</interpret> 
Interpretation (output): 
<gold:form> 
<gold:LinguisticForm> 
<gold:orthographicRepresen
tation>ahali 
</gold:orthographicRepresen
tation> 
</gold:LinguisticForm> 
</gold:form> 
Figure 3. Example interpretation of an element 
Of primary importance to the interpretation of 
content is the translate directive, as shown in 
Figure 4. In this example, the tag <Feature 
name="type">, embedded within <POS>, is 
interpreted as referencing a morphosyntactic prop-
erty, the value of which is content interpretable by 
the terminology set identified by the reference 
Hopi/Hopi_pos_mapping.xml. A terminol-
ogy set contains a simple mapping between terms 
used in the source document and the names of the 
equivalent concepts in the ontology. SIL can han-
dle both one-to-one terminology mappings (e.g., 
mapping from the tag vt to the concept VERB-
TRANSITIVE) as well as one-to-many mappings 
(e.g. mapping from 1sg to a property bundle of 
FIRSTPERSON and SINGULARNUMBER). 
Input document: 
<POS> 
<Feature name = "type">vt 
</Feature> 
</POS> 
Metaschema directive: 
<interpret markup = "POS/ 
Feature[@name='type']"> 
<translate concept = 
"gold:property" mapping = 
"Hopi/Hopi_pos_mapping.xml"/> 
</interpret> 
Interpretation (output): 
<gold:property rdf:resource = 
"emeld.org/gold#VerbTransitive"/> 
Figure 4. Example interpretation of content  
SIL is designed to allow interoperability be-
tween resources by mapping the different struc-
tures and content of markup in the source docu-
ments onto the same set of ontological concepts. 
This is demonstrated by comparing the trans-
formed output for Hopi shown in Figure 4 with the 
transformed output for Sikaiana in Figure 5. Note 
that the inputs are different but the outputs are the 
same. 
Input document: 
<pos>Verbt</pos> 
Metaschema directive: 
<interpret markup="pos"> 
<translate concept = 
"gold:property" mapping = 
"SKY/SKY_pos_mapping.xml"/> 
</interpret> 
Interpretation (output): 
<gold:property rdf:resource = 
"emeld.org/gold#VerbTransitive"/> 
Figure 5. Transformed Sikaiana <pos> 
The SIL only guarantees interoperability when 
comparable semantic resources are employed in 
the mapping. If an entire group relies on a common 
semantic schema, e.g. GOLD, a ?community of 
practice? is formed. This in turn facilitates intelli-
gent search across converted resources. 
Currently, writing an SIL metaschema is done 
entirely by hand. We are in the process, however, 
of developing two tools to automate the process. 
The first tool will allow the user to define the rela-
tionship between the terminology used within a 
resource with relevant GOLD concepts. The sec-
ond tool will define the structural mapping rela-
tionship between the resource and a given meta-
structure. The first tool, named Alchemy, presents 
the user with a drag-and-drop interface in which 
the user defines the terms used within her resource 
by associating them with one or more GOLD con-
cepts. The relationship between any given term 
and relevant GOLD concepts can be complex, with 
one-to-one or one-to-many relationships being al-
lowed, and the relationships themselves can be of 
any of a number of types: SameAs, KindOf, etc. 
We are in the process of building this tool, embed-
ded within an systems developer toolkit accompa-
nying GOLD. 
The second as of yet unnamed tool is still in the 
early design stages. This tool will allow the user to 
first define the type of resource she is converting 
(lexicon, interlinear text, grammar, etc.), and will 
then lead her through a series of questions that de-
fine the structure by associating it with a meta-type 
definition for the particular resource type. The tool 
will require a precise and well-defined ?semantics 
of linguistic structure?, a conceptual space of lin-
guistic structural types that will be included in 
GOLD, but is still in the process of being defined. 
The final output of this tool, in association with an 
Alchemy-defined terminology set, will be an SIL 
metaschema. 
6 Querying Resources 
In this section, we discuss the general issue of 
searching over linguistic descriptions on the Web, 
and the current state of our effort to do so using 
SeRQL (see section 3 item 4) over the RDF reposi-
tories for Sikaiana, Hopi and Potawatomi gener-
ated by the metaschemas from their XML-encoded 
lexicons. 
6.1 Dimensions of search over linguistic de-
scriptions 
As mentioned in section 1 above, one of the 
most compelling reasons to migrate XML docu-
mentation to a semantically interoperable format is 
to enable intelligent search. For the linguistics 
community, we envision several parameters of 
search over semantically interoperable linguistic 
documentation. Search may be performed accord-
ing to: 
? level of analysis (phonetic, morphosyntactic, 
discourse) 
? typological dimension (including language 
type) 
? intent of search (for exploring some particu-
lar language, or for language comparison) 
? kind of results desired (which data structure 
to return) 
Search also varies according to degree of diffi-
culty, that is, whether search requires the assis-
tance of an inferencing engine or not. Direct 
search is defined as search over explicitly repre-
sented data, i.e. instance data in the knowledge 
space. This includes the simple string matching of 
conventional search engines. But since the search 
will be carried out using the enriched RDF frame-
work, direct search is not limited to string match-
ing in the original XML. An example of direct 
search is to find all data that includes a reference to 
instances of some grammatical category (e.g., 
PASTTENSE). Boolean searching with direct search 
is also possible, e.g., searching for cases of port-
manteau morphemes, expressed in our framework 
as two or more MORPHOSYNTACTICATTRIBUTES 
associated with some LINGUISTICUNIT. 
Indirect search goes beyond direct search by 
making use of inferences based on the structuring 
of the concepts in an ontology. For example the 
concept of PLURALNUMBER means ?two or more?, 
the concept of DUALNUMBER means ?exactly two?, 
and the concept of MULTALNUMBER means ?three 
or more?. A direct search for PLURALNUMBER will 
miss those instances represented as DUALNUMBER 
and MULTALNUMBER, whereas an indirect search 
will find them. 
6.2 Some SeRQL queries 
In Figure 6, we give the SeRQL query (omitting 
using namespace) for the orthographic forms 
for all the lexical items specified as having the 
GOLD concept PROGRESSIVEASPECT in the three 
lexicons. This query returned 1135 results, all from 
Hopi.  
select distinct R 
from {LI} <gold:meaning> {} 
<gold:grammar> {} 
<gold:property> 
{<gold:ProgressiveAspect>}, 
{LI} <gold:form> {} 
<gold:orthographicRepresenta
tion> {R} 
Figure 6. SeRQL query for 
PROGRESSIVEASPECT forms 
Next, the query in Figure 7 returns all the gram-
matical properties of lexical items categorized as 
NOUNs in each of the lexicons. There were 21 re-
sults from Hopi, 3 from Sikaiana and 6 from 
Potawatomi; an example for each language is 
given in Figure 8. The fact that certain items 
categorized as NOUNs in Sikaiana are also 
categorized as VERBs indicates that those items 
have both classifications. In Figure 9, we give the 
SeRQL query for all such items; 61 results were 
obtained. 
select distinct P, LC 
from {LI} <gold:meaning> {} 
<gold:grammar> {MSI} 
<gold:property> 
{<gold:Noun>}; 
<gold:property> {P}, 
{LI} <gold:languageCode> {LC} 
where P != <gold:Noun> 
Figure 7. SeRQL query for attributes of NOUNs 
Hopi: AUGMENTATIVE 
Sikaiana: VERB 
Potawatomi: INANIMATE 
Figure 8. Sample results of query in Figure 7 
select distinct LI 
from {LI} <gold:meaning> {} 
<gold:grammar> {} 
<gold:property> {<gold:Noun>}; 
<gold:property> {<gold:Verb>} 
Figure 9. SeRQL query for all lexical items 
marked as both NOUN and VERB 
Finally in Figure 10, we give a query used to 
find the parts of speech that are common to entries 
in the Hopi and Sikaiana lexicons. Four results 
were returned, NOUN, VERB, ADJECTIVE and 
NUMERAL. 
select distinct P 
from {LI} <gold:meaning> {} 
<gold:grammar> {} 
<gold:property> {P},  
{LI2} <gold:meaning> {} 
<gold:grammar> {} 
<gold:property> {P},  
{LI} <gold:languageCode> {LC}, 
{LI2} <gold:languageCode> 
{LC2} 
where LC = "HOP" AND LC2 = "SKY" 
Figure 10. SeRQL query for common parts of 
speech in two lexicons 
More complex queries that take advantage of the 
structure of the ontology are also possible, for ex-
ample to find all the verbs in the lexicons regard-
less of whether they have been tagged as transitive 
verbs, intransitive verbs, or simply as verbs. With 
further development of the method described here, 
much more elaborate queries over much larger lin-
guistic data repositories will be possible. This re-
sult, we hope, will encourage much more wide-
spread distribution of language resources on the 
Web and the creation of a large community of 
practice that uses those resources for research, 
teaching, and language revitalization efforts. 
References  
J. Bell and S. Bird. 2000. A preliminary study of 
the structure of lexicon entries. In ?Workshop on 
Web-Based Language Documentation and De-
scription?, Philadelphia. 
[www.ldc.upenn.edu/exploration/expl2000/papers
/bell/bell.html] 
S. Bird and G. F. Simons. 2003. Seven dimensions 
of portability for language documentation and 
description. Language 79(3):557-582. 
D. Brickley and R. V. Guha. 2004. RDF Vocabu-
lary Description Language 1.0: RDF Schema. 
W3C Recommendation 10 February 2004, 
World Wide Web Consortium.  
[www.w3.org/TR/rdf-schema] 
J. Broekstra, A. Kampman and F. van Harmelen. 
2002. Sesame: A generic architecture for storing 
and querying RDF and RDF schema. In ?Pro-
ceedings of the First International Semantic Web 
Conference?, I. Horrocks & J. Hendler, ed., 
pages 54-68, Springer-Verlag, Berlin. 
S. O. Farrar and D. T. Langendoen. 2003. A lin-
guistic ontology for the Semantic Web. Glot In-
ternational 7(3):97-100. 
S. O. Farrar, W. D. Lewis and D. T. Langendoen. 
2002. An ontology for linguistic annotation. In 
?Semantic Web Meets Language Resources: Pa-
pers from the AAAI Workshop?, N. Ide & C. 
Welty, ed., pages 11-16, AAAI Press, Menlo 
Park, CA. 
V. Haarslev and R. Moller. 2001. Description of 
the RACER system and its applications. In ?Pro-
ceedings of the Description Logics Workshop 
DL2001?, pages 132-142, Stanford, CA. 
N. Ide and L. Romary. 2003. Outline of the inter-
national standard Linguistic Annotation Frame-
work. In ?Proceedings of ACL?03 Workshop on 
Linguistic Annotation: Getting the Model 
Right?, pages 1-5, Sapporo.  
[www.cs.vassar.edu/~ide/papers/acl2003-ws-
laf.pdf] 
N. Ide, L. Romary and E. de la Clergerie. 2003. 
International standard for a Linguistic Annota-
tion Framework. In ?Proceedings of HLT-
NAACL'03 Workshop on The Software Engi-
neering and Architecture of Language Technol-
ogy?, Edmonton. 
[www.cs.vassar.edu/~ide/papers/ide-romary-
clergerie.pdf] 
D. T. Langendoen and G. F. Simons. 1995. A ra-
tionale for the Text Encoding Initiative recom-
mendations for feature-structure markup. Com-
puters and the Humanities 29:191-205. 
C. Masolo, S. Borgo, A. Gangemi, N. Guarino, A. 
Oltramari and L. Schneider. 2002. WonderWeb 
deliverable D17 version 2.0. In ?The Wonder-
Web Library of Foundational Ontologies and the 
DOLCE ontology.? 
[www.loa-cnr.it/Papers/WonderWebD17V2.0.pdf] 
M. Maxwell, G. F. Simons and L. Hayashi. 2002. 
A morphological glossing assistant. In ?Proceed-
ings of the International Workshop on Resources 
and Tools in Field Linguistics?, Las Palmas, 
Spain. 
[www.mpi.nl/lrec/papers/lrec-pap-25-
MorphologicalGlossingAssistant.pdf] 
D. L. McGuinness and F. van Harmelen, ed. 2004. 
OWL Web Ontology Language overview.  
[www.w3.org/TR/2004/REC-owl-features-
20040210] 
I. Niles and A. Pease. 2001. Toward a standard 
upper ontology. In ?Proceedings of the 2nd In-
ternational conference on Formal Ontology in 
Information Systems?, Ogunquit, ME. 
[projects.teknowledge.com/HPKB/Publications/
FOIS.pdf] 
G. F. Simons. 2003. Developing a metaschema 
language to support interoperation among XML 
resources with different markup schemas. Paper 
presented at the ACH/ALLC conference, Athens, 
GA. 
[www.sil.org/~simonsg/metaschema/ACH%202
003.pdf] 
G. F. Simons. 2004. A metaschema language for 
the semantic interpretation of XML markup in 
documents. Technical report, SIL, Dallas. 
[www.sil.org/~simonsg/metaschema/sil.htm] 
C. M. Sperberg-McQueen and L. Burnard, eds. 
2002. TEI P4: Guidelines for electronic text en-
coding and interchange, XML version, Text En-
coding Initiative Consortium, Oxford etc. 
[www.tei-c.org/P4X] 
C. M. Sperberg-McQueen, C. Huitfeldt, and A. 
Renear. 2000. Meaning and interpretation of 
markup. Markup Languages: Theory and Prac-
tice 2:215-234. 
User Guide for Sesame. 2004.  
[www.openrdf.org/publications/users/index.html] 
