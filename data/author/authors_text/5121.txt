MATCH: An Architecture for Multimodal Dialogue Systems
Michael Johnston, Srinivas Bangalore, Gunaranjan Vasireddy, Amanda Stent
Patrick Ehlen, Marilyn Walker, Steve Whittaker, Preetam Maloor
AT&T Labs - Research, 180 Park Ave, Florham Park, NJ 07932, USA
johnston,srini,guna,ehlen,walker,stevew,pmaloor@research.att.com
Now at SUNY Stonybrook, stent@cs.sunysb.edu
Abstract
Mobile interfaces need to allow the user
and system to adapt their choice of com-
munication modes according to user pref-
erences, the task at hand, and the physi-
cal and social environment. We describe a
multimodal application architecture which
combines finite-state multimodal language
processing, a speech-act based multimodal
dialogue manager, dynamic multimodal
output generation, and user-tailored text
planning to enable rapid prototyping of
multimodal interfaces with flexible input
and adaptive output. Our testbed appli-
cation MATCH (Multimodal Access To
City Help) provides a mobile multimodal
speech-pen interface to restaurant and sub-
way information for New York City.
1 Multimodal Mobile Information Access
In urban environments tourists and residents alike
need access to a complex and constantly changing
body of information regarding restaurants, theatre
schedules, transportation topology and timetables.
This information is most valuable if it can be de-
livered effectively while mobile, since places close
and plans change. Mobile information access devices
(PDAs, tablet PCs, next-generation phones) offer
limited screen real estate and no keyboard or mouse,
making complex graphical interfaces cumbersome.
Multimodal interfaces can address this problem by
enabling speech and pen input and output combining
speech and graphics (See (Andre?, 2002) for a detailed
overview of previous work on multimodal input and
output). Since mobile devices are used in different
physical and social environments, for different tasks,
by different users, they need to be both flexible in in-
put and adaptive in output. Users need to be able to
provide input in whichever mode or combination of
modes is most appropriate, and system output should
be dynamically tailored so that it is maximally effec-
tive given the situation and the user?s preferences.
We present our testbed multimodal application
MATCH (Multimodal Access To City Help) and the
general purpose multimodal architecture underlying
it, that: is designed for highly mobile applications;
enables flexible multimodal input; and provides flex-
ible user-tailored multimodal output.
Figure 1: MATCH running on Fujitsu PDA
Highly mobile MATCH is a working city guide
and navigation system that currently enables mobile
users to access restaurant and subway information for
New York City (NYC). MATCH runs standalone on
a Fujitsu pen computer (Figure 1), and can also run
in client-server mode across a wireless network.
Flexible multimodal input Users interact with a
graphical interface displaying restaurant listings and
a dynamic map showing locations and street infor-
mation. They are free to provide input using speech,
by drawing on the display with a stylus, or by us-
ing synchronous multimodal combinations of the two
modes. For example, a user might ask to see cheap
                Computational Linguistics (ACL), Philadelphia, July 2002, pp. 376-383.
                         Proceedings of the 40th Annual Meeting of the Association for
Italian restaurants in Chelsea by saying show cheap
italian restaurants in chelsea, by circling an area on
the map and saying show cheap italian restaurants
in this neighborhood; or, in a noisy or public envi-
ronment, by circling an area and writing cheap and
italian (Figure 2). The system will then zoom to the
appropriate map location and show the locations of
restaurants on the map. Users can ask for information
about restaurants, such as phone numbers, addresses,
and reviews. For example, a user might circle three
restaurants as in Figure 3 and say phone numbers for
these three restaurants (or write phone). Users can
also manipulate the map interface directly. For exam-
ple, a user might say show upper west side or circle
an area and write zoom.
Figure 2: Unimodal pen command
Flexible multimodal output MATCH provides
flexible, synchronized multimodal generation and
can take initiative to engage in information-seeking
subdialogues. If a user circles the three restaurants in
Figure 3 and writes phone, the system responds with
a graphical callout on the display, synchronized with
a text-to-speech (TTS) prompt of the phone number,
for each restaurant in turn (Figure 4).
Figure 3: Two area gestures
Figure 4: Phone query callouts
The system also provides subway directions. If the
user says How do I get to this place? and circles one
of the restaurants displayed on the map, the system
will ask Where do you want to go from? The user
can then respond with speech (e.g., 25th Street and
3rd Avenue), with pen by writing (e.g., 25th St & 3rd
Ave), or multimodally ( e.g, from here with a circle
gesture indicating location). The system then calcu-
lates the optimal subway route and dynamically gen-
erates a multimodal presentation of instructions. It
starts by zooming in on the first station and then grad-
ually zooms out, graphically presenting each stage of
the route along with a series of synchronized TTS
prompts. Figure 5 shows the final display of a sub-
way route heading downtown on the 6 train and trans-
ferring to the L train Brooklyn bound.
Figure 5: Multimodal subway route
User-tailored generation MATCH can also pro-
vide a user-tailored summary, comparison, or rec-
ommendation for an arbitrary set of restaurants, us-
ing a quantitative model of user preferences (Walker
et al, 2002). The system will only discuss restau-
rants that rank highly according to the user?s dining
preferences, and will only describe attributes of those
restaurants the user considers important. This per-
mits concise, targeted system responses. For exam-
ple, the user could say compare these restaurants and
circle a large set of restaurants (Figure 6). If the user
considers inexpensiveness and food quality to be the
most important attributes of a restaurant, the system
response might be:
Compare-A: Among the selected restaurants, the following
offer exceptional overall value. Uguale?s price is 33 dollars. It
has excellent food quality and good decor. Da Andrea?s price is
28 dollars. It has very good food quality and good decor. John?s
Pizzeria?s price is 20 dollars. It has very good food quality and
mediocre decor.
Figure 6: Comparing a large set of restaurants
2 Multimodal Application Architecture
The multimodal architecture supporting MATCH
consists of a series of agents which communicate
through a facilitator MCUBE (Figure 7).
Figure 7: Multimodal Architecture
MCUBE is a Java-based facilitator which enables
agents to pass messages either to single agents or
groups of agents. It serves a similar function to sys-
tems such as OAA (Martin et al, 1999), the use of
KQML for messaging in Allen et al(2000), and the
Communicator hub (Seneff et al, 1998). Agents may
reside either on the client device or elsewhere on the
network and can be implemented in multiple differ-
ent languages. MCUBE messages are encoded in
XML, providing a general mechanism for message
parsing and facilitating logging.
Multimodal User Interface Users interact with
the system through the Multimodal UI, which is
browser-based and runs in Internet Explorer. This
greatly facilitates rapid prototyping, authoring, and
reuse of the system for different applications since
anything that can appear on a webpage (dynamic
HTML, ActiveX controls, etc.) can be used in
the visual component of a multimodal user inter-
face. A TCP/IP control enables communication with
MCUBE.
MATCH uses a control that provides a dynamic
pan-able, zoomable map display. The control has ink
handling capability. This enables both pen-based in-
teraction (on the map) and normal GUI interaction
(on the rest of the page) without requiring the user to
overtly switch ?modes?. When the user draws on the
map their ink is captured and any objects potentially
selected, such as currently displayed restaurants, are
identified. The electronic ink is broken into a lat-
tice of strokes and sent to the gesture recognition
and handwriting recognition components which en-
rich this stroke lattice with possible classifications of
strokes and stroke combinations. The UI then trans-
lates this stroke lattice into an ink meaning lattice
representing all of the possible interpretations of the
user?s ink and sends it to MMFST.
In order to provide spoken input the user must tap
a click-to-speak button on the Multimodal UI. We
found that in an application such as MATCH which
provides extensive unimodal pen-based interaction, it
is preferable to use click-to-speak rather than pen-
to-speak or open-mike. With pen-to-speak, spurious
speech results received in noisy environments can
disrupt unimodal pen commands.
The Multimodal UI also provides graphical output
capabilities and performs synchronization of multi-
modal output. For example, it synchronizes the dis-
play actions and TTS prompts in the answer to the
route query mentioned in Section 1.
Speech Recognition MATCH uses AT&T?s Wat-
son speech recognition engine. A speech manager
running on the device gathers audio and communi-
cates with a recognition server running either on the
device or on the network. The recognition server pro-
vides word lattice output which is passed to MMFST.
Gesture and handwriting recognition Gesture
and handwriting recognition agents provide possible
classifications of electronic ink for the UI. Recogni-
tions are performed both on individual strokes and
combinations of strokes in the input ink lattice. The
handwriting recognizer supports a vocabulary of 285
words, including attributes of restaurants (e.g. ?chi-
nese?,?cheap?) and zones and points of interest (e.g.
?soho?,?empire?,?state?,?building?). The gesture rec-
ognizer recognizes a set of 10 basic gestures, includ-
ing lines, arrows, areas, points, and question marks.
It uses a variant of Rubine?s classic template-based
gesture recognition algorithm (Rubine, 1991) trained
on a corpus of sample gestures. In addition to classi-
fying gestures the gesture recognition agent also ex-
tracts features such as the base and head of arrows.
Combinations of this basic set of gestures and hand-
written words provide a rich visual vocabulary for
multimodal and pen-based commands.
Gestures are represented in the ink meaning lat-
tice as symbol complexes of the following form: G
FORM MEANING (NUMBER TYPE) SEM. FORM
indicates the physical form of the gesture and has val-
ues such as area, point, line, arrow. MEANING indi-
cates the meaning of that form; for example an area
can be either a loc(ation) or a sel(ection). NUMBER
and TYPE indicate the number of entities in a selec-
tion (1,2,3, many) and their type (rest(aurant), the-
atre). SEM is a place holder for the specific content
of the gesture, such as the points that make up an area
or the identifiers of objects in a selection.
When multiple selection gestures are present
an aggregation technique (Johnston and Bangalore,
2001) is employed to overcome the problems with
deictic plurals and numerals described in John-
ston (2000). Aggregation augments the ink meaning
lattice with aggregate gestures that result from com-
bining adjacent selection gestures. This allows a de-
ictic expression like these three restaurants to com-
bine with two area gestures, one which selects one
restaurant and the other two, as long as their sum is
three. For example, if the user makes two area ges-
tures, one around a single restaurant and the other
around two restaurants (Figure 3), the resulting ink
meaning lattice will be as in Figure 8. The first ges-
ture (node numbers 0-7) is either a reference to a
location (loc.) (0-3,7) or a reference to a restaurant
(sel.) (0-2,4-7). The second (nodes 7-13,16) is either
a reference to a location (7-10,16) or to a set of two
restaurants (7-9,11-13,16). The aggregation process
applies to the two adjacent selections and adds a se-
lection of three restaurants (0-2,4,14-16). If the user
says show chinese restaurants in this neighborhood
and this neighborhood, the path containing the two
locations (0-3,7-10,16) will be taken when this lat-
tice is combined with speech in MMFST. If the user
says tell me about this place and these places, then
the path with the adjacent selections is taken (0-2,4-
9,11-13,16). If the speech is tell me about these or
phone numbers for these three restaurants then the
aggregate path (0-2,4,14-16) will be chosen.
Multimodal Integrator (MMFST) MMFST re-
ceives the speech lattice (from the Speech Manager)
and the ink meaning lattice (from the UI) and builds
a multimodal meaning lattice which captures the po-
tential joint interpretations of the speech and ink in-
puts. MMFST is able to provide rapid response times
by making unimodal timeouts conditional on activity
in the other input mode. MMFST is notified when the
user has hit the click-to-speak button, when a speech
result arrives, and whether or not the user is inking on
the display. When a speech lattice arrives, if inking
is in progress MMFST waits for the ink meaning lat-
tice, otherwise it applies a short timeout (1 sec.) and
treats the speech as unimodal. When an ink meaning
lattice arrives, if the user has tapped click-to-speak
MMFST waits for the speech lattice to arrive, other-
wise it applies a short timeout (1 sec.) and treats the
ink as unimodal.
MMFST uses the finite-state approach to multi-
modal integration and understanding proposed by
Johnston and Bangalore (2000). Possibilities for
multimodal integration and understanding are cap-
tured in a three tape device in which the first tape
represents the speech stream (words), the second the
ink stream (gesture symbols) and the third their com-
bined meaning (meaning symbols). In essence, this
device takes the speech and ink meaning lattices as
inputs, consumes them using the first two tapes, and
writes out a multimodal meaning lattice using the
third tape. The three tape finite-state device is sim-
ulated using two transducers: G:W which is used to
align speech and ink and G W:M which takes a com-
posite alphabet of speech and gesture symbols as in-
put and outputs meaning. The ink meaning lattice
G and speech lattice W are composed with G:W and
the result is factored into an FSA G W which is com-
posed with G W:M to derive the meaning lattice M.
In order to capture multimodal integration using
finite-state methods, it is necessary to abstract over
specific aspects of gestural content (Johnston and
Bangalore, 2000). For example, all possible se-
quences of coordinates that could occur in an area
gesture cannot be encoded in the finite-state device.
We employ the approach proposed in (Johnston and
Bangalore, 2001) in which the ink meaning lattice is
converted to a transducer I:G, where G are gesture
symbols (including SEM) and I contains both gesture
symbols and the specific contents. I and G differ only
in cases where the gesture symbol on G is SEM, in
which case the corresponding I symbol is the specific
interpretation. After multimodal integration a pro-
jection G:M is taken from the result G W:M machine
and composed with the original I:G in order to rein-
corporate the specific contents that were left out of
the finite-state process (I:G o G:M = I:M).
The multimodal finite-state transducers used at
runtime are compiled from a declarative multimodal
context-free grammar which captures the structure
Figure 8: Ink Meaning Lattice
and interpretation of multimodal and unimodal com-
mands, approximated where necessary using stan-
dard approximation techniques (Nederhof, 1997).
This grammar captures not just multimodal integra-
tion patterns but also the parsing of speech and ges-
ture, and the assignment of meaning. In Figure 9 we
present a small simplified fragment capable of han-
dling MATCH commands such as phone numbers for
these three restaurants. A multimodal CFG differs
from a normal CFG in that the terminals are triples:
W:G:M, where W is the speech stream (words), G
the ink stream (gesture symbols) and M the meaning
stream (meaning symbols). An XML representation
for meaning is used to facilate parsing and logging
by other system components. The meaning tape sym-
bols concatenate to form coherent XML expressions.
The epsilon symbol (eps) indicates that a stream is
empty in a given terminal.
When the user says phone numbers for these
three restaurants and circles two groups of restau-
rants (Figure 3). The gesture lattice (Figure 8) is
turned into a transducer I:G with the same sym-
bol on each side except for the SEM arcs which are
split. For example, path 15-16 SEM([id1,id2,id3])
becomes [id1,id2,id3]:SEM. After G and the speech
W are integrated using G:W and G W:M. The G path
in the result is used to re-establish the connection
between SEM symbols and their specific contents
in I:G (I:G o G:M = I:M). The meaning read off
I:M is<cmd><phone><restaurant> [id1,id2,id3]
</restaurant> </phone> </cmd>. This is passed
to the multimodal dialog manager (MDM) and from
there to the Multimodal UI resulting in a display like
Figure 4 with coordinated TTS output. Since the
speech input is a lattice and there is also potential
for ambiguity in the multimodal grammar, the output
from MMFST to MDM is an N-best list of potential
multimodal interpretations.
Multimodal Dialog Manager (MDM) The MDM
is based on previous work on speech-act based mod-
els of dialog (Stent et al, 1999; Rich and Sidner,
1998). It uses a Java-based toolkit for writing dialog
managers that is similar in philosophy to TrindiKit
(Larsson et al, 1999). It includes several rule-based
S ! eps:eps:<cmd> CMD eps:eps:</cmd>
CMD ! phone:eps:<phone> numbers:eps:eps
for:eps:eps DEICTICNP
eps:eps:</phone>
DEICTICNP ! DDETPL eps:area:eps eps:selection:eps
NUM RESTPL eps:eps:<restaurant>
eps:SEM:SEM eps:eps:</restaurant>
DDETPL ! these:G:eps
RESTPL ! restaurants:restaurant:eps
NUM ! three:3:eps
Figure 9: Multimodal grammar fragment
processes that operate on a shared state. The state
includes system and user intentions and beliefs, a di-
alog history and focus space, and information about
the speaker, the domain and the available modalities.
The processes include interpretation, update, selec-
tion and generation processes.
The interpretation process takes as input an N-best
list of possible multimodal interpretations for a user
input from MMFST. It rescores them according to a
set of rules that encode the most likely next speech
act given the current dialogue context, and picks the
most likely interpretation from the result. The update
process updates the dialogue context according to the
system?s interpretation of user input. It augments the
dialogue history, focus space, models of user and sys-
tem beliefs, and model of user intentions. It also al-
ters the list of current modalities to reflect those most
recently used by the user.
The selection process determines the system?s next
move(s). In the case of a command, request or ques-
tion, it first checks that the input is fully specified
(using the domain ontology, which contains informa-
tion about required and optional roles for different
types of actions); if it is not, then the system?s next
move is to take the initiative and start an information-
gathering subdialogue. If the input is fully specified,
the system?s next move is to perform the command or
answer the question; to do this, MDM communicates
with the UI. Since MDM is aware of the current set
of preferred modalities, it can provide feedback and
responses tailored to the user?s modality preferences.
The generation process performs template-based
generation for simple responses and updates the sys-
tem?s model of the user?s intentions after generation.
The text planner is used for more complex genera-
tion, such as the generation of comparisons.
In the route query example in Section 1, MDM first
receives a route query in which only the destination
is specified How do I get to this place? In the se-
lection phase it consults the domain model and de-
termines that a source is also required for a route.
It adds a request to query the user for the source to
the system?s next moves. This move is selected and
the generation process selects a prompt and sends it
to the TTS component. The system asks Where do
you want to go from? If the user says or writes 25th
Street and 3rd Avenue then MMFST will assign this
input two possible interpretations. Either this is a re-
quest to zoom the display to the specified location or
it is an assertion of a location. Since the MDM dia-
logue state indicates that it is waiting for an answer
of the type location, MDM reranks the assertion as
the most likely interpretation. A generalized overlay
process (Alexandersson and Becker, 2001) is used to
take the content of the assertion (a location) and add
it into the partial route request. The result is deter-
mined to be complete. The UI resolves the location
to map coordinates and passes on a route request to
the SUBWAY component.
We found this traditional speech-act based dia-
logue manager worked well for our multimodal inter-
face. Critical in this was our use of a common seman-
tic representation across spoken, gestured, and multi-
modal commands. The majority of the dialogue rules
operate in a mode-independent fashion, giving users
flexibility in the mode they choose to advance the di-
alogue. On the other hand, mode sensitivity is also
important since user modality choice can be used to
determine system mode choice for confirmation and
other responses.
Subway Route Constraint Solver (SUBWAY)
This component has access to an exhaustive database
of the NYC subway system. When it receives a route
request with the desired source and destination points
from the Multimodal UI, it explores the search space
of possible routes to identify the optimal one, using a
cost function based on the number of transfers, over-
all number of stops, and the walking distance from
the station at each end. It builds a list of actions re-
quired to reach the destination and passes them to the
multimodal generator.
Multimodal Generator and Text-to-speech The
multimodal generator processes action lists from
SUBWAY and other components and assigns appro-
priate prompts for each action using a template-based
generator. The result is a ?score? of prompts and ac-
tions which is passed to the Multimodal UI. The Mul-
timodal UI plays this ?score? by coordinating changes
in the interface with the corresponding TTS prompts.
AT&T?s Natural Voices TTS engine is used to pro-
vide the spoken output. When the UI receives a mul-
timodal score, it builds a stack of graphical actions
such as zooming the display to a particular location
or putting up a graphical callout. It then sends the
prompts to be rendered by the TTS server. As each
prompt is synthesized the TTS server sends progress
notifications to the Multimodal UI, which pops the
next graphical action off the stack and executes it.
Text Planner and User Model The text plan-
ner receives instructions from MDM for execution
of ?compare?, ?summarize?, and ?recommend? com-
mands. It employs a user model based on multi-
attribute decision theory (Carenini and Moore, 2001).
For example, in order to make a comparison between
the set of restaurants shown in Figure 6, the text
planner first ranks the restaurants within the set ac-
cording to the predicted ranking of the user model.
Then, after selecting a small set of the highest ranked
restaurants, it utilizes the user model to decide which
restaurant attributes are important to mention. The
resulting text plan is converted to text and sent to TTS
(Walker et al, 2002). A user model for someone who
cares most highly about cost and secondly about food
quality and decor leads to a system response such as
that in Compare-A above. A user model for someone
whose selections are driven by food quality and food
type first, and cost only second, results in a system
response such as that shown in Compare-B.
Compare-B: Among the selected restaurants, the following of-
fer exceptional overall value. Babbo?s price is 60 dollars. It has
superb food quality. Il Mulino?s price is 65 dollars. It has superb
food quality. Uguale?s price is 33 dollars. It has excellent food.
Note that the restaurants selected for the user who
is not concerned about cost includes two rather more
expensive restaurants that are not selected by the text
planner for the cost-oriented user.
Multimodal Logger User studies, multimodal data
collection, and debugging were accomplished by in-
strumenting MATCH agents to send details of user
inputs, system processes, and system outputs to a log-
ger agent that maintains an XML log designed for
multimodal interactions. Our critical objective was
to collect data continually throughout system devel-
opment, and to be able to do so in mobile settings.
While this rendered the common practice of video-
taping user interactions impractical, we still required
high fidelity records of each multimodal interaction.
To address this problem, MATCH logs the state of
the UI and the user?s ink, along with detailed data
from other components. These components can in
turn dynamically replay the user?s speech and ink as
they were originally received, and show how the sys-
tem responded. The browser- and component-based
architecture of the Multimodal UI facilitated its reuse
in a Log Viewer that reads multimodal log files, re-
plays interactions between the user and system, and
allows analysis and annotation of the data. MATCH?s
logging system is similar in function to STAMP (Ovi-
att and Clow, 1998), but does not require multimodal
interactions to be videotaped and allows rapid re-
configuration for different annotation tasks since it
is browser-based. The ability of the system to log
data standalone is important, since it enables testing
and collection of multimodal data in realistic mobile
environments without relying on external equipment.
3 Experimental Evaluation
Our multimodal logging infrastructure enabled
MATCH to undergo continual user trials and evalu-
ation throughout development. Repeated evaluations
with small numbers of test users both in the lab and
in mobile settings (Figure 10) have guided the design
and iterative development of the system.
Figure 10: Testing MATCH in NYC
This iterative development approach highlighted
several important problems early on. For example,
while it was originally thought that users would for-
mulate queries and navigation commands primarily
by specifying the names of New York neighborhoods,
as in show italian restaurants in chelsea, early field
test studies in the city revealed that the need for
neighborhood names in the grammar was minimal
compared to the need for cross-streets and points of
interest; hence, cross-streets and a sizable list of land-
marks were added. Other early tests revealed the
need for easily accessible ?cancel? and ?undo? fea-
tures that allow users to make quick corrections. We
also discovered that speech recognition performance
was initially hindered by placement of the ?click-to-
speak? button and the recognition feedback box on
the bottom-right side of the device, leading many
users to speak ?to? this area, rather than toward the
microphone on the upper left side. This placement
also led left-handed users to block the microphone
with their arms when they spoke. Moving the but-
ton and the feedback box to the top-left of the device
resolved both of these problems.
After initial open-ended piloting trials, more struc-
tured user tests were conducted, for which we devel-
oped a set of six scenarios ordered by increasing level
of difficulty. These required the test user to solve
problems using the system. These scenarios were left
as open-ended as possible to elicit natural responses.
Sample scenario:You have plans to meet your aunt for dinner
later this evening at a Thai restaurant on the Upper West Side
near her apartment on 95th St. and Broadway. Unfortunately,
you forgot what time you?re supposed to meet her, and you can?t
reach her by phone. Use MATCH to find the restaurant and write
down the restaurant?s telephone number so you can check on the
reservation time.
Test users received a brief tutorial that was inten-
tionally vague and broad in scope so the users might
overestimate the system?s capabilities and approach
problems in new ways. Figure 11 summarizes re-
sults from our last scenario-based data collection for
a fixed version of the system. There were five sub-
jects (2 male, 3 female) none of whom had been in-
volved in system development. All of these five tests
were conducted indoors in offices.
exchanges 338 asr word accuracy 59.6%
speech only 171 51% asr sent. accuracy 36.1%
multimodal 93 28% handwritten sent. acc. 64%
pen only 66 19% task completion rate 85%
GUI actions 8 2% average time/scenario 6.25m
Figure 11: MATCH study
There were an average of 12.75 multimodal ex-
changes (pairs of user input and system response) per
scenario. The overall time per scenario varied from
1.5 to to 15 minutes. The longer completion times
resulted from poor ASR performance for some of the
users. Although ASR accuracy was low, overall task
completion was high, suggesting that the multimodal
aspects of the system helped users to complete tasks.
Unimodal pen commands were recognized more suc-
cessfully than spoken commands; however, only 19%
of commands were pen only. In ongoing work, we
are exploring strategies to increase users? adoption of
more robust pen-based and multimodal input.
MATCH has a very fast system response time.
Benchmarking a set of speech, pen, and multimodal
commands, the average response time is approxi-
mately 3 seconds (time from end of user input to sys-
tem response). We are currently completing a larger
scale scenario-based evaluation and an independent
evaluation of the functionality of the text planner.
In addition to MATCH, the same multimodal ar-
chitecture has been used for two other applications:
a multimodal interface to corporate directory infor-
mation and messaging and a medical application to
assist emergency room doctors. The medical proto-
type is the most recent and demonstrates the utility of
the architecture for rapid prototyping. System devel-
opment took under two days for two people.
4 Conclusion
The MATCH architecture enables rapid develop-
ment of mobile multimodal applications. Combin-
ing finite-state multimodal integration with a speech-
act based dialogue manager enables users to interact
flexibly using speech, pen, or synchronized combina-
tions of the two depending on their preferences, task,
and physical and social environment. The system
responds by generating coordinated multimodal pre-
sentations adapted to the multimodal dialog context
and user preferences. Features of the system such
as the browser-based UI and general purpose finite-
state architecture for multimodal integration facili-
tate rapid prototyping and reuse of the technology for
different applications. The lattice-based finite-state
approach to multimodal understanding enables both
multimodal integration and dialogue context to com-
pensate for recognition errors. The multimodal log-
ging infrastructure has enabled an iterative process
of pro-active evaluation and data collection through-
out system development. Since we can replay multi-
modal interactions without video we have been able
to log and annotate subjects both in the lab and in
NYC throughout the development process and use
their input to drive system development.
Acknowledgements
Thanks to AT&T Labs and DARPA (contract MDA972-99-3-
0003) for financial support. We would also like to thank Noemie
Elhadad, Candace Kamm, Elliot Pinson, Mazin Rahim, Owen
Rambow, and Nika Smith.
References
J. Alexandersson and T. Becker. 2001. Overlay as the ba-
sic operation for discourse processing in a multimodal
dialogue system. In 2nd IJCAI Workshop on Knowl-
edge and Reasoning in Practical Dialogue Systems.
J. Allen, D. Byron, M. Dzikovska, G. Ferguson,
L. Galescu, and A. Stent. 2000. An architecture for
a generic dialogue shell. JNLE, 6(3).
E. Andre?. 2002. Natural language in multime-
dia/multimodal systems. In Ruslan Mitkov, editor,
Handbook of Computational Linguistics. OUP.
G. Carenini and J. D. Moore. 2001. An empirical study of
the influence of user tailoring on evaluative argument
effectiveness. In IJCAI, pages 1307?1314.
M. Johnston and S. Bangalore. 2000. Finite-state mul-
timodal parsing and understanding. In Proceedings of
COLING 2000, Saarbru?cken, Germany.
M. Johnston and S. Bangalore. 2001. Finite-state meth-
ods for multimodal parsing and integration. In ESSLLI
Workshop on Finite-state Methods, Helsinki, Finland.
M. Johnston. 2000. Deixis and conjunction in mul-
timodal systems. In Proceedings of COLING 2000,
Saarbru?cken, Germany.
S. Larsson, P. Bohlin, J. Bos, and D. Traum. 1999.
TrindiKit manual. Technical report, TRINDI Deliver-
able D2.2.
D. Martin, A. Cheyer, and D. Moran. 1999. The Open
Agent Architecture: A framework for building dis-
tributed software systems. Applied Artificial Intelli-
gence, 13(1?2):91?128.
M-J. Nederhof. 1997. Regular approximations of CFLs:
A grammatical view. In Proceedings of the Interna-
tional Workshop on Parsing Technology, Boston.
S. L. Oviatt and J. Clow. 1998. An automated tool for
analysis of multimodal system performance. In Pro-
ceedings of ICSLP.
C. Rich and C. Sidner. 1998. COLLAGEN: A collabora-
tion manager for software interface agents. User Mod-
eling and User-Adapted Interaction, 8(3?4):315?350.
D. Rubine. 1991. Specifying gestures by example. Com-
puter graphics, 25(4):329?337.
S. Seneff, E. Hurley, R. Lau, C. Pao, P. Schmid, and
V. Zue. 1998. Galaxy-II: A reference architecture for
conversational system development. In ICSLP-98.
A. Stent, J. Dowding, J. Gawron, E. Bratt, and R. Moore.
1999. The CommandTalk spoken dialogue system. In
Proceedings of ACL?99.
M. A. Walker, S. J. Whittaker, P. Maloor, J. D. Moore,
M. Johnston, and G. Vasireddy. 2002. Speech-Plans:
Generating evaluative responses in spoken dialogue. In
In Proceedings of INLG-02.
Dynamic User Level and Utility Measurement for Adaptive 
Dialog in a Help-Desk System 
Preetam Maloor 
Department ofComputer Science, 
Texas A & M University, 
College Station, TX 77843, USA 
preetam@csdl.tamu.edu 
Joyee Chai 
Conversational Machines 
IBM T. J. Watson Research Center, 
Hawthorne, NY 10532, USA 
jchai@us.ibm.com 
Abstract 
The learning and self-adaptive capability in 
dialog systems has become increasingly 
important with the advances in a wide range of 
applications. For any application, particularly 
the one dealing with a technical domain, the 
system should pay attention to not only the user 
experience level and dialog goals, but more 
importantly, the mechanism to adapt he system 
behavior to the evolving state of the user. This 
paper describes a methodology that first 
identifies the user experience level and utility 
metrics of the goal and sub-goals, then 
automatically adjusts those parameters based on 
discourse history and thus directs adaptive 
dialog management. 
Introduction 
A new generation of dialog systems hould be 
viewed as learning systems rather than static 
models (Jokinen, 2000). Close-world and 
static approaches have tremendous limitations 
and often fail when the task becomes complex 
and the application environment and 
knowledge changes. Thus, the learning 
capability of a dialog system has become an 
important issue. It has been addressed in many 
different aspects including dynamic 
construction of mutual knowledge (Andersen 
et al 1999), learning of speech acts (Stolcker 
et al 1998), learning optimal strategies 
(Litman et al 1998; Litman et al 1999; 
Walker et al 1998), collaborative agent in plan 
recognition (Lesh et al 1999), etc. This paper 
addresses the dynamic user modeling and 
dialog-goal utility measurement to facilitate 
adaptive dialog behavior. 
For any dialog system dealing with a technical 
domain, such as repair support (Weis, 1997), 
help-desk support, etc, it is crucial for the 
system not only to pay attention to the user 
knowledge and experience level and dialog 
goals, but more important, to have certain 
mechanisms that adapt he system behavior in 
terms of action planning, content selection, 
and content realization to user cognitive 
limitations. Dialog strategies and management 
should be adjusted to the evolving state of the 
user. Thus a better understanding and 
modeling of user cognitive process and human 
perception is desirable. 
In this paper, we propose a methodology that 
automatically learns user experience levels 
based on sub-goal utilities and characteristics 
observed during the interaction. Those user 
levels will further feedback to update utility 
metrics and direct different dialog strategies at 
each level of dialog management: action 
planning, content selection and content 
realization. The Help-Desk is our application 
domain. This is a work in progress. We have 
built a prototype system and are currently in 
the process of evaluation of our methodology 
and hypotheses. 
1 System Overview 
The system components, hown in figure 1, 
consist of a problem space representation a d 
a set of modules and agents that utilize this 
representation. The architecture supports a 
dynamic updating process for user level and 
sub-goal utility measurement, and thus allows 
the system to adapt its dialog behavior to the 
updated environment. 
94 
~(~o r~nt ,~decdoll I oa Lq4 - 
1 1 
r I 
i i 
Figure 1. System Components 
The problem space is modeled by an Acyclic 
Problem Graph structure, which represents he 
dialog goal (i.e., final goal) and different paths 
(solutions) to the final goal. The Level 
Adjusting Agent controls the initial detection 
and dynamic shifting of user expertise level 
based on the interactions with the user. The 
Action Planner identifies the problem node 
(i.e., dialog goal) in the Acyclic Problem 
Graph and locates the optimal path to it. The 
Content Selection component uses the Level 
Adjusting Agent and the Action Planner to 
select he content for the dialog. The Content 
Realization module deals with the final 
presentation of the dialog content o the user. 
The Utility Updating Agent automatically 
updates the utility metrics of the sub-goals in 
the Acyclic Problem Graph based on the single 
and group user models that are created uring 
interactions. Different strategies are applied in 
different modules, which will be described 
later. 
2 Problem Space Modeling 
The problem space is modeled by an aeyclic 
graph named Acyclic Problem Graph. It can 
also be considered as a forest containing joint 
trees that have overlapped root nodes and 
internal nodes. Internal nodes correspond to 
sub-goals. A path traversed from a root to a 
particular node contains a potential solution to 
a goal or sub-goal related to that node. Given a 
root node, the ffurffier away from the root, the 
greater is the complexity of the goal (or sub- 
goal) represented by a node. Since multiple 
paths can lead to a node, there could be 
multiple solutions to a goal. 
Figure 2 is a fragment of an acyclic graph for 
solving problems pertaining to a Windows 
based PC. In this example, three paths 
correspond to three potential solutions to the 
problem about how to set the display 
resolution of a monitor. 
A C 
Concept:. Desklop Settings 
Remedy: (set of remedies for 
generation purpose) 
Reward: +15 
Plmishment: -45 
Timeout: 
Best.case: 10 sees (reward: +10) 
Worst-ease: 30 sees (puais lma~t:  
-2O) 
Figure 2. Acyclie Problem Graph 
Each node in the graph has the following 
fields: Concept Name, Remedy, and Utility 
Metrics that include Reward, Punishment, 
Best-case timeout and Worst-case firneout. 
Concept Name represents an instruction 
corresponding to a particular goal or sub-goal 
during the problem solving. For example, the 
concept of "Display Properties" node deals 
with manipulating the display of the monitor. 
Remedy is the template that is used to generate 
natural language responses and explanations 
corresponding to a particular goal. It also 
contains phrases and key terms used for 
language generation. 
Reward and Punishment are the utility metrics 
corresponding to each sub-goal (Winlder, 
95 
1972) depending upon the \]hypothesis of
uncertainty of understanding and the level of 
importance. Uncertainty of understanding 
implies the difficulty in following certain 
instructions or understanding certain concepts. 
For example, some technical terms require 
users to possess greater expertise in order to 
comprehend them. Some potential ways of 
initializing uncertainty ofunders.tanding are by 
observation, analysis of previously logged 
data, or surveys. The level of importance 
indicates the importance of the sub-goal for 
understanding an instruction or a concept 
towards the realization of the overall goal of 
solving the problem. One good indication of 
such importance, for example, in the Acyclic 
Problem Graph, is the branch factor of each 
node. A more difficult concept has a greater 
level of uncertainty and hence would lead to 
less punishment if the user does not 
understand it. On the other hand, if a user 
correctly understands a concept that has a high 
degree of uncertainty, he would be rewarded 
highly. Reward and punishment can be pre- 
determined and then re-adjusted later when the 
user and the group modeling progresses. 
Timeout metrics are used to indicate whether 
the user understands the instruction or the 
concept associated With the sub-goal within 
the expected period of time. The hypothesis 
that when a user has no problem of 
understanding a system instruction, the user is 
very likely to respond to the system rapidly. 
However, when the user has difficulties, 
he/she tends to spend more time on thinking 
and asking for help. There are two timeouts: 
best-case and worst-case. Each timeout has a 
reward and a punishment. Best-case time is the 
time expected by the system, in the best ease, 
that a user would take to understaud the 
instruction. The user is rewarded when actual 
time spent is less than the best-case time. 
Similarly, the worst-case time is the system 
expectation for the worst ease. If the user still 
doesn't get the instruction after the worst-ease 
time period, he is punished for it. Again, these 
values are pre-set and will be dynamically ree- 
adjusted. 
3 Dialog Management 
The Dialog Manager can be broadly classified 
into two main modules: Content Selection and 
Content Realization. 
3.1 Content Selection Module 
The Content Selection Module consists of four 
components: Level-Adjusting Agent, Utility- 
Updating Agent, Action Planner and Content 
Selector. 
& L1 The Level-Adjusting A ent 
There are three levels of user expertise that he 
dialog manager takes into consideration: 
Expert, Moderate and Novice. The agent 
controls the initial detection and dynamic 
shifting of user expertise level based on 
interactions with the user. 
If a user is using the system for the first time, a 
good indication of the initial user expertise 
level is the level of detail and technical 
complexity of the initial query. As user's 
interaction with the system continues, a profile 
of the user is constructed gradually. This 
profile could be re-used to set the initial user 
expertise when the user uses the system again. 
The dynamic shifting of user expertise l vel is 
of two kinds: local (i.e., temporary) shifting 
between local expertise levels and 
accumulated (i.e., long term) shifting between 
accumulated expertise levels. Local shifting 
adjusts the expertise level temporarily - by 
observing the user confirmation (currently an 
explicit user confirmation is expected) which 
indicates whether he/she understands a certain 
instruction. The reason for temporary 
adjustment is because we assume that the user 
is having trouble understanding only this 
particular instruction and not the overall 
solution. 
The accumulated shifting permauently adjusts 
the user expertise level depending upon two 
threshold values: EXPERTLEVEL and 
NOVICELEVEL. The user is considered an 
expert when his accumulated expertise l vel is 
above the EXPERTLEVEL and is considered 
96 
novice when that is below the 
NOVICE_LEVEL. The user is assumed to 
have moderate xpertise if he lies between 
these two thresholds. An accumulated value 
(ACCUM_VALUE) is calculated based on the 
whole dialog history. If the ACCUiVLVALUE 
of a user crosses a threshold, the accumulated 
user expertise level changes long term as it is 
assumed that there is a change in the user's 
overall understanding of the solution. 
At any point of the interaction, the system 
maintains ACCUM VALUE for the user. This 
value is used to adjust he user expertise level. 
The ACCUM VALUE is calculated based on 
the following set of features associated with 
utility metrics in each node in the discourse 
history (Wies, 1997; Jameson et al 1999): 
Sub-goal Complexity: More complex sub- 
goals have a greater level of importance and 
uncertainty of understanding, and thus have a 
high reward and a low punishment. Similarly, 
comparably simple sub-goals have a low 
reward and a high punishment. 
Accomplishing Time: this is perhaps the 
trickiest parameter as the chance of making an 
incorrect assumption is much higher. The user 
response time could be a good indication of 
user understanding. The longer the resolving 
of the user's problems lasts, the more 
unfavorable the evaluation is. Also if the user 
responds quickly, he is rewarded for it. To 
detect whether the user is distracted or not, if a 
series of timeouts occur continuously, the user 
is not paying attention to the system. 
Response Complexity: There is a reward and a 
punishment associated with each system 
response that reflects the complexity of the 
content and realization of the system 
responses. First of all, the content for response 
generation varies with different expertise 
levels. For novice users, all the content on the 
solution path will be generated as several turns 
of responses based on the number of sub-goals 
in the path. For expert users, only 40% content 
on the solution path (toward the final goal) is 
used for the generation as one response. 
Furthermore, for users with different expertise 
level, the Content Realization Module will 
generate system responses (in the prototype 
system, the system responses are mainly 
instructions that guide users to solve a help- 
desk problem) with different levels of 
syntactic omplexity and technical details. For 
example, for novice users, the system tends to 
generate responses with single instruction 
corresponding to one sub-goal, while for 
expert users, the system tends to generate 
responses with single instruction 
corresponding to multiple sub-goals on the 
solution path. The response with multiple 
instructions will have higher eward and lower 
punishment than those are associated with 
single instruction. Thus the user who gives a 
positive confirmation to a more complex 
system response will be rewarded higher than 
those who understand a simple system 
response. 
Based on the above factors, the 
ACCUM VALUE can be calculated 
depending upon the conditions using the 
following formulae: 
ACCUM VALUE = ACCUlvLVALUE + 
f/response -complexity (reward, punishment), sub-goal(reward, 
punishmen0, timeout(reward, punishment)\] 
In the prototype system, we have used the 
following: 
If a goal is accomplished by the user(indicated 
by positive user confirmation), 
ACCUM_VALUE = ACCUM...VALUE + \[response- 
complexity(reward) * sub-goal(reward)\] 
If a goal is not accomplished(indicated by 
negative user confirmation), 
ACCUM_VALUE = ACCUM. VALUE \[response- 
complexity(punishment) * sub-goal(punishment)\] 
If a goal is accomplished before best-time 
timeout value, 
ACCUM_VALUE = ACCUM_VALUE + \ [ response-  
complexity(reward) * sub-goal(best-case timeout reward)\]. 
If a goal is not accomplished before worst-time 
timeout value, 
ACCUMVALUE = ACCUM.VALUE - \[response- 
complexity(punishment) * sub-goal(worst-ease timeout punis- 
lament)\]. 
Other variations of the formula re expected to 
be explored in the future. 
97 
3.L 2 Action Planner and Content Selector 
The Action Planner identifies the final 
goal node in the Acyclic Problem Graph 
and finds the optimal path to it. The 
optimal path is selected based on the path 
utility function. The utility of a path in the 
graph is the summation of the 
reward/punishment ra io of all the nodes (sub- 
goals) in that path. 
Path utility (start-node, goal) = E (r i / Pi) 
n 
where i is a concept node in the path from the 
start node to the goal node, ri is the reward and 
pl is the punishment of the corresponding ode 
i. The number of nodes n in the path acts as 
the normalizing factor. 
Thusfor a given path, higher its path utility, 
greater is the difficulty to understand the 
concepts it contains and thus higher is the 
level of expertise required. 
The following co-operative strategies are used: 
for an expert user, select he path that has the 
maximum path utility. For a novice, select he 
one with the minimum path utility since this is 
the one containing concepts easiest to 
understand and with more steps of 
instructions. For a moderate-experience us r, 
select a path in between. (We are currently 
more focused on the experienced and novice 
users.) Content Selector is applied to select he 
appropriate nodes on the path to form the 
content of dialog. 
3.L3 Utility Updating Agent 
A set of users having very similar expertise 
levels can be classified as a group. A Utility 
Updating Agent dynamically updates utility 
metrics of sub-goals in the Acyclic Problem 
Graph based on the group interactions with the 
system. For example, Group A has a reward of 
+50 and a punishment o f -10  assigned to the 
sub-goal with associated concept of Display 
Properties. However the agent notices that the 
majority of the group understand the 
corresponding instruction very quickly without 
going into the sub-goal resolution, then the 
agent decreases the reward to +35 and 
increases the punishment to -25. This 
dynamic re-training of utility metrics in sub- 
goals would reflect the evolving user 
experience level as a whole and would 
improve the robustness of the dialog manager. 
3.2 Content Realization Module 
This module deals with the final presentation 
of the dialog content o the user. The dialog 
manager adopts different response strategies 
for each of the three expertise levels. It has 
been observed that an expert user appreciates a 
response, which is precise, to the point, and 
short. For a novice user, it has been observed 
that such a user likes system instructions that 
are step-wise, higher level of detail and 
minimum technical jargon. For a moderate- 
experience user, the strategy lies somewhere in
between which we haven't given a full 
consideration. The response strategy followed 
for each type of user is given in the table 1. 
Response \[ I.~ve~ ofd~l  of system Teclmical t~'ms in system SyntacTic Conccisencss of the 
\[ inKa'uctions and e:(planation in.~ru~ows and ~planation explanation Expertise i 
Expert / Low High High 
Moderate I Moderate Moderate Moderate 
Novice High Low Low 
Table 1. User expertise level and corresponding dialog strategies 
98 
3.3 Algorithm 
The proposed algorithm for action planning, 
content selection and content realization is 
given in Figure 3. This algorithm recursively 
applies a divide and conquer mechanism to 
accomplish the final goal by resolving sub- 
goals. Two variables (i,e., local expertise l vel 
and accumulated expertise level) are 
maintained by the Level-Adjusting Agent for 
the automated level updating. The Action 
Planner identifies the goal node and the 
solution path to it depending on the expertise 
level of the user. Based on this level, the 
Content Realization Module will first select 
the content on the path to be presented and 
then use various response strategies to 
generate and display system instructions to the 
user. For novice users, all the content on 
solution path will be used; for moderate and 
expert users, only partial content on the path 
(toward the goal) will be used. In terms of 
generation, for novice and moderate xpertise 
users, the system generates responses with 
single instruction corresponding to one sub- 
goal, while for expert users, the system tends 
to generate responses with single instruction 
corresponding to multiple sub-goals on the 
solution path. The syntax of the response 
becomes more complex as the expertise level 
increases. Depending on the response of the 
user, the Level-Adjusting Agent updates the 
user expertise level and adapts the response 
strategies accordingly. 
1) Level-Adjnsting Agent detects the initial expertise level and assigns it to both local expertise level and accumulated 
expertise l vel. 
2) Action Planner identifies the start node and goal node in the Acyclic Problem Graph and locates the appropriate path 
between the start node and the goal node. 
a~ For novice user, the path with minimum path utility is selected 
b. For expert user, the path with maximum path utility is selected 
c. For moderate user, a path in between is selected 
3) Content Realization Module generates system instructions based on the selected path by using the following response 
SU'~tegles" 
a. For an expert, the instruction is generated by using the nodes that fall within a distance of X% from the goal 
node to the root node. 
b. For a moderate-experienced user, nodes within a distance of Y% (where Y > X) are used, 
e. For a novice, all nodes from the root to the goal are used to generate the instruction 
(X and Y could be experimentally determined later) 
4) Content Realization Module displays generated insmactions tothe user. 
5) Level-Adjusting Agent receives the user confirmation and updates user expertise l vel. 
a. If the confirmation ispositive, the Level Adjusting Agent does the following: 
i. Update ACCUM_VALUE=ACCUM VALUE + \[response--complexity(reward) * sub-goal(reward)\] 
i i .  If ACCUM VALUE crosses above an expertise level threshold, upgrade accumulated expertise 
level 
iii. If the goal node is the final node, exit. Otherwise, continue to the next node. 
b. If the confirmation isnegative 
i. If current local expertise l vel is greater than novice, temporarily reduce local expertise level; else 
suspend system at current state (so that the user can take his own time in understand/rig the 
instruction or seek outside help). 
i i .  Update ACCUM_VALUE= ACCUM VALUE - \[response.complexity(punishment) * sub- 
goal(punishmen0\]. 
iii. If ACCCUIvLVALUE crosses below a level threshold, reduce accumulated experience l vel. 
iv. Record the current node and the current path 
v. Make current node as the goal node; Go to step 2. Repeat until all sub-goal nodes of this goal node 
are understood. 
6) Re-initialize local expertise level to current value of accumulated expertise level. Restore path to value stored in step 
5.b.iv. Go to step 2. Reset he start node. Continue till the final goal is reached. 
(A timer that is running on a separate hread also modifies the ACCUM_VALUE variable. On occurrence ofa tirneout, he 
following steps are followed: 
If the time spent is less than the best-case time 
ACCUM._VALUE=ACCUM_.VALUE + \[response-complexity(reward) * sub-goal(best-case timeout reward)\]. 
Go to step 5.a.ii. 
If the time spent is more than the worst-case time 
ACCUM_VALUE=ACCUM_VALUE - \[response-complexity(punishment) * sub-goal(worst.ease timeout 
punishrnent)l. 
Go to step 5.b.iii. ) 
Figure 3. Algorithm 
99 
4 An example  of  interaction 
A scenario appl icat ion for the system using the 
prob lem tree o f  F igure 2 is g iven in F igure 4. 
This set o f  interactions is between the system 
and a user  who is trying to adjust the display 
settings o f  his monitor.  
1. System: Hi, how may I help you? 
2. User: I need to adjust the desktop resolution of my monitor 
> Initial accumulated expertise l vel detected - Expert 
Goal node-Desktop Setting (as it deals with adjusting the resolution) 
Shortest part is nodes 1-2-6.7 (assuming that it has the maximum path utility value). 
Nodes 6,7 (40% rounded to nearest whole number) are selected to generate r sponse. 
> Response generated with instruction corresponding to multiple sub-goals on the solution path. 
3. System: Yon can do that by adjusting the desktop area in the desktop settings section of the display 
properties window. 
4. User: Where is desktop setting window? 
Temporarily decreasing local expertise l vel to Moderate. 
ACCUM VALUE=ACCUlVLVALUE- \[response-complexity (punishment) * Desktop- 
Setting(punishment)\] 
} Shortest path to Desktop Setting recalculated as 8-5-6-7 (assuming that it has the average path 
utility value). 
Nodes 5,6,7 (70% rounded to nearest whole number) are selected to generate r sponse. 
Response generated with single instruction corresponding to one sub-goal. 
5. System: First, go to the Control Panel window. 
...worst-case timeout occurred .... 
> Temporarily decrease local expertise level to Novice. 
> ACCUIVLVALUE=AC CU/VLVALUE \[response-complexity(punishment) * control- 
panel(worst-case timeout punishment)\] 
> ACCUM_VALUE falls below EXPERTLEVEL Make accumulated experience l vel moderate. 
> Shortest path to Control Panel recalculated as nodes 3-.4-5 (assuming it has the minimum path 
utility value). 
> All nodes used to generate r sponse. 
Response generated with single instruction corresponding to one sub-goal. 
6. System: 1. Click on "Start" icon on lower left corner of your screen. 
7. User: Ok 
> ACCUM VALUE = ACCUM LEVEL + \[response-eomplexity (reward), Start(reward)\] 
8. System: 2. Click on "Settings" label. 
9. User: Ok 
> ACCUM_VALUE=ACCUM_LEVEL + \[response-complexity(reward), Settings(reward)\] 
10. System: 3. Click on "Control Panel" label. 
> No change in ACCUM VALUE as user has been punished earlier at this step. 
local experience l vel goes back to moderate. Path reset o 8-5-6-7 selected in step 4. 
11. System: Now click on the DLsplay Properties window. 
12. User: OK 
No change in ACCUlVLVALUE as user has been punished earlier at this step. 
13. System: Select "Desktop settings" in this window. 
14. User: Ok 
No change in ACCUM_VALUE as user has been punished earlier at this step. 
15. System: Finally, adjust "display area" by moving the slide-bar. 
16. User: Ok. Thank yon 
No change in ACC"UM_VALUE as user has been punished earlier at this step. 
Profile of user stored. 
Figure 4. An example 
100 
Notice that after step 9, the user level remains 
at moderate and does not return to expert. 
This is because adecrease in accumulated user 
expertise level has taken place in step 5. Also, 
the style of the dialog is different at each level 
according to the expertise level of the user at 
that time. 
Conclusion 
This paper describes hypotheses, strategies 
and a methodology in building a dialog system 
that adapts itself to the evolving level of user 
expertise. Furthermore, the system allows 
automated sub-goal utility adjusmaent based 
on history of interactions with groups of users. 
We have implemented the algorithm described 
in this paper on a prototype system where the 
utility metrics have been initialized manually 
by a help-desk expert, based on his 
experiences of interaction with users. We are 
currently working on evaluation of hypotheses 
and the system. 
This work is still in its early stage. Our future 
work includes conducting evaluation of the 
hypotheses and the system and investigating 
machine learning techniques for improving 
utility adjustments. 
Acknowledgement 
This work was a summer project while the 
first author was doing his summer internship at 
the Conversational Machines Group at IBM T. 
J. Watson Research Center. We would like to 
thank all members in Conversational Machines 
Group for their discussions and support. 
References 
Carl Andersen, David Traum, K. Purang Darsana 
Purushothaman, Don Perlis (1999) Mixed 
Initiative Dialogue and Intelligence via Active 
Logic. In proceedings of the AAAI99 Workshop 
on Mixed-Initiative Intelligence, pp. 60-67. 
Anthony Jameson, Ralph Sch~fer, Thomas Weis, 
Andr6 Berthold and Thomas Weyrath (1999) 
MaMng Systems Sensitive to the User ~ Time and 
Working Memory Constraints, Intelligent User 
Interfaces. 
Kristiina Jokinen (2000) Learning Dialog System. 
LREC 2000 Second International Conference on 
Language Resources and Evaluation, Athens, 
Greece. 
Neal Lesh, Charles Rich, Candace Sidner (1997) 
Using plan recognition in human-computer 
collaboration. In 7tn International Conf. On User 
Modeling, Banff, Canada. 
Diane J. Litman, Shirnei Pan, Marilyn A Walker, 
(1998) Evaluating Response Strategies in a 
Web-Based Spoken Dialogue Agent. In 
Proceedings of the 36 th Annual Meeting of the 
Association for Computational Linguistics and 
the 17th International Conference on 
Computational Linguistics (COLING-ACL'98), 
Montreal, Canada, pp. 780-786. 
Diane J. Litrnan, Shimei Pan (1999) Empirically 
Evaluating an Adaptable Spoken Dialogue 
System. In Proceedings of the 7th International 
Conference on User Modeling (UM), Banff, 
Canada, pp. 55-64. 
Andros Stolcke, Elizabeth Shriberg, Rebecca Bates, 
Noah Coccaro, Daniel Jurafsky, Rachel 
Martin, Marie Meteer, Klaus Ries, Paul Taylor, 
Carol Van Ess-Dykerna (1998) Dialog act 
modeling for conversational speech. In Chu- 
Carroll J., and Green N., (Eds), Applying 
Machine Learning to Discourse Processing. 
Papers fi'om the 1998 AAAI Spring Symposium. 
Stanford, CA. 
Marilyn Walker, Jeanne Fromer, Shrikanth 
Narayanan (1998) Learning Optimal Dialog 
Strategies: A Case Study of a Spoken Dialog 
Agent for EmaiL In Proceedings of COLING- 
ACL'98, University of Montreal, Canada. 
Thomas Weis (1997) Resource-Adaptive Action 
Planning in a Dialogue System for Repair 
Support, KI. 
Robert L Winlder (1972) Introduction to Bayesian 
Inference and Decision. Holt, Rinehart and 
Winston Inc. 
101 
