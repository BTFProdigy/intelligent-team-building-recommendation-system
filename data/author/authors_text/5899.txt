Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning, pages 904?915, Jeju Island, Korea, 12?14 July 2012. c?2012 Association for Computational Linguistics
A Novel Discriminative Framework for Sentence-Level Discourse Analysis
Shafiq Joty and Giuseppe Carenini and Raymond T. Ng
{rjoty, carenini, rng}@cs.ubc.ca
Department of Computer Science
University of British Columbia
Vancouver, BC, V6T 1Z4, Canada
Abstract
We propose a complete probabilistic discrim-
inative framework for performing sentence-
level discourse analysis. Our framework com-
prises a discourse segmenter, based on a bi-
nary classifier, and a discourse parser, which
applies an optimal CKY-like parsing algo-
rithm to probabilities inferred from a Dynamic
Conditional Random Field. We show on two
corpora that our approach outperforms the
state-of-the-art, often by a wide margin.
1 Introduction
Automatic discourse analysis has been shown to
be critical in several fundamental Natural Lan-
guage Processing (NLP) tasks including text gener-
ation (Prasad et al2005), summarization (Marcu,
2000b), sentence compression (Sporleder and Lap-
ata, 2005) and question answering (Verberne et al
2007). Rhetorical Structure Theory (RST) (Mann
and Thompson, 1988), one of the most influential
theories of discourse, posits a tree representation of
a discourse, known as a Discourse Tree (DT), as
exemplified by the sample DT shown in Figure 1.
The leaves of a DT correspond to contiguous atomic
text spans, also called Elementary Discourse Units
(EDUs) (three in the example). The adjacent EDUs
are connected by a rhetorical relation (e.g., ELAB-
ORATION), and the resulting larger text spans are
recursively also subject to this relation linking. A
span linked by a rhetorical relation can be either
a NUCLEUS or a SATELLITE depending on how
central the message is to the author. Discourse anal-
ysis in RST involves two subtasks: (i) breaking the
text into EDUs (known as discourse segmentation)
and (ii) linking the EDUs into a labeled hierarchical
tree structure (known as discourse parsing).
Figure 1: Discourse structure of a sentence in RST-DT.
Previous studies on discourse analysis have been
quite successful in identifying what machine learn-
ing approaches and what features are more useful for
automatic discourse segmentation and parsing (Sori-
cut and Marcu, 2003; Subba and Eugenio, 2009; du-
Verle and Prendinger, 2009). However, all the pro-
posed solutions suffer from at least one of the fol-
lowing two key limitations: first, they make strong
independence assumptions on the structure and the
labels of the resulting DT, and typically model the
construction of the DT and the labeling of the rela-
tions separately; second, they apply a greedy, sub-
optimal algorithm to build the structure of the DT.
In this paper, we propose a new sentence-level
discourse parser that addresses both limitations. The
crucial component is a probabilistic discriminative
parsing model, expressed as a Dynamic Conditional
Random Field (DCRF) (Sutton et al2007). By
representing the structure and the relation of each
discourse tree constituent jointly and by explicitly
capturing the sequential and hierarchical dependen-
cies between constituents of a discourse tree, our
DCRF model does not make any independence as-
sumption among these properties. Furthermore, our
904
parsing model supports a bottom-up parsing algo-
rithm which is non-greedy and provably optimal.
The discourse parser assumes that the input text
has been already segmented into EDUs. As an addi-
tional contribution of this paper, we propose a novel
discriminative approach to discourse segmentation
that not only achieves state-of-the-art performance,
but also reduces the time and space complexities by
using fewer features. Notice that the combination
of our segmenter with our parser forms a complete
probabilistic discriminative framework for perform-
ing sentence-level discourse analysis.
Our framework was tested in a series of experi-
ments. The empirical evaluation indicates that our
approach to discourse parsing outperforms the state-
of-the-art by a wide margin. Moreover, we show this
to be the case on two very different genres: news ar-
ticles and instructional how-to-do manuals.
In the rest of the paper, after discussing related
work, we present our discourse parser. Then, we
describe our segmenter. The experiments and the
corpora we used are described next, followed by a
discussion of the key results and some error analysis.
2 Related work
Automatic discourse analysis has a long history;
see (Stede, 2011) for a detailed overview. Sori-
cut and Marcu (2003) present the publicly available
SPADE1 system that comes with probabilistic mod-
els for sentence-level discourse segmentation and
parsing based on lexical and syntactic features de-
rived from the lexicalized syntactic tree of a sen-
tence. Their parsing algorithm finds the most proba-
ble DT for a sentence, where the probabilities of the
constituents are estimated by their parsing model.
A constituent (e.g., ATTRIBUTION-NS[(1,2),3] in
Figure 1) in a DT has two components, first, the la-
bel denoting the relation and second, the structure
indicating which spans are being linked by the rela-
tion. The nuclearity statuses of the spans are built
into the relation labels (e.g., NS[(1,2),3] means that
span (1,2) is the NUCLEUS and it comes before
span 3 which is the SATELLITE). SPADE is limited
in several ways. It makes an independence assump-
tion between the label and the structure while mod-
eling a constituent, and it ignores the sequential and
1http://www.isi.edu/licensed-sw/spade/
hierarchical dependencies between the constituents
in the parsing model. Furthermore, SPADE relies
only on lexico-syntactic features, and it follows a
generative approach to estimate the model param-
eters for the segmentation and the parsing models.
SPADE was trained and tested on the RST-DT cor-
pus (Carlson et al2002), which contains human-
annotated discourse trees for news articles.
Subsequent research addresses the question of
how much syntax one really needs in discourse
analysis. Sporleder and Lapata (2005) focus on
discourse chunking, comprising the two subtasks
of segmentation and non-hierarchical nuclearity as-
signment. More specifically, they examine whether
features derived via part of speech (POS) and chunk
taggers would be sufficient for these purposes. Their
results on RST-DT turn out to be comparable to
SPADE without using any features from the syntac-
tic tree. Later, Fisher and Roark (2007) demonstrate
over 4% absolute ?performance gain? in segmenta-
tion, by combining the features extracted from the
syntactic tree with the ones derived via taggers. Us-
ing quite a large number of features in a binary log-
linear model they achieve the state-of-the-art seg-
mentation performance on the RST-DT test set.
On the different genre of instructional manuals,
Subba and Eugenio (2009) propose a shift-reduce
parser that relies on a classifier to find the appro-
priate relation between two text segments. Their
classifier is based on Inductive Logic Programming
(ILP), which learns first-order logic rules from a
large set of features including the linguistically rich
compositional semantics coming from a semantic
parser. They show that the compositional seman-
tics improves the classification performance. How-
ever, their discourse parser implements a greedy ap-
proach (hence not optimal) and their classifier disre-
gards the sequence and hierarchical dependencies.
Using RST-DT, Hernault et al2010) present
the HILDA system that comes with a segmenter
and a parser based on Support Vector Machines
(SVMs). The segmenter is a binary SVM classi-
fier which relies on the same lexico-syntactic fea-
tures used in SPADE, but with more context. The
discourse parser builds a DT iteratively utilizing two
SVM classifiers in each iteration: (i) a binary classi-
fier decides which of the two adjacent spans to link,
and (ii) a multi-class classifier then connects the se-
905
lected spans with the appropriate relation. They use
a very large set of features in their parser. How-
ever, taking a radically-greedy approach, they model
structure and relations separately, and ignore the se-
quence dependencies in their models.
Recently, there has been an explosion of interest
in Conditional Random Fields (CRFs) (Lafferty et
al., 2001) for solving structured output classification
problems, with many successful applications in NLP
including syntactic parsing (Finkel et al2008), syn-
tactic chunking (Sha and Pereira, 2003) and dis-
course chunking (Ghosh et al2011) in Penn Dis-
course Treebank (Prasad et al2008). CRFs being a
discriminative approach to sequence modeling (i.e.,
directly models the conditional p(y|x,?)), have sev-
eral advantages over its generative counterparts such
as Hidden Markov Models (HMMs) and Markov
Random Fields (MRFs), which first model the joint
p(y, x|?), then infer the conditional p(y|x,?)). Key
advantages include the ability to incorporate arbi-
trary overlapping local and global features, and the
ability to relax strong independence assumptions. It
has been advocated that CRFs are generally more
accurate since they do not ?waste effort? modeling
complex distributions (i.e., p(x)) that are not rele-
vant for the target task (Murphy, 2012).
3 The Discourse Parser
Assuming that a sentence is already segmented into
a sequence of EDUs e1, e2, . . . en manually or by an
automatic segmenter (see Section 4), the discourse
parsing problem is to decide which spans to con-
nect (i.e., structure of the DT) and which relations
(i.e., labels of the internal nodes) to use in the pro-
cess of building the hierarchical DT. To build the
DTs effectively, a common assumption is that they
are binary trees (Soricut and Marcu, 2003; duVerle
and Prendinger, 2009). That is, multi-nuclear re-
lations (e.g., LIST, JOINT, SEQUENCE) involving
more than two EDUs are mapped to a hierarchi-
cal right-branching binary tree. For example, a flat
LIST (e1, e2, e3, e4) is mapped to a right-branching
binary tree LIST (e1, LIST (e2, LIST (e3, e4))).
Our discourse parser has two components. The
first component, the parsing model, assigns a proba-
bility to every possible DT. The second component,
the parsing algorithm, finds the most probable DT
among the candidate discourse trees.
3.1 Parsing Model
A DT can be represented as a set of constituents
of the form R[i,m, j], which denotes a rhetorical
relation R that holds between the span containing
EDUs i through m, and the span containing EDUs
m+1 through j. For example, the DT in Figure 1
can be written as {ELABORATION-NS[1,1,2],
ATTRIBUTION-NS[1,2,3]}. Notice that a rela-
tion R also indicates the nuclearity assignments
of the spans being connected, which can be one
of NUCLEUS-SATELLITE (NS), SATELLITE-
NUCLEUS (SN) and NUCLEUS-NUCLEUS (NN).
Given the model parameters ? and a candi-
date DT T , for all the constituents c in T , our
parsing model estimates the conditional probabil-
ity P (c|C,?), which specifies the joint probabil-
ity of the relation R and the structure [i,m, j]
associated with the constituent c, given that c
has a set of sub-constituents C. For instance,
for the DT shown in Figure 1, our model
would estimate P (R?[1, 1, 2]|?), P (R?[2, 2, 3]|?),
P (R?[1, 2, 3]|R??[1, 1, 2],?) etc. for all R? and R??
ranging on the set of relations. In what follows we
describe our probabilistic parsing model to compute
all these conditional probabilities P (c|C,?). We
will demonstrate how our approach not only models
the structure and the relation jointly, but it also cap-
tures linear sequence dependencies and hierarchical
dependencies between constituents of a DT.
Our novel parsing model is the Dynamic Condi-
tional Random Field (DCRF) (Sutton et al2007)
shown in Figure 2. A DCRF is a generalization
of linear-chain CRFs to represent complex interac-
tion between labels, such as when performing mul-
tiple labeling tasks on the same sequence. The ob-
served nodes Wj in the figure are the text spans.
A text span can be either an EDU or a concatena-
tion of a sequence of EDUs. The structure nodes
Sj?{0, 1} in the figure represent whether text spans
Wj?1 and Wj should be connected or not. The re-
lation nodes Rj?{1 . . .M} denote the discourse re-
lation between spans Wj?1 and Wj , given that M is
the total number of relations in our relation set. No-
tice that we now model the structure and the relation
jointly and also take the sequential dependencies be-
tween adjacent constituents into consideration.
906
Figure 2: A Dynamic CRF as a discourse parsing model.
We can obtain the conditional probabilities of
the constituents (i.e., P (c|C,?)) of all candidate
DTs for a sentence by applying the DCRF pars-
ing model recursively at different levels, and by
computing the posterior marginals of the relation-
structure pairs. To illustrate, consider the example
sentence in Figure 1 where we have three EDUs
e1, e2 and e3. The DCRF model for the first
level is shown in Figure 3(a), where the (observed)
EDUs are the spans in the span sequence. Given
this model, we obtain the probabilities of the con-
stituents R[1, 1, 2] and R[2, 2, 3] by computing the
posterior marginals P (R2, S2=1|e1, e2, e3,?) and
P (R3, S3=1|e1, e2, e3,?), respectively. At the sec-
ond level (see Figure 3(b)), there are two possi-
ble span sequences (e1:2, e3) and (e1, e2:3). In the
first sequence, EDUs e1 and e2 are linked into
a larger span, and in the second one, EDUs e2
and e3 are connected into a larger span. We ap-
ply our DCRF model to the two possible span se-
quences and obtain the probabilities of the con-
stituents R[1, 2, 3] and R[1, 1, 3] by computing
the posterior marginals P (R3, S3=1|e1:2, e3,?) and
P (R2:3, S2:3=1|e1, e2:3,?), respectively.
Figure 3: DCRF model applied to the sequences at differ-
ent levels in the example in Fig. 1. (a) A sequence at the
first level (b) Two possible sequences at the second level.
To further clarify the process, let us as-
sume that the sentence contains four EDUs
e1, e2, e3 and e4. At the first level (Fig-
ure 4(a)), there is only one possible span se-
quence to which we apply our DCRF model.
We obtain the probabilities of the constituents
R[1, 1, 2], R[2, 2, 3] and R[3, 3, 4] by computing the
posterior marginals P (R2, S2=1|e1, e2, e3, e4,?),
P (R3, S3=1|e1, e2, e3, e4,?) and P (R4, S4=1|e1,
e2, e3, e4,?), respectively. At the second level
(Figure 4(b)), there are three possible sequences
(e1:2, e3, e4), (e1, e2:3, e4) and (e1, e2, e3:4). When
the DCRF model is applied to the sequence
(e1:2, e3, e4), we obtain the probabilities of the
constituent R[1, 2, 3] by computing the posterior
marginal P (R3, S3=1|e1:2, e3, e4,?). Likewise, the
posterior marginals P (R2:3, S2:3=1|e1, e2:3, e4,?)
and P (R4, S4=1|e1, e2:3, e4,?) in the DCRF model
applied to the sequence (e1, e2:3, e4) represents
the probabilities of the constituents R[1, 1, 3]
and R[2, 3, 4], respectively. Similarly, we at-
tain the probabilities of the constituent R[2, 2, 4]
from the DCRF model applied to the sequence
(e1, e2, e3:4) by computing the posterior marginal
P (R3:4, S3:4=1|e1, e2, e3:4,?). At the third level
(Figure 4(c)), there are three possible sequences
(e1:3, e4), (e1, e2:4) and (e1:2, e3:4), to which we ap-
ply our model and acquire the probabilities of the
constituents R[1, 3, 4], R[1, 1, 4] and R[1, 2, 4] by
computing their respective posterior marginals.
Figure 4: DCRF model applied to the sequences at differ-
ent levels of a discourse tree. (a) A sequence at the first
level, (b) Three possible sequences at the second level,
(c) Two possible sequences at the third level.
Our DCRF model is designed using MALLET
(McCallum, 2002). In order to avoid overfitting we
regularize the DCRF model with l2 regularization
and learn the model parameters using the limited-
memory BFGS (L-BFGS) fitting algorithm. Since
exact inference can be intractable in DCRF models,
907
we perform approximate inference (to compute the
posterior marginals) using tree-based reparameteri-
zation (Wainwright et al2002).
3.1.1 Features Used in the Parsing Model
Crucial to parsing performance is the set of fea-
tures used, as summarized in Table 1. Note that
these features are defined on two consecutive spans
Wj?1 and Wj of a span sequence. Most of the fea-
tures have been explored in previous studies. How-
ever, we improve some of these as explained below.
Organizational features encode useful informa-
tion about the surface structure of a sentence as
shown by (duVerle and Prendinger, 2009). We mea-
sure the length of the spans in terms of the number of
EDUs and tokens in it. However, in order to better
adjust to the length variations, rather than comput-
ing their absolute numbers in a span, we choose to
measure their relative numbers with respect to their
total numbers in the sentence. For example, in a sen-
tence containing three EDUs, a span containing two
of these EDUs will have a relative EDU number of
0.67. We also measure the distances of the spans
from the beginning and to the end of the sentence in
terms of the number of EDUs.
8 organizational features
Relative number of EDUs in span 1 and span 2.
Relative number of tokens in span 1 and span 2.
Distances of span 1 in EDUs to the beginning and to the end.
Distances of span 2 in EDUs to the beginning and to the end.
8 N-gram features
Beginning and end lexical N-grams in span 1.
Beginning and end lexical N-grams in span 2.
Beginning and end POS N-grams in span 1.
Beginning and end POS N-grams in span 2.
5 dominance set features
Syntactic labels of the head node and the attachment node.
Lexical heads of the head node and the attachment node.
Dominance relationship between the two text spans.
2 contextual features
Previous and next feature vectors.
2 substructure features
Root nodes of the left and right rhetorical subtrees.
Table 1: Features used in the DCRF parsing model.
Discourse connectives (e.g., because, but), when
present, signal rhetorical relations between two text
segments (Knott and Dale, 1994; Marcu, 2000a).
However, previous studies (e.g., Hernault et al
(2010), Biran and Rambow (2011)) suggest that an
empirically acquired lexical N-gram dictionary is
more effective than a fixed list of connectives, since
this approach is domain independent and capable
of capturing non-lexical cues such as punctuations.
To build the lexical N-gram dictionary empirically
from the training corpus we consider the first and
last N tokens (N?{1, 2}) of each span and rank
them according to their mutual information2 with
the two labels, Structure and Relation. Intuitively,
the most informative cues are not only the most fre-
quent, but also the ones that are indicative of the la-
bels in the training data (Blitzer, 2008). In addition
to the lexical N-grams we also encode POS tags of
the first and last N tokens (N?{1, 2}) as features.
Figure 5: A discourse segmented lexicalized syntactic
tree. Boxed nodes form the dominance set D.
Dominance set extracted from the Discourse Seg-
mented Lexicalized Syntactic Tree (DS-LST) (Sori-
cut and Marcu, 2003) has been shown to be a very
effective feature in SPADE. Figure 5 shows the DS-
LST for our running example (see Figure 1 and 3).
In a DS-LST, each EDU except the one with the root
node must have a head node NH that is attached to
an attachment node NA residing in a separate EDU.
A dominance set D (shown at the bottom of Figure 5
for our example) contains these attachment points of
the EDUs in a DS-LST. In addition to the syntactic
and lexical information of the head and attachment
nodes, each element in D also represents a domi-
nance relationship between the EDUs involved. The
EDU with NA dominates the EDU with NH . In or-
2In contrast, HILDA ranks the N-grams by frequencies.
908
der to extract dominance set features for two consec-
utive spans ei:j and ej+1:k, we first compute D from
the DS-LST of the sentence. We then extract the
element from D that holds across the EDUs j and
j + 1. In our running example, for the spans e1 and
e2 (Figure 3(a)), the relevant dominance set element
is (1, efforts/NP)>(2, to/S). We encode the syntac-
tic labels and lexical heads of NH and NA and the
dominance relationship (i.e., which of the two spans
is dominating) as features in our model.
We also incorporate more contextual information
by including the above features computed for the
neighboring span pairs in the current feature vector.
We incorporate hierarchical dependencies be-
tween constituents in a DT by means of the sub-
structure features. For the two adjacent spans ei:j
and ej+1:k, we extract the roots of the rhetorical
subtrees spanning over ei:j (left) and ej+1:k (right).
In our example (see Figure 1 and Figure 3 (b)),
the root of the rhetorical subtree spanning over e1:2
is ELABORATION-NS. However, this assumes the
presence of a labeled DT which is not the case when
we apply the parser to a new sentence. This problem
can be easily solved by looping twice through build-
ing the model and the parsing algorithm (described
below). We first build the model without considering
the substructure features. Then we find the optimal
DT employing our parsing algorithm. This interme-
diate DT will now provide labels for the substruc-
tures. Next we can build a new, more accurate model
by including the substructure features, and run again
the parsing algorithm to find the final optimal DT.
3.2 Parsing Algorithm
Our parsing model above assigns a conditional prob-
ability to every possible DT constituent for a sen-
tence, the job of the parsing algorithm is to find the
most probable DT. Formally, this can be written as,
DT ? = argmax DTP (DT |?)
Our discourse parser implements a probabilistic
CKY-like bottom-up algorithm for computing the
most likely parse of a sentence using dynamic pro-
gramming; see (Jurafsky and Martin, 2008) for a
description. Specifically, with n number of EDUs
in a sentence, we use the upper-triangular por-
tion of the n ? n Dynamic Programming Table
(DPT). The cell [i, j] in the DPT represents the
span containing EDUs i through j and stores the
probability of a constituent R[i,m, j], where m =
argmax i?k?jP (R[i, k, j]).
In contrast to HILDA which implements a greedy
algorithm, our approach finds a DT that is glob-
ally optimal. Our approach is also different from
SPADE?s implementation. SPADE first finds the
tree structure that is globally optimal, then it assigns
the most probable relations to the internal nodes.
More specifically, the cell [i, j] in SPADE?s DPT
stores the probability of a constituent R[i,m, j],
where m = argmax i?k?jP ([i, k, j]). Disregard-
ing the relation label R while building the DPT, this
approach may find a tree that is not globally optimal.
4 The Discourse Segmenter
Our discourse parser above assumes that the input
sentences have been already segmented into EDUs.
Since it has been shown that discourse segmentation
is a primary source of inaccuracy for discourse pars-
ing (Soricut and Marcu, 2003), we have developed
our own segmenter, that not only achieves state-of-
the-art performance as shown later, but also reduces
the time complexity by using fewer features.
Our segmenter implements a binary classifier to
decide for each word (except the last word) in a sen-
tence, whether to put an EDU boundary after that
word. We use a Logistic Regression (LR) (i.e., dis-
criminative) model with l2 regularization and learn
the model parameters using the L-BFGS algorithm,
which gives quadratic convergence rate. To avoid
overfitting, we use 5-fold cross validation to learn
the regularization strength parameter from the train-
ing data. We also use a simple bagging technique
(Breiman, 1996) to deal with the sparsity of bound-
ary tags. Note that, our first attempt at this task im-
plemented a linear-chain CRF model to capture the
sequence dependencies between the tags in a dis-
criminative way. However, the binary LR classifier,
using the same features, not only outperforms the
CRF model, but also reduces the space complexity.
4.1 Features Used in the Segmentation Model
Our set of features for discourse segmentation are
mostly inspired from previous studies but used in a
novel way as we describe below.
Our first subset of features which we call SPADE
features, includes the lexico-syntactic patterns ex-
909
tracted from the lexicalized syntactic tree for the
given sentence. These features replicates the fea-
tures used in SPADE, but used in a discriminative
way. To decide on an EDU boundary after a token
wk, we find the lowest constituent in the lexicalized
syntactic tree that spans over tokens wi . . . wj such
that i?k<j. The production that expands this con-
stituent in the tree and its different variations, form
the feature set. For example in Figure 5, the produc-
tion NP(efforts)?PRP$(its)NNS(efforts)?S(to) and
its different variations depending on whether they
include the lexical heads and how many non-
terminals (up to two) to consider before and after
the potential EDU boundary (?), are used to de-
termine the existence of a boundary after the word
efforts (see (Fisher and Roark, 2007) for details).
SPADE uses these features in a generative way,
meaning that, it inserts an EDU boundary if the rela-
tive frequency (i.e., Maximum Likelihood Estimate
(MLE)) of a potential boundary given the production
in the training corpus is greater than 0.5. If the pro-
duction has not been observed frequently enough, it
uses its other variations to perform further smooth-
ing. In contrast, we compute the MLE estimates for
a production and its other variations, and use those
as features with/without binarizing the values.
Shallow syntactic parse (or Chunk) and POS tags
have been shown to possess valuable cues for dis-
course segmentation (Fisher and Roark, 2007). For
example, it is less likely that an EDU boundary oc-
curs within a chunk. We, therefore, annotate the to-
kens of a sentence with chunk and POS tags by a
state-of-the-art tagger3 and encode these as features.
EDUs are normally multi-word strings. Thus, a
token near the beginning or end of a sentence is un-
likely to be the end of a segment. Therefore, for each
token we include its relative position in the sentence
and distances to the beginning and end as features.
It is unlikely that two consecutive tokens are
tagged with EDU boundaries. We incorporate con-
textual information for a token by including the
above features computed for its neighboring tokens.
We also experimented with different N-gram
(N?{1, 2, 3}) features extracted from the token se-
quence, POS sequence and chunk sequence. How-
ever, since such features did not improve the seg-
3http://cogcomp.cs.illinois.edu/page/software
mentation accuracy on the development set, they
were excluded from our final set of features.
5 Experiments
5.1 Corpora
To demonstrate the generality of our model, we ex-
periment with two different genres. First, we use the
standard RST-DT corpus (Carlson et al2002) that
contains discourse annotations for 385 Wall Street
Journal news articles from the Penn Treebank (Mar-
cus et al1994). Second, we use the Instructional
corpus developed by Subba and Eugenio (2009) that
contains discourse annotations for 176 instructional
how-to-do manuals on home-repair.
The RST-DT corpus is partitioned into a training
set of 347 documents (7673 sentences) and a test set
of 38 documents (991 sentences), and 53 documents
(1208 sentences) have been (doubly) annotated by
two human annotators, based on which we compute
the human agreement. We use the human-annotated
syntactic trees from Penn Treebank to train SPADE
in our experiments using RST-DT as done in (Sori-
cut and Marcu, 2003). We extracted a sentence-level
DT from a document-level DT by finding the subtree
that exactly spans over the sentence. By our count,
7321 sentences in the training set, 951 sentences
in the test set and 1114 sentences in the doubly-
annotated set have a well-formed DT in RST-DT.
The Instructional corpus contains 3430 sentences in
total, out of which 3032 have a well-formed DT.
This forms our sentence-level corpora for discourse
parsing. However, the existence of a well-formed
DT in not a necessity for discourse segmentation,
therefore, we do not exclude any sentence in our dis-
course segmentation experiments.
5.2 Experimental Setup
We perform our experiments on discourse pars-
ing in RST-DT with the 18 coarser relations (see
Figure 6) defined in (Carlson and Marcu, 2001)
and also used in SPADE and HILDA. By attach-
ing the nuclearity statuses (i.e., NS, SN, NN) to
these relations we get 39 distinct relations4. Our
experiments on the Instructional corpus consider
the same 26 primary relations (e.g., GOAL:ACT,
CAUSE:EFFECT, GENERAL-SPECIFIC) used in
4Not all relations take all the possible nuclearity statuses.
910
(Subba and Eugenio, 2009) and also treat the re-
versals of non-commutative relations as separate re-
lations. That is, PREPARATION-ACT and ACT-
PREPARATION are two different relations. Attach-
ing the nuclearity statuses to these relations gives 70
distinct relations in the Instructional corpus.
We use SPADE as our baseline model and apply
the same modifications to its default setting as de-
scribed in (Fisher and Roark, 2007), which delivers
improved performance. Specifically, in testing, we
replace the Charniak parser (Charniak, 2000) with a
more accurate reranking parser (Charniak and John-
son, 2005). We use the reranking parser in all our
models to generate the syntactic trees. This parser
was trained on the sections of the Penn Treebank not
included in the test set. For a fair comparison, we ap-
ply the same canonical lexical head projection rules
(Magerman, 1995; Collins, 2003) to lexicalize the
syntactic trees as done in SPADE and HILDA. Note
that, all the previous works described in Section 2,
report their models? performance on a particular test
set of a specific corpus. To compare our results with
the previous studies, we test our models on those
specific test sets. In addition, we show more general
performance based on 10-fold cross validation.
5.3 Parsing based on Manual Segmentation
First, we present the results of our discourse parser
based on manual segmentation. The parsing perfor-
mance is assessed using the unlabeled (i.e., span)
and labeled (i.e., nuclearity, relation) precision, re-
call and F-score as described in (Marcu, 2000b, page
143). For brevity, we report only the F-scores in Ta-
ble 2. Notice that, our parser (DCRF) consistently
outperforms SPADE (SP) on the RST-DT test set5.
Especially, on relation labeling, which is the hardest
among the three tasks, we get an absolute F-score
improvement of 9.5%, which represents a relative
error rate reduction of 29.3%. Our F-score of 77.1
in relation labeling is also close to the human agree-
ment (i.e., F-score of 83.0) on the doubly-annotated
data. Our results on the RST-DT test set are con-
sistent with the mean scores over 10-folds, when we
perform 10-fold cross validation on RST-DT.
The improvement is even larger on the Instruc-
tional corpus, where we compare our mean results
5The improvements are statistically significant (p < 0.01).
over 10-folds with the results reported in Subba and
Eugenio (S&E) (2009) on a test set6, giving ab-
solute F-score improvements of 4.8%, 15.5% and
10.6% in span, nuclearity and relations, respectively.
Our parser reduces the errors by 67.6%, 54.6% and
28.6% in span, nuclearity and relations, respectively.
RST-DT Instructional
Test set 10-fold Doubly S&E 10-fold
Scores SP DCRF DCRF Human ILP DCRF
Span 93.5 94.6 93.7 95.7 92.9 97.7
Nuc. 85.8 86.9 85.2 90.4 71.8 87.2
Rel. 67.6 77.1 75.4 83.0 63.0 73.6
Table 2: Parsing results using manual segmentation.
If we compare the performance of our model on
the two corpora, we see that our model is more accu-
rate in finding the right tree structure (see Span) on
the Instructional corpus. This may be due to the fact
that sentences in the Instructional domain are rela-
tively short and contain fewer EDUs than sentences
in the News domain, thus making it easier to find
the right tree structure. However, when we compare
the performance on the relation labeling task, we ob-
serve a decrease on the Instructional corpus. This
may be due to the small amount of data available for
training and the imbalanced distribution of a large
number of discourse relations in this corpus.
To analyze the features, Table 3 presents the pars-
ing results on the RST-DT test set using different
subsets of features. Every new subset of features
appears to improve the accuracy. More specifically,
when we add the organizational features with the
dominance set features (see S2), we get about 2%
absolute improvement in nuclearity and relations.
With N-gram features (S3), the gain is even higher;
6% in relations and 3.5% in nuclearity, demonstrat-
ing the utility of the N-gram features. This is con-
sistent with the findings of (duVerle and Prendinger,
2009; Schilder, 2002). Including the Contextual fea-
tures (S4), we get further 3% and 2.2% improve-
ments in nuclearity and relations, respectively. No-
tice that, adding the substructure features (S5) does
not help much in sentence-level parsing, giving only
6Subba and Eugenio (2009) report their results based on an
arbitrary split between a training set and a test set. We asked the
authors for their particular split. However, since we could not
obtain that information, we compare our model?s performance
based on 10-fold cross validation with their reported results.
911
an improvement of 0.8% in relations. Therefore, one
may choose to avoid using this computationally ex-
pensive feature in time-constrained scenarios. How-
ever, in the future, it will be interesting to see its im-
portance in document-level parsing with large trees.
Scores S1 S2 S3 S4 S5
Span 91.3 92.1 93.3 94.6 94.6
Nuclearity 78.2 80.3 83.8 86.8 86.9
Relation 66.2 68.1 74.1 76.3 77.1
Table 3: Parsing results based on manual segmentation
using different subsets of features on RST-DT test set.
Feature subsets S1 = {Dominance set}, S2 = {Dominance
set, Organizational}, S3 = {Dominance set, Organiza-
tional, N-gram}, S4 = {Dominance set, Organizational,
N-gram, Contextual}, S5 (all) = {Dominance set, Orga-
nizational, N-gram, Contextual, Substructure}.
5.4 Evaluation of the Discourse Segmenter
We evaluate the segmentation accuracy with respect
to the intra-sentential segment boundaries following
(Fisher and Roark, 2007). Specifically, if a sen-
tence contains n EDUs, which corresponds to n? 1
intra-sentence segment boundaries, we measure the
model?s ability to correctly identify these n ? 1
boundaries. Human agreement for this task is quite
high (F-score of 98.3) on RST-DT.
Table 4 shows the results of different models in
(P)recision, (R)ecall, and (F)-score on the two cor-
pora. We compare our model?s (LR) results with
HILDA (HIL), SPADE (SP) and the results reported
in Fisher and Roark (F&R) (2007) on the RST-DT
test set. HILDA gives the weakest performance7.
Our results are also much better than SPADE8, with
an absolute F-score improvement of 4.9%, and com-
parable to the results of F&R, even though we use
fewer features. Furthermore, we perform 10-fold
cross validation on both corpora and compare with
SPADE. However, SPADE does not come with a
training module for its segmenter. We reimple-
mented this module and verified it on the RST-DT
test set. Due to the lack of human-annotated syntac-
tic trees in the Instructional corpus, we train SPADE
in this corpus using the syntactic trees produced
7Note that, the high segmentation accuracy reported in (Her-
nault et al2010) is due to a less stringent evaluation metric.
8The improvements are statistically significant (p<2.4e-06)
by the reranking parser. Our model delivers abso-
lute F-score improvements of 3.8% and 8.1% on the
RST-DT and the Instructional corpora, respectively,
which is statistically significant in both cases (p <
3.0e-06). However, when we compare our results on
the two corpora, we observe a substantial decrease in
performance on the Instructional corpus. This could
be due to a smaller amount of data in this corpus and
the inaccuracies in the syntactic parser and taggers,
which are trained on news articles.
RST-DT Instructional
Test Set 10-fold 10-fold 10-fold
HIL SP F&R LR SP LR SP LR
P 77.9 83.8 91.3 88.0 83.7 87.5 65.1 73.9
R 70.6 86.8 89.7 92.3 86.2 89.9 82.8 89.7
F 74.1 85.2 90.5 90.1 84.9 88.7 72.8 80.9
Table 4: Segmentation results of different models.
5.5 Parsing based on Automatic Segmentation
In order to evaluate our full system, we feed our
discourse parser the output of our discourse seg-
menter. Table 5 shows the F-score results. We com-
pare our results with SPADE on the RST-DT test set.
We achieve absolute F-score improvements of 3.6%,
3.4% and 7.4% in span, nuclearity and relation, re-
spectively. These improvements are statistically sig-
nificant (p<0.001). Our system, therefore, reduces
the errors by 15.5%, 11.4%, and 17.6% in span, nu-
clearity and relations, respectively. These results are
also consistent with the mean results over 10-folds.
RST-DT Instructional
Test set 10-fold 10-fold
Scores SPADE DCRF DCRF DCRF
Span 76.7 80.3 78.7 71.9
Nuclearity 70.2 73.6 72.2 64.3
Relation 58.0 65.4 64.2 54.8
Table 5: Parsing results using automatic segmentation.
For the Instructional corpus, the last column of
Table 5 shows the mean 10-fold cross validation re-
sults. We cannot compare with S&E because no re-
sults were reported using an automatic segmenter.
However, it is interesting to observe how much our
full system is affected by an automatic segmenter
on both RST-DT and the Instructional corpus (see
Table 2 and Table 5). Nevertheless, taking into ac-
count the segmentation results in Table 4, this is
912
not surprising because previous studies (Soricut and
Marcu, 2003) have already shown that automatic
segmentation is the primary impediment to high ac-
curacy discourse parsing. This demonstrates the
need for a more accurate segmentation model in the
Instructional genre. A promising future direction
would be to apply effective domain adaptation meth-
ods (e.g., easyadapt (Daume, 2007)) to improve
the segmentation performance in the Instructional
domain by leveraging the rich data in RST-DT.
5.6 Error Analysis and Discussion
The results in Table 2 suggest that given a manually
segmented discourse, our sentence-level discourse
parser finds the unlabeled (i.e., span) discourse tree
and assigns the nuclearity statuses to the spans at a
performance level close to human annotators. We,
therefore, look more closely into the performance of
our parser on the hardest task of relation labeling.
Figure 6 shows the confusion matrix for the rela-
tion labeling task using manual segmentation on the
RST-DT test set. The relation labels are ordered ac-
cording to their frequency in the RST-DT training
set and represented by their initial letters. For exam-
ple, EL represents ELABORATION and CA repre-
sents CAUSE. In general, errors can be explained by
two different phenomena acting together: (i) the fre-
quency of the relations in the training data, and (ii)
the semantic (or pragmatic) similarity between the
relations. The most frequent relations (e.g., ELAB-
ORATION) tend to confuse the less frequent ones
(e.g., SUMMARY), and the relations which are se-
mantically similar (e.g., CAUSE, EXPLANATION)
confuse each other, making it hard to distinguish for
the computational models. Notice that, the confu-
sions caused by JOINT appears to be high consid-
ering its frequency. The confusion between JOINT
and TEMPORAL may be due to the fact that both of
these coarser relations9 contain finer relations (i.e.,
list in JOINT and sequence in TEMPORAL), which
are semantically similar, as pointed out by Carlson
and Marcu (2001). The confusion between JOINT
and BACKGROUND may be explained by their dif-
ferent (semantic vs. pragmatic) interpretation in the
RST theory (Stede, 2011, page 85).
9JOINT is actually not a relation, but is characterized by
juxtaposition of two EDUs without a relation.
Figure 6: Confusion matrix for the relation labels on
the RST-DT test set. Y-axis represents true and X-axis
represents predicted labels. The relation labels are TOPIC-
COMMENT, EVALUATION, SUMMARY, MANNER-MEANS,
COMPARISON, EXPLANATION, CONDITION, TEMPORAL,
CAUSE, ENABLEMENT, BACKGROUND, CONTRAST, JOINT,
SAME-UNIT, ATTRIBUTION, ELABORATION.
Based on these observations we will pursue two
ways to improve our discourse parser. We need a
more robust (e.g., bagging) method to deal with the
imbalanced distribution of relations, along with a
better representation of semantic knowledge. For
example, compositional semantics (Subba and Eu-
genio, 2009) and subjectivity (Somasundaran, 2010)
can be quite relevant for identifying relations.
6 Conclusion
In this paper, we have described a complete prob-
abilistic discriminative framework for performing
sentence-level discourse analysis. Experiments indi-
cate that our approach outperforms the state-of-the-
art on two corpora, often by a wide margin.
In ongoing work, we plan to generalize our
DCRF-based parser to multi-sentential text and also
verify to what extent parsing and segmentation can
be jointly performed. A longer term goal is to extend
our framework to also work with graph structures
of discourse, as recommended by several recent dis-
course theories (Wolf and Gibson, 2005). Once we
achieve similar performance on graph structures, we
will perform extrinsic evaluation to determine their
relative utility for various NLP tasks.
Acknowledgments
We are grateful to G. Murray, J. CK Cheung, the 3
reviewers and the NSERC CGS-D award.
913
References
Or Biran and Owen Rambow. 2011. Identifying Justifi-
cations in Written Dialogs by Classifying Text as Ar-
gumentative. Int. J. Semantic Computing, 5(4):363?
381.
J. Blitzer, 2008. Domain Adaptation of Natural Lan-
guage Processing Systems. PhD thesis, University of
Pennsylvania.
L. Breiman. 1996. Bagging predictors. Machine Learn-
ing, 24(2):123?140, August.
L. Carlson and D. Marcu. 2001. Discourse Tagging Ref-
erence Manual. Technical Report ISI-TR-545, Univer-
sity of Southern California Information Sciences Insti-
tute.
L. Carlson, D. Marcu, and M. Okurowski. 2002. RST
Discourse Treebank (RST-DT) LDC2002T07. Lin-
guistic Data Consortium, Philadelphia.
E. Charniak and M. Johnson. 2005. Coarse-to-Fine n-
Best Parsing and MaxEnt Discriminative Reranking.
In Proceedings of the 43rd Annual Meeting of the As-
sociation for Computational Linguistics, pages 173?
180, NJ, USA. ACL.
E. Charniak. 2000. A Maximum-Entropy-Inspired
Parser. In Proceedings of the 1st North American
Chapter of the Association for Computational Linguis-
tics Conference, pages 132?139, Seattle, Washington.
ACL.
M. Collins. 2003. Head-Driven Statistical Models for
Natural Language Parsing. Computational Linguis-
tics, 29(4):589?637, December.
H. Daume. 2007. Frustratingly Easy Domain Adapta-
tion. In Proceedings of the 45th Annual Meeting of
the Association for Computational Linguistics, pages
256?263, Prague, Czech Republic. ACL.
D. duVerle and H. Prendinger. 2009. A Novel Discourse
Parser based on Support Vector Machine Classifica-
tion. In Proceedings of the Joint Conference of the
47th Annual Meeting of the ACL and the 4th Interna-
tional Joint Conference on Natural Language Process-
ing of the AFNLP, pages 665?673, Suntec, Singapore.
ACL.
J. Finkel, A. Kleeman, and C. Manning. 2008. Efficient,
Feature-based, Conditional Random Field Parsing. In
Proceedings of the 46th Annual Meeting of the Associ-
ation for Computational Linguistics, pages 959?967,
Columbus, Ohio, USA. ACL.
S. Fisher and B. Roark. 2007. The Utility of Parse-
derived Features for Automatic Discourse Segmenta-
tion. In Proceedings of the 45th Annual Meeting of
the Association for Computational Linguistics, pages
488?495, Prague, Czech Republic. ACL.
S. Ghosh, R. Johansson, G. Riccardi, and S. Tonelli.
2011. Shallow Discourse Parsing with Conditional
Random Fields. In Proceedings of the 5th Interna-
tional Joint Conference on Natural Language Process-
ing, pages 1071?1079, Chiang Mai, Thailand. AFNLP.
H. Hernault, H. Prendinger, D. duVerle, and M. Ishizuka.
2010. HILDA: A Discourse Parser Using Support
Vector Machine Classification. Dialogue and Dis-
course, 1(3):1?33.
D. Jurafsky and J. Martin, 2008. Speech and Language
Processing, chapter 14. Prentice Hall.
A. Knott and R. Dale. 1994. Using Linguistic Phenom-
ena to Motivate a Set of Coherence Relations. Dis-
course Processes, 18(1):35?62.
J. Lafferty, A. McCallum, and F. Pereira. 2001. Condi-
tional Random Fields: Probabilistic Models for Seg-
menting and Labeling Sequence Data. In Proceedings
of the Eighteenth International Conference on Ma-
chine Learning, pages 282?289, San Francisco, CA,
USA. Morgan Kaufmann Publishers Inc.
D. Magerman. 1995. Statistical Decision-tree Mod-
els for Parsing. In Proceedings of the 33rd annual
meeting on Association for Computational Linguistics,
pages 276?283, Cambridge, Massachusetts. ACL.
W. Mann and S. Thompson. 1988. Rhetorical Structure
Theory: Toward a Functional Theory of Text Organi-
zation. Text, 8(3):243?281.
D. Marcu. 2000a. The Rhetorical Parsing of Unrestricted
Texts: A Surface-based Approach. Computational
Linguistics, 26:395?448.
D. Marcu. 2000b. The Theory and Practice of Discourse
Parsing and Summarization. MIT Press, Cambridge,
MA, USA.
M. Marcus, B. Santorini, and M. Marcinkiewicz. 1994.
Building a Large Annotated Corpus of English:
The Penn Treebank. Computational Linguistics,
19(2):313?330.
A. McCallum. 2002. MALLET: A Machine Learning
for Language Toolkit. http://mallet.cs.umass.edu.
K. Murphy. 2012. Machine Learning A Probabilistic
Perspective (Forthcoming, August 2012). MIT Press,
Cambridge, MA, USA.
R. Prasad, A. Joshi, N. Dinesh, A. Lee, E. Miltsakaki, and
B. Webber. 2005. The Penn Discourse TreeBank as a
Resource for Natural Language Generation. In Pro-
ceedings of the Corpus Linguistics Workshop on Us-
ing Corpora for Natural Language Generation, pages
25?32, Birmingham, U.K.
R. Prasad, N. Dinesh, A. Lee, E. Miltsakaki, L. Robaldo,
A. Joshi, and B. Webber. 2008. The Penn Discourse
TreeBank 2.0. In Proceedings of the Sixth Interna-
tional Conference on Language Resources and Eval-
uation (LREC), pages 2961?2968, Marrakech, Mo-
rocco. ELRA.
914
F. Schilder. 2002. Robust Discourse Parsing via Dis-
course Markers, Topicality and Position. Natural Lan-
guage Engineering, 8(3):235?255, June.
F. Sha and F. Pereira. 2003. Shallow Parsing with
Conditional Random Fields. In Proceedings of the
2003 Conference of the North American Chapter of the
Association for Computational Linguistics on Human
Language Technology - Volume 1, pages 134?141, Ed-
monton, Canada. ACL.
S. Somasundaran, 2010. Discourse-Level Relations for
Opinion Analysis. PhD thesis, University of Pitts-
burgh.
R. Soricut and D. Marcu. 2003. Sentence Level Dis-
course Parsing Using Syntactic and Lexical Informa-
tion. In Proceedings of the 2003 Conference of the
North American Chapter of the Association for Com-
putational Linguistics on Human Language Technol-
ogy - Volume 1, pages 149?156, Edmonton, Canada.
ACL.
C. Sporleder and M. Lapata. 2005. Discourse Chunk-
ing and its Application to Sentence Compression. In
Proceedings of the conference on Human Language
Technology and Empirical Methods in Natural Lan-
guage Processing, pages 257?264, Vancouver, British
Columbia, Canada. ACL.
M. Stede. 2011. Discourse Processing. Synthesis Lec-
tures on Human Language Technologies. Morgan And
Claypool Publishers, November.
R. Subba and B. Di Eugenio. 2009. An Effective
Discourse Parser that Uses Rich Linguistic Informa-
tion. In Proceedings of Human Language Technolo-
gies: The 2009 Annual Conference of the North Ameri-
can Chapter of the Association for Computational Lin-
guistics, pages 566?574, Boulder, Colorado. ACL.
C. Sutton, A. McCallum, and K. Rohanimanesh. 2007.
Dynamic Conditional Random Fields: Factorized
Probabilistic Models for Labeling and Segmenting Se-
quence Data. Journal of Machine Learning Research
(JMLR), 8:693?723.
S. Verberne, L. Boves, N. Oostdijk, and P. Coppen.
2007. Evaluating Discourse-based Answer Extrac-
tion for Why-question Answering. In Proceedings of
the 30th annual international ACM SIGIR conference
on Research and development in information retrieval,
pages 735?736, Amsterdam, The Netherlands. ACM.
M. Wainwright, T. Jaakkola, and A. Willsky. 2002. Tree-
based Reparameterization for Approximate Inference
on Loopy Graphs. In Advances in Neural Information
Processing Systems 14, pages 1001?1008. MIT Press.
F. Wolf and E. Gibson. 2005. Representing Discourse
Coherence: A Corpus-Based Study. Computational
Linguistics, 31:249?288, June.
915
Proceedings of the Workshop on Evaluation Metrics and System Comparison for Automatic Summarization, pages 10?18,
Montre?al, Canada, June 3-8, 2012. c?2012 Association for Computational Linguistics
Using the Omega Index for Evaluating Abstractive Community Detection
Gabriel Murray
Computer Information Systems
University of the Fraser Valley
gabriel.murray@ufv.ca
Giuseppe Carenini
Computer Science
University of British Columbia
carenini@cs.ubc.ca
Raymond Ng
Computer Science
University of British Columbia
rng@cs.ubc.ca
Abstract
Numerous NLP tasks rely on clustering or
community detection algorithms. For many
of these tasks, the solutions are disjoint, and
the relevant evaluation metrics assume non-
overlapping clusters. In contrast, the relatively
recent task of abstractive community detection
(ACD) results in overlapping clusters of sen-
tences. ACD is a sub-task of an abstractive
summarization system and represents a two-
step process. In the first step, we classify sen-
tence pairs according to whether the sentences
should be realized by a common abstractive
sentence. This results in an undirected graph
with sentences as nodes and predicted abstrac-
tive links as edges. The second step is to
identify communities within the graph, where
each community corresponds to an abstrac-
tive sentence to be generated. In this paper,
we describe how the Omega Index, a met-
ric for comparing non-disjoint clustering so-
lutions, can be used as a summarization eval-
uation metric for this task. We use the Omega
Index to compare and contrast several commu-
nity detection algorithms.
1 Introduction
Automatic summarization has long been proposed
as a helpful tool for managing the massive amounts
of language data in our modern lives (Luhn, 1958;
Edmundson, 1969; Teufel and Moens, 1997; Car-
bonell and Goldstein, 1998; Radev et al, 2001).
Most summarization systems are extractive, mean-
ing that a subset of sentences from an input docu-
ment forms a summary of the whole. Particular sig-
nificance may be attached to the chosen sentences,
e.g. that they are relevant to a provided query, gen-
erally important for understanding the overall doc-
ument, or represent a particular phenomenon such
as action items from a meeting. In any case, ex-
traction consists of binary classification of candidate
sentences, plus post-processing steps such as sen-
tence ranking and compression. In contrast, recent
work attempts to replicate the abstractive nature of
human-authored summaries, wherein new sentences
are generated that describe the input document from
a higher-level perspective. While some abstractive
summary sentences are very similar to individual
sentences from the document, others are created
by synthesizing multiple document sentences into
a novel abstract sentence. In this paper, we ad-
dress a component of this latter task, namely iden-
tifying which sentences from the source documents
should be combined in generated abstract sentences.
We call this task abstractive community detection
(ACD), and apply the task to a publicly available
meeting dataset.
Herein we focus on describing how the Omega
Index (Collins and Dent, 1988), a metric for com-
paring non-disjoint clustering solutions, can be used
as a summarization evaluation metric for the ACD
task. Metrics such as the Rand Index (Rand, 1971)
are insufficient since they are intended only for dis-
joint clusters.
ACD itself is carried out in two steps. First, we
classify sentence pairs according to whether they
should be realized by a common abstractive sen-
tence. For this step, we use supervised machine
learning that exploits human-annotated links be-
tween abstracts and extracts for a given document.
This results in an undirected graph with nodes repre-
senting sentences and edges representing predicted
abstractive links. Second, we identify communi-
ties within the graph, where each community cor-
responds to an abstractive sentence to be generated.
We experiment with several divisive community de-
10
tection algorithms, and highlight the importance of
selecting an algorithm that allows overlapping com-
munities, owing to the fact that a document sentence
can be expressed by, and linked to, more than one
abstract summary sentence in the gold-standard.
The structure of the paper is as follow. In Sec-
tion 2, we compare and contrast ACD with other
relevant tasks such as extractive summarization and
topic clustering. In Sections 3-4, we describe the
two ACD steps before we can fully discuss evalua-
tion methods. Section 5 describes the experimental
setup and corpora used, including a description of
the abstractive and extractive summary annotations
and the links between them. In Section 6, we give a
detailed description of the Omega Index and explain
how it differs from the more common Rand Index.
In Sections 7-8 we present results and draw conclu-
sions.
2 Related Work
The ACD task differs from more common extrac-
tive summarization (Mani, 2001a; Jurafsky and Mar-
tin, 2008). Whereas extraction involves simply clas-
sifying sentences as important or not, ACD is a
sub-task of abstractive summarization wherein doc-
ument sentences are grouped according to whether
they can be jointly realized by a common abstrac-
tive sentence. The first step of ACD, where we pre-
dict links between sentence pairs, can be seen to en-
compass extraction since the link is via an as-yet-
ungenerated abstract sentence, i.e. each linked sen-
tence is considered summary-worthy. However, the
second step moves away from extraction by cluster-
ing the linked sentences from the document in order
to generate abstract summary sentences.
ACD also differs from topic clustering (Malioutov
and Barzilay, 2006; Joty et al, 2010), though there
are superficial similarities. A first observation is that
topic links and abstract links are genuinely differ-
ent phenomena, though sometimes related. A sin-
gle abstract sentence can reference more than one
topic, e.g. They talked about the interface design
and the budget report, and a single topic can be
referenced in numerous abstract sentences. From a
practical standpoint, in our work on ACD we can-
not use many of the methods and evaluation metrics
designed for topic clustering, due to the fact that a
document sentence can belong to more than one ab-
stract sentence. This leads to overlapping commu-
nities, whereas most work on topic clustering has
focused primarily on disjoint communities where a
sentence belongs to a single topic. In Section 4, we
discuss community detection algorithms and evalu-
ation metrics that allow overlapping communities.
Work on detecting adjacency pairs (Shriberg et
al., 2004; Galley et al, 2004) also involves classify-
ing sentence pairs as being somehow related. For ex-
ample, if sentence B directly follows sentence A, we
might determine that they have a relationship such
as question-answer or request-accept. In contrast,
with ACD there is no requirement that sentence pairs
be adjacent or even in proximity to one another, nor
must they be in a rhetorical relation.
Work on sentence fusion (Barzilay and McKe-
own, 2005) identifies sentences containing similar
or repeated information and combines them into
new sentences. In contrast, in our task sentences
need not contain repeated information in order to be
linked. For example, two sentences could be linked
to a common abstract sentence due to a more com-
plex rhetorical relationship such as proposal-reject
or question-answer.
ACD is a more general problem that may incor-
porate elements of topic clustering, adjacency pair
detection and other sentence clustering or pairing
tasks. Here we try to directly learn the abstrac-
tive sentence links using lower-level features such as
shared n-grams and cosine similarity, as described in
Section 3, but in future work we will model higher-
level features of topics and rhetorical structure.
3 Step 1: Building a Sentence Pair Graph
In order to describe the use of the Omega Index for
the ACD task, we must first introduce the ACD task
in some detail. The first step in ACD is to determine
which sentence pairs are linked. If two sentences are
linked, it means they can be at least partly realized
in the abstract summary by a common sentence. A
document sentence may ?belong? to more than one
abstract sentence. We take a supervised classifica-
tion approach to this problem, training on a dataset
containing explicit links between extract sentences
and abstract sentences. The corpus and relevant an-
notation are described in detail in Section 5. For
11
Figure 1: Linked Sentences
our gold-standard data, a sentence pair is considered
linked if both sentences are linked to a common ab-
stract sentence and not-linked otherwise.
Figure 1 shows an example snippet of linked sen-
tences from our corpus. The first and second sen-
tences are linked via one abstract sentence while the
first and third sentences are linked via a different ab-
stract sentence. While it is not shown in this exam-
ple, note that two sentences can also be linked via
more than one abstract sentence.
We take a supervised machine learning approach
toward predicting whether a sentence pair is linked.
For each pair, we extract features that can be classed
as follows:
? Structural: The intervening number of sen-
tences, the document position as indicated by
the midpoint of the two sentences, the com-
bined length and the difference in length be-
tween the two sentences, and whether the two
sentences share the same speaker.
? Linguistic: The number of shared bigrams,
shared part-of-speech tags, the sum and aver-
age of tf.idf weights, and the cosine similarity
of the sentence vectors.
We run the trained classifier over sentence pairs,
predicting abstractive links between sentences in the
document. This results in an unweighted, undirected
graph where nodes represent sentences and edges
Figure 2: Graph with Sentence Nodes
represent an abstractive link. Continuing with the
conversation snippet from Figure 1, we would end
up with a graph like Figure 2. This very simple
example of a graph shows that there are abstractive
links predicted between sentences s1 and s2 and be-
tween sentences s1 and s3. There is no direct link
predicted between sentences s2 and s3. However,
it is possible for two sentences with no predicted
link between them to wind up in the same abstractive
community after running a community detection al-
gorithm on the graph. We discuss this community
detection step in the following section.
4 Step 2: Discovering Abstractive
Sentence Communities
In the first step of ACD, we predicted whether pairs
of sentences can be at least partly realized by a com-
mon abstractive sentence. We then want to identify
communities or clusters within the graph. Each of
these communities will correspond to an abstractive
12
Figure 3: Overlapping Communities in Graph
sentence that we will generate. Continuing with our
simple example, Figure 3 shows two communities
that have been identified in the graph. Note that
the communities are overlapping, as each contains
sentence s1; we would generate one abstractive sen-
tence describing sentences s1 and s2 and another de-
scribing sentences s1 and s3. We will return to this
critical issue of overlapping communities shortly.
The task of identifying communities in networks
or graphs has received considerable attention (Porter
et al, 2009). The Girvan-Newman algorithm (Gir-
van and Newman, 2002) is a popular community de-
tection method based on a measure of betweenness.
The betweenness score for an edge is the number of
shortest paths between pairs of nodes in the graph
that run along that edge. An edge with a high be-
tweenness score is likely to be between two commu-
nities and is therefore a good candidate for removal,
as the goal is to break the initial graph into distinct
communities. The Girvan-Newman algorithm pro-
ceeds as follows:
1. Calculate the betweenness of each edge in the
graph.
2. Remove the edge with the highest betweenness.
3. For any edge affected by Step 2, recalculate be-
tweenness.
4. Repeat steps 2 and 3 until no edges remain
In this way we proceed from the full graph with all
edges intact to the point where no edges remain and
each node is in its own community. The intermediate
steps can be visualized by the resulting dendrogram,
such as seen in Figure 4 1.
The top row, the ?leaves? of the dendrogram, rep-
resents the individual nodes in the graph. The rest
1Image Source: Wikimedia Commons (Mhbrugman)
Figure 4: Community Dendrogram
of the dendrogram shows how these nodes are sit-
uated in nested communities, e.g. b and c form a
community bc that combines with def to form bcdef.
In our case, where nodes are sentences, the dendro-
gram shows us how sentences combine into nested
communities. This can be useful for generating ab-
stracts of different granularities, e.g. we could de-
scribe bcdef in one sentence or generate two sen-
tences to separately describe bc and def.
The drawback of Girvan-Newman for our pur-
poses is that it does not allow overlapping commu-
nities, and we know that our human-annotated data
contain overlaps. Note from Figure 4 that all com-
munities decompose into disjoint nested communi-
ties, such as bcdef being comprised of bc and def,
not bc and bdef or some other overlapping case.
We therefore hypothesize that Girvan-Newman in its
traditional form is not sufficient for our current re-
search. For the same reason, recent graph-based ap-
proaches to topic clustering (Malioutov and Barzi-
lay, 2006; Joty et al, 2010) are not directly applica-
ble here.
It is only in recent years that much attention has
been paid to the problem of overlapping (or non-
disjoint) communities. Here we consider two recent
modifications to the Girvan-Newman algorithm that
allow for overlaps. The CONGA algorithm (Gre-
gory, 2007) extends Girvan-Newman so that instead
of removing an edge on each iteration, we either
remove an edge or copy a node. When a node is
copied, an overlap is created. Nodes are associated
with a betweenness score (called the split between-
ness) derived from the edge betweenness scores, and
at each step we either remove the edge with the high-
est betweenness score or copy the node with the
13
Figure 5: CONGA algorithm
highest split betweenness, if it is greater. The edge
and node betweenness scores are then recalculated.
In such a manner we can detect overlapping com-
munities. Figure 5 shows the CONGA copying and
splitting operations applied to our simple example,
so that sentence s1 now exists in two communities.
The CONGO algorithm (Gregory, 2008) is an ap-
proximation of CONGA that is more efficient for
large graphs. Girvan-Newman (and hence CONGA)
are not feasible algorithms for very large graphs, due
to the number of repeated betweenness calculations.
CONGO addresses this problem by using local be-
tweenness scores. Instead of calculating between-
ness using the shortest paths of every pair of nodes
in the graph, only nodes within a given horizon h of
an edge are considered. When h =? then CONGO
and CONGA are identical. Gregory (Gregory, 2008)
found good results using h = 2 or h = 3 on a va-
riety of datasets including blog networks; here we
experiment h = 2.
For the community detection step of our system,
we run both CONGA and CONGO on our graphs
and compare our results with the Girvan-Newman
algorithm. For all community detection methods,
as well as human annotations, any sentences that
are not linked to at least one other sentence in Step
1 are assigned to their own singleton communities.
Also, the algorithms we are evaluating are hierarchi-
cal (see Figure 4), and we evaluate at n = 18 clus-
ters, since that is the average number of sentences
per abstractive meeting summary in the training set.
5 Experimental Setup
In this section we describe the dataset used, includ-
ing relevant annotations, as well as the statistical
classifiers used for Step 1.
5.1 AMI Corpus
For these experiments we use the AMI meeting cor-
pus (Carletta, 2006), specifically, the subset of sce-
nario meetings where participants play roles within
a fictional company. For each meeting, an annotator
first authors an abstractive summary. Multiple an-
notators then create extractive summaries by linking
sentences from the meeting transcript to sentences
within the abstract. This generates a many-to-many
mapping between transcript sentences and abstract
sentences, so that a given transcript sentence can
relate to more than one abstract sentence and vice-
verse. A sample of this extractive-abstractive linking
was shown in Figure 1.
It is known that inter-annotator agreement can be
quite low for the summarization task (Mani et al,
1999; Mani, 2001b), and this is the case with the
AMI extractive summarization codings. The aver-
age ? score is 0.45.
In these experiments, we use only human-
authored transcripts and plan to use speech recog-
nition transcripts in the future. Note that our overall
approach is not specific to conversations or to speech
data. Step 2 is completely general, while Step 1 uses
a single same-speaker feature that is specific to con-
versations. That feature can be dropped to make our
approach completely general (or, equivalently, that
binary feature can be thought of as always 1 when
applied to monologic text).
5.2 Classifiers
For Step 1, predicting abstractive links between sen-
tences, we train a logistic regression classifier us-
ing the liblinear toolkit2. The training set consists
of 98 meetings and there are nearly one million sen-
tence pair instances since we consider every pairing
of sentences within a meeting. The test set consists
of 20 meetings on which we perform our evaluation.
6 Evaluation Metrics
In this section, we present our evaluation metrics for
the two steps of the task.
6.1 Step 1 Evaluation: PRF and AUROC
For evaluating Step 1, predicting abstractive sen-
tence links, we present both precision/recall/f-score
2http://www.csie.ntu.edu.tw/ cjlin/liblinear/
14
as well as the area under the receiver operator char-
acteristic curve (AUROC). While the former scores
evaluate the classifier at a particular posterior proba-
bility threshold, the AUROC evaluates the classifier
more generally by comparing the true-positive and
false-positive rates at varying probability thresholds.
6.2 Step 2 Evaluation: The Omega Index
For evaluating Step 2, ACD, we employ a metric
called the Omega Index which is designed for com-
paring disjoint clustering solutions. To describe and
motivate our use of this metric, it is necessary to de-
scribe previous metrics upon which the Omega In-
dex improves. The Rand Index (Rand, 1971) is a
way of comparing disjoint clustering solutions that
is based on pairs of the objects being clustered. Two
solutions are said to agree on a pair of objects if they
each put both objects into the same cluster or each
into different clusters. The Rand Index can then be
formalized as
(a+ d)/N
where N is the number of pairs of objects, a is
the number of times the solutions agree on putting
a pair in the same cluster and d is the number of
times the solutions agree on putting a pair in differ-
ent clusters. That is, the Rand Index is the number of
pairs that are agreed on by the two solutions divided
by the total number of pairs. The Rand Index is in-
sufficient for overlapping solutions because pairs of
objects can exist together in more than one commu-
nity. In those cases, two solutions might agree on
the occurrence of a pair of objects in one commu-
nity but disagree on the occurrence of that pair in
another community. The Rand Index cannot capture
that distinction.
An improvement to the Rand Index is the Ad-
justed Rand Index (Hubert and Arabie, 1985) which
adjusts the level of agreement according to the ex-
pected amount of agreement based on chance. How-
ever, the Adjusted Rand Index also cannot account
for disjoint solutions.
The Omega Index (Collins and Dent, 1988) builds
on both the Rand Index and Adjusted Rand Index
by accounting for disjoint solutions and correcting
for chance agreement. The Omega Index considers
the number of clusters in which a pair of objects is
together. The observed agreement between solutions
is calculated by
Obs(s1, s2) =
min(J,K)?
j=0
Aj/N
where J and K represent the maximum number of
clusters in which any pair of objects appears together
in solutions 1 and 2, respectively, Aj is the number
of the pairs agreed by both solutions to be assigned
to number of clusters j, and N is again the number
of pairs of objects. That is, the observed agreement
is the proportion of pairs classified the same way by
the two solutions. The expected agreement is given
by:
Exp(s1, s2) =
min(J,K)?
j=0
Nj1Nj2/N
2
where Nj1 is the total number of pairs assigned
to number of clusters j in solution 1, and Nj2 is the
total number of pairs assigned to number of clusters
j in solution 2. The Omega Index is then calculated
as
Omega(s1, s2) =
Obs(s1, s2)? Exp(s1, s2)
1? Exp(s1, s2)
The numerator is the observed agreement adjusted
by expected agreement, while the denominator is
maximum possible agreement adjusted by expected
agreement. The highest possible score of 1 indicates
that two solutions perfectly agree on how each pair
of objects is clustered. With the Omega Index, we
can now evaluate the overlapping solutions discov-
ered by our community detection algorithms.3
7 Results
In this section we present the results for both steps
of ACD. Because the Omega Index is not used for
evaluating Step 1, we keep that discussion brief.
7.1 Step 1 Results: Predicting Abstractive
Sentence Links
For the task of predicting abstractive links within
sentence pairs, the resulting graphs have an aver-
age of 133 nodes and 1730 edges, though this varies
3Software for calculating the Omega Index will be released
upon publication of this paper.
15
System Prec. Rec. F-Score AUROC
Lower-Bound 0.18 1 0.30 0.50
Message Links 0.30 0.03 0.05 -
Abstractive Links 0.62 0.54 0.54 0.89
Table 1: P/R/F and AUROCs for Link Prediction
widely depending on meeting length (from 37 nodes
and 61 edges for one short meeting to 224 edges and
5946 edges for a very long meeting). In compar-
ison, the gold-standard graphs have an average of
113 nodes and 1360 edges. The gold-standards sim-
ilarly show huge variation in graph size depending
on meeting length.
Table 1 reports both the precision/recall/f-scores
as well as the AUROC metrics. We compare our
supervised classifier (labeled ?Abstractive Links?)
with a lower-bound where all instances are predicted
as positive, leading to perfect recall and low preci-
sion. Our system scores moderately well on both
precision and recall, with an average f-score of 0.54.
The AUROC for the abstractive link classifier is
0.89.
It is difficult to compare with previous work since,
to our knowledge, nobody has previously modeled
these extractive-abstractive mappings between doc-
ument sentences and associated abstracts. We can
compare with the results of Murray et al (2010),
however, who linked sentences by aggregating them
into messages. In that work, each message is com-
prised of sentences that share a dialogue act type
(e.g. an action item) and mention at least one com-
mon entity (e.g. remote control). Similar to our
work, sentences can belong to more than one mes-
sage. We assess how well their message-based ap-
proach captures these abstractive links, reporting
their precision/recall/f-scores for this task in Table 1,
with their system labeled ?Message Links?. While
their precision is above the lower-bound, the recall
and f-score are extremely low. This demonstrates
that their notion of message links does not capture
the phenomenon of abstractive sentence linking.
7.2 Step 2 Results: Discovering Abstractive
Communities
For the task of discovering abstractive communi-
ties in our sentence graphs, Table 2 reports the
Omega Index for the CONGA, CONGO and Girvan-
Newman algorithms. We also report the average
Omega Index for the human annotators themselves,
derived by comparing each pair of annotator solu-
tions for each meeting.
It is not surprising that the Omega Index is low for
the inter-annotator comparison; we reported previ-
ously that the ? score for the extractive summaries of
this corpus is 0.45. That ? score indicates that there
is high disagreement about which sentences are most
important in a meeting. We should not be surprised
then that there is further disagreement about how the
sentences are linked to one another. What is surpris-
ing is that the automatic community detection al-
gorithms achieve higher Omega Index scores than
do the annotators. Note that the higher scores of
the community detection algorithms relative to hu-
man agreement is not simply an artefact of identify-
ing clustering solutions that have more overlap than
human solutions, since even the disjoint Girvan-
Newman solutions are higher than inter-annotator
levels. One possible explanation is that the annota-
tors are engaged in a fairly local task when they cre-
ate extractive summaries; for each abstractive sen-
tence, they are looking for a set of sentences from
the document that relate to that abstract sentence,
and because of high redundancy in the document the
different annotators choose subsets of sentences that
have little overlap but are still similar (Supporting
this, we have found that we can train on annotator
A?s extractive codings and test on annotator B?s and
get good classification results even if A and B have a
low ? score.). In contrast, the community detection
algorithms are taking a more comprehensive, global
approach by considering all predicted links between
sentences (Step 1) and identifying the overlapping
communities among them (Step 2).
When looking for differences between automatic
and human community detection, we observed that
the algorithms assigned more overlap to sentences
16
System Omega
Girvan-Newman 0.254
CONGA 0.263
CONGO 0.241
Human 0.209
Table 2: Omega Index for Community Detection
than did the human annotators. For example, the
CONGA algorithm assigned each sentence to an av-
erage of 1.1 communities while the human annota-
tors assigned each to an average of 1.04 communi-
ties. Note that every sentence belongs to at least one
community since unlinked sentences belong to their
own singleton communities, and most sentences are
unlinked, explaining why both scores are close to 1.
Comparing the algorithms themselves, we find
that CONGA is better than both Girvan-Newman
(marginally significant, p = 0.07) and CONGO
(p = 0.015) according to paired t-test. We be-
lieve that the superiority of CONGA over Girvan-
Newman points to the importance of allowing over-
lapping communities. And while CONGO is an ef-
ficient approximation of CONGA that can be useful
for very large graphs where CONGA and Girvan-
Newman cannot be applied, in these experiments the
local betweenness used by CONGO leads to lower
overall scores. Furthermore, our networks are small
enough that both CONGA and Girvan-Newman are
able to finish quickly and there is therefore no need
to rely on CONGO.
Our Step 2 results are dependent on the qual-
ity of the Step 1 results. We therefore test how
good our community detection results would be if
we had gold-standard graphs rather than the imper-
fect output from Step 1. We report two sets of re-
sults. In the first case, we take an annotator?s gold-
standard sentence graph showing links between sen-
tences and proceed to run our algorithms over that
graph, comparing our community detection results
with the communities detected by all annotators. In
the second case, we again take an annotator?s gold-
standard graph and apply our algorithms, but then
only compare our community detection results with
the communities detected by the annotator who sup-
plied the gold-standard graph. Table 3 shows both
sets of results. We can see that the latter set contains
System Omega Omega
All Annots. 1 Annot.
Girvan-Newman 0.445 0.878
CONGA 0.454 0.896
CONGO 0.453 0.894
Table 3: Omega Index, Gold-Standard Graphs
much higher scores, again reflecting that annotators
disagree with each other on this task.
Given gold-standard sentence graphs, CONGA
and CONGO perform very similarly; the differences
are negligible. Both are substantially better than the
Girvan-Newman algorithm (all p < 0.01). This tells
us that it is necessary to employ community detec-
tion algorithms that allow overlapping communities.
These results also tell us that the CONGO algorithm
is more sensitive to errors in the Step 1 output since
it performed well using the gold-standard but worse
than Girvan-Newman when using the automatically
derived graphs.
8 Conclusion
After giving an overview of the ACD task and our
approach to it, we described how the Omega Index
can be used as a summarization evaluation metric for
this task, and explained why other community de-
tection metrics are insufficient. The Omega Index is
suitable because it can account for overlapping clus-
tering solutions, and corrects for chance agreement.
The main surprising result was that all of the com-
munity detection algorithms have higher Omega In-
dex scores than the human-human Omega scores
representing annotator agreement. We have offered
one possibe explanation; namely, that while the hu-
man annotators have numerous similar candidate
sentences from the document that each could be
linked to a given abstract sentence, they may be sat-
isfied to only link (and thus extract) a small repre-
sentative handful, whereas the community detection
algorithms work to find all extractive-abstractive
links. We plan to further research this issue, and po-
tentially derive other evaluation metrics that better
account for this phenomenon.
17
References
R. Barzilay and K. McKeown. 2005. Sentence fusion for
multidocument news summarization. Computational
Linguistics, 31(3):297?328.
J. Carbonell and J. Goldstein. 1998. The use of MMR,
diversity-based reranking for reordering documents
and producing summaries. In Proc. of ACM SIGIR
Conference on Research and Development in Informa-
tion Retrieval 1998, Melbourne, Australia, pages 335?
336.
J. Carletta. 2006. Unleashing the killer corpus: expe-
riences in creating the multi-everything ami meeting
corpus. In Proc. of LREC 2006, Genoa, Italy, pages
181?190.
L. Collins and C. Dent. 1988. Omega: A general formu-
lation of the rand index of cluster recovery suitable for
non-disjoint solutions. Multivariate Behavioral Re-
search, 23:231?242.
H. P. Edmundson. 1969. New methods in automatic ex-
tracting. J. ACM, 16(2):264?285.
M. Galley, K. McKeown, J. Hirschberg, and E. Shriberg.
2004. Identifying agreement and disagreement in con-
versational speech: Use of bayesian networks to model
pragmatic dependencies. In Proc. of ACL 2004.
M. Girvan and M.E.J. Newman. 2002. Community
structure in social and biological networks. Proc. of
the National Academy of Sciences, 99:7821?7826.
S. Gregory. 2007. An algorithm to find overlap-
ping community structure in networks. In Proc. of
ECML/PKDD 2007, Warsaw, Poland.
S. Gregory. 2008. A fast algorithm to find overlapping
communities in networks. In Proc. of ECML/PKDD
2008, Antwerp, Belgium.
L. Hubert and P. Arabie. 1985. Comparing partitions.
Journal of Classification, 2:193?218.
S. Joty, G. Carenini, G. Murray, and R. Ng. 2010. Ex-
ploiting conversation structure in unsupervised topic
segmentation for emails. In Proc. of EMNLP 2010,
Cambridge, MA, USA.
D. Jurafsky and J. H. Martin, 2008. Speech and Lan-
guage Processing. Prentice Hall.
H. P. Luhn. 1958. The automatic creation of litera-
ture abstracts. IBM Journal of Research Development,
2(2):159?165.
I. Malioutov and R. Barzilay. 2006. Minimum cut model
for spoken lecture segmentation. In Proc. of ACL
2006, Sydney, Australia.
I. Mani, D. House, G. Klein, L. Hirschman, T. Firmin,
and B. Sundheim. 1999. The TIPSTER SUMMAC
text summarization evaluation. In Proc. of EACL
1999, Bergen, Norway, pages 77?85.
I. Mani. 2001a. Automatic Summarization. John Ben-
jamin, Amsterdam, NL.
I. Mani. 2001b. Summarization evaluation: An
overview. In Proc. of the NTCIR Workshop 2 Meeting
on Evaluation of Chinese and Japanese Text Retrieval
and Text Summarization, Tokyo, Japan, pages 77?85.
G. Murray, G. Carenini, and R. Ng. 2010. Generating
and validating abstracts of meeting conversations: a
user study. In Proc. of INLG 2010, Dublin, Ireland.
M. Porter, J-P. Onnela, and P. Mucha. 2009. Communi-
ties in networks. Notices of the American Mathemati-
cal Society, 56:1082?1097.
D. Radev, S. Blair-Goldensohn, and Z. Zhang. 2001. Ex-
periments in single and multi-document summariza-
tion using MEAD. In Proc. of DUC 2001, New Or-
leans, LA, USA.
W.M. Rand. 1971. Objective criteria for the evaluation
of clustering methods. Journal of the American Statis-
tical Association, 66:846?850.
E. Shriberg, R. Dhillon, S. Bhagat, J. Ang, , and H. Car-
vey. 2004. The ICSI meeting recorder dialog act
(MRDA) corpus. In Proceedings of SIGdial Workshop
on Discourse and Dialogue, Cambridge, MA, USA,
pages 97?100.
S. Teufel and M. Moens. 1997. Sentence extraction as a
classification task. In Proc. of ACL 1997, Workshop on
Intelligent and Scalable Text Summarization, Madrid,
Spain, pages 58?65.
18
