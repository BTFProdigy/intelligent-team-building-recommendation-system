Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 917?927,
October 25-29, 2014, Doha, Qatar.
c
?2014 Association for Computational Linguistics
A Polynomial-Time Dynamic Oracle
for Non-Projective Dependency Parsing
Carlos G
?
omez-Rodr??guez
Departamento de
Computaci?on
Universidade da Coru?na, Spain
cgomezr@udc.es
Francesco Sartorio
Department of
Information Engineering
University of Padua, Italy
sartorio@dei.unipd.it
Giorgio Satta
Department of
Information Engineering
University of Padua, Italy
satta@dei.unipd.it
Abstract
The introduction of dynamic oracles has
considerably improved the accuracy of
greedy transition-based dependency pars-
ers, without sacrificing parsing efficiency.
However, this enhancement is limited to
projective parsing, and dynamic oracles
have not yet been implemented for pars-
ers supporting non-projectivity. In this
paper we introduce the first such oracle,
for a non-projective parser based on At-
tardi?s parser. We show that training with
this oracle improves parsing accuracy over
a conventional (static) oracle on a wide
range of datasets.
1 Introduction
Greedy transition-based parsers for dependency
grammars have been pioneered by Yamada and
Matsumoto (2003) and Nivre (2003). These meth-
ods incrementally process the input sentence from
left to right, predicting the next parsing action,
called transition, on the basis of a compact rep-
resentation of the derivation history.
Greedy transition-based parsers can be very
efficient, allowing web-scale parsing with high
throughput. However, the accuracy of these meth-
ods still falls behind that of transition-based pars-
ers using beam-search, where the accuracy im-
provement is obtained at the cost of a decrease
in parsing efficiency; see for instance Zhang and
Nivre (2011), Huang and Sagae (2010), Choi and
McCallum (2013). As an alternative to beam-
search, recent research on transition-based parsing
has therefore explored possible ways of improving
accuracy at no extra cost in parsing efficiency.
The training of transition-based parsers relies
on a component called the parsing oracle, which
maps parser configurations to optimal transitions
with respect to a gold tree. A discriminative model
is then trained to simulate the oracle?s behavior,
and is later used for decoding. Traditionally, so-
called static oracles have been exploited in train-
ing, where a static oracle is defined only for con-
figurations that have been reached by computa-
tions with no mistake, and it returns a single ca-
nonical transition among those that are optimal.
Very recently, Goldberg and Nivre (2012),
Goldberg and Nivre (2013) and Goldberg et al.
(2014) showed that the accuracy of transition-
based parsers can be substantially improved using
dynamic oracles. A dynamic oracle returns the
set of all transitions that are optimal for a given
configuration, with respect to the gold tree, and
is well-defined and correct for every configuration
that is reachable by the parser.
Na??ve implementations of dynamic oracles run
in exponential time, since they need to simulate
all possible computations of the parser for the in-
put configuration. Polynomial-time implementa-
tions of dynamic oracles have been proposed by
the above mentioned authors for several project-
ive dependency parsers. To our knowledge, no
polynomial-time algorithm has been published for
transition-based parsers based on non-projective
dependency grammars.
In this paper we consider a restriction of a
transition-based, non-projective parser originally
presented by Attardi (2006). This restriction
was further investigated by Kuhlmann and Nivre
(2010) and Cohen et al. (2011). We provide an im-
plementation for a dynamic oracle for this parser
running in polynomial time.
We experimentally compare the parser trained
with the dynamic oracle to a baseline obtained
by training with a static oracle. Significant ac-
curacy improvements are achieved on many lan-
guages when using our dynamic oracle. To our
knowledge, these are the first experimental results
on non-projective parsing based on a dynamic or-
acle.
917
2 Preliminary Definitions
Transition-based dependency parsing was origin-
ally introduced by Yamada and Matsumoto (2003)
and Nivre (2003). In this section we briefly sum-
marize the notation we use for this framework and
introduce the notion of dynamic oracle.
2.1 Transition-Based Dependency Parsing
We represent an input sentence as a string w =
w
0
? ? ?w
n
, n ? 1, where each w
i
with i 6= 0 is a
lexical symbol and w
0
is a special symbol called
root. Set V
w
= {i | 0 ? i ? n} denotes the sym-
bol occurrences in w. For i, j ? V
w
with i 6= j,
we write i ? j to denote a grammatical depend-
ency of some unspecified type betweenw
i
andw
j
,
where w
i
is the head and w
j
is the dependent.
A dependency tree t for w is a directed tree
with node set V
w
and with root node 0. An arc of t
is a pair (i, j), encoding a dependency i ? j; we
will often use the latter notation to denote arcs.
A transition-based dependency parser typically
uses a stack data structure to process the input
string from left to right, in a way very similar
to the classical push-down automaton for context-
free languages (Hopcroft et al., 2006). Each stack
element is a node from V
w
, representing the root
of a dependency tree spanning some portion of the
input w, and no internal state is used. At each step
the parser applies some transition that updates the
stack and/or consumes one symbol from the input.
Transitions may also construct new dependencies,
which are added to the current configuration of the
parser.
We represent the stack as an ordered sequence
? = [h
d
, . . . , h
1
], d ? 0, of nodes h
i
? V
w
, with
the topmost element placed at the right. When
d = 0, we have the empty stack ? = []. We use
the vertical bar to denote the append operator for
?, and write ? = ?
?
|h
1
to indicate that h
1
is the
topmost element of ?.
The portion of the input string still to be pro-
cessed by the parser is called the buffer. We
represent the buffer as an ordered sequence ? =
[i, . . . , n] of nodes from V
w
, with i the first ele-
ment of the buffer. We denote the empty buffer
as ? = []. Again, we use the vertical bar to de-
note the append operator, and write ? = i|?
?
to
indicate that i is the first symbol occurrence of ?;
consequently, we have ?
?
= [i+ 1, . . . , n].
In a transition-based parser, the parsing pro-
cess is defined through the technical notions of
configuration and transition. A configuration of
the parser relative to w is a triple c = (?, ?,A),
where ? and ? are a stack and a buffer, respect-
ively, and A is the set of arcs that have been built
so far. A transition is a partial function map-
ping the set of parser configurations into itself.
Each transition-based parser is defined by means
of some finite inventory of transitions. We will
later introduce the specific inventory of transitions
for the parser that we investigate in this paper.
We use the symbol ` to denote the binary relation
formed by the union of all transitions of a parser.
With the notions of configuration and transition
in place, we can define a computation of the
parser on w as a sequence c
0
, c
1
, . . . , c
m
, m ? 0,
of configurations relative tow, under the condition
that c
i?1
` c
i
for each i with 1 ? i ? m. We use
the reflexive and transitive closure of `, written
`
?
, to represent computations.
2.2 Configuration Loss and Dynamic Oracles
A transition-based dependency parser is a non-
deterministic device, meaning that a given con-
figuration can be mapped into several configur-
ations by the available transitions. However, in
several implementations the parser is associated
with a discriminative model that, on the basis of
some features of the current configuration, always
chooses a single transition. In other words, the
model is used to run the parser as a pseudo-de-
terministic device. The training of the discriminat-
ive model relies on a component called the parsing
oracle, which maps parser configurations to ?op-
timal? transitions with respect to some reference
dependency tree, which we call the gold tree.
Traditionally, so-called static oracles have been
used which return a single, canonical transition
and they do so only for configurations that can
reach the gold tree, that is, configurations repres-
enting parsing histories with no mistake. In re-
cent work, Goldberg and Nivre (2012), Goldberg
and Nivre (2013) and Goldberg et al. (2014) have
introduced dynamic oracles, which return the set
of all transitions that are optimal with respect to
a gold tree, and are well-defined and correct for
every configuration that is reachable by the parser.
These authors have shown that the accuracy of
transition-based dependency parsers can be sub-
stantially improved if dynamic oracles are used in
place of static ones. In what follows, we provide
a mathematical definition of dynamic oracles, fol-
lowing Goldberg et al. (2014).
918
(?, k|?,A) `
sh
(?|k, ?,A)
(?|i|j, ?,A) `
la
(?|j, ?,A ? {j ? i})
(?|i|j, ?,A) `
ra
(?|i, ?, A ? {i? j})
(?|i|j|k, ?,A) `
la
2
(?|j|k, ?,A ? {k ? i})
(?|i|j|k, ?,A) `
ra
2
(?|i|j, ?,A ? {i? k})
Figure 1: Transitions of the non-projective parser.
Let t
1
and t
2
be dependency trees for w, with
arc sets A
1
and A
2
, respectively. The loss of t
1
with respect to t
2
is defined as
L(t
1
, t
2
) = |A
1
\A
2
| . (1)
Note that L(t
1
, t
2
) = L(t
2
, t
1
), since |A
1
| = |A
2
|.
Furthermore L(t
1
, t
2
) = 0 if and only if t
1
and t
2
are the same tree.
Let c be a configuration of a transition-based
parser relative to w. Let also D(c) be the set of all
dependency trees that can be obtained in a com-
putation of the form c `
?
c
f
, where c
f
is a final
configuration, that is, a configuration that has con-
structed a dependency tree for w. We extend the
loss function in (1) to configurations by letting
L(c, t
2
) = min
t
1
?D(c)
L(t
1
, t
2
) . (2)
Let t
G
be the gold tree for w. Quantity L(c, t
G
)
can be used to define a dynamic oracle as follows.
For any transition `
?
in the finite inventory of our
parser, we use the functional notation ?(c) = c
?
in
place of c `
?
c
?
. We then let
oracle(c, t
G
) =
{? | L(?(c), t
G
)? L(c, t
G
) = 0} . (3)
In words, (3) provides the set of transitions that do
not increase the loss of c; we call these transitions
optimal for c.
A na??ve way of implementing (3) would be
to explicitly compute the set D(c) in (2), which
has exponential size. More interestingly, the im-
plementation of dynamic oracles proposed by the
above cited authors all run in polynomial time.
These oracles are all defined for projective pars-
ing. In this paper, we present a polynomial-time
oracle for a non-projective parser.
3 Non-Projective Dependency Parsing
In this section we introduce a parser for non-
projective dependency grammars that is derived
from the transition-based parser originally presen-
ted by Attardi (2006), and was further investigated
by Kuhlmann and Nivre (2010) and Cohen et al.
(2011). Our definitions follow the framework in-
troduced in Section 2.1.
We start with some additional notation. Let t be
a dependency tree for w and let k be a node of t.
Consider the complete subtree t
?
of t rooted at k,
that is, the subtree of t induced by k and all of the
descendants of k in t. The span of t
?
is the sub-
sequence of tokens in w represented by the nodes
of t
?
. Node k has gap-degree 0 if the span of t
?
forms a (contiguous) substring of w. A depend-
ency tree is called projective if all of its nodes
have gap-degree 0; a dependency tree which is not
projective is called non-projective.
Given w as input, the parser starts with the ini-
tial configuration ([], [0, . . . , n], ?), consisting of
an empty stack, a buffer with all the nodes repres-
enting the symbol occurrences in w, and an empty
set of constructed dependencies (arcs). The parser
stops when it reaches a final configuration of the
form ([0], [], A), consisting of a stack with only the
root node and of an empty buffer; in any such con-
figuration, set A always implicitly defines a valid
dependency tree (rooted in node 0).
The core of the parser consists of an invent-
ory of five transitions, defined in Figure 1. Each
transition is specified using the free variables ?,
?, A, i, j and k. As an example, the schema
(?|i|j, ?,A) `
la
(?|j, ?,A? {j ? i}) means that
if a configuration c matches the antecedent, then a
new configuration is obtained by instantiating the
variables in the consequent accordingly.
The transition `
sh
, called shift, reads a new
token from the input sentence by removing it from
the buffer and pushing it into the stack. Each
of the other transitions, collectively called reduce
transitions, has the effect of building a dependency
between two nodes in the stack, and then removing
the dependent node from the stack. The removal
of the dependent ensures that the output depend-
ency tree is built in a bottom-up order, collecting
all of the dependents of each node i before linking
i to its head.
The transition `
la
, called left-arc, creates a left-
ward arc where the topmost stack node is the
head and the second topmost node is the depend-
ent, and removes the latter from the stack. The
transition `
ra
, called right-arc, is defined sym-
metrically, so that the topmost stack node is at-
919
? ? ?
h h h
h
1 1 2
3minimum
stack length
at c     c1
c c c0 1
stack length
...
...
m
m
Figure 2: General form of the computations asso-
ciated with an item [h
1
, h
2
, h
3
].
tached as a dependent of the second topmost node.
The combination of the shift, left-arc and right-
arc transitions provides complete coverage of pro-
jective dependency trees, but no support for non-
projectivity, and corresponds to the so-called arc-
standard parser introduced by Nivre (2004).
Support for non-projective dependencies is
achieved by adding the transitions `
la
2
and `
ra
2
,
which are variants of the left-arc and right-arc
transitions, respectively. These new transitions
create dependencies involving the first and the
third topmost nodes in the stack. The creation of
dependencies between non-adjacent stack nodes
might produce crossing arcs and is the key to the
construction of non-projective trees.
Recall that transitions are partial functions,
meaning that they might be undefined for some
configurations. Specifically, the shift transition is
only defined for configurations with a non-empty
buffer. Similarly, the left-arc and right-arc trans-
itions can only be applied if the length of the stack
is at least 2, while the transitions `
la
2
and `
ra
2
re-
quire at least 3 nodes in the stack.
Transitions `
la
2
and `
ra
2
were originally intro-
duced by Attardi (2006) together with other, more
complex transitions. The parser we define here
is therefore more restrictive than Attardi (2006),
meaning that it does not cover all the non-pro-
jective trees that can be processed by the ori-
ginal parser. However, the restricted parser has re-
cently attracted some research interest, as it covers
the vast majority of non-projective constructions
appearing in standard treebanks (Attardi, 2006;
Kuhlmann and Nivre, 2010), while keeping sim-
plicity and interesting properties like being com-
patible with polynomial-time dynamic program-
ming (Cohen et al., 2011).
4 Representation of Computations
Our oracle algorithm exploits a dynamic program-
ming technique which, given an input string, com-
bines certain pieces of a computation of the parser
from Section 3 to obtain larger pieces. In order
to efficiently encode pieces of computations, we
borrow a representation proposed by Cohen et al.
(2011), which is introduced in this section.
Let w = a
0
? ? ? a
n
and V
w
be specified as in
Section 2, and let w
?
be some substring of w. (The
specification of w
?
is not of our concern in this
section.) Let also h
1
, h
2
, h
3
? V
w
. We are inter-
ested in computations of the parser processing the
substring w
?
and having the form c
0
, c
1
, . . . , c
m
,
m ? 1, that satisfy both of the following condi-
tions, exemplified in Figure 2.
? For some sequence of nodes ? with |?| ? 0,
the stack associated with c
0
has the form ?|h
1
and the stack associated with c
m
has the form
?|h
2
|h
3
.
? For each intermediate configuration c
i
, 1 ?
i ? m ? 1, the stack associated with c
i
has
the form ??
i
, where ?
i
is a sequence of nodes
with |?
i
| ? 2.
An important property of the above definition
needs to be discussed here, which is at the heart of
the polynomial-time algorithm in the next section.
If in c
0
, c
1
, . . . , c
m
we replace ? with a different
sequence ?
?
, we obtain a valid computation for w
?
constructing exactly the same dependencies as the
original computation. To see this, let c
i?1
`
?
i
c
i
for each i with 1 ? i ? m. Then `
?
1
must be a
shift, otherwise |?
1
| ? 2 would be violated. Con-
sider now a transition `
?
i
with 2 ? i ? m that
builds some dependency. From |?
i
| ? 2 we derive
|?
i?1
| ? 3. We can easily check from Figure 1
that none of the nodes in ? can be involved in the
constructed dependency.
Intuitively, the above property asserts that the
sequence of transitions `
?
1
,`
?
2
, . . . ,`
?
m
can be
applied to parse substring w
?
independently of the
context ?. This suggests that we can group into
an equivalence class all the computations satisfy-
ing the conditions above, for different values of
?. We indicate such class by means of the tuple
[h
1
, h
2
h
3
], called item. It is easy to see that each
item represents an exponential number of compu-
tations. In the next section we will show how we
can process items with the purpose of obtaining an
efficient computation for dynamic oracles.
920
5 Dynamic Oracle Algorithm
Our algorithm takes as input a gold tree t
G
for
string w and a parser configuration c = (?, ?,A)
relative to w, specified as in Section 2. We assume
that t
G
can be parsed by the non-projective parser
of Section 3 starting from the initial configuration.
5.1 Basic Idea
The algorithm consists of two separate stages, in-
formally discussed in what follows. In the first
stage we identify some tree fragments of t
G
that
can be constructed by the parser after reaching
configuration c, in a way that does not depend on
the content of ?. This means that these fragments
can be precomputed by looking only into ?. Fur-
thermore, since these fragments are subtrees of t
G
,
their computation has no effect on the overall loss
of a computation on w.
For each fragment t with the above properties,
we replace all the nodes in ? that are also nodes
of t with the root node of t itself. The result of the
first stage is therefore a new node sequence shorter
than ?, which we call the reduced buffer ?
R
.
In the second stage of the algorithm we use a
variant of the tabular method developed by Co-
hen et al. (2011), which was originally designed
to simulate all computations of the parser in Sec-
tion 3 on an input string w. We run the above
method on the concatenation of the stack and the
reduced buffer, with some additional constraints
that restrict the search space in two respects. First,
we visit only those computations of the parser
that step through configuration c. Second, we
reach only those dependency trees that contain all
the tree fragments precomputed in the first stage.
We can show that such search space always con-
tains at least one dependency tree with the desired
loss, which we then retrieve performing a Viterbi
search.
5.2 Preprocessing of the Buffer
Let t be a complete subtree of t
G
, having root
node k in ?. Consider the following two condi-
tions, defined on t.
? Bottom-up completeness: No arc i ? j in t
is such that i is a node in ?, i 6= k, and j is a
node in ?.
? Zero gap-degree: The nodes of t that are in ?
form a (contiguous) substring of w.
We claim that if t satisfies the above conditions,
then we can safely reduce the nodes of t appearing
in ?, replacing them with node k. We only report
here an informal discussion of this claim, and omit
a formal proof.
As a first remark, recall that our parser imple-
ments a purely bottom-up strategy. This means
that after a tree has been constructed, all of its
nodes but the root are removed from the parser
configuration. Then the Bottom-up completeness
condition guarantees that if we remove from ? all
nodes of t but k, the nodes of t that are in ? can still
be processed in a way that does not affect the loss,
since their parent must be either k or a node that is
neither in ? nor in ?. Note that the nodes of t that
are neither in ? nor in ? are irrelevant to the pre-
computation of t from ?, since these nodes have
already been attached and are no longer available
to the parser.
As a second remark, the Zero gap-degree con-
dition guarantees that the span of t over the nodes
of ? is not interleaved by nodes that do not belong
to t. This is also an important requirement for the
precomputation of t from ?, since a tree fragment
having a discontinuous span over ? might not be
constructable independently of ?. More specific-
ally, parsing such fragment implies dealing with
the nodes in the discontinuities, and this might re-
quire transitions involving nodes from ?.
We can now use the sufficient condition above
to compute ?
R
. We process ? from left to right.
For each node k, we can easily test the Bottom-up
completeness condition and the Zero gap-degree
condition for the complete subtree t of t
G
rooted
at k, and perform the reduction if both conditions
are satisfied. Note that in this process a node k
resulting from the reduction of t might in turn be
removed from ? if, at some later point, we reduce
a supertree of t.
5.3 Computation of the Loss
We describe here our dynamic programming al-
gorithm for the computation of the loss of an in-
put configuration c. We start with some additional
notation. Let ? = ??
R
be the concatenation of ?
and ?
R
, which we treat as a string of nodes. For
integers i with 0 ? i ? |?| ? 1, we write ?[i] to
denote the (i + 1)-th node of ?. Let also ` = |?|.
Symbol ` is used to mark the boundary between
the stack and the reduced buffer in ?, thus ?[i] with
i < ` is a node of ?, while ?[i] with i ? ` is a node
of ?
R
.
Algorithm 1 computes the loss of c by pro-
cessing the sequence ? in a way quite similar to the
921
standard nested loop implementation of the CKY
parser for context-free grammars (Hopcroft et al.,
2006). The algorithm uses a two-dimensional ar-
ray T whose indexes range from 0 to |?| = ` +
|?
R
|, and only the cells T [i, j] with i < j are
filled.
We view each T [i, j] as an association list
whose keys are items [h
1
, h
2
h
3
], defined in the
context of the substring ?[i] ? ? ? ?[j ? 1] of ?; see
Section 4. The value stored at T [i, j]([h
1
, h
2
h
3
])
is the minimum loss contribution due to the com-
putations represented by [h
1
, h
2
h
3
]. For technical
reasons, we assume that our parser starts with a
symbol $ 6? V
w
in the stack, denoting the bottom
of the stack.
We initialize the table by populating the cells
of the form T [i, i + 1] with information about
the trivial computations consisting of a single `
sh
transition that shifts the node ?[i] into the stack.
These computations are known to have zero loss
contribution, because a `
sh
transition does not cre-
ate any arcs. In the case where the node ?[i] be-
longs to ?, i.e., i < `, we assign loss contribution
0 to the entry T [i, i + 1]([?[i? 1], ?[i? 1]?[i]])
(line 3 of Algorithm 1), because ?[i] is shifted with
?[i? 1] at the top of the stack. On the other hand,
if ?[i] is in ?, i.e., i ? `, we assign loss contri-
bution 0 to several entries in T [i, i + 1] (line 6)
because, at the time ?[i] is shifted, the content of
the stack depends on the transitions executed be-
fore that point.
After the above initialization, we consider
pairs of contiguous substrings ?[i] ? ? ? ?[k ? 1] and
?[k] ? ? ? ?[j ? 1] of ?. At each inner iteration
of the nested loops of lines 7-11 we update cell
T [i, j] based on the content of the cells T [i, k] and
T [k, j]. We do this through the procedure PRO-
CESSCELL(T , i, k, j), which considers all pairs
of keys [h
1
, h
2
h
3
] in T [i, k] and [h
3
, h
4
h
5
] in
T [k, j]. Note that we require the index h
3
to match
between both items, meaning that their computa-
tions can be concatenated. In this way, for each
reduce transition ? in our parser, we compute the
loss contribution for a new piece of computation
defined by concatenating a computation with min-
imum loss contribution in the first item and a com-
putation with minimum loss contribution in the
second item, followed by the transition ? . The fact
that the new piece of computation can be repres-
ented by an item is exemplified in Figure 3 for the
case ? = `
ra
2
.
?
h1
c0
?
h
h
2
3
c
?
h
h
2
3
c
?
h
h
2
c
h5
4
?
h
h
4
5
c +1
la  : create arc
h     h  and remove
h   from stack
2
5 2
2
[h , h h ]1 2 3 la 2?
?
h1
c0
?
h
h
4
5
c +1
... ...
+ +[h , h h ]3 4 5
[h , h h ]1 4 5
...
?
m m r r
r
Figure 3: Concatenation of two computa-
tions/items and transition `
ra
2
, resulting in a new
computation/item.
The computed loss contribution is used to up-
date the entry in T [i, j] corresponding to the item
associated with the new computation. Observe
how the loss contribution provided by the arc cre-
ated by ? is computed by the ?
G
function at lines
17, 20, 23 and 26, which is defined as:
?
G
(i? j) =
{
0, if i? j is in t
G
;
1, otherwise.
(4)
We remark that the nature of our problem al-
lows us to apply several shortcuts and optimiza-
tions that would not be possible in a setting where
we actually needed to parse the string ?. First, the
range of variable i in the loop in line 8 starts at
max{0, `?d}, rather than at 0, because we do not
need to combine pairs of items originating from
nodes in ? below the topmost node, as the items
resulting from such combinations correspond to
computations that do not contain our input config-
uration c. Second, when we have set values for i
such that i+2 < `, we can omit calling PROCESS-
CELL for values of the parameter k ranging from
i+2 to `?1, as those calls would use as their input
one of the items described above, which are not of
interest. Finally, when processing substrings that
are entirely in ?
R
(i ? `) we can restrict the trans-
itions that we explore to those that generate arcs
that either are in the gold tree t
G
, or have a parent
node which is not present in ? (see conditions in
922
Algorithm 1 Computation of the loss function
1: T [0, 1]([$, $0])? 0 . shift node 0 on top of empty stack symbol $
2: for i? 1 to `? 1 do
3: T [i, i+ 1]([?[i? 1], ?[i? 1]?[i]])? 0 . shift node ?[i] with ?[i? 1] on top of the stack
4: for i? ` to |?| do
5: for h? 0 to i? 1 do
6: T [i, i+ 1]([?[h], ?[h]?[i]])? 0 . shift node ?[i] with ?[h] on top of the stack
7: for d? 2 to |?| do . consider substrings of length d
8: for i? max{0, `? d} to |?| ? d do . i = beginning of substring
9: j ? i+ d . j ? 1 = end of substring
10: PROCESSCELL(T , i, i+ 1, j) . We omit the range k = i+ 2 to max{i+ 2, `} ? 1
11: for k ? max{i+ 2, `} to j do . factorization of substring at k
12: PROCESSCELL(T , i, k, j)
13: return T [0, |?|]([$, $0]) +
?
i?[0,`?1]
L
c
(?[i], t
G
)
14: procedure PROCESSCELL(T , i, k, j)
15: for each key [h
1
, h
2
h
3
]) defined in T [i, k] do
16: for each key [h
3
, h
4
h
5
]) defined in T [k, j] do . h
3
must match between the two entries
17: loss
la
? T [i, k]([h
1
, h
2
h
3
]) + T [k, j]([h
3
, h
4
h
5
]) + ?
G
(h
5
? h
4
)
18: if (i < `) ? ?
G
(h
5
? h
4
) = 0 ? (h
5
6? ?) then
19: T [i, j]([h
1
, h
2
h
5
])? min{loss
la
, T [i, j]([h
1
, h
2
h
5
])} . cell update `
la
20: loss
ra
? T [i, k]([h
1
, h
2
h
3
]) + T [k, j]([h
3
, h
4
h
5
]) + ?
G
(h
4
? h
5
)
21: if (i < `) ? ?
G
(h
4
? h
5
) = 0 ? (h
4
6? ?) then
22: T [i, j]([h
1
, h
2
h
4
])? min{loss
ra
, T [i, j]([h
1
, h
2
h
4
])} . cell update `
ra
23: loss
la
2
? T [i, k]([h
1
, h
2
h
3
]) + T [k, j]([h
3
, h
4
h
5
]) + ?
G
(h
5
? h
2
)
24: if (i < `) ? ?
G
(h
5
? h
2
) = 0 ? (h
5
6? ?) then
25: T [i, j]([h
1
, h
4
h
5
])? min{loss
la
2
, T [i, j]([h
1
, h
4
h
5
])} . cell update `
la
2
26: loss
ra
2
? T [i, k]([h
1
, h
2
h
3
]) + T [k, j]([h
3
, h
4
h
5
]) + ?
G
(h
2
? h
5
)
27: if (i < `) ? ?
G
(h
2
? h
5
) = 0 ? (h
2
6? ?) then
28: T [i, j]([h
1
, h
2
h
4
])? min{loss
ra
2
, T [i, j]([h
1
, h
2
h
4
])} . cell update `
ra
2
lines 18, 21, 24, 27), because we know that incor-
rectly attaching a buffer node as a dependent of an-
other buffer node, when the correct head is avail-
able, can never be an optimal decision in terms of
loss.
Once we have filled the table T , the loss for
the input configuration c can be obtained from the
value of the entry T [0, |?|]([$, $0]), representing
the minimum loss contribution among computa-
tions that reach the input configuration c and parse
the whole input string. To obtain the total loss,
we add to this value the loss contribution accu-
mulated by the dependency trees with root in the
stack ? of c. This is represented in Algorithm 1 as
?
i?[0,`?1]
L
c
(?[i], t
G
), where L
c
(?[i], t
G
) is the
count of the descendants of ?[i] (the (i+1)-th ele-
ment of ?) that had been assigned the wrong head
by the parser with respect to t
G
.
5.4 Sample Run
Consider the Czech sentence and the gold depend-
ency tree t
G
shown in Figure 4(a). Given the con-
figuration c = (?, ?,A) where ? = [0, 1, 3, 4],
? = [5, . . . , 13] and A = {3 ? 2}, we trace the
two stages of the algorithm.
Preprocessing of the buffer The complete sub-
tree rooted at node 7 satisfies the Bottom-up com-
pleteness and the Zero gap-degree conditions in
Section 5.2, so the nodes 5, . . . , 12 in ? can be
replaced with the root 7. Note that all the nodes in
the span 5, . . . , 12 have all their (gold) dependents
in that span, with the exception of the root 7, with
its dependent node 1 still in the stack. No other
reduction is possible, and we have ?
R
= [7, 13].
The corresponding fragment of t
G
is represented
in Figure 4(b).
Computation of the loss Let ? = ??
R
. Al-
gorithm 1 builds the two-dimensional array T in
Figure 4(c). Each cell T [i, j] contains an asso-
ciation list, whose (key:value) pairs map items to
their loss contribution. Figure 4(c) only shows the
pairs involved in the minimum-loss computation.
Lines 1-6 of Algorithm 1 initialize the cells in
the diagonal, T [0, 1], . . . , T [5, 6]. The boundary
between stack and buffer is ` = 4, thus cells
T [0, 1], T [1, 2], and T [2, 3] contain only one ele-
ment, while T [3, 4], T [4, 5] and T [5, 6] contain as
many as the previous elements in ?, although not
all of them are shown in the figure.
Lines 7-12 fill the superdiagonals until T [0, 6]
is reached. The cells T [0, 2], T [0, 3] and T [1, 3]
923
-Root- V be?z?ne?m provozu vs?ak telefonn?? linky nermaj?? takivou kvalitu jako v laborator?i .
0 1 2 3 4 5 6 7 8 9 10 11 12 13
(a) Non-projective dependency tree from the Prague Dependency Treebank.
-Root- V provozu vs?ak nermaj?? .
0 1 3 4 7 13
? ?R
(b) Fragment of dependency tree in (a) after buffer
reduction.
i j 1 2 3 4 5 6
0 [$,$ 0]:0 ? ? . . . [$,$ 0]:1 [$,$ 0]:1
1 [0,0 1]:0 ? . . . [0,0 4]:1 . . .
2 [1,1 3]:0 [1,1 4]:1 [1,4 7]:1 . . .
3 [3,3 4]:0 [3,4 7]:1 . . .
4 [4,4 7]:0 . . .
5 [0,0 13]:0
(c) Relevant portion of T computed by Algorithm 1, with the
loss of c in the yellow entry.
Figure 4: Example of loss computation given the sentence in (a) and considering a configuration c with
? = [0, 1, 3, 4] and ? = [5, . . . , 13].
are left empty because ` = 4. Once T [0, 6]
is calculated, it contains only the entry with key
[$, $, 0], with the associated value 1 representing
the minimum number of wrong arcs that the pars-
ing algorithm has to build to reach a final con-
figuration from c. Then, Line 13 retrieves the
loss of the configuration, computed as the sum of
T [0, 6]([$, $, 0]) with the termL
c
, representing the
erroneous arcs made before reaching c.
Note that in our example the loss of c is 1, even
though L
c
= 0, meaning that there are no wrong
arcs in A. Indeed, given c, there is no single com-
putation that builds all the remaining arcs in t
G
.
This is reflected in T , where the path to reach the
item with minimum loss has to go through either
T [3, 5] or T [2, 4], which implies building the erro-
neous arc (w
7
? w
3
) or (w
4
? w
3
), respectively.
6 Computational Analysis
The first stage of our algorithm can be easily im-
plemented in time O(|?| |t
G
|), where |t
G
| is the
number of nodes in t
G
, which is equal to the length
n of the input string.
For the worst-case complexity of the second
stage (Algorithm 1), note that the number
of cell updates made by calling PROCESS-
CELL(T , i, k, j) with k < ` is O(|?|
3
|?|
2
|?
R
|).
This is because these updates can only be caused
by procedure calls on line 10 (as those on line 12
always set k ? `) and therefore the index k always
equals i + 1, while h
2
must equal h
1
because the
item [h
1
, h
2
h
3
] is one of the initial items created
on line 3. The variables i, h
1
and h
3
must index
nodes on the stack ? as they are bounded by k,
while j ranges over ?
R
and h
4
and h
5
can refer to
nodes either on ? or on ?
R
.
On the other hand, the number of cell updates
triggered by calls to PROCESSCELL such that k ?
` is O(|?|
4
|?
R
|
4
), as they happen for four indices
referring to nodes of ?
R
(k, j, h
4
, h
5
) and four
indices that can range over ? or ?
R
(i, h
1
, h
2
, h
3
).
Putting everything together, we conclude that
the overall complexity of our algorithm is
O(|?| |t
G
|+ |?|
3
|?|
2
|?
R
|+ |?|
4
|?
R
|
4
).
In practice, quantities |?|, |?
R
| and |?| are signi-
ficantly smaller than n, providing reasonable train-
ing times as we will see in Section 7. For instance,
when measured on the Czech treebank, the aver-
age value of |?| is 7.2, with a maximum of 87.
Even more interesting, the average value of |?
R
|
is 2.6, with a maximum of 23. Comparing this to
the average and maximum values of |?|, 11 and
192, respectively, we see that the buffer reduction
is crucial in reducing training time.
Note that, when expressed as a function of n,
our dynamic oracle has a worst-case time com-
plexity of O(n
8
). This is also the time complexity
of the dynamic programming algorithm of Cohen
et al. (2011) we started with, simulating all com-
putations of our parser. In contrast, the dynamic
oracle of Goldberg et al. (2014) for the projective
case achieves a time complexity ofO(n
3
) from the
dynamic programming parser by Kuhlmann et al.
(2011) running in time O(n
5
).
924
The reason why we do not achieve any asymp-
totic improvement is that some helpful properties
that hold with projective trees are no longer satis-
fied in the non-projective case. In the projective
(arc-standard) case, subtrees that are in the buf-
fer can be completely reduced. As a consequence,
each oracle step always combines an inferred entry
in the table with either a node from the stack or a
node from the reduced buffer, asymptotically re-
ducing the time complexity. However, in the non-
projective (Attardi) case, subtrees in the buffer can
not always be completely reduced, for the reasons
mentioned in the second-to-last paragraph of Sec-
tion 5.2. As a consequence, the oracle needs to
make cell updates in a more general way, which
includes linking pairs of elements in the reduced
buffer or pairs of inferred entries in the table.
-Root- John was not as good for the job as Kate .
0 1 2 3 4 5 6 7 8 9 10 11
Figure 5: Non-projective dependency tree adapted
from the Penn Treebank.
An example of why this is needed is provided
by the gold tree in Figure 5. Assume a config-
uration c = (?, ?,A) where ? = [0, 1, 2, 3, 4],
? = [5, . . . , 11], and A = ?. It is easy to see that
the loss of c is greater than zero, since the gold tree
is not reachable from c: parsing the subtree rooted
at node 5 requires shifting 6 into the stack, and
this makes it impossible to build the arcs 2 ? 5
and 2? 6. However, if we reduced the subtree in
the buffer with root 5, we would incorrectly obtain
a loss of 0, as the resulting tree is parsable if we
start with `
sh
followed by `
la
and `
ra
2
. Note that
there is no way of knowing whether it is safe to
reduce the subtree rooted at 5 without using non-
local information. For example, the arc 2 ? 6 is
crucial here: if 6 depended on 5 or 4 instead, the
loss would be zero. These complications are not
found in the projective case, allowing for the men-
tioned asymptotic improvement.
7 Experimental Evaluation
For comparability with previous work on dynamic
oracles, we follow the experimental settings repor-
ted by Goldberg et al. (2014) for their arc-standard
dynamic oracle. In particular, we use the same
training algorithm, features, and root node posi-
tion. However, we train the model for 20 itera-
static dynamic
UAS LAS UAS LAS
Arabic 80.90 71.56 82.23 72.63
Basque 75.96 66.74 74.32 65.59
Catalan 90.55 85.20 89.94 84.96
Chinese 84.72 79.93 85.34 81.00
Czech 79.83 72.69 82.08 74.44
English 85.52 84.46 87.38 86.40
Greek 79.84 72.26 81.55 74.14
Hungarian 78.13 68.90 76.27 68.14
Italian 83.08 78.94 84.43 80.45
Turkish 79.57 69.44 79.41 70.32
Bulgarian 89.46 85.99 89.32 85.92
Danish 85.58 81.25 86.03 81.59
Dutch 79.05 75.69 80.13 77.22
German 88.34 86.48 88.86 86.94
Japanese 93.06 91.64 93.56 92.18
Portuguese 84.80 81.38 85.36 82.10
Slovene 76.33 68.43 78.20 70.22
Spanish 79.88 76.84 80.25 77.45
Swedish 87.26 82.77 87.24 82.49
PTB 89.55 87.18 90.47 88.18
Table 1: Unlabelled Attachment Score (UAS) and
Labelled Attachment Score (LAS) using a static
and a dynamic oracle. Evaluation on CoNLL 2007
(first block) and CoNLL 2006 (second block) data-
sets is carried out including punctuation, evalu-
ation on the Penn Treebank excludes it.
tions rather than 15, as the increased search space
and spurious ambiguity of Attardi?s non-project-
ive parser implies that more iterations are required
to converge to a stable model. A more detailed
description of the experimental settings follows.
7.1 Experimental Setup
Training We train a global linear model using
the averaged perceptron algorithm and a labelled
version of the parser described in Section 3. We
perform on-line training using the oracle defined
in Section 5: at each parsing step, the model?s
weights are updated if the predicted transition res-
ults into an increase in configuration loss, but
the process continues by following the predicted
transition independently of the loss increase.
As our baseline we train the model using the
static oracle defined by (Cohen et al., 2012). This
oracle follows a canonical computation that cre-
ates arcs as soon as possible, and prioritizes the
`
la
transition over the `
la
2
transition in situations
925
where both create a gold arc. The static oracle
is not able to deal with configurations that can-
not reach the gold dependency tree, so we con-
strain the training algorithm to follow the zero-loss
transition provided by the oracle.
While this version of Attardi?s parser has been
shown to cover the vast majority of non-projective
sentences in several treebanks (Attardi, 2006; Co-
hen et al., 2012), there still are some sentences
which are not parsable. These sentences are
skipped during training, but not during test and
evaluation of the model.
Datasets We evaluate the parser performance
over CoNLL 2006 and CoNLL 2007 datasets.
If a language is present in both datasets, we
use the latest version. We also include res-
ults over the Penn Treebank (PTB) (Marcus et
al., 1993) converted to Stanford basic dependen-
cies (De Marneffe et al., 2006). For the CoNLL
datasets we use the provided part-of-speech tags
and the standard training/test partition; for the
PTB we use automatically assigned tags, we train
on sections 2-21 and test on section 23.
7.2 Results and Analysis
In Table 1 we report the unlabelled (UAS) and la-
belled (LAS) attachment scores for the static and
the dynamic oracles. Each figure is an average
over the accuracy provided by 5 models trained
with the same setup but using a different random
seed. The seed is only used to shuffle the sentences
in random order during each iteration of training.
Our results are consistent with the results re-
ported by Goldberg and Nivre (2013) and Gold-
berg et al. (2014). For most of the datasets, we
obtain a relevant improvement in both UAS and
LAS. For Dutch, Czech and German, we achieve
an error reduction of 5.2%, 11.2% and 4.5%, re-
spectively. Exceptions to this general trend are
Swedish and Bulgarian, where the accuracy differ-
ences are negligible, and the Basque, Catalan and
Hungarian datasets, where the performance actu-
ally decreases.
If instead of testing on the standard test sets we
use 10-fold cross-validation and average the res-
ulting accuracies, we obtain improvements for all
languages in Table 1 but Basque and Hungarian.
More specifically, measured (UAS, LAS) pairs for
Swedish are (86.85, 82.17) with dynamic oracle
against (86.6, 81.93) with static oracle; for Bul-
garian (88.42, 83.91) against (88.20, 83.55); and
for Catalan (88.33, 83.64) against (88.06, 83.13).
This suggests that the negligible or unfavourable
results in Table 1 for these languages are due to
statistical variability given the small size of the test
sets.
As for Basque, we measure (75.54, 67.58)
against (76.77, 68.20); similarly, for Hungarian
we measure (75.66, 67.66) against (77.22, 68.42).
Unfortunately, we have no explanation for these
performance decreases, in terms of the typology
of the non-projective patterns found in these two
datasets. Note that Goldberg et al. (2014) also
observed a performance decrease on the Basque
dataset in the projective case, although not on
Hungarian.
The parsing times measured in our experiments
for the static and the dynamic oracles are the same,
since the oracle algorithm is only used during the
training stage. Thus the reported improvements in
parsing accuracy come at no extra cost for parsing
time. In the training stage, the extra processing
needed to compute the loss and to explore paths
that do not lead to a gold tree made training about
4 times slower, on average, for the dynamic oracle
model. This confirms that our oracle algorithm is
fast enough to be of practical interest, in spite of its
relatively high worst-case asymptotic complexity.
8 Conclusions
We have presented what, to our knowledge, are
the first experimental results for a transition-based
non-projective parser trained with a dynamic or-
acle. We have also shown significant accuracy im-
provements on many languages over a static oracle
baseline.
The general picture that emerges from our ap-
proach is that dynamic programming algorithms
originally conceived for the simulation of trans-
ition-based parsers can effectively be used in the
development of polynomial-time algorithms for
dynamic oracles.
Acknowledgments
The first author has been partially funded by Min-
isterio de Econom??a y Competitividad/FEDER
(Grant TIN2010-18552-C03-02) and by Xunta de
Galicia (Grant CN2012/008). The third author has
been partially supported by MIUR under project
PRIN No. 2010LYA9RH 006.
926
References
Giuseppe Attardi. 2006. Experiments with a multil-
anguage non-projective dependency parser. In Pro-
ceedings of the Tenth Conference on Computational
Natural Language Learning (CoNLL), pages 166?
170, New York, USA.
Jinho D. Choi and Andrew McCallum. 2013.
Transition-based dependency parsing with selec-
tional branching. In Proceedings of the 51st An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 1052?
1062, Sofia, Bulgaria, August. Association for Com-
putational Linguistics.
Shay B. Cohen, Carlos G?omez-Rodr??guez, and Giorgio
Satta. 2011. Exact inference for generative prob-
abilistic non-projective dependency parsing. In Pro-
ceedings of the 2011 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1234?
1245, Edinburgh, Scotland, UK., July. Association
for Computational Linguistics.
Shay B. Cohen, Carlos G?omez-Rodr??guez, and Gior-
gio Satta. 2012. Elimination of spurious ambigu-
ity in transition-based dependency parsing. CoRR,
abs/1206.6735.
Marie-Catherine De Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed
dependency parses from phrase structure parses. In
Proceedings of the 5th International Conference
on Language Resources and Evaluation (LREC),
volume 6, pages 449?454.
Yoav Goldberg and Joakim Nivre. 2012. A dynamic
oracle for arc-eager dependency parsing. In Proc. of
the 24
th
COLING, Mumbai, India.
Yoav Goldberg and Joakim Nivre. 2013. Training
deterministic parsers with non-deterministic oracles.
Transactions of the association for Computational
Linguistics, 1.
Yoav Goldberg, Francesco Sartorio, and Giorgio Satta.
2014. A tabular method for dynamic oracles in
transition-based parsing. Transactions of the Associ-
ation for Computational Linguistics, 2(April):119?
130.
John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ull-
man. 2006. Introduction to Automata Theory, Lan-
guages, and Computation (3rd Edition). Addison-
Wesley Longman Publishing Co., Inc., Boston, MA,
USA.
Liang Huang and Kenji Sagae. 2010. Dynamic pro-
gramming for linear-time incremental parsing. In
Proceedings of the 48th Annual Meeting of the As-
sociation for Computational Linguistics, July.
Marco Kuhlmann and Joakim Nivre. 2010. Transition-
based techniques for non-projective dependency
parsing. Northern European Journal of Language
Technology, 2(1):1?19.
Marco Kuhlmann, Carlos G?omez-Rodr??guez, and Gior-
gio Satta. 2011. Dynamic programming algorithms
for transition-based dependency parsers. In Pro-
ceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, pages 673?682, Portland, Ore-
gon, USA, June. Association for Computational Lin-
guistics.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313?330.
Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
Eighth International Workshop on Parsing Techno-
logies (IWPT), pages 149?160, Nancy, France.
Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. In Workshop on Incremental
Parsing: Bringing Engineering and Cognition To-
gether, pages 50?57, Barcelona, Spain.
Hiroyasu Yamada and Yuji Matsumoto. 2003. Stat-
istical dependency analysis with support vector ma-
chines. In Proceedings of the 8th International
Workshop on Parsing Technologies (IWPT), pages
195?206.
Yue Zhang and Joakim Nivre. 2011. Transition-based
dependency parsing with rich non-local features. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, pages 188?193, Portland, Ore-
gon, USA, June. Association for Computational Lin-
guistics.
927
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 135?144,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
A Transition-Based Dependency Parser
Using a Dynamic Parsing Strategy
Francesco Sartorio
Department of
Information Engineering
University of Padua, Italy
sartorio@dei.unipd.it
Giorgio Satta
Department of
Information Engineering
University of Padua, Italy
satta@dei.unipd.it
Joakim Nivre
Department of
Linguistics and Philology
Uppsala University, Sweden
joakim.nivre@lingfil.uu.se
Abstract
We present a novel transition-based, greedy
dependency parser which implements a
flexible mix of bottom-up and top-down
strategies. The new strategy allows the
parser to postpone difficult decisions until
the relevant information becomes available.
The novel parser has a ?12% error reduc-
tion in unlabeled attachment score over an
arc-eager parser, with a slow-down factor
of 2.8.
1 Introduction
Dependency-based methods for syntactic parsing
have become increasingly popular during the last
decade or so. This development is probably due
to many factors, such as the increased availability
of dependency treebanks and the perceived use-
fulness of dependency structures as an interface
to downstream applications, but a very important
reason is also the high efficiency offered by de-
pendency parsers, enabling web-scale parsing with
high throughput. The most efficient parsers are
greedy transition-based parsers, which only explore
a single derivation for each input and relies on
a locally trained classifier for predicting the next
parser action given a compact representation of the
derivation history, as pioneered by Yamada and
Matsumoto (2003), Nivre (2003), Attardi (2006),
and others. However, while these parsers are cap-
able of processing tens of thousands of tokens per
second with the right choice of classifiers, they are
also known to perform slightly below the state-of-
the-art because of search errors and subsequent
error propagation (McDonald and Nivre, 2007),
and recent research on transition-based depend-
ency parsing has therefore explored different ways
of improving their accuracy.
The most common approach is to use beam
search instead of greedy decoding, in combination
with a globally trained model that tries to minim-
ize the loss over the entire sentence instead of a
locally trained classifier that tries to maximize the
accuracy of single decisions (given no previous er-
rors), as first proposed by Zhang and Clark (2008).
With these methods, transition-based parsers have
reached state-of-the-art accuracy for a number of
languages (Zhang and Nivre, 2011; Bohnet and
Nivre, 2012). However, the drawback with this ap-
proach is that parsing speed is proportional to the
size of the beam, which means that the most accur-
ate transition-based parsers are not nearly as fast
as the original greedy transition-based parsers. An-
other line of research tries to retain the efficiency of
greedy classifier-based parsing by instead improv-
ing the way in which classifiers are learned from
data. While the classical approach limits training
data to parser states that result from oracle predic-
tions (derived from a treebank), these novel ap-
proaches allow the classifier to explore states that
result from its own (sometimes erroneous) predic-
tions (Choi and Palmer, 2011; Goldberg and Nivre,
2012).
In this paper, we explore an orthogonal approach
to improving the accuracy of transition-based pars-
ers, without sacrificing their advantage in efficiency,
by introducing a new type of transition system.
While all previous transition systems assume a
static parsing strategy with respect to top-down
and bottom-up processing, our new system allows
a dynamic strategy for ordering parsing decisions.
This has the advantage that the parser can postpone
difficult decisions until the relevant information be-
comes available, in a way that is not possible in
existing transition systems. A second advantage of
dynamic parsing is that we can extend the feature
inventory of previous systems. Our experiments
show that these advantages lead to significant im-
provements in parsing accuracy, compared to a
baseline parser that uses the arc-eager transition
system of Nivre (2003), which is one of the most
135
widely used static transition systems.
2 Static vs. Dynamic Parsing
The notions of bottom-up and top-down parsing
strategies do not have a general mathematical defin-
ition; they are instead specified, often only inform-
ally, for individual families of grammar formal-
isms. In the context of dependency parsing, a pars-
ing strategy is called purely bottom-up if every
dependency h ? d is constructed only after all
dependencies of the form d ? i have been con-
structed. Here h? d denotes a dependency with
h the head node and d the dependent node. In con-
trast, a parsing strategy is called purely top-down
if h? d is constructed before any dependency of
the form d? i.
If we consider transition-based dependency pars-
ing (Nivre, 2008), the purely bottom-up strategy is
implemented by the arc-standard model of Nivre
(2004). After building a dependency h ? d, this
model immediately removes from its stack node d,
preventing further attachment of dependents to this
node. A second popular parser, the arc-eager model
of Nivre (2003), instead adopts a mixed strategy.
In this model, a dependency h? d is constructed
using a purely bottom-up strategy if it represents a
left-arc, that is, if the dependent d is placed to the
left of the head h in the input string. In contrast, if
h ? d represents a right-arc (defined symmetric-
ally), then this dependency is constructed before
any right-arc d ? i (top-down) but after any left-
arc d? i (bottom-up).
What is important to notice about the above
transition-based parsers is that the adopted pars-
ing strategies are static. By this we mean that each
dependency is constructed according to some fixed
criterion, depending on structural conditions such
as the fact that the dependency represents a left or a
right arc. This should be contrasted with dynamic
parsing strategies in which several parsing options
are simultaneously available for the dependencies
being constructed.
In the context of left-to-right, transition-based
parsers, dynamic strategies are attractive for sev-
eral reasons. One argument is related to the well-
known PP-attachment problem, illustrated in Fig-
ure 1. Here we have to choose whether to attach
node P as a dependent of V (arc ?2) or else as
a dependent of N1 (arc ?3). The purely bottom-
up arc-standard model has to take a decision as
soon as N1 is placed into the stack. This is so
V N1 P N2
?1
?2
?3 ?4
Figure 1: PP-attachment example, with dashed arcs
identifying two alternative choices.
because the construction of ?1 excludes ?3 from
the search space, while the alternative decision of
shifting P into the stack excludes ?2. This is bad,
because the information about the correct attach-
ment could come from the lexical content of node P.
The arc-eager model performs slightly better, since
it can delay the decision up to the point in which ?1
has been constructed and P is read from the buffer.
However, at this point it must make a commitment
and either construct ?3 or pop N1 from the stack
(implicitly committing to ?2) before N2 is read
from the buffer. In contrast with this scenario, in
the next sections we implement a dynamic parsing
strategy that allows a transition system to decide
between the attachments ?2 and ?3 after it has seen
all of the four nodes V, N1, P and N2.
Other additional advantages of dynamic parsing
strategies with respect to static strategies are re-
lated to the increase in the feature inventory that
we apply to parser states, and to the increase of
spurious ambiguity. However, these arguments are
more technical than the PP-attachment argument
above, and will be discussed later.
3 Dependency Parser
In this section we present a novel transition-based
parser for projective dependency trees, implement-
ing a dynamic parsing strategy.
3.1 Preliminaries
For non-negative integers i and j with i ? j, we
write [i, j] to denote the set {i, i+1, . . . , j}. When
i > j, [i, j] is the empty set.
We represent an input sentence as a string w =
w0 ? ? ?wn, n ? 1, where token w0 is a special
root symbol and, for each i ? [1, n], token wi =
(i, ai, ti) encodes a lexical element ai and a part-of-
speech tag ti associated with the i-th word in the
sentence.
A dependency tree for w is a directed, ordered
tree Tw = (Vw, Aw), where Vw = {wi | i ?
136
w4
w2 w5 w7
w1 w3 w6
Figure 2: A dependency tree with left spine
?w4, w2, w1? and right spine ?w4, w7?.
[0, n]} is the set of nodes, and Aw ? Vw ? Vw is
the set of arcs. Arc (wi, wj) encodes a dependency
wi ? wj . A sample dependency tree (excluding
w0) is displayed in Figure 2. If (wi, wj) ? Aw for
j < i, we say that wj is a left child of wi; a right
child is defined in a symmetrical way.
The left spine of Tw is an ordered sequence
?u1, . . . , up? with p ? 1 and ui ? Vw for i ? [1, p],
consisting of all nodes in a descending path from
the root of Tw taking the leftmost child node at
each step. More formally, u1 is the root node of Tw
and ui is the leftmost child of ui?1, for i ? [2, p].
The right spine of Tw is defined symmetrically;
see again Figure 2. Note that the left and the right
spines share the root node and no other node.
3.2 Basic Idea
Transition-based dependency parsers use a stack
data structure, where each stack element is associ-
ated with a tree spanning some (contiguous) sub-
string of the input w. The parser can combine
two trees T and T ? through attachment operations,
called left-arc or right-arc, under the condition that
T and T ? appear at the two topmost positions in
the stack. Crucially, only the roots of T and T ? are
available for attachment; see Figure 3(a).
In contrast, a stack element in our parser records
the entire left spine and right spine of the associated
tree. This allows us to extend the inventory of the
attachment operations of the parser by including
the attachment of tree T as a dependent of any node
in the left or in the right spine of a second tree T ?,
provided that this does not violate projectivity.1
See Figure 3(b) for an example.
The new parser implements a mix of bottom-up
and top-down strategies, since after any of the at-
tachments in Figure 3(b) is performed, additional
dependencies can still be created for the root of T .
Furthermore, the new parsing strategy is clearly dy-
1A dependency tree for w is projective if every subtree has
a contiguous yield in w.
T
T ?
T
T ?
(a) (b)
Figure 3: Left-arc attachment of T to T ? in case
of (a) standard transition-based parsers and (b) our
parser.
namic, due to the free choice in the timing for these
attachments. The new strategy is more powerful
than the strategy of the arc-eager model, since we
can use top-down parsing at left arcs, which is not
allowed in arc-eager parsing, and we do not have
the restrictions of parsing right arcs (h? d) before
the attachment of right dependents at node d.
To conclude this section, let us resume our dis-
cussion of the PP-attachment example in Figure 1.
We observe that the new parsing strategy allows the
construction of a tree T ? consisting of the only de-
pendency V? N1 and a tree T , placed at the right
of T ?, consisting of the only dependency P? N2.
Since the right spine of T ? consists of nodes V
and N1, we can freely choose between attachment
V? P and attachment N1? P. Note that this is
done after we have seen node N2, as desired.
3.3 Transition-based Parser
We assume the reader is familiar with the formal
framework of transition-based dependency parsing
originally introduced by Nivre (2003); see Nivre
(2008) for an introduction. To keep the notation at
a simple level, we only discuss here the unlabeled
version of our parser; however, a labeled extension
is used in ?5 for our experiments.
Our transition-based parser uses a stack data
structure to store partial parses for the input string
w. We represent the stack as an ordered sequence
? = [?d, . . . , ?1], d ? 0, of stack elements, with
the topmost element placed at the right. When d =
0, we have the empty stack ? = []. Sometimes we
use the vertical bar to denote the append operator
for ?, and write ? = ??|?1 to indicate that ?1 is the
topmost element of ?.
A stack element is a pair
?k = (?uk,1, . . . , uk,p?, ?vk,1, . . . , vk,q?)
where the ordered sequences ?uk,1, . . . , uk,p? and
137
?vk,1, . . . , vk,q? are the left and the right spines, re-
spectively, of the tree associated with ?k. Recall
that uk,1 = vk,1, since the root node of the associ-
ated tree is shared by the two spines.
The parser also uses a buffer to store the por-
tion of the input string still to be processed. We
represent the buffer as an ordered sequence ? =
[wi, . . . , wn], i ? 0, of tokens from w, with the
first element placed at the left. Note that ? always
represents a (non-necessarily proper) suffix of w.
When i > n, we have the empty buffer ? = [].
Sometimes we use the vertical bar to denote the
append operator for ?, and write ? = wi|?? to in-
dicate that wi is the first token of ?; consequently,
we have ?? = [wi+1, . . . , wn].
When processing w, the parser reaches several
states, technically called configurations. A con-
figuration of the parser relative to w is a triple
c = (?, ?,A), where ? and ? are a stack and
a buffer, respectively, and A ? Vw ? Vw is a
set of arcs. The initial configuration for w is
([], [w0, . . . , wn], ?). The set of terminal config-
urations consists of all configurations of the form
([?1], [], A), where ?1 is associated with a tree hav-
ing root w0, that is, u1,1 = v1,1 = w0, and A is any
set of arcs.
The core of a transition-based parser is the set
of its transitions. Each transition is a binary rela-
tion defined over the set of configurations of the
parser. Since the set of configurations is infinite,
a transition is infinite as well, when viewed as a
set. However, transitions can always be specified
by some finite means. Our parser uses three types
of transitions, defined in what follows.
? SHIFT, or sh for short. This transition re-
moves the first node from the buffer and
pushes into the stack a new element, consist-
ing of the left and right spines of the associ-
ated tree. More formally
(?,wi|?,A) `sh (?|(?wi?, ?wi?), ?, A)
? LEFT-ARCk, k ? 1, or lak for short. Let h
be the k-th node in the left spine of the top-
most tree in the stack, and let d be the root
node of the second topmost tree in the stack.
This transition creates a new arc h? d. Fur-
thermore, the two topmost stack elements are
replaced by a new element associated with the
tree resulting from the h? d attachment. The
transition does not advance with the reading
of the buffer. More formally
(??|?2|?1, ?, A) `lak (??|?la, ?, A ? {h? d})
where
?1 = (?u1,1, . . . , u1,p?, ?v1,1, . . . , v1,q?) ,
?2 = (?u2,1, . . . , u2,r?, ?v2,1, . . . , v2,s?) ,
?la = (?u1,1, . . . , u1,k, u2,1, . . . , u2,r?,
?v1,1, . . . , v1,q?) ,
and where we have set h = u1,k and d = u2,1.
? RIGHT-ARCk, k ? 1, or rak for short. This
transition is defined symmetrically with re-
spect to lak. We have
(??|?2|?1, ?, A) `rak (??|?ra, ?, A ? {h? d})
where ?1 and ?2 are as in the lak case,
?ra = (?u2,1, . . . , u2,r?,
?v2,1, . . . , v2,k, v1,1, . . . , v1,q?) ,
and we have set h = v2,k and d = v1,1.
Transitions lak and rak are parametric in k,
where k is bounded by the length of the input string
and not by a fixed constant (but see also the experi-
mental findings in ?5). Thus our system uses an un-
bounded number of transition relations, which has
an apparent disadvantage for learning algorithms.
We will get back to this problem in ?4.3.
A complete computation relative to w is a se-
quence of configurations c1, c2, . . . , ct, t ? 1, such
that c1 and ct are initial and final configurations,
respectively, and for each i ? [2, t], ci is produced
by the application of some transition to ci?1. It is
not difficult to see that the transition-based parser
specified above is sound, meaning that the set of
arcs constructed in any complete computation on
w is always a dependency tree for w. The parser
is also complete, meaning that every (projective)
dependency tree for w is constructed by some com-
plete computation on w. A mathematical proof of
this statement is beyond the scope of this paper,
and will not be provided here.
3.4 Deterministic Parsing Algorithm
The transition-based parser of the previous sec-
tion is a nondeterministic device, since several
transitions can be applied to a given configuration.
This might result in several complete computations
138
Algorithm 1 Parsing Algorithm
Input: string w = w0 ? ? ?wn, function score()
Output: dependency tree Tw
c = (?, ?,A)? ([], [w0, . . . , wn], ?)
while |?| > 1 ? |?| > 0 do
while |?| < 2 do
update c with sh
p? length of left spine of ?1
s? length of right spine of ?2
T ? {lak | k ? [1, p]} ?
{rak | k ? [1, s]} ? {sh}
bestT ? argmaxt?T score(t , c)
update c with bestT
return Tw = (Vw, A)
for w. We present here an algorithm that runs
the parser in pseudo-deterministic mode, greed-
ily choosing at each configuration the transition
that maximizes some score function. Algorithm 1
takes as input a string w and a scoring function
score() defined over parser transitions and parser
configurations. The scoring function will be the
subject of ?4 and is not discussed here. The output
of the parser is a dependency tree for w.
At each iteration the algorithm checks whether
there are at least two elements in the stack and, if
this is not the case, it shifts elements from the buffer
to the stack. Then the algorithm uses the function
score() to evaluate all transitions that can be ap-
plied under the current configuration c = (?, ?,A),
and it applies the transition with the highest score,
updating the current configuration.
To parse a sentence of length n (excluding the
root token w0) the algorithm applies exactly 2n+1
transitions. In the worst case, each transition ap-
plication involves 1 + p+ s transition evaluations.
We therefore conclude that the algorithm always
reaches a configuration with an empty buffer and a
stack which contains only one element. Then the al-
gorithm stops, returning the dependency tree whose
arc set is defined as in the current configuration.
4 Model and Training
In this section we introduce the adopted learning
algorithm and discuss the model parameters.
4.1 Learning Algorithm
We use a linear model for the score function in
Algorithm 1, and define score(t , c) = ~? ? ?(t , c).
Here ~? is a weight vector and function ? provides
Algorithm 2 Learning Algorithm
Input: pair (w = w0 ? ? ?wn, Ag), vector ~?
Output: vector ~?
c = (?, ?,A)? ([], [w0, . . . , wn], ?)
while |?| > 1 ? |?| > 0 do
while |?| < 2 do
update c with SHIFT
p? length of left spine of ?1
s? length of right spine of ?2
T ? {lak | k ? [1, p]} ?
{rak | k ? [1, s]} ? {sh}
bestT ? argmaxt?T score(t , c)
bestCorrectT ?
argmaxt?T ?isCorrect(t) score(t , c)
if bestT 6= bestCorrectT then
~? ? ~? ? ?(bestT , c)
+?(bestCorrectT , c)
update c with bestCorrectT
a feature vector representation for a transition t ap-
plying to a configuration c. The function ? will be
discussed at length in ?4.3. The vector ~? is trained
using the perceptron algorithm in combination with
the averaging method to avoid overfitting; see Fre-
und and Schapire (1999) and Collins and Duffy
(2002) for details.
The training data set consists of pairs (w,Ag),
where w is a sentence and Ag is the set of arcs
of the gold (desired) dependency tree for w. At
training time, each pair (w,Ag) is processed using
the learning algorithm described as Algorithm 2.
The algorithm is based on the notions of correct and
incorrect transitions, discussed at length in ?4.2.
Algorithm 2 parsesw following Algorithm 1 and
using the current ~?, until the highest score selec-
ted transition bestT is incorrect according to Ag .
When this happens, ~? is updated by decreasing the
weights of the features associated with the incorrect
bestT and by increasing the weights of the features
associated with the transition bestCorrectT having
the highest score among all possible correct trans-
itions. After each update, the learning algorithm
resumes parsing from the current configuration by
applying bestCorrectT , and moves on using the
updated weights.
4.2 Correct and Incorrect Transitions
Standard transition-based dependency parsers are
trained by associating each gold tree with a canon-
ical complete computation. This means that, for
each configuration of interest, only one transition
139
?2 ?1 b1
(a)
?2 ?1 b1
(b)
?2 ?1
? ? ?
bi
(c)
?2 ?1
? ? ?
bi
(d)
Figure 4: Graphical representation of configura-
tions; drawn arcs are in Ag but have not yet been
added to the configuration. Transition sh is incor-
rect for configuration (a) and (b); sh and ra1 are
correct for (c); sh and la1 are correct for (d).
leading to the gold tree is considered as correct. In
this paper we depart from such a methodology, and
follow Goldberg and Nivre (2012) in allowing more
than one correct transition for each configuration,
as explained in detail below.
Let (w,Ag) be a pair in the training set. In ?3.3
we have mentioned that there is always a complete
computation on w that results in the construction
of the set Ag . In general, there might be more than
one computation forAg . This means that the parser
shows spurious ambiguity.
Observe that all complete computations for Ag
share the same initial configuration cI,w and final
configuration cF,Ag . Consider now the set C(w) of
all configurations c that are reachable from cI,w,
meaning that there exists a sequence of transitions
that takes the parser from cI,w to c. A configuration
c ? C(w) is correct for Ag if cF,Ag is reachable
from c; otherwise, c is incorrect for Ag .
Let c ? C(w) be a correct configuration for Ag .
A transition t is correct for c and Ag if c `t c?
and c? is correct for Ag ; otherwise, t is incorrect
for c and Ag . The next lemma provides a charac-
terization of correct and incorrect transitions; see
Figure 4 for examples. We use this characterization
in the implementation of predicate isCorrect() in
Algorithm 2.
Lemma 1 Let (w,Ag) be a pair in the training set
and let c ? C(w) with c = (?, ?,A) be a correct
configuration for Ag . Let alo v1,k, k ? [1, q], be
the nodes in the right spine of ?1.
(i) lak and rak are incorrect for c and Ag if and
only if they create a new arc (h? d) 6? Ag ;
(ii) sh is incorrect for c and Ag if and only if the
following conditions are both satisfied:
(a) there exists an arc (h ? d) in Ag such
that h is in ? and d = v1,1;
(b) there is no arc (h? ? d?) in Ag with
h? = v1,k, k ? [1, q], and d? in ?. 2
PROOF (SKETCH) To prove part (i) we focus on
transition rak; a similar argument applies to lak.
The ?if? statement in part (i) is self-evident.
?Only if?. Assuming that transition rak creates
a new arc (h? d) ? Ag , we argue that from con-
figuration c? with c `rak c? we can still reach the
final configuration associated with Ag . We have
h = v2,k and d = u1,1. The tree fragments in ?
with roots v2,k+1 and u1,1 must be adjacent siblings
in the tree associated with Ag , since c is a correct
configuration for Ag and (v2,k ? u1,1) ? Ag .
This means that each of the nodes v2,k+1, . . . , v2,s
in the right spine in ?2 in c must have already ac-
quired all of its right dependents, since the tree is
projective. Therefore it is safe for transition rak to
eliminate the nodes v2,k+1, . . . , v2,s from the right
spine in ?2.
We now deal with part (ii). Let c `sh c?, c? =
(??, ??, A).
?If?. Assuming (ii)a and (ii)b, we argue that c? is
incorrect. Node d is the head of ??2. Arc (h? d) is
not inA, and the only way we could create (h? d)
from c? is by reaching a new configuration with d
in the topmost stack symbol, which amounts to say
that ??1 can be reduced by a correct transition. Node
h is in some ??i, i > 2, by (ii)a. Then reduction of
??1 implies that the root of ??1 is reachable from the
root of ??2, which contradicts (ii)b.
?Only if?. Assuming (ii)a is not satisfied, we
argue that sh is correct for c and Ag . There must
be an arc (h? d) not in A with d = v1,1 and h is
some token wi in ?. From stack ?? = ???|??2|??1 it
is always possible to construct (h? d) consuming
the substring of ? up to wi and ending up with
stack ???|?red , where ?red is a stack element with
root wi. From there, the parser can move on to
the final configuration cF,Ag . A similar argument
applies if we assume that (ii)b is not satisfied. 
From condition (i) in Lemma 1 and from the fact
that there are no cycles in Ag , it follows that there
is at most one correct transition among the trans-
itions of type lak or rak. From condition (ii) in the
lemma we can also see that the existence of a cor-
rect transition of type lak or rak for some configura-
tion does not imply that the sh transition is incorrect
140
for the same configuration; see Figures 4(c,d) for
examples. It follows that for a correct configuration
there might be at most 2 correct transitions. In our
training experiments for English in ?5 we observe 2
correct transitions for 42% of the reached configur-
ations. This nondeterminism is a byproduct of the
adopted dynamic parsing strategy, and eventually
leads to the spurious ambiguity of the parser.
As already mentioned, we do not impose any ca-
nonical form on complete computations that would
hardwire a preference for some correct transition
and get rid of spurious ambiguity. Following Gold-
berg and Nivre (2012), we instead regard spurious
ambiguity as an additional resource of our pars-
ing strategy. Our main goal is that the training
algorithm learns to prefer a sh transition in a con-
figuration that does not provide enough information
for the choice of the correct arc. In the context of
dependency parsing, the strategy of delaying arc
construction when the current configuration is not
informative is called the easy-first strategy, and
has been first explored by Goldberg and Elhadad
(2010).
4.3 Feature Extraction
In existing transition-based parsers a set of atomic
features is statically defined and extracted from
each configuration. These features are then com-
bined together into complex features, according to
some feature template, and joined with the avail-
able transition types. This is not possible in our
system, since the number of transitions lak and rak
is not bounded by a constant. Furthermore, it is not
meaningful to associate transitions lak and rak, for
any k ? 1, always with the same features, since
the constructed arcs impinge on nodes at differ-
ent depths in the involved spines. It seems indeed
more significant to extract information that is local
to the arc h? d being constructed by each trans-
ition, such as for instance the grandparent and the
great grandparent nodes of d. This is possible if
we introduce a higher level of abstraction than in
existing transition-based parsers. We remark here
that this abstraction also makes the feature repres-
entation more similar to the ones typically found
in graph-based parsers, which are centered on arcs
or subgraphs of the dependency tree.
We index the nodes in the stack ? relative to
the head node of the arc being constructed, in
case of the transitions lak or rak, or else relative
to the root node of ?1, in case of the transition
sh. More precisely, let c = (?, ?,A) be a con-
figuration and let t be a transition. We define
the context of c and t as the tuple C(c, t) =
(s3, s2, s1, q1, q2, gp, gg), whose components are
placeholders for word tokens in ? or in ?. All these
placeholders are specified in Table 1, for each c and
t . Figure 5 shows an example of feature extraction
for the displayed configuration c = (?, ?,A) and
the transition la2. In this case we have s3 = u3,1,
s2 = u2,1, s1 = u1,2, q1 = gp = u1,1, q2 = b1;
gg = none because the head of gp is not available
in c.
Note that in Table 1 placeholders are dynamic-
ally assigned in such a way that s1 and s2 refer to
the nodes in the constructed arc h? d, and gp, gg
refer to the grandparent and the great grandparent
nodes, respectively, of d. Furthermore, the node
assigned to s3 is the parent node of s2, if such a
node is defined; otherwise, the node assigned to
s3 is the root of the tree fragment in the stack un-
derneath ?2. Symmetrically, placeholders q1 and
q2 refer to the parent and grandparent nodes of s1,
respectively, when these nodes are defined; other-
wise, these placeholders get assigned tokens from
the buffer. See again Figure 5.
Finally, from the placeholders in C(c, t) we ex-
tract a standard set of atomic features and their
complex combinations, to define the function ?.
Our feature template is an extended version of the
feature template of Zhang and Nivre (2011), ori-
ginally developed for the arc-eager model. The
extension is obtained by adding top-down features
for left-arcs (based on placeholders gp and gg),
and by adding right child features for the first stack
element. The latter group of features is usually ex-
ploited for the arc-standard model, but is undefined
for the arc-eager model.
5 Experimental Assessment
Performance evaluation is carried out on the Penn
Treebank (Marcus et al, 1993) converted to Stan-
ford basic dependencies (De Marneffe et al, 2006).
We use sections 2-21 for training, 22 as develop-
ment set, and 23 as test set. The part-of-speech
tags are assigned by an automatic tagger with ac-
curacy 97.1%. The tagger used on the training set
is trained on the same data set by using four-way
jackknifing, while the tagger used on the develop-
ment and test sets is trained on all the training set.
We train an arc-labeled version of our parser.
In the first three lines of Table 2 we compare
141
context sh lak rak
placeholder k = 1 k = 2 k > 2 k = 1 k = 2 k > 2
s1 u1,1 = v1,1 u1,k u1,1 = v1,1
s2 u2,1 = v2,1 u2,1 = v2,1 v2,k
s3 u3,1 = v3,1 u3,1 = v3,1 u3,1 = v3,1 v2,k?1
q1 b1 b1 u1,k?1 b1
q2 b2 b2 b1 u1,k?2 b2
gp none none u1,k?1 none v2,k?1
gg none none none u1,k?2 none none v2,k?2
Table 1: Definition ofC(c, t) = (s3, s2, s1, q1, q2, gp, gg), for c = (??|?3|?2|?1, b1|b2|?,A) and t of type
sh or lak, rak, k ? 1. Symbols uj,k and vj,k are the k-th nodes in the left and right spines, respectively, of
stack element ?j , with uj,1 = vj,1 being the shared root of ?j ; none is an artificial element used when
some context?s placeholder is not available.
? ? ?
stack ?
u3,1 = v3,1
v3,2
u2,1 = v2,1
u2,2 v2,2
v2,3
u1,1 = v1,1
u1,2 v1,2
u1,3 v1,3
la2
buffer ?
b1 b2 b3 ? ? ?
context extracted for la2
s3 s2 s1 q1=gp q2
Figure 5: Extraction of atomic features for context C(c, la2) = (s3, s2, s1, q1, q2, gp, gg), c = (?, ?,A).
parser iter UAS LAS UEM
arc-standard 23 90.02 87.69 38.33
arc-eager 12 90.18 87.83 40.02
this work 30 91.33 89.16 42.38
arc-standard + easy-first 21 90.49 88.22 39.61
arc-standard + spine 27 90.44 88.23 40.27
Table 2: Accuracy on test set, excluding punc-
tuation, for unlabeled attachment score (UAS),
labeled attachment score (LAS), unlabeled exact
match (UEM).
the accuracy of our parser against our implementa-
tion of the arc-eager and arc-standard parsers. For
the arc-eager parser, we use the feature template
of Zhang and Nivre (2011). The same template is
adapted to the arc-standard parser, by removing the
top-down parent features and by adding the right
child features for the first stack element. It turns out
that our feature template, described in ?4.3, is the
exact merge of the templates used for the arc-eager
and the arc-standard parsers.
We train all parsers up to 30 iterations, and for
each parser we select the weight vector ~? from the
iteration with the best accuracy on the development
set. All our parsers attach the root node at the end
of the parsing process, following the ?None? ap-
proach discussed by Ballesteros and Nivre (2013).
Punctuation is excluded in all evaluation metrics.
Considering UAS, our parser provides an improve-
ment of 1.15 over the arc-eager parser and an im-
provement of 1.31 over the arc-standard parser, that
is an error reduction of ?12% and ?13%, respect-
ively. Considering LAS, we achieve improvements
of 1.33 and 1.47, with an error reduction of ?11%
and ?12%, over the arc-eager and the arc-standard
parsers, respectively.
We speculate that the observed improvement of
our parser can be ascribed to two distinct com-
ponents. The first component is the left-/right-
spine representation for stack elements, introduced
in ?3.3. The second component is the easy-first
strategy, implemented on the basis of the spurious
ambiguity of our parser and the definition of cor-
rect/incorrect transitions in ?4.2. In this perspective,
we observe that our parser can indeed be viewed as
an arc-standard model augmented with (i) the spine
representation, and (ii) the easy-first strategy. More
specifically, (i) generalizes the la/ra transitions to
the lak/rak transitions, introducing a top-down com-
ponent into the purely bottom-up arc-standard. On
the other hand, (ii) drops the limitation of canonical
computations for the arc-standard, and leverages
142
on the spurious ambiguity of the parser to enlarge
the search space.
The two components above are mutually inde-
pendent, meaning that we can individually imple-
ment each component on top of an arc-standard
model. More precisely, the arc-standard + spine
model uses the transitions lak/rak but retains the
definition of canonical computation, defined by ap-
plying each lak/rak transition as soon as possible.
On the other hand, the arc-standard + easy-first
model retains the original la/ra transitions but is
trained allowing any correct transition at each con-
figuration. In this case the characterization of cor-
rect and incorrect configurations in Lemma 1 has
been adapted to transitions la/ra, taking into ac-
count the bottom-up constraint.
With the purpose of incremental comparison, we
report accuracy results for the two ?incremental?
models in the last two lines of Table 2. Analyzing
these results, and comparing with the plain arc-
standard, we see that the spine representation and
the easy-first strategy individually improve accur-
acy. Moreover, their combination into our model
(third line of Table 2) works very well, with an
overall improvement larger than the sum of the
individual contributions.
We now turn to a computational analysis. At
each iteration our parser evaluates a number of
transitions bounded by ?+1, with ? the maximum
value of the sum of the lengths of the left spine in ?1
and of the right spine in ?2. Quantity ? is bounded
by the length n of the input sentence. Since the
parser applies exactly 2n + 1 transitions, worst
case running time is O(n2). We have computed
the average value of ? on our English data set,
resulting in 2.98 (variance 2.15) for training set,
and 2.95 (variance 1.96) for development set. We
conclude that, in the expected case, running time is
O(n), with a slow down constant which is rather
small, in comparison to standard transition-based
parsers. Accordingly, when running our parser
against our implementation of the arc-eager and
arc-standard models, we measured a slow-down of
2.8 and 2.2, respectively. Besides the change in
representation, this slow-down is also due to the
increase in the number of features in our system.
We have also checked the worst case value of ? in
our data set. Interestingly, we have seen that for
strings of length smaller than 40 this value linearly
grows with n, and for longer strings the growth
stops, with a maximum worst case observed value
of 22.
6 Concluding Remarks
We have presented a novel transition-based parser
using a dynamic parsing strategy, which achieves
a ?12% error reduction in unlabeled attachment
score over the static arc-eager strategy and even
more over the (equally static) arc-standard strategy,
when evaluated on English.
The idea of representing the right spine of a
tree within the stack elements of a shift-reduce
device is quite old in parsing, predating empirical
approaches. It has been mainly exploited to solve
the PP-attachment problem, motivated by psycho-
linguistic models. The same representation is also
adopted in applications of discourse parsing, where
right spines are usually called right frontiers; see
for instance Subba and Di Eugenio (2009). In
the context of transition-based dependency parsers,
right spines have also been exploited by Kitagawa
and Tanaka-Ishii (2010) to decide where to attach
the next word from the buffer. In this paper we
have generalized their approach by introducing the
symmetrical notion of left spine, and by allowing
attachment of full trees rather than attachment of a
single word.2
Since one can regard a spine as a stack in it-
self, whose elements are tree nodes, our model is
reminiscent of the embedded pushdown automata
of Schabes and Vijay-Shanker (1990), used to parse
tree adjoining grammars (Joshi and Schabes, 1997)
and exploiting a stack of stacks. However, by im-
posing projectivity, we do not use the extra-power
of the latter class.
An interesting line of future research is to com-
bine our dynamic parsing strategy with a training
method that allows the parser to explore transitions
that apply to incorrect configurations, as in Gold-
berg and Nivre (2012).
Acknowledgments
We wish to thank Liang Huang and Marco Kuhl-
mann for discussion related to the ideas reported in
this paper, and the anonymous reviewers for their
useful suggestions. The second author has been
partially supported by MIUR under project PRIN
No. 2010LYA9RH 006.
2Accuracy comparison of our work with Kitagawa and
Tanaka-Ishii (2010) is not meaningful, since these authors
have evaluated their system on the same data set but based on
gold part-of-speech tags (personal communication).
143
References
Giuseppe Attardi. 2006. Experiments with a multil-
anguage non-projective dependency parser. In Pro-
ceedings of the 10th Conference on Computational
Natural Language Learning (CoNLL), pages 166?
170.
Miguel Ballesteros and Joakim Nivre. 2013. Going
to the roots of dependency parsing. Computational
Linguistics, 39(1):5?13.
Bernd Bohnet and Joakim Nivre. 2012. A transition-
based system for joint part-of-speech tagging and
labeled non-projective dependency parsing. In Pro-
ceedings of the 2012 Joint Conference on Empirical
Methods in Natural Language Processing and Com-
putational Natural Language Learning, pages 1455?
1465.
Jinho D. Choi and Martha Palmer. 2011. Getting the
most out of transition-based dependency parsing. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL), pages
687?692.
Michael Collins and Nigel Duffy. 2002. New ranking
algorithms for parsing and tagging: Kernels over dis-
crete structures, and the voted perceptron. In Pro-
ceedings of the 40th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL), pages
263?270, Philadephia, Pennsylvania.
Marie-Catherine De Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed
dependency parses from phrase structure parses. In
Proceedings of the 5th International Conference
on Language Resources and Evaluation (LREC),
volume 6, pages 449?454.
Yoav Freund and Robert E. Schapire. 1999. Large
margin classification using the perceptron algorithm.
Machine Learning, 37(3):277?296, December.
Yoav Goldberg and Michael Elhadad. 2010. An ef-
ficient algorithm for easy-first non-directional de-
pendency parsing. In Proceedings of Human Lan-
guage Technologies: The 2010 Annual Conference
of the North American Chapter of the Association
for Computational Linguistics (NAACL), pages 742?
750, Los Angeles, USA.
Yoav Goldberg and Joakim Nivre. 2012. A dynamic or-
acle for arc-eager dependency parsing. In Proceed-
ings of the 24th International Conference on Com-
putational Linguistics (COLING), pages 959?976.
Aravind K. Joshi and Yves Schabes. 1997. Tree-
Adjoining Grammars. In Grzegorz Rozenberg and
Arto Salomaa, editors, Handbook of Formal Lan-
guages, volume 3, pages 69?123. Springer.
Kotaro Kitagawa and Kumiko Tanaka-Ishii. 2010.
Tree-based deterministic dependency parsing ? an
application to Nivre?s method ?. In Proceedings of
the 48th Annual Meeting of the Association for Com-
putational Linguistics (ACL) Short Papers, pages
189?193.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19:313?330.
Ryan McDonald and Joakim Nivre. 2007. Character-
izing the errors of data-driven dependency parsing
models. In Proceedings of the 2007 Joint Confer-
ence on Empirical Methods in Natural Language
Processing and Computational Natural Language
Learning (EMNLP-CoNLL), pages 122?131.
Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
Eighth International Workshop on Parsing Techno-
logies (IWPT), pages 149?160, Nancy, France.
Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. In Workshop on Incremental
Parsing: Bringing Engineering and Cognition To-
gether, pages 50?57, Barcelona, Spain.
Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Computational Lin-
guistics, 34(4):513?553.
Yves Schabes and K. Vijay-Shanker. 1990. Determ-
inistic left to right parsing of tree adjoining lan-
guages. In Proceedings of the 28th annual meet-
ing of the Association for Computational Linguistics
(ACL), pages 276?283, Pittsburgh, Pennsylvania.
Rajen Subba and Barbara Di Eugenio. 2009. An effect-
ive discourse parser that uses rich linguistic inform-
ation. In Proceedings of Human Language Techno-
logies: The 2009 Annual Conference of the North
American Chapter of the Association for Computa-
tional Linguistics, pages 566?574.
Hiroyasu Yamada and Yuji Matsumoto. 2003. Stat-
istical dependency analysis with support vector ma-
chines. In Proceedings of the 8th International
Workshop on Parsing Technologies (IWPT), pages
195?206.
Yue Zhang and Stephen Clark. 2008. A tale of two
parsers: Investigating and combining graph-based
and transition-based dependency parsing. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing (EMNLP), pages 562?
571.
Yue Zhang and Joakim Nivre. 2011. Transition-based
parsing with rich non-local features. In Proceedings
of the 49th Annual Meeting of the Association for
Computational Linguistics (ACL), pages 188?193.
144
A Tabular Method for Dynamic Oracles in Transition-Based Parsing
Yoav Goldberg
Department of
Computer Science
Bar Ilan University, Israel
yoav.goldberg@gmail.com
Francesco Sartorio
Department of
Information Engineering
University of Padua, Italy
sartorio@dei.unipd.it
Giorgio Satta
Department of
Information Engineering
University of Padua, Italy
satta@dei.unipd.it
Abstract
We develop parsing oracles for two trans-
ition-based dependency parsers, including the
arc-standard parser, solving a problem that
was left open in (Goldberg and Nivre, 2013).
We experimentally show that using these or-
acles during training yields superior parsing
accuracies on many languages.
1 Introduction
Greedy transition-based dependency parsers (Nivre,
2008) incrementally process an input sentence from
left to right. These parsers are very fast and
provide competitive parsing accuracies (Nivre et al.,
2007). However, greedy transition-based parsers
still fall behind search-based parsers (Zhang and
Clark, 2008; Huang and Sagae, 2010) with respect
to accuracy.
The training of transition-based parsers relies on
a component called the parsing oracle, which maps
parser configurations to optimal transitions with re-
spect to a gold tree. A discriminative model is then
trained to simulate the oracle?s behavior. A parsing
oracle is deterministic if it returns a single canon-
ical transition. Furthermore, an oracle is partial if it
is defined only for configurations that can reach the
gold tree, that is, configurations representing pars-
ing histories with no mistake. Oracles that are both
deterministic and partial are called static. Tradition-
ally, only static oracles have been exploited in train-
ing of transition-based parsers.
Recently, Goldberg and Nivre (2012; 2013)
showed that the accuracy of greedy parsers can be
substantially improved without affecting their pars-
ing speed. This improvement relies on the intro-
duction of novel oracles that are nondeterministic
and complete. An oracle is nondeterministic if it re-
turns the set of all transitions that are optimal with
respect to the gold tree, and it is complete if it is
well-defined and correct for every configuration that
is reachable by the parser. Oracles that are both non-
deterministic and complete are called dynamic.
Goldberg and Nivre (2013) develop dynamic or-
acles for several transition-based parsers. The con-
struction of these oracles is based on a property of
transition-based parsers that they call arc decompos-
ition. They also prove that the popular arc-standard
system (Nivre, 2004) is not arc-decomposable, and
they leave as an open research question the construc-
tion of a dynamic oracle for the arc-standard system.
In this article, we develop one such oracle (?4) and
prove its correctness (?5).
An extension to the arc-standard parser was
presented by Sartorio et al. (2013), which relaxes
the bottom-up construction order and allows mixing
of bottom-up and top-down strategies. This parser,
called here the LR-spine parser, achieves state-of-
the-art results for greedy parsing. Like the arc-stand-
ard system, the LR-spine parser is not arc-decom-
posable, and a dynamic oracle for this system was
not known. We extend our oracle for the arc-stand-
ard system to work for the LR-spine system as well
(?6).
The dynamic oracles developed by Goldberg and
Nivre (2013) for arc-decomposable systems are
based on local properties of computations. In con-
trast, our novel dynamic oracle algorithms rely on
arguably more complex structural properties of com-
putations, which are computed through dynamic
programming. This leaves open the question of
whether a machine-learning model can learn to ef-
fectively simulate such complex processes: will the
119
Transactions of the Association for Computational Linguistics, 2 (2014) 119?130. Action Editor: Ryan McDonald.
Submitted 11/2013; Revised 2/2014; Published 4/2014. c?2014 Association for Computational Linguistics.
benefit of training with the dynamic oracle carry
over to the arc-standard and LR-spine systems? We
show experimentally that this is indeed the case (?8),
and that using the training-with-exploration method
of (Goldberg and Nivre, 2013) with our dynamic
programming based oracles yields superior parsing
accuracies on many languages.
2 Arc-Standard Parser
In this section we introduce the arc-standard parser
of Nivre (2004), which is the model that we use in
this article. To keep the notation at a simple level,
we only discuss the unlabeled version of the parser;
however, a labeled extension is used in ?8 for our
experiments.
2.1 Preliminaries and Notation
The set of non-negative integers is denoted as N0.
For i, j ? N0 with i ? j, we write [i, j] to denote
the set {i, i + 1, . . . , j}. When i > j, [i, j] denotes
the empty set.
We represent an input sentence as a string w =
w0 ? ? ?wn, n ? N0, where token w0 is a special
root symbol, and each wi with i ? [1, n] is a lex-
ical token. For i, j ? [0, n] with i ? j, we write
w[i, j] to denote the substring wiwi+1 ? ? ?wj of w.
We write i ? j to denote a grammatical de-
pendency of some unspecified type between lexical
tokens wi and wj , where wi is the head and wj is the
dependent. A dependency tree for w is a directed,
ordered tree t = (Vw, A), such that Vw = [0, n] is
the set of nodes, A ? Vw?Vw is the set of arcs, and
node 0 is the root. Arc (i, j) encodes a dependency
i ? j, and we will often use the latter notation to
denote arcs.
2.2 Transition-Based Dependency Parsing
We assume the reader is familiar with the formal
framework of transition-based dependency parsing
originally introduced by Nivre (2003); see Nivre
(2008) for an introduction. We only summarize here
our notation.
Transition-based dependency parsers use a stack
data structure, where each stack element is associ-
ated with a tree spanning (generating) some sub-
string of the input w. The parser processes the in-
put string incrementally, from left to right, applying
at each step a transition that updates the stack and/or
consumes one token from the input. Transitions may
also construct new dependencies, which are added to
the current configuration of the parser.
We represent the stack data structure as an
ordered sequence ? = [?d, . . . , ?1], d ? N0, of
nodes ?i ? Vw, with the topmost element placed
at the right. When d = 0, we have the empty stack
? = []. Sometimes we use the vertical bar to denote
the append operator for ?, and write ? = ??|?1 to
indicate that ?1 is the topmost element of ?.
The parser also uses a buffer to store the portion
of the input string still to be processed. We represent
the buffer as an ordered sequence ? = [i, . . . , n] of
nodes from Vw, with i the first element of the buf-
fer. In this way ? always encodes a (non-necessarily
proper) suffix of w. We denote the empty buffer as
? = []. Sometimes we use the vertical bar to denote
the append operator for ?, and write ? = i|?? to in-
dicate that i is the first token of ?; consequently, we
have ?? = [i+ 1, . . . , n].
When processing w, the parser reaches several
states, technically called configurations. A config-
uration of the parser relative to w is a triple c =
(?, ?,A), where ? and ? are a stack and a buffer,
respectively, and A ? Vw ? Vw is a set of arcs. The
initial configuration for w is ([], [0, . . . , n], ?). For
the purpose of this article, a configuration is final
if it has the form ([0], [], A), and in a final config-
uration arc set A always defines a dependency tree
for w.
The core of a transition-based parser is the set of
its transitions, which are specific to each family of
parsers. A transition is a binary relation defined
over the set of configurations of the parser. We use
symbol ` to denote the union of all transition rela-
tions of a parser.
A computation of the parser on w is a sequence
c0, . . . , cm, m ? N0, of configurations (defined rel-
ative to w) such that ci?1 ` ci for each i ? [1,m].
We also use the reflexive and transitive closure rela-
tion `? to represent computations. A computation is
called complete whenever c0 is initial and cm is fi-
nal. In this way, a complete computation is uniquely
associated with a dependency tree for w.
2.3 Arc-Standard Parser
The arc-standard model uses the three types of trans-
itions formally specified in Figure 1
120
(?, i|?,A) `sh (?|i, ?, A)
(?|i|j, ?,A) `la (?|j, ?,A ? {j ? i})
(?|i|j, ?,A) `ra (?|i, ?, A ? {i? j})
Figure 1: Transitions in the arc-standard model.
? Shift (sh) removes the first node in the buffer
and pushes it into the stack;
? Left-Arc (la) creates a new arc with the topmost
node on the stack as the head and the second-
topmost node as the dependent, and removes
the second-topmost node from the stack;
? Right-Arc (ra) is symmetric to la in that it cre-
ates an arc with the second-topmost node as the
head and the topmost node as the dependent,
and removes the topmost node.
Notation We sometimes use the functional nota-
tion for a transition ? ? {sh, la, ra}, and write
?(c) = c? in place of c `? c?. Naturally, sh applies
only when the buffer is not empty, and la,ra require
two elements on the stack. We denote by valid(c)
the set of valid transitions in a given configuration.
2.4 Arc Decomposition
Goldberg and Nivre (2013) show how to derive dy-
namic oracles for any transition-based parser which
has the arc decomposition property, defined below.
They also show that the arc-standard parser is not
arc-decomposable.
For a configuration c, we write Ac to denote the
associated set of arcs. A transition-based parser is
arc-decomposable if, for every configuration c and
for every set of arcs A that can be extended to a pro-
jective tree, we have
?(i? j) ? A,?c?[c `? c? ? (i? j) ? Ac? ]
? ?c??[c `? c?? ?A ? Ac?? ] .
In words, if each arc in A is individually derivable
from c, then the set A in its entirety can be derived
from c as well. The arc decomposition property
is useful for deriving dynamic oracles because it is
relatively easy to investigate derivability for single
arcs and then, using this property, draw conclusions
about the number of gold-arcs that are simultan-
eously derivable from the given configuration.
Unfortunately, the arc-standard parser is not arc-
decomposable. To see why, consider a configura-
tion with stack ? = [i, j, k]. Consider also arc set
A = {(i, j), (i, k)}. The arc (i, j) can be derived
through the transition sequence ra, ra, and the arc
(i, k) can be derived through the alternative trans-
ition sequence la, ra. Yet, it is easy to see that a con-
figuration containing both arcs cannot be reached.
As we cannot rely on the arc decomposition prop-
erty, in order to derive a dynamic oracle for the arc-
standard model we need to develop more sophistic-
ated techniques which take into account the interac-
tion among the applied transitions.
3 Configuration Loss and Dynamic Oracles
We aim to derive a dynamic oracle for the arc-stand-
ard (and related) system. This is a function that takes
a configuration c and a gold tree tG and returns a set
of transitions that are ?optimal? for c with respect
to tG. As already mentioned in the introduction, a
dynamic oracle can be used to improve training of
greedy transition-based parsers. In this section we
provide a formal definition for a dynamic oracle.
Let t1 and t2 be two dependency trees over the
same stringw, with arc setsA1 andA2, respectively.
We define the loss of t1 with respect to t2 as
L(t1, t2) = |A1 \A2| . (1)
Note that L(t1, t2) = L(t2, t1), since |A1| =
|A2|. Furthermore L(t1, t2) = 0 if and only if t1
and t2 are the same tree.
Let c be a configuration of our parser relative to
input string w. We write D(c) to denote the set of
all dependency trees that can be obtained in a com-
putation of the form c `? cf , where cf is some final
configuration. We extend the loss function in (1) to
configurations by letting
L(c, t2) = min
t1?D(c)
L(t1, t2) . (2)
Assume some reference (desired) dependency
tree tG for w, which we call the gold tree. Quantity
L(c, tG) can be used to compute a dynamic oracle
relating a parser configuration c to a set of optimal
actions by setting
oracle(c, tG) =
{? | L(?(c), tG)? L(c, tG) = 0} . (3)
121
We therefore need to develop an algorithm for com-
puting (2). We will do this first for the arc-standard
parser, and then for an extension of this model.
Notation We also apply the loss function L(t, tG)
in (1) when t is a dependency tree for a substring
of w. In this case the nodes of t are a subset of
the nodes of tG, and L(t, tG) provides a count of
the nodes of t that are assigned a wrong head node,
when tG is considered as the reference tree.
4 Main Algorithm
Throughout this section we assume an arc-standard
parser. Our algorithm takes as input a projective
gold tree tG and a configuration c = (?L, ?, A). We
call ?L the left stack, in contrast with a right stack
whose construction is specified below.
4.1 Basic Idea
The algorithm consists of two steps. Informally, in
the first step we compute the largest subtrees, called
here tree fragments, of the gold tree tG that have
their span entirely included in the buffer ?. The
root nodes of these tree fragments are then arranged
into a stack data structure, according to the order in
which they appear in ? and with the leftmost root in
? being the topmost element of the stack. We call
this structure the right stack ?R. Intuitively, ?R can
be viewed as the result of pre-computing ? by ap-
plying all sequences of transitions that match tG and
that can be performed independently of the stack in
the input configuration c, that is, ?L.
In the second step of the algorithm we use dy-
namic programming techniques to simulate all com-
putations of the arc-standard parser starting in a con-
figuration with stack ?L and with a buffer consisting
of ?R, with the topmost token of ?R being the first
token of the buffer. As we will see later, the search
space defined by these computations includes the de-
pendency trees for w that are reachable from the in-
put configuration c and that have minimum loss. We
then perform a Viterbi search to pick up such value.
The second step is very similar to standard imple-
mentations of the CKY parser for context-free gram-
mars (Hopcroft and Ullman, 1979), running on an
input string obtained as the concatenation of ?L and
?R. The main difference is that we restrict ourselves
to parse only those constituents in ?L?R that dom-
inate the topmost element of ?L (the rightmost ele-
ment, if ?L is viewed as a string). In this way, we ac-
count for the additional constraint that we visit only
those configurations of the arc-standard parser that
can be reached from the input configuration c. For
instance, this excludes the reduction of two nodes in
?L that are not at the two topmost positions. This
would also exclude the reduction of two nodes in
?R: this is correct, since the associated tree frag-
ments have been chosen as the largest such frag-
ments in ?.
The above intuitive explanation will be made
mathematically precise in ?5, where the notion of
linear dependency tree is introduced.
4.2 Construction of the Right Stack
In the first step we process ? and construct a stack
?R, which we call the right stack associated with c
and tG. Each node of ?R is the root of a tree t which
satisfies the following properties
? t is a tree fragment of the gold tree tG having
span entirely included in the buffer ?;
? t is bottom-up complete for tG, meaning that
for each node i of t different from t?s root, the
dependents of i in tG cannot be in ?L;
? t is maximal for tG, meaning that every super-
tree of t in tG violates the above conditions.
The stack ?R is incrementally constructed by pro-
cessig ? from left to right. Each node i is copied into
?R if it satisfies any of the following conditions
? the parent node of i in tG is not in ?;
? some dependent of i in tG is in ?L or has
already been inserted in ?R.
It is not difficult to see that the nodes in ?R are the
roots of tree fragments of tG that satisfy the condi-
tion of bottom-up completeness and the condition of
maximality defined above.
4.3 Computation of Configuration Loss
We start with some notation. Let `L = |?L| and
`R = |?R|. We write ?L[i] to denote the i-th ele-
ment of ?L and t(?L[i]) to denote the correspond-
ing tree fragment; ?R[i] and t(?R[i]) have a similar
meaning. In order to simplify the specification of
the algorithm, we assume below that ?L[1] = ?R[1].
122
Algorithm 1 Computation of the loss function for the arc-standard parser
1: T [1, 1](?L[1])? L(t(?L[1]), tG)
2: for d? 1 to `L + `R ? 1 do . d is the index of a sub-anti-diagonal
3: for j ? max{1, d? `L + 1} to min{d, `R} do . j is the column index
4: i? d? j + 1 . i is the row index
5: if i < `L then . expand to the left
6: for each h ? ?i,j do
7: T [i+ 1, j](h)? min{T [i+ 1, j](h), T [i, j](h) + ?G(h? ?L[i+ 1])}
8: T [i+ 1, j](?L[i+ 1])? min{T [i+ 1, j](?L[i+ 1]), T [i, j](h) + ?G(?L[i+ 1]? h)}
9: if j < `R then . expand to the right
10: for each h ? ?i,j do
11: T [i, j + 1](h)? min{T [i, j + 1](h), T [i, j](h) + ?G(h? ?R[j + 1])}
12: T [i, j+1](?R[j + 1])? min{T [i, j+1](?R[j + 1]), T [i, j](h)+?G(?R[j + 1]? h)}
13: return T [`L, `R](0) +?i?[1,`L] L(t(?L[i]), tG)
Therefore the elements of ?R which have been con-
structed in ?4.2 are ?R[i], i ? [2, `R].
Algorithm 1 uses a two-dimensional array T of
size `L ? `R, where each entry T [i, j] is an as-
sociation list from integers to integers. An entry
T [i, j](h) stores the minimum loss among depend-
ency trees rooted at h that can be obtained by run-
ning the parser on the first i elements of stack ?L and
the first j elements of buffer ?R. More precisely, let
?i,j = {?L[k] | k ? [1, i]} ?
{?R[k] | k ? [1, j]} . (4)
For each h ? ?i,j , the entry T [i, j](h) is the
minimum loss among all dependency trees defined
as above and with root h. We also assume that
T [i, j](h) is initialized to +? (not reported in the
algorithm).
Algorithm 1 starts at the top-left corner of T , vis-
iting each individual sub-anti-diagonal of T in as-
cending order, and eventually reaching the bottom-
right corner of the array. For each entry T [i, j], the
left expansion is considered (lines 5 to 8) by com-
bining with tree fragment ?L[i+ 1], through a left
or a right arc reduction. This results in the update
of T [i + 1, j](h), for each h ? ?i+1,j , whenever a
smaller value of the loss is achieved for a tree with
root h. The Kronecker-like function used at line 8
provides the contribution of each single arc to the
loss of the current tree. Denoting with AG the set of
arcs of tG, such a function is defined as
?G(i? j) =
{
0, if (i? j) ? AG;
1, otherwise. (5)
A symmetrical process is implemented for the
right expansion of T [i, j] through tree fragment
?R[j + 1] (lines 9 to 12).
As we will see in the next section, quantity
T [`L, `R](0) is the minimal loss of a tree composed
only by arcs that connect nodes in ?L and ?R. By
summing the loss of all tree fragments t(?L[i]) to
the loss in T [`L, `R](0), at line 13, we obtain the
desired result, since the loss of each tree fragment
t(?R[j]) is zero.
5 Formal Properties
Throughout this section we let w, tG, ?L, ?R and
c = (?L, ?, A) be defined as in ?4, but we no longer
assume that ?L[1] = ?R[1]. To simplify the present-
ation, we sometimes identify the tokens in w with
the associated nodes in a dependency tree for w.
5.1 Linear Trees
Algorithm 1 explores all dependency trees that can
be reached by an arc-standard parser from configur-
ation c, under the condition that (i) the nodes in the
buffer ? are pre-computed into tree fragments and
collapsed into their root nodes in the right stack ?R,
and (ii) nodes in ?R cannot be combined together
prior to their combination with other nodes in the
left stack ?L. This set of dependency trees is char-
123
j4
i6 i5 i3 j5
i4 i1 j3
i2 j1 j2
?R?L
Figure 2: A possible linear tree for string pair (?L, ?R),
where ?L = i6i5i4i3i2i1 and ?R = j1j2j3j4j5. The
spine of the tree consists of nodes j4, i3 and i1.
acterized here using the notion of linear tree, to be
used later in the correctness proof.
Consider two nodes ?L[i] and ?L[j] with j >
i > 1. An arc-standard parser can construct an arc
between ?L[i] and ?L[j], in any direction, only after
reaching a configuration in which ?L[i] is at the top
of the stack and ?L[j] is at the second topmost posi-
tion. In such configuration we have that ?L[i] dom-
inates ?L[1]. Furthermore, consider nodes ?R[i] and
?R[j] with j > i ? 1. Since we are assuming that
tree fragments t(?R[i]) and t(?R[j]) are bottom-up
complete and maximal, as defined in ?4.2, we allow
the construction of an arc between ?R[i] and ?R[j],
in any direction, only after reaching a configuration
in which ?R[i] dominates node ?L[1].
The dependency trees satisfying the restrictions
above are captured by the following definition. A
linear tree over (?L, ?R) is a projective dependency
tree t for string ?L?R satisfying both of the addi-
tional conditions reported below. The path from t?s
root to node ?L[1] is called the spine of t.
? Every node of t not in the spine is a dependent
of some node in the spine.
? For each arc i ? j in t with j in the spine, no
dependent of i can be placed in between i and
j within string ?L?R.
An example of a linear tree is depicted in Figure 2.
Observe that the second condition above forbids the
reduction of two nodes i and j, in case none of these
dominates node ?L[1]. For instance, the ra reduc-
tion of nodes i3 and i2 would result in arc i3 ? i2
replacing arc i1 ? i2 in Figure 2. The new depend-
ency tree is not linear, because of a violation of the
second condition above. Similarly, the la reduction
of nodes j3 and j4 would result in arc j4 ? j3 re-
placing arc i3 ? j3 in Figure 2, again a violation of
the second condition above.
Lemma 1 Any tree t ? D(c) can be decomposed
into trees t(?L[i]), i ? [1, `L], trees tj , j ? [1, q] and
q ? 1, and a linear tree tl over (?L, ?R,t), where
?R,t = r1 ? ? ? rq and each rj is the root node of tj . 2
PROOF (SKETCH) Trees t(?L[i]) are common to
every tree in D(c), since the arc-standard model can
not undo the arcs already built in the current con-
figuration c. Similar to the construction in ?4.2 of
the right stack ?R from tG, we let tj , j ? [1, q], be
tree fragments of t that cover only nodes associated
with the tokens in the buffer ? and that are bottom-
up complete and maximal for t. These trees are in-
dexed according to their left to right order in ?. Fi-
nally, tl is implicitly defined by all arcs of t that are
not in trees t(?L[i]) and tj . It is not difficult to see
that tl has a spine ending with node ?L[1] and is a
linear tree over (?L, ?R,t). 
5.2 Correctness
Our proof of correctness for Algorithm 1 is based on
a specific dependency tree t? for w, which we define
below. Let SL = {?L[i] | i ? [1, `L]} and letDL be
the set of nodes that are descendants of some node
in SL. Similarly, let SR = {?R[i] | i ? [1, `R]}
and let DR be the set of descendants of nodes in
SR. Note that sets SL, SR, DL and DR provide a
partition of Vw.
We choose any linear tree t?l over (?L, ?R) having
root 0, such that L(t?l , tG) = mint L(t, tG), where
t ranges over all possible linear trees over (?L, ?R)
with root 0. Tree t? consists of the set of nodes Vw
and the set of arcs obtained as the union of the set
of arcs of t?l and the set of arcs of all trees t(?L[i]),
i ? [1, `L], and t(?R[j]), j ? [1, `R].
Lemma 2 t? ? D(c). 2
PROOF (SKETCH) All tree fragments t(?L[i]) have
already been parsed and are available in the stack
associated with c. Each tree fragment t(?R[j]) can
later be constructed in the computation, when a con-
figuration c? is reached with the relevant segment of
w at the start of the buffer. Note also that parsing of
t(?R[j]) can be done in a way that does not depend
on the content of the stack in c?.
124
Finally, the parsing of the tree fragments t(?R[j])
is interleaved with the construction of the arcs from
the linear tree t?l , which are all of the form (i ? j)
with i, j ? (SL ? SR). More precisely, if (i ? j)
is an arc from t?l , at some point in the computation
nodes i and j will become available at the two top-
most positions in the stack. This follows from the
second condition in the definition of linear tree. 
We now show that tree t? is ?optimal? within the
set D(c) and with respect to tG.
Lemma 3 L(t?, tG) = L(c, tG). 2
PROOF Consider an arbitrary tree t ? D(c). As-
sume the decomposition of t defined in the proof of
Lemma 1, through trees t(?L[i]), i ? [1, `L], trees
tj , j ? [1, q], and linear tree tl over (?L, ?R,t).
Recall that an arc i ? j denotes an ordered pair
(i, j). Let us consider the following partition for the
set of arcs of any dependency tree for w
A1 = (SL ?DL)?DL ,
A2 = (SR ?DR)?DR ,
A3 = (Vw ? Vw) \ (A1 ?A2) .
In what follows, we compare the losses L(t, tG) and
L(t?, tG) by separately looking into the contribution
to such quantities due to the arcs in A1, A2 and A3.
Note that the arcs of trees t(?L[i]) are all in A1,
the arcs of trees t(?R[j]) are all in A2, and the arcs
of tree t?l are all in A3. Since t and t? share trees
t(?L[i]), when restricted to arcs in A1 quantities
L(t, tG) and L(t?, tG) are the same. When restric-
ted to arcs in A2, quantity L(t?, tG) is zero, by con-
struction of the trees t(?R[j]). Thus L(t, tG) can not
be smaller thanL(t?, tG) for these arcs. The difficult
part is the comparison of the contribution to L(t, tG)
and L(t?, tG) due to the arcs in A3. We deal with
this below.
LetAS,G be the set of all arcs from tG that are also
in set (SL ? SR) ? (SR ? SL). In words, AS,G rep-
resents gold arcs connecting nodes in SL and nodes
in SR, in any direction. Within tree t, these arcs can
only be found in the tl component, since nodes in
SL are all placed within the spine of tl, or else at the
left of that spine.
Let us consider an arc (j ? i) ? AS,G with j ?
SL and i ? SR, and let us assume that (j ? i) is in
t?l . If token ai does not occur in ?R,t, node i is not
in tl and (j ? i) can not be an arc of t. We then
have that (j ? i) contributes one unit to L(t, tG)
but does not contribute to L(t?, tG). Similarly, let
(i ? j) ? AS,G be such that i ? SR and j ? SL,
and assume that (i? j) is in t?l . If token ai does not
occur in ?R,t, arc (i ? j) can not be in t. We then
have that (i ? j) contributes one unit to L(t, tG)
but does not contribute to L(t?, tG).
Intuitively, the above observations mean that the
winning strategy for trees in D(c) is to move nodes
from SR as much as possible into the linear tree
component tl, in order to make it possible for these
nodes to connect to nodes in SL, in any direction. In
this case, arcs fromA3 will also move into the linear
tree component of a tree inD(c), as it happens in the
case of t?. We thus conclude that, when restricted to
the set of arcs in A3, quantity L(t, tG) is not smal-
ler than L(t?, tG), because stack ?R has at least as
many tokens corresponding to nodes in SR as stack
?R,t, and because t?l has the minimum loss among
all the linear trees over (?L, ?R).
Putting all of the above observations together,
we conclude that L(t, tG) can not be smaller than
L(t?, tG). This concludes the proof, since t has been
arbitrarily chosen in D(c). 
Theorem 1 Algorithm 1 computes L(c, tG). 2
PROOF (SKETCH) Algorithm 1 implements a Vi-
terbi search for trees with smallest loss among all
linear trees over (?L, ?R). Thus T [`L, `R](0) =
L(t?l , tG). The loss of the tree fragments t(?R[j])
is 0 and the loss of the tree fragments t(?L[i]) is ad-
ded at line 13 in the algorithm. Thus the algorithm
returns L(t?, tG), and the statement follows from
Lemma 2 and Lemma 3. 
5.3 Computational Analysis
Following ?4.2, the right stack ?R can be easily
constructed in time O(n), n the length of the in-
put string. We now analyze Algorithm 1. For each
entry T [i, j] and for each h ? ?i,j , we update
T [i, j](h) a number of times bounded by a con-
stant which does not depend on the input. Each up-
dating can be computed in constant time as well.
We thus conclude that Algorithm 1 runs in time
O(`L ? `R ? (`L + `R)). Quantity `L+`R is bounded
by n, but in practice the former is significantly smal-
ler. When measured over the sentences in the Penn
125
Treebank, the average value of `L+`Rn is 0.29. Interms of runtime, training is 2.3 times slower when
using our oracle instead of a static oracle.
6 Extension to the LR-Spine Parser
In this section we consider the transition-based
parser proposed by Sartorio et al. (2013), called
here the LR-spine parser. This parser is not arc-
decomposable: the same example reported in ?2.4
can be used to show this fact. We therefore extend to
the LR-spine parser the algorithm developed in ?4.
6.1 The LR-Spine Parser
Let t be a dependency tree. The left spine of t is
an ordered sequence ?i1, . . . , ip?, p ? 1, consisting
of all nodes in a descending path from the root of
t taking the leftmost child node at each step. The
right spine of t is defined symmetrically. We use ?
to denote sequence concatenation.
In the LR-spine parser each stack element ?[i] de-
notes a partially built subtree t(?[i]) and is represen-
ted by a pair (lsi, rsi), with lsi and rsi the left and the
right spine, respectively, of t(?[i]). We write lsi[k]
(rsi[k]) to represent the k-th element of lsi (rsi, re-
spectively). We also write r(?[i]) to denote the root
of t(?[i]), so that r(?[i]) = lsi[1] = rsi[1].
Informally, the LR-spine parser uses the same
transition typologies as the arc-standard parser.
However, an arc (h ? d) can now be created with
the head node h chosen from any node in the spine
of the involved tree. The transition types of the LR-
spine parser are defined as follows.
? Shift (sh) removes the first node from the buf-
fer and pushes into the stack a new element,
consisting of the left and right spines of the as-
sociated tree
(?, i|?,A) `sh (?|(?i?, ?i?), ?, A) .
? Left-Arc k (lak) creates a new arc h ? d from
the k-th node in the left spine of the topmost
tree in the stack to the head of the second ele-
ment in the stack. Furthermore, the two top-
most stack elements are replaced by a new ele-
ment associated with the resulting tree
(??|?[2]|?[1], ?, A) `lak (??|?lak , ?, A ? {h? d})
where we have set h = ls1[k], d = r(?[2]) and
?lak = (?ls1[1], . . . , ls1[k]? ? ls2, rs1).
? Right-Arc k (rak for short) is defined symmet-
rically with respect to lak
(??|?[2]|?[1], ?, A) `rak (??|?rak , ?, A ? {h? d})
where we have set h = rs2[k], d = r(?[1]) and
?rak = (ls2, ?rs2[1], . . . , rs2[k]? ? rs1).
Note that, at each configuration in the LR-spine
parser, there are |ls1| possible lak transitions, one for
each choice of a node in the left spine of t(?[1]);
similarly, there are |rs2| possible rak transitions,
one for each choice of a node in the right spine of
t(?[2]).
6.2 Configuration Loss
We only provide an informal description of the ex-
tended algorithm here, since it is very similar to the
algorithm in ?4.
In the first phase we use the procedure of ?4.2 for
the construction of the right stack ?R, considering
only the roots of elements in ?L and ignoring the
rest of the spines. The only difference is that each
element ?R[j] is now a pair of spines (lsR,j , rsR,j).
Since tree fragment t(?R[j]) is bottom-up complete
(see ?4.1), we now restrict the search space in such
a way that only the root node r(?R[j]) can take de-
pendents. This is done by setting lsR,j = rsR,j =
?r(?R[j])? for each j ? [1, `R]. In order to simplify
the presentation we also assume ?R[1] = ?L[1], as
done in ?4.3.
In the second phase we compute the loss of an in-
put configuration using a two-dimensional array T ,
defined as in ?4.3. However, because of the way
transitions are defined in the LR-spine parser, we
now need to distinguish tree fragments not only on
the basis of their roots, but also on the basis of their
left and right spines. Accordingly, we define each
entry T [i, j] as an association list with keys of the
form (ls, rs). More specifically, T [i, j](ls, rs) is the
minimum loss of a tree with left and right spines ls
and rs, respectively, that can be obtained by running
the parser on the first i elements of stack ?L and the
first j elements of buffer ?R.
We follow the main idea of Algorithm 1 and ex-
pand each tree in T [i, j] at its left side, by combin-
ing with tree fragment t(?L[i+ 1]), and at its right
side, by combining with tree fragment t(?R[j + 1]).
126
Tree combination deserves some more detailed dis-
cussion, reported below.
We consider the combination of a tree ta from
T [i, j] and tree t(?L[i+ 1]) by means of a left-arc
transition. All other cases are treated symmetric-
ally. Let (lsa, rsa) be the spine pair of ta, so that
the loss of ta is stored in T [i, j](lsa, rsa). Let also
(lsb, rsb) be the spine pair of t(?L[i+ 1]). In case
there exists a gold arc in tG connecting a node from
lsa to r(?L[i+ 1]), we choose the transition lak,
k ? [1, |lsa|], that creates such arc. In case such gold
arc does not exists, we choose the transition lak with
the maximum possible value of k, that is, k = |lsa|.
We therefore explore only one of the several pos-
sible ways of combining these two trees by means
of a left-arc transition.
We remark that the above strategy is safe. In fact,
in case the gold arc exists, no other gold arc can ever
involve the nodes of lsa eliminated by lak (see the
definition in ?6.1), because arcs can not cross each
other. In case the gold arc does not exist, our choice
of k = |lsa| guarantees that we do not eliminate any
element from lsa.
Once a transition lak is chosen, as described
above, the reduction is performed and the spine
pair (ls, rs) for the resulting tree is computed from
(lsa, rsa) and (lsb, rsb), as defined in ?6.1. At the
same time, the loss of the resulting tree is com-
puted, on the basis of the loss T [i, j](lsa, rsa), the
loss of tree t(?L[i+ 1]), and a Kronecker-like func-
tion defined below. This loss is then used to update
T [i+ 1, j](ls, rs).
Let ta and tb be two trees that must be combined
in such a way that tb becomes the dependent of
some node in one of the two spines of ta. Let also
pa = (lsa, rsa) and pb = (lsb, rsb) be spine pairs for
ta and tb, respectively. Recall that AG is the set of
arcs of tG. The new Kronecker-like function for the
computation of the loss is defined as
?G(pa, pb) =
?
?????
?????
0, if r(ta) < r(tb)?
?k[(rska ? r(tb)) ? AG];
0, if r(ta) > r(tb)?
?k[(lska ? r(tb)) ? AG];
1, otherwise.
6.3 Efficiency Improvement
The algorithm in ?6.2 has an exponential behaviour.
To see why, consider trees in T [i, j]. These trees are
produced by the combination of trees in T [i ? 1, j]
with tree t(?L[i]), or by the combination of trees in
T [i, j ? 1] with tree t(?R[j]). Since each combin-
ation involves either a left-arc or a right-arc trans-
ition, we obtain a recursive relation that resolves into
a number of trees in T [i, j] bounded by 4i+j?2.
We introduce now two restrictions to the search
space of our extended algorithm that result in a huge
computational saving. For a spine s, we write N (s)
to denote the set of all nodes in s. We also let ?i,j be
the set of all pairs (ls, rs) such that T [i, j](ls, rs) 6=
+?.
? Every time a new pair (ls, rs) is created in
?[i, j], we remove from ls all nodes different
from the root that do not have gold dependents
in {r(?L[k]) | k < i}, and we remove from
rs all nodes different from the root that do not
have gold dependents in {r(?R[k]) | k > j}.
? A pair pa = (lsa, rsa) is removed from
?[i, j] if there exists a pair pb = (lsb, rsb)
in ?[i, j] with the same root node as pa and
with (lsa, rsa) 6= (lsb, rsb), such that N (lsa) ?
N (lsb), N (rsa) ? N (rsb), and T [i, j](pa) ?
T [i, j](pb).
The first restriction above reduces the size of a spine
by eliminating a node if it is irrelevant for the com-
putation of the loss of the associated tree. The
second restriction eliminates a tree ta if there is a
tree tb with smaller loss than ta, such that in the
computations of the parser tb provides exactly the
same context as ta. It is not difficult to see that
the above restrictions do not affect the correctness of
the algorithm, since they always leave in our search
space some tree that has optimal loss.
A mathematical analysis of the computational
complexity of the extended algorithm is quite in-
volved. In Figure 3, we plot the worst case size
of T [i, j] for each value of j + i ? 1, computed
over all configurations visited in the training phase
(see ?7). We see that |T [i, j]| grows linearly with
j + i? 1, leading to the same space requirements of
Algorithm 1. Empirically, training with the dynamic
127
0 10 20 30 40 500
10
20
30
40
50
i+ j ? 1
ma
xn
um
be
ro
fe
lem
en
ts
Figure 3: Empirical worst case size of T [i, j] for each
value of i + j ? 1 as measured on the Penn Treebank
corpus.
Algorithm 2 Online training for greedy transition-
based parsers
1: w? 0
2: for k iterations do
3: shuffle(corpus)
4: for sentencew and gold tree tG in corpus do
5: c? INITIAL(w)
6: while not FINAL(c) do
7: ?p ? argmax??valid(c)w ? ?(c, ?)
8: ?o ? argmax??oracle(c,tG)w??(c, ?)
9: if ?p 6? oracle(c, tG) then
10: w? w + ?(c, ?o)? ?(c, ?p)
11: ? ?
{
?p if EXPLORE
?o otherwise
12: c? ?(c)
return averaged(w)
oracle is only about 8 times slower than training with
the oracle of Sartorio et al. (2013) without exploring
incorrect configurations.
7 Training
We follow the training procedure suggested by
Goldberg and Nivre (2013), as described in Al-
gorithm 2. The algorithm performs online learning
using the averaged perceptron algorithm. A weight
vector w (initialized to 0) is used to score the valid
transitions in each configuration based on a feature
representation ?, and the highest scoring transition
?p is predicted. If the predicted transition is not
optimal according to the oracle, the weights w are
updated away from the predicted transition and to-
wards the highest scoring oracle transition ?o. The
parser then moves to the next configuration, by tak-
ing either the predicted or the oracle transition. In
the ?error exploration? mode (EXPLORE is true), the
parser follows the predicted transition, and other-
wise the parser follows the oracle transition. Note
that the error exploration mode requires the com-
pleteness property of a dynamic oracle.
We consider three training conditions: static, in
which the oracle is deterministic (returning a single
canonical transition for each configuration) and no
error exploration is performed; nondet, in which we
use a nondeterministic partial oracle (Sartorio et al.,
2013), but do not perform error exploration; and ex-
plore in which we use the dynamic oracle and per-
form error exploration. The static setup mirrors the
way greedy parsers are traditionally trained. The
nondet setup allows the training procedure to choose
which transition to take in case of spurious ambigu-
ities. The explore setup increases the configuration
space explored by the parser during training, by ex-
posing the training procedure to non-optimal con-
figurations that are likely to occur during parsing,
together with the optimal transitions to take in these
configurations. It was shown by Goldberg and Nivre
(2012; 2013) that the nondet setup outperforms the
static setup, and that the explore setup outperforms
the nondet setup.
8 Experimental Evaluation
Datasets Performance evaluation is carried out on
CoNLL 2007 multilingual dataset, as well as on the
Penn Treebank (PTB) (Marcus et al., 1993) conver-
ted to Stanford basic dependencies (De Marneffe
et al., 2006). For the CoNLL datasets we use gold
part-of-speech tags, while for the PTB we use auto-
matically assigned tags. As usual, the PTB parser is
trained on sections 2-21 and tested on section 23.
Setup We train labeled versions of the arc-stand-
ard (std) and LR-spine (lrs) parsers under the static,
nondet and explore setups, as defined in ?7. In
the nondet setup we use a nondeterministic partial
oracle and in the explore setup we use the non-
deterministic complete oracles we present in this pa-
per. In the static setup we resolve oracle ambiguities
and choose a canonic transition sequence by attach-
ing arcs as soon as possible. In the explore setup,
128
parser:train Arabic Basque Catalan Chinese Czech English Greek Hungarian Italian Turkish PTB
UAS
std:static 81.39 75.37 90.32 85.17 78.90 85.69 79.90 77.67 82.98 77.04 89.86
std:nondet 81.33 74.82 90.75 84.80 79.92 86.89 81.19 77.51 84.15 76.85 90.56
std:explore 82.56 74.39 90.95 85.65 81.01 87.70 81.85 78.72 84.37 77.21 90.92
lrs:static 81.67 76.07 91.47 84.24 77.93 86.36 79.43 76.56 84.64 77.00 90.33
lrs:nondet 83.14 75.53 91.31 84.98 80.03 88.38 81.12 76.98 85.29 77.63 91.18
lrs:explore 84.54 75.82 91.92 86.72 81.19 89.37 81.78 77.48 85.38 78.61 91.77
LAS
std:static 71.93 65.64 84.90 80.35 71.39 84.60 72.25 67.66 78.77 65.90 87.56
std:nondet 71.09 65.28 85.36 80.06 71.47 85.91 73.40 67.77 80.06 65.81 88.30
std:explore 72.89 65.27 85.82 81.28 72.92 86.79 74.22 69.57 80.25 66.71 88.72
lrs:static 72.24 66.21 86.02 79.36 70.48 85.38 72.36 66.79 80.38 66.02 88.07
lrs:nondet 72.94 65.66 86.03 80.47 71.32 87.45 73.09 67.70 81.32 67.02 88.96
lrs:explore 74.54 66.91 86.83 82.38 72.72 88.44 74.04 68.76 81.50 68.06 89.53
Table 1: Scores on the CoNLL 2007 dataset (including punctuation, gold parts of speech) and on Penn Tree Bank
(excluding punctuation, predicted parts of speech). Label ?std? refers to the arc-standard parser, and ?lrs? refers to the
LR-spine parser. Each number is an average over 5 runs with different randomization seeds.
from the first round of training onward, we always
follow the predicted transition (EXPLORE is true).
For all languages, we deal with non-projectivity by
skipping the non-projective sentences during train-
ing but not during test. For each parsing system,
we use the same feature templates across all lan-
guages.1 The arc-standard models are trained for 15
iterations and the LR-spine models for 30 iterations,
after which all the models seem to have converged.
Results In Table 1 we report the labeled (LAS)
and unlabeled (UAS) attachment scores. As expec-
ted, the LR-spine parsers outperform the arc-stand-
ard parsers trained under the same setup. Training
with the dynamic oracles is also beneficial: despite
the arguable complexity of our proposed oracles, the
trends are consistent with those reported by Gold-
berg and Nivre (2012; 2013). For the arc-standard
model we observe that the move from a static to
a nondeterministic oracle during training improves
the accuracy for most of languages. Making use of
the completeness of the dynamic oracle and moving
to the error exploring setup further improve results.
The only exceptions are Basque, that has a small
dataset with more than 20% of non-projective sen-
tences, and Chinese. For Chinese we observe a re-
duction of accuracy in the nondet setup, but an in-
crease in the explore setup.
For the LR-spine parser we observe a practically
constant increase of performance by moving from
1Our complete code, together with the description of the fea-
ture templates, is available on the second author?s homepage.
the static to the nondeterministic and then to the er-
ror exploring setups.
9 Conclusions
We presented dynamic oracles, based on dynamic
programming, for the arc-standard and the LR-
spine parsers. Empirical evaluation on 10 languages
showed that, despite the apparent complexity of the
oracle calculation procedure, the oracles are still
learnable, in the sense that using these oracles in
the error exploration training algorithm presented in
(Goldberg and Nivre, 2012) considerably improves
the accuracy of the trained parsers.
Our algorithm computes a dynamic oracle using
dynamic programming to explore a forest of depend-
ency trees that can be reached from a given parser
configuration. For the arc-standard parser, the com-
putation takes cubic time in the size of the largest of
the left and right input stacks. Dynamic program-
ming for the simulation of arc-standard parsers have
been proposed by Kuhlmann et al. (2011). That al-
gorithm could be adapted to compute minimum loss
for a given configuration, but the running time is
O(n4), n the size of the input string: besides being
asymptotically slower by one order of magnitude, in
practice n is also larger than the stack size above.
Acknowledgments We wish to thank the anonym-
ous reviewers. In particular, we are indebted to one
of them for two important technical remarks. The
third author has been partially supported by MIUR
under project PRIN No. 2010LYA9RH 006.
129
References
Marie-Catherine De Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed de-
pendency parses from phrase structure parses. In Pro-
ceedings of the 5th International Conference on Lan-
guage Resources and Evaluation (LREC), volume 6,
pages 449?454.
Yoav Goldberg and Joakim Nivre. 2012. A dynamic or-
acle for arc-eager dependency parsing. In Proc. of the
24th COLING, Mumbai, India.
Yoav Goldberg and Joakim Nivre. 2013. Training
deterministic parsers with non-deterministic oracles.
Transactions of the association for Computational
Linguistics, 1.
John E. Hopcroft and Jeffrey D. Ullman. 1979. Intro-
duction to Automata Theory, Languages and Compu-
tation. Addison-Wesley, Reading, MA.
Liang Huang and Kenji Sagae. 2010. Dynamic program-
ming for linear-time incremental parsing. In Proceed-
ings of the 48th Annual Meeting of the Association for
Computational Linguistics, July.
Marco Kuhlmann, Carlos Go?mez-Rodr??guez, and Gior-
gio Satta. 2011. Dynamic programming algorithms
for transition-based dependency parsers. In Proceed-
ings of the 49th Annual Meeting of the Association for
Computational Linguistics: Human Language Techno-
logies, pages 673?682, Portland, Oregon, USA, June.
Association for Computational Linguistics.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a large annotated cor-
pus of english: The penn treebank. Computational
Linguistics, 19(2):313?330.
Joakim Nivre, Johan Hall, Sandra Ku?bler, Ryan McDon-
ald, Jens Nilsson, Sebastian Riedel, and Deniz Yuret.
2007. The CoNLL 2007 shared task on dependency
parsing. In Proceedings of EMNLP-CoNLL.
Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
Eighth International Workshop on Parsing Technolo-
gies (IWPT), pages 149?160, Nancy, France.
Joakim Nivre. 2004. Incrementality in deterministic de-
pendency parsing. In Workshop on Incremental Pars-
ing: Bringing Engineering and Cognition Together,
pages 50?57, Barcelona, Spain.
Joakim Nivre. 2008. Algorithms for deterministic incre-
mental dependency parsing. Computational Linguist-
ics, 34(4):513?553.
Francesco Sartorio, Giorgio Satta, and Joakim Nivre.
2013. A transition-based dependency parser using a
dynamic parsing strategy. In Proceedings of the 51st
Annual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 135?144,
Sofia, Bulgaria, August. Association for Computa-
tional Linguistics.
Yue Zhang and Stephen Clark. 2008. A tale of two
parsers: Investigating and combining graph-based and
transition-based dependency parsing. In Proceedings
of EMNLP.
130
