Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning, pages 523?534, Jeju Island, Korea, 12?14 July 2012. c?2012 Association for Computational Linguistics
Open Language Learning for Information Extraction
Mausam, Michael Schmitz, Robert Bart, Stephen Soderland, and Oren Etzioni
Turing Center
Department of Computer Science and Engineering
University of Washington, Seattle
{mausam,schmmd,rbart,soderlan,etzioni}@cs.washington.edu
Abstract
Open Information Extraction (IE) systems ex-
tract relational tuples from text, without re-
quiring a pre-specified vocabulary, by iden-
tifying relation phrases and associated argu-
ments in arbitrary sentences. However, state-
of-the-art Open IE systems such as REVERB
and WOE share two important weaknesses ?
(1) they extract only relations that are medi-
ated by verbs, and (2) they ignore context,
thus extracting tuples that are not asserted as
factual. This paper presents OLLIE, a sub-
stantially improved Open IE system that ad-
dresses both these limitations. First, OLLIE
achieves high yield by extracting relations me-
diated by nouns, adjectives, and more. Sec-
ond, a context-analysis step increases preci-
sion by including contextual information from
the sentence in the extractions. OLLIE obtains
2.7 times the area under precision-yield curve
(AUC) compared to REVERB and 1.9 times
the AUC of WOEparse.
1 Introduction
While traditional Information Extraction (IE)
(ARPA, 1991; ARPA, 1998) focused on identifying
and extracting specific relations of interest, there
has been great interest in scaling IE to a broader
set of relations and to far larger corpora (Banko et
al., 2007; Hoffmann et al2010; Mintz et al2009;
Carlson et al2010; Fader et al2011). However,
the requirement of having pre-specified relations of
interest is a significant obstacle. Imagine an intel-
ligence analyst who recently acquired a terrorist?s
laptop or a news reader who wishes to keep abreast
of important events. The substantial endeavor in
1. ?After winning the Superbowl, the Saints are now
the top dogs of the NFL.?
O: (the Saints; win; the Superbowl)
2. ?There are plenty of taxis available at Bali airport.?
O: (taxis; be available at; Bali airport)
3. ?Microsoft co-founder Bill Gates spoke at ...?
O: (Bill Gates; be co-founder of; Microsoft)
4. ?Early astronomers believed that the earth is the
center of the universe.?
R: (the earth; be the center of; the universe)
W: (the earth; be; the center of the universe)
O: ((the earth; be the center of; the universe)
AttributedTo believe; Early astronomers)
5. ?If he wins five key states, Romney will be elected
President.?
R,W: (Romney; will be elected; President)
O: ((Romney; will be elected; President)
ClausalModifier if; he wins five key states)
Figure 1: OLLIE (O) has a wider syntactic range and finds
extractions for the first three sentences where REVERB
(R) and WOEparse (W) find none. For sentences #4,5,
REVERB and WOEparse have an incorrect extraction by
ignoring the context that OLLIE explicitly represents.
analyzing their corpus is the discovery of important
relations, which are likely not pre-specified. Open
IE (Banko et al2007) is the state-of-the-art
approach for such scenarios.
However, the state-of-the-art Open IE systems,
REVERB (Fader et al2011; Etzioni et al2011)
and WOEparse (Wu and Weld, 2010) suffer from two
key drawbacks. Firstly, they handle a limited sub-
set of sentence constructions for expressing relation-
ships. Both extract only relations that are mediated
by verbs, and REVERB further restricts this to a sub-
set of verbal patterns. This misses important infor-
mation mediated via other syntactic entities such as
nouns and adjectives, as well as a wider range of
verbal structures (examples #1-3 in Figure 1).
523
Secondly, REVERB and WOEparse perform only
a local analysis of a sentence, so they often extract
relations that are not asserted as factual in the sen-
tence (examples #4,5). This often occurs when the
relation is within a belief, attribution, hypothetical
or other conditional context.
In this paper we present OLLIE (Open Language
Learning for Information Extraction), 1 our novel
Open IE system that overcomes the limitations of
previous Open IE by (1) expanding the syntactic
scope of relation phrases to cover a much larger
number of relation expressions, and (2) expand-
ing the Open IE representation to allow additional
context information such as attribution and clausal
modifiers. OLLIE extractions obtain a dramatically
higher yield at higher or comparable precision rela-
tive to existing systems.
The outline of the paper is as follows. First, we
provide background on Open IE and how it relates
to Semantic Role Labeling (SRL). Section 3 de-
scribes the syntactic scope expansion component,
which is based on a novel approach that learns open
pattern templates. These are relation-independent
dependency parse-tree patterns that are automati-
cally learned using a novel bootstrapped training set.
Section 4 discusses the context analysis component,
which is based on supervised training with linguistic
and lexical features.
Section 5 compares OLLIE with REVERB and
WOEparse on a dataset from three domains: News,
Wikipedia, and a Biology textbook. We find that
OLLIE obtains 2.7 times the area in precision-yield
curves (AUC) as REVERB and 1.9 times the AUC
as WOEparse. Moreover, for specific relations com-
monly mediated by nouns (e.g., ?is the president
of?) OLLIE obtains two order of magnitude higher
yield. We also compare OLLIE to a state-of-the-art
SRL system (Johansson and Nugues, 2008) on an
IE-related end task and find that they both have com-
parable performance at argument identification and
have complimentary strengths in sentence analysis.
In Section 6 we discuss related work on pattern-
based relation extraction.
2 Background
Open IE systems extract tuples consisting of argu-
ment phrases from the input sentence and a phrase
1Available for download at http://openie.cs.washington.edu
from the sentence that expresses a relation between
the arguments, in the format (arg1; rel; arg2). This is
done without a pre-specified set of relations and with
no domain-specific knowledge engineering. We
compare OLLIE to two state-of-the-art Open IE sys-
tems: (1) REVERB (Fader et al2011), which
uses shallow syntactic processing to identify rela-
tion phrases that begin with a verb and occur be-
tween the argument phrases;2 (2) WOEparse (Wu
and Weld, 2010), which uses bootstrapping from en-
tries in Wikipedia info-boxes to learn extraction pat-
terns in dependency parses. Like REVERB, the
relation phrases begin with verbs, but can handle
long-range dependencies and relation phrases that
do not come between the arguments. Unlike RE-
VERB, WOE does not include nouns within the re-
lation phrases (e.g., cannot represent ?is the presi-
dent of? relation phrase). Both systems ignore con-
text around the extracted relations that may indi-
cate whether it is a supposition or conditionally true
rather than asserted as factual (see #4-5 in Figure 1).
The task of Semantic role labeling is to identify
arguments of verbs in a sentence, and then to clas-
sify the arguments by mapping the verb to a se-
mantic frame and mapping the argument phrases to
roles in that frame, such as agent, patient, instru-
ment, or benefactive. SRL systems can also identify
and classify arguments of relations that are mediated
by nouns when trained on NomBank annotations.
Where SRL begins with a verb or noun and then
looks for arguments that play roles with respect to
that verb or noun, Open IE looks for a phrase that ex-
presses a relation between a pair of arguments. That
phrase is often more than simply a single verb, such
as the phrase ?plays a role in?, or ?is the CEO of?.
3 Relational Extraction in OLLIE
Figure 2 illustrates OLLIE?s architecture for learning
and applying binary extraction patterns. First, it uses
a set of high precision seed tuples from REVERB to
bootstrap a large training set. Second, it learns open
pattern templates over this training set. Next, OLLIE
applies these pattern templates at extraction time.
This section describes these three steps in detail. Fi-
nally, OLLIE analyzes the context around the tuple
(Section 4) to add information (attribution, clausal
modifiers) and a confidence function.
2Available for download at http://reverb.cs.washington.edu/
524
ReVerb 
Seed Tuples 
Training Data 
Open Pattern Learning Bootstrapper 
Pattern Templates 
Pattern Matching Context Analysis Sentence Tuples Ext. Tuples 
Extraction 
Learning 
Figure 2: System architecture: OLLIE begins with seed
tuples from REVERB, uses them to build a bootstrap
training set, and learns open pattern templates. These are
applied to individual sentences at extraction time.
3.1 Constructing a Bootstrapping Set
Our goal is to automatically create a large training
set, which encapsulates the multitudes of ways in
which information is expressed in text. The key ob-
servation is that almost every relation can also be ex-
pressed via a REVERB-style verb-based expression.
So, bootstrapping sentences based on REVERB?s tu-
ples will likely capture all relation expressions.
We start with over 110,000 seed tuples ? these are
high confidence REVERB extractions from a large
Web corpus (ClueWeb)3 that are asserted at least
twice and contain only proper nouns in the argu-
ments. These restrictions reduce ambiguity while
still covering a broad range of relations. For ex-
ample, a seed tuple may be (Paul Annacone; is the
coach of; Federer) that REVERB extracts from the
sentence ?Paul Annacone is the coach of Federer.?
For each seed tuple, we retrieve all sentences in a
Web corpus that contains all content words in the
tuple. We obtain a total of 18 million sentences.
For our example, we will retrieve all sentences that
contain ?Federer?, ?Paul?, ?Annacone? and some syn-
tactic variation of ?coach?. We may find sentences
like ?Now coached by Annacone, Federer is win-
ning more titles than ever.?
Our bootstrapping hypothesis assumes that all
these sentences express the information of the orig-
inal seed tuple. This hypothesis is not always true.
As an example, for a seed tuple (Boyle; is born in;
Ireland) we may retrieve a sentence ?Felix G. Whar-
ton was born in Donegal, in the northwest of Ireland,
a county where the Boyles did their schooling.?
3http://lemurproject.org/clueweb09.php/
To reduce bootstrapping errors we enforce addi-
tional dependency restrictions on the sentences. We
only allow sentences where the content words from
arguments and relation can be linked to each other
via a linear path of size four in the dependency parse.
To implement this restriction, we only use the sub-
set of content words that are headwords in the parse
tree. In the above sentence ?Ireland?, ?Boyle? and
?born? connect via a dependency path of length six,
and hence this sentence is rejected from the training
set. This reduces our set to 4 million (seed tuple,
sentence) pairs.
In our implementation, we use Malt Dependency
Parser (Nivre and Nilsson, 2004) for dependency
parsing, since it is fast and hence, easily applica-
ble to a large corpus of sentences. We post-process
the parses using Stanford?s CCprocessed algorithm,
which compacts the parse structure for easier extrac-
tion (de Marneffe et al2006).
We randomly sampled 100 sentences from our
bootstrapping set and found that 90 of them sat-
isfy our bootstrapping hypothesis (64 without de-
pendency constraints). We find this quality to be sat-
isfactory for our needs of learning general patterns.
Bootstrapped data has been previously used to
generate positive training data for IE (Hoffmann et
al., 2010; Mintz et al2009). However, previous
systems retrieved sentences that only matched the
two arguments, which is error-prone, since multiple
relations can hold between a pair of entities (e.g.,
Bill Gates is the CEO of, a co-founder of, and has a
high stake in Microsoft).
Alternatively, researchers have developed sophis-
ticated probabilistic models to alleviate the effect
of noisy data (Riedel et al2010; Hoffmann et al
2011). In our case, by enforcing that a sentence ad-
ditionally contains some syntactic form of the rela-
tion content words, our bootstrapping set is naturally
much cleaner.
Moreover, this form of bootstrapping is better
suited for Open IE?s needs, as we will use this data
to generalize to other unseen relations. Since the
relation words in the sentence and seed match, we
can learn general pattern templates that may apply
to other relations too. We discuss this process next.
3.2 Open Pattern Learning
OLLIE?s next step is to learn general patterns that
encode various ways of expressing relations. OL-
525
Extraction Template Open Pattern
1. (arg1; be {rel} {prep}; arg2) {arg1} ?nsubjpass? {rel:postag=VBN} ?{prep ?}? {arg2}
2. (arg1; {rel}; arg2) {arg1} ?nsubj? {rel:postag=VBD} ?dobj? {arg2}
3. (arg1; be {rel} by; arg2) {arg1} ?nsubjpass? {rel:postag=VBN} ?agent? {arg2}
4. (arg1; be {rel} of; arg2) {rel:postag=NN;type=Person} ?nn? {arg1} ?nn? {arg2}
5. (arg1; be {rel} {prep}; arg2) {arg1} ?nsubjpass? {slot:postag=VBN;lex ?announce|name|choose...}
?dobj? {rel:postag=NN} ?{prep ?}? {arg2}
Figure 3: Sample open pattern templates. Notice that some patterns (1-3) are purely syntactic, and others are seman-
tic/lexically constrained (in bold font). A dependency parse that matches pattern #1 is shown in Figure 4.
LIE learns open pattern templates ? a mapping from
a dependency path to an open extraction, i.e., one
that identifies both the arguments and the exact
(REVERB-style) relation phrase. Figure 3 gives ex-
amples of high-frequency pattern templates learned
by OLLIE. Note that some of the dependency
paths are completely unlexicalized (#1-3), whereas
in other cases some nodes have lexical or semantic
restrictions (#4, 5).
Open pattern templates encode the ways in
which a relation (in the first column) may
be expressed in a sentence (second column).
For example, a relation (Godse; kill; Gandhi)
may be expressed with a dependency path (#2)
{Godse}?nsubj?{kill:postag=VBD}?dobj?{Gandhi}.
To learn the pattern templates, we first extract the
dependency path connecting the arguments and re-
lation words for each seed tuple and the associated
sentence. We annotate the relation node in the path
with the exact relation word (as a lexical constraint)
and the POS (postag constraint). We create a re-
lation template from the seed tuple by normalizing
?is?/?was?/?will be? to ?be?, and replacing the rela-
tion content word with {rel}.4
If the dependency path has a node that is not part
of the seed tuple, we call it a slot node. Intuitively,
if slot words do not negate the tuple they can be
skipped over. As an example, ?hired? is a slot word
for the tuple (Annacone; is the coach of; Federer) in
the sentence ?Federer hired Annacone as a coach?.
We associate postag and lexical constraints with the
slot node as well. (see #5 in Figure 3).
Next, we perform several syntactic checks on
each candidate pattern. These checks are the con-
straints that we found to hold in very general pat-
terns, which we can safely generalize to other un-
seen relations. The checks are: (1) There are no slot
4Our current implementation only allows a single relation
content word; extending to multiple words is straightforward ?
the templates will require rel1, rel2,. . .
nodes in the path. (2) The relation node is in the
middle of arg1 and arg2. (3) The preposition edge
(if any) in the pattern matches the preposition in the
relation. (4) The path has no nn or amod edges.
If the checks hold true we accept it as a purely
syntactic pattern with no lexical constraints. Oth-
ers are semantic/lexical patterns and require further
constraints to be reliable as extraction patterns.
3.2.1 Purely Syntactic Patterns
For syntactic patterns, we aggressively general-
ize to unseen relations and prepositions. We remove
all lexical restrictions from the relation nodes. We
convert all preposition edges to an abstract {prep ?}
edge. We also replace the specific prepositions in
extraction templates with {prep}.
As an example, consider the sentences, ?Michael
Webb appeared on Oprah...? and ?...when Alexan-
der the Great advanced to Babylon.? and associ-
ated seed tuples (Michael Webb; appear on; Oprah)
and (Alexander; advance to; Babylon). Both these
data points return the same open pattern after gen-
eralization: ?{arg1} ?nsubj? {rel:postag=VBD}
?{prep ?}? {arg2}? with the extraction template
(arg1, {rel} {prep}, arg2). Other examples of syn-
tactic pattern templates are #1-3 in Figure 3.
3.2.2 Semantic/Lexical Patterns
Patterns that do not satisfy the checks are not as
general as those that do, but are still important. Con-
structions like ?Microsoft co-founder Bill Gates...?
work for some relation words (e.g., founder, CEO,
director, president, etc.) but would not work for
other nouns; for instance, from ?Chicago Symphony
Orchestra? we should not conclude that (Orchestra;
is the Symphony of; Chicago).
Similarly, we may conclude (Annacone; is the
coach of; Federer) from the sentence ?Federer hired
Annacone as a coach.?, but this depends on the se-
mantics of the slot word, ?hired?. If we replaced
526
?hired? by ?fired? or ?considered? then the extraction
would be false.
To enable such patterns we retain the lexical con-
straints on the relation words and slot words.5 We
collect all patterns together based only on the syn-
tactic restrictions and convert the lexical constraint
into a list of words with which the pattern was seen.
Example #5 in Figure 3 shows one such lexical list.
Can we generalize these lexically-annotated pat-
terns further? Our insight is that we can generalize
a list of lexical items to other similar words. For
example, if we see a list like {CEO, director, presi-
dent, founder}, then we should be able to generalize
to ?chairman? or ?minister?.
Several ways to compute semantically similar
words have been suggested in the literature like
Wordnet-based, distributional similarity, etc. (e.g.,
(Resnik, 1996; Dagan et al1999; Ritter et al
2010)). For our proof of concept, we use a simple
overlap metric with two important Wordnet classes
? Person and Location. We generalize to these types
when our list has a high overlap (> 75%) with hy-
ponyms of these classes. If not, we simply retain the
original lexical list without generalization. Example
#4 in Figure 3 is a type-generalized pattern.
We combine all syntactic and semantic patterns
and sort in descending order based on frequency of
occurrence in the training set. This imposes a natural
ranking on the patterns ? more frequent patterns are
likely to give higher precision extractions.
3.3 Pattern Matching for Extraction
We now describe how these open patterns are used
to extract binary relations from a new sentence. We
first match the open patterns with the dependency
parse of the sentence and identify the base nodes for
arguments and relations. We then expand these to
convey all the information relevant to the extraction.
As an example, consider the sentence: ?I learned
that the 2012 Sasquatch music festival is scheduled
for May 25th until May 28th.? Figure 4 illustrates the
dependency parse. To apply pattern #1 from Figure
3 we first match arg1 to ?festival?, rel to ?scheduled?
and arg2 to ?25th? with prep ?for?. However, (festi-
val, be scheduled for, 25th) is not a very meaningful
extraction. We need to expand this further.
5For highest precision extractions, we may also need seman-
tic constraints on the arguments. In this work, we increase our
yield by ignoring the argument-type constraints.
learned_VBD 
I_PRP scheduled_VBN 
that_IN festival_NN is_VBZ 25th_NNP 28th_NNP 
the_DET Sasquatch_NNP music_NN May_NNP_11 May_NNP_14 2012_CD 
nsubj ccomp 
complm nsubjpass auxpass prep_for prep_until 
det num nn nn nn nn 
Figure 4: A sample dependency parse. The col-
ored/greyed nodes represent all words that are extracted
from the pattern {arg1} ?nsubjpass? {rel:postag=VBN}
?{prep ?}? {arg2}. The extraction is (the 2012
Sasquatch Music Festival; is scheduled for; May 25th).
For the arguments we expand on amod, nn, det,
neg, prep of, num, quantmod edges to build the
noun-phrase. When the base noun is not a proper
noun, we also expand on rcmod, infmod, partmod,
ref, prepc of edges, since these are relative clauses
that convey important information. For relation
phrases, we expand on advmod, mod, aux, auxpass,
cop, prt edges. We also include dobj and iobj in the
case that they are not in an argument. After identi-
fying the words in arg/relation we choose their order
as in the original sentence. For example, these rules
will result in the extraction (the Sasquatch music fes-
tival; be scheduled for; May 25th).
3.4 Comparison with WOEparse
OLLIE?s algorithm is similar to that of WOEparse
? both systems follow the basic structure of boot-
strap learning of patterns based on dependency parse
paths. However, there are three significant differ-
ences. WOE uses Wikipedia-based bootstrapping,
finding a sentence in a Wikipedia article that con-
tains the infobox values. Since WOE does not have
access to a seed relation phrase, it heuristically as-
signs all intervening words between the arguments
in the parse as the relation phrase. This often results
in under-specified or nonsensical relation phrases.
For example, from the sentence ?David Miscavige
learned that after Tom Cruise divorced Mimi Rogers,
he was pursuing Nicole Kidman.? WOE?s heuristics
will extract the relation divorced was pursuing be-
tween ?Tom Cruise? and ?Nicole Kidman?. OLLIE,
in contrast, produces well-formed relation phrases
by basing its templates on REVERB relation phrases.
Secondly, WOE does not assign semantic/lexical
restrictions to its patterns, and thus, has lower preci-
sion due to aggressive syntactic generalization. Fi-
nally, WOE is designed to have verb-mediated rela-
527
tion phrases that do not include nouns, thus missing
important relations such as ?is the president of?. In
our experiments (see Figure 5) we find WOEparse to
have lower precision and yield than OLLIE.
4 Context Analysis in OLLIE
We now turn to the context analysis component,
which handles the problem of extractions that are not
asserted as factual in the text. In some cases, OLLIE
can handle this by extending the tuple representation
with an extra field that turns an otherwise incorrect
tuple into a correct one. In other cases, there is no re-
liable way to salvage the extraction, and OLLIE can
avoid an error by giving the tuple a low confidence.
Cases where OLLIE extends the tuple representa-
tion include conditional truth and attribution. Con-
sider sentence #4 in Figure 1. It is not asserting that
the earth is the center of the universe. OLLIE adds
an AttributedTo field, which makes the final extrac-
tion valid (see OLLIE extraction in Figure 1). This
field indicates who said, suggested, believes, hopes,
or doubts the information in the main extraction.
Another case is when the extraction is only condi-
tionally true. Sentence #5 in Figure 1 does not assert
as factual that (Romney; will be elected; President),
so it is an incorrect extraction. However, adding
a condition (?if he wins five states?) can turn this
into a correct extraction. We extend OLLIE to have
a ClausalModifier field when there is a dependent
clause that modifies the main extraction.
Our approach for extracting these additional fields
makes use of the dependency parse structure. We
find that attributions are marked by a ccomp (clausal
complement) edge. For example, in the parse of sen-
tence #4 there is a ccomp edge between ?believe?
and ?center?. Our algorithm first checks for the pres-
ence of a ccomp edge to the relation node. However,
not all ccomp edges are attributions. We match the
context verb (e.g., ?believe?) with a list of commu-
nication and cognition verbs from VerbNet (Schuler,
2006) to detect attributions. The context verb and its
subject then populate the AttributedTo field.
Similarly, the clausal modifiers are marked by ad-
vcl (adverbial clause) edge. We filter these lexically,
and add a ClausalModifier field when the first word
of the clause matches a list of 16 terms created using
a training set: {if, when, although, because, ...}.
OLLIE has high precision for AttributedTo and
ClausalModifier fields, nearly 98% on a develop-
ment set, however, these two fields do not cover all
the cases where an extraction is not asserted as fac-
tual. To handle others, we train OLLIE?s confidence
function to reduce the confidence of an extraction if
its context indicates it is likely to be non-factual.
We use a supervised logistic regression classifier
for the confidence function. Features include the
frequency of the extraction pattern, the presence of
AttributedTo or ClausalModifier fields, and the po-
sition of certain words in the extraction?s context,
such as function words or the communication and
cognition verbs used for the AttributedTo field. For
example, one highly predictive feature tests whether
or not the word ?if? comes before the extraction
when no ClausalModifier fields are attached. Our
training set was 1000 extractions drawn evenly from
Wikipedia, News, and Biology sentences.
5 Experiments
Our experiments evaluate three main questions. (1)
How does OLLIE?s performance compare with exis-
ting state-of-the-art open extractors? (2) What are
the contributions of the different sub-components
within OLLIE? (3) How do OLLIE?s extractions com-
pare with semantic role labeling argument identifi-
cation?
5.1 Comparison of Open IE Systems
Since Open IE is designed to handle a variety of
domains, we create a dataset of 300 random sen-
tences from three sources: News, Wikipedia and Bi-
ology textbook. The News and Wikipedia test sets
are a random subset of Wu and Weld?s test set for
WOEparse. We ran three systems, OLLIE, REVERB
and WOEparse on this dataset resulting in a total of
1,945 extractions from all three systems. Two an-
notators tagged the extractions as correct if the sen-
tence asserted or implied that the relation was true.
Inter-annotator agreement was 0.96, and we retained
the subset of extractions on which the two annotators
agree for further analysis.
All systems associate a confidence value with an
extraction ? ranking with these confidence values
generates a precision-yield curve for this dataset.
Figure 5 reports the curves for the three systems.
We find that OLLIE has a higher performance, ow-
ing primarily to its higher yield at comparable preci-
528
0.5  
0.6  
0.7  
0.8  
0.9  
1  
0  100  200  300  400  500  600  
OLLIE  
ReVerb 
WOE  
Yield 
Pre
cis
ion
 
parse 
Figure 5: Comparison of different Open IE systems. OL-
LIE achieves substantially larger area under the curve
than other Open IE systems.
sion. OLLIE finds 4.4 times more correct extractions
than REVERB and 4.8 times more than WOEparse at
a precision of about 0.75. Overall, OLLIE has 2.7
times larger area under the curve than REVERB and
1.9 times larger than WOEparse.6 We use the Boot-
strap test (Cohen, 1995) to find that OLLIE?s better
performance compared to the two systems is highly
statistically significant.
We perform further analysis to understand the rea-
sons behind the high yield from OLLIE. We find that
40% of the OLLIE extractions that REVERB misses
are due to OLLIE?s use of parsers ? REVERB misses
those because its shallow syntactic analysis cannot
skip over the intervening clauses or prepositional
phrases between the relation phrase and the argu-
ments. About 30% of the additional yield is those
extractions where the relation is not between its ar-
guments (see instance #1 in Figure 1). The rest are
due to other causes such as OLLIE?s ability to handle
relationships mediated by nouns and adjectives, or
REVERB?s shallow syntactic analysis, etc. In con-
trast, OLLIE misses very few extractions returned by
REVERB, mostly due to parser errors.
We find that WOEparse misses extractions found
by OLLIE for a variety of reasons. The primary
cause is that WOEparse does not include nouns in re-
lation phrases. It also misses some verb-based pat-
terns, probably due to training noise. In other cases,
WOEparse misses extractions due to ill-formed rela-
tion phrases (as in the example of Section 3.4: ?di-
vorced was pursuing? instead of the correct relation
?was pursuing?).
While the bulk of OLLIE?s extractions in our test
6Evaluating recall is difficult at this scale ? however, since
yield is proportional to recall, the area differences also hold for
the equivalent precision-recall curves.
Relation OLLIE REVERB incr.
is capital of 8,566 146 59x
is president of 21,306 1,970 11x
is professor at 8,334 400 21x
is scientist of 730 5 146x
Figure 6: OLLIE finds many more correct extractions for
relations that are typically expressed by noun phrases ?
up to 146 times that of REVERB. WOEparse outputs no
instances of these, because it does not allow nouns in the
relation. These results are at point of maximum yield
(with comparable precisions around 0.66).
set were verb-mediated, our intuition suggests that
there exist many relationships that are most natu-
rally expressed via noun phrases. To demonstrate
this effect, we chose four such relations ? is capi-
tal of, is president of, is professor at, and is scientist
of. We ran our systems on 100 million random sen-
tences from the ClueWeb corpus. Figure 6 reports
the yields of these four relations.7
OLLIE found up to 146 times as many extrac-
tions for these relations than REVERB. Because
WOEparse does not include nouns in relation phrases,
it is unable to extract any instance of these relations.
We examine a sample of the extractions to verify that
noun-mediated extractions are the main reason for
this large yield boost over REVERB (73% of OLLIE
extractions were noun-mediated). High-frequency
noun patterns like ?Obama, the president of the US?,
?Obama, the US president?, ?US President Obama?
far outnumber sentences of the form ?Obama is the
president of the US?. These relations are seldom the
primary information in a sentence, and are typically
mentioned in passing in noun phrases that express
the relation.
For some applications, noun-mediated relations
are important, as they associate people with work
places and job titles. Overall, we think of the results
in Figure 6 as a ?best case analysis? that illustrates
the dramatic increase in yield for certain relations,
due to syntactic scope expansion in Open IE.
5.2 Analysis of OLLIE
We perform two control experiments to understand
the value of semantic/lexical restrictions in pattern
learning and precision boost due to context analysis
component.
7We multiply the total number of extractions with precision
on a sample for that relation to estimate the yield.
529
0  
0.2  
0.4  
0.6  
0.8  
1  
0  10  20  30  40  50  60  
OLLIE  
OLLIE[Lex]  
OLLIE[syn]  
Yield 
Pre
cis
ion
 
Figure 7: Results on the subset of extractions from pat-
terns with semantic/lexical restrictions. Ablation study
on patterns with semantic/lexical restrictions. These pat-
terns without restrictions (OLLIE[syn]) result in low pre-
cision. Type generalization improves yield compared to
patterns with only lexical constraints (OLLIE[lex]).
Are semantic restrictions important for open pat-
tern learning? How much does type generalization
help? To answer these questions we compare three
systems ? OLLIE without semantic or lexical restric-
tions (OLLIE[syn]), OLLIE with lexical restrictions
but no type generalization (OLLIE[lex]) and the full
system (OLLIE). We restrict this experiment to the
patterns where OLLIE adds semantic/lexical restric-
tions, rather than dilute the result with patterns that
would be unchanged by these variants.
Figure 7 shows the results of this experiment on
our dataset from three domains. As the curves
show, OLLIE was correct to add lexical/semantic
constraints to these patterns ? precision is quite low
without the restrictions. This matches our intuition,
since these are not completely general patterns and
generalizing to all unseen relations results in a large
number of errors. OLLIE[lex] performs well though
at lower yield. The type generalization helps the
yield somewhat, without hurting the precision. We
believe that a more data-driven type generalization
that uses distributional similarity (e.g., (Ritter et al
2010)) may help much more. Also, notice that over-
all precision numbers are lower, since these are the
more difficult relations to extract reliably. We con-
clude that lexical/semantic restrictions are valuable
for good performance of OLLIE.
We also compare our full system to a version that
does not use the context analysis of Section 4. Fig-
ure 8 compares OLLIE to a version (OLLIE[pat]) that
does not add the AttributedTo and ClausalModifier
fields, and, instead of context-sensitive confidence
function, uses the pattern frequency in the training
0.5  
0.6  
0.7  
0.8  
0.9  
1  
0  100  200  300  400  500  600  
OLLIE  
OLLIE[pat]  
Yield 
Pre
cis
ion
 
Figure 8: Context analysis increases precision, raising the
area under the curve by 19%.
set as a ranking function. 10% of the sentences have
an OLLIE extraction with ClausalModifier and 6%
have AttributedTo fields. Adding ClausalModifier
corrects errors for 21% of extractions that have a
ClausalModifier and does not introduce any new er-
rors. Adding AttributedTo corrects errors for 55%
of the extractions with AttributedTo and introduces
an error for 3% of the extractions. Overall, we find
that OLLIE gives a significant boost to precision over
OLLIE[pat] and obtains 19% additional AUC.
Finally, we analyze the errors made by OLLIE.
Unsurprisingly, because of OLLIE?s heavy reliance
on the parsers, parser errors account for a large part
of OLLIE?s errors (32%). 18% of the errors are due
to aggressive generalization of a pattern to all un-
seen relations and 12% due to incorrect application
of lexically annotated patterns. About 14% of the er-
rors are due to important context missed by OLLIE.
Another 12% of the errors are because of the limita-
tions of binary representation, which misses impor-
tant information that can only be expressed in n-ary
tuples.
We believe that as parsers become more robust
OLLIE?s performance will improve even further. The
presence of context-related errors suggests that there
is more to investigate in context analysis. Finally, in
the future we wish to extend the representation to
include n-ary extractions.
5.3 Comparison with SRL
Our final evaluation suggests answers to two im-
portant questions. First, how does a state-of-the-art
Open IE system do in terms of absolute recall? Sec-
ond, how do Open IE systems compare against state-
of-the-art SRL systems?
SRL, as discussed in Section 2, has a very dif-
ferent goal ? analyzing verbs and nouns to identify
530
their arguments, then mapping the verb or noun to
a semantic frame and determining the role that each
argument plays in that frame. These verbs and nouns
need not make the full relation phrase, although, re-
cent work has shown that they may be converted
to Open IE style extractions with additional post-
processing (Christensen et al2011).
While a direct comparison between OLLIE and
a full SRL system is problematic, we can compare
performance of OLLIE and the argument identifica-
tion step of an SRL system. We set each system the
following task ? ?based on a sentence, find all noun-
pairs that have an asserted relationship.? This task is
permissive for both systems, as it does not require
finding an exact relation phrase or argument bound-
ary, or determining the argument roles in a relation.
We create a gold standard by tagging a random
50 sentences of our test set to identify all pairs of
NPs that have an asserted relation. We only counted
relation expressed by a verb or noun in the text, and
did not include relations expressed simply with ?of?
or apostrophe-s. Where a verb mediates between an
argument and multiple NPs, we represent this as a
binary relation for all pairs of NPs.
For example the sentence, ?Macromolecules
translocated through the phloem include proteins
and various types of RNA that enter the sieve tubes
through plasmodesmata.? has five binary relations.
arg1: arg2: relation term
Macromolecules phloem translocated
Macromolecules proteins include
Macromolecules types of RNA include
types of RNA sieve tubes enter
types of RNA plasmodesmata enter
We find an average of 4.0 verb-mediated relations
and 0.3 noun-mediated relations per sentence. Eval-
uating OLLIE against this gold standard helps to an-
swer the question of absolute recall: what percent-
age of binary relations expressed in a sentence can
our systems identify.
For comparison, we use a state-of-the-art SRL
system from Lund University (Johansson and
Nugues, 2008), which is trained on PropBank
(Martha and Palmer, 2002) for its verb-frames and
NomBank (Meyers et al2004) for noun-frames.
The PropBank version of the system won the very
competitive 2008 CONLL SRL evaluation.
We conduct this experiment by manually compar-
LUND OLLIE union
Verb relations 0.58 (0.69) 0.49 (0.55) 0.71 (0.83)
Noun relations 0.07 (0.33) 0.13 (0.13) 0.20 (0.33)
All relations 0.54 (0.67) 0.47 (0.52) 0.67 (0.80)
Figure 9: Recall of LUND and OLLIE on binary relations.
In parentheses is recall with oracle co-reference. Both
systems identify approximately half of all argument pairs,
but have lower recall on noun-mediated relations.
ing the outputs of LUND and OLLIE against the gold
standard. For each pair of NPs in the gold standard
we determine whether the systems find a relation
with that pair of NPs as arguments. Recall is based
on the percentage of NP pairs where the head nouns
matches head nouns of two different arguments in an
extraction or semantic frame. If the argument value
is conjunctive, we count a match against the head
noun of each item in the list. We also count cases
where system output would match the gold standard,
given perfect co-reference.
Figure 9 shows the recall for OLLIE and LUND,
with recall based on oracle co-referential matches
in parentheses. Our analysis shows strong recall
for both systems for verb-mediated relations: LUND
finding about two thirds of the argument pairs and
OLLIE finding over half. Both systems have low
recall for noun-mediated relations, with most of
LUND?s recall requiring co-reference. We observe
that a union of the two systems raises recall to
0.71 for verb-mediated relations and 0.83 with co-
reference, demonstrating that each system is identi-
fying argument pairs that the other missed.
It is not surprising that OLLIE has recall of ap-
proximately 0.5, since it is tuned for high precision
extraction, and avoids less reliable extractions from
constructions such as reduced relative clauses and
gerunds, or from noun-mediated relations with long-
range dependencies. In contrast, SRL is tuned to
identify the argument structure for nearly all verbs
and nouns in a sentence. The missing recall from
SRL is primarily where it does not identify both ar-
guments of a binary relation, or where the correct
argument is buried in a long argument phrase, but is
not its head noun.
It is surprising that LUND, trained on Nom-
Bank, identifies so few noun-mediated argument
pairs without co-reference. An example will make
this clear. For the sentence, ?Clarcor, a maker of
packaging and filtration products, said ...?, the tar-
531
get relation is between Clarcor and the products it
makes. LUND identifies a frame maker.01 in which
argument A0 has head noun ?maker? and A1 is a PP
headed by ?products?, missing the actual name of the
maker without co-reference post-processing. OLLIE
finds the extraction (Clarcor; be a maker of; packag-
ing and filtration products) where the heads of both
arguments matched those of the target. In another
example, LUND identifies ?his? and ?brother? as the
arguments of the frame brother.01, rather than the
actual names of the two brothers.
We can draw several conclusions from this exper-
iment. First, nouns, although less frequently mediat-
ing relations, are much harder and both systems are
failing significantly on those ? OLLIE is somewhat
better. Two, neither systems dominates the other;
in fact, recall is increased significantly by a union
of the two. Three, and probably most importantly,
significant information is still being missed by both
systems, and more research is warranted.
6 Related Work
There is a long history of bootstrapping and pat-
tern learning approaches in traditional informa-
tion extraction, e.g., DIPRE (Brin, 1998), Snow-
Ball (Agichtein and Gravano, 2000), Espresso (Pan-
tel and Pennacchiotti, 2006), PORE (Wang et al
2007), SOFIE (Suchanek et al2009), NELL (Carl-
son et al2010), and PROSPERA (Nakashole et
al., 2011). All these approaches first bootstrap data
based on seed instances of a relation (or seed data
from existing resources such as Wikipedia) and then
learn lexical or lexico-POS patterns to create an ex-
tractor. Other approaches have extended these to
learning patterns based on full syntactic analysis of
a sentence (Bunescu and Mooney, 2005; Suchanek
et al2006; Zhao and Grishman, 2005).
OLLIE has significant differences from the previ-
ous work in pattern learning. First, and most impor-
tantly, these previous systems learn an extractor for
each relation of interest, whereas OLLIE is an open
extractor. OLLIE?s strength is its ability to gener-
alize from one relation to many other relations that
are expressed in similar forms. This happens both
via syntactic generalization and type generalization
of relation words (sections 3.2.1 and 3.2.2). This ca-
pability is essential as many relations in the test set
are not even seen in the training set ? in early exper-
iments we found that non-generalized pattern learn-
ing (equivalent to traditional IE) had significantly
less yield at a slightly higher precision.
Secondly, previous systems begin with seeds that
consist of a pair of entities, whereas we also in-
clude the content words from REVERB relations in
our training seeds. This results in a much higher
precision bootstrapping set and high rule preci-
sion while still allowing morphological variants that
cover noun-mediated relations. A third difference is
in the scale of the training ? REVERB yields millions
of training seeds, where previous systems had orders
of magnitude less. This enables OLLIE to learn pat-
terns with greater coverage.
The closest to our work is the pattern learning
based open extractor WOEparse. Section 3.4 de-
tails the differences between the two extractors. An-
other extractor, StatSnowBall (Zhu et al2009), has
an Open IE version, which learns general but shal-
low patterns. Preemptive IE (Shinyama and Sekine,
2006) is a paradigm related to Open IE that first
groups documents based on pairwise vector cluster-
ing, then applies additional clustering to group en-
tities based on document clusters. The clustering
steps make it difficult for it to scale to large corpora.
7 Conclusions
Our work describes OLLIE, a novel Open IE ex-
tractor that makes two significant advances over
the existing Open IE systems. First, it expands
the syntactic scope of Open IE systems by identi-
fying relationships mediated by nouns and adjec-
tives. Our experiments found that for some rela-
tions this increases the number of correct extrac-
tions by two orders of magnitude. Second, by an-
alyzing the context around an extraction, OLLIE is
able to identify cases where the relation is not as-
serted as factual, but is hypothetical or conditionally
true. OLLIE increases precision by reducing con-
fidence in those extractions or by associating addi-
tional context in the extractions, in the form of at-
tribution and clausal modifiers. Overall, OLLIE ob-
tains 1.9 to 2.7 times more area under precision-
yield curves compared to existing state-of-the-art
open extractors. OLLIE is available for download at
http://openie.cs.washington.edu.
532
Acknowledgments
This research was supported in part by NSF grant IIS-0803481,
ONR grant N00014-08-1-0431, DARPA contract FA8750-09-
C-0179 and the Intelligence Advanced Research Projects Ac-
tivity (IARPA) via Air Force Research Laboratory (AFRL) con-
tract number FA8650-10-C-7058. The U.S. Government is au-
thorized to reproduce and distribute reprints for Governmen-
tal purposes notwithstanding any copyright annotation thereon.
The views and conclusions contained herein are those of the au-
thors and should not be interpreted as necessarily representing
the official policies or endorsements, either expressed or im-
plied, of IARPA, AFRL, or the U.S. Government. This research
is carried out at the University of Washington?s Turing Center.
We thank Fei Wu and Dan Weld for providing WOE?s code
and Anthony Fader for releasing REVERB?s code. Peter Clark,
Alan Ritter, and Luke Zettlemoyer provided valuable feedback
on the research and Dipanjan Das helped us with state-of-the-
art SRL systems. We also thank the anonymous reviewers for
their comments on an earlier draft.
References
E. Agichtein and L. Gravano. 2000. Snowball: Ex-
tracting relations from large plain-text collections. In
Procs. of the Fifth ACM International Conference on
Digital Libraries.
ARPA. 1991. Proc. 3rd Message Understanding Conf.
Morgan Kaufmann.
ARPA. 1998. Proc. 7th Message Understanding Conf.
Morgan Kaufmann.
M. Banko, M. Cafarella, S. Soderland, M. Broadhead,
and O. Etzioni. 2007. Open information extraction
from the Web. In Procs. of IJCAI.
S. Brin. 1998. Extracting Patterns and Relations from the
World Wide Web. In WebDB Workshop at 6th Interna-
tional Conference on Extending Database Technology,
EDBT?98, pages 172?183, Valencia, Spain.
Razvan C. Bunescu and Raymond J. Mooney. 2005. A
shortest path dependency kernel for relation extrac-
tion. In Proc. of HLT/EMNLP.
Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr
Settles, Estevam R. Hruschka Jr., and Tom M.
Mitchell. 2010. Toward an architecture for never-
ending language learning. In Procs. of AAAI.
Janara Christensen, Mausam, Stephen Soderland, and
Oren Etzioni. 2011. An analysis of open informa-
tion extraction based on semantic role labeling. In
Proceedings of the 6th International Conference on
Knowledge Capture (K-CAP ?11).
Paul R. Cohen. 1995. Empirical Methods for Artificial
Intelligence. MIT Press.
Ido Dagan, Lillian Lee, and Fernando C. N. Pereira.
1999. Similarity-based models of word cooccurrence
probabilities. Machine Learning, 34(1-3):43?69.
Marie-Catherine de Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed de-
pendency parses from phrase structure parses. In Lan-
guage Resources and Evaluation (LREC 2006).
Oren Etzioni, Anthony Fader, Janara Christensen,
Stephen Soderland, and Mausam. 2011. Open infor-
mation extraction: the second generation. In Proceed-
ings of the International Joint Conference on Artificial
Intelligence (IJCAI ?11).
Anthony Fader, Stephen Soderland, and Oren Etzioni.
2011. Identifying relations for open information ex-
traction. In Proceedings of EMNLP.
Raphael Hoffmann, Congle Zhang, and Daniel S. Weld.
2010. Learning 5000 relational extractors. In Pro-
ceedings of the 48th Annual Meeting of the Association
for Computational Linguistics, ACL ?10, pages 286?
295.
Raphael Hoffmann, Congle Zhang, Xiao Ling, Luke S.
Zettlemoyer, and Daniel S. Weld. 2011. Knowledge-
based weak supervision for information extraction of
overlapping relations. In ACL, pages 541?550.
Richard Johansson and Pierre Nugues. 2008. The ef-
fect of syntactic representation on semantic role label-
ing. In Proceedings of the 22nd International Con-
ference on Computational Linguistics (COLING 08),
pages 393?400.
Paul Kingsbury Martha and Martha Palmer. 2002. From
treebank to propbank. In Proceedings of the Third In-
ternational Conference on Language Resources and
Evaluation (LREC 02).
A. Meyers, R. Reeves, C. Macleod, R. Szekely, V. Zielin-
ska, B. Young, and R. Grishman. 2004. Annotating
Noun Argument Structure for NomBank. In Proceed-
ings of LREC-2004, Lisbon, Portugal.
Mike Mintz, Steven Bills, Rion Snow, and Dan Jurafsky.
2009. Distant supervision for relation extraction with-
out labeled data. In ACL-IJCNLP ?09: Proceedings
of the Joint Conference of the 47th Annual Meeting of
the ACL and the 4th International Joint Conference on
Natural Language Processing of the AFNLP: Volume
2, pages 1003?1011.
Ndapandula Nakashole, Martin Theobald, and Gerhard
Weikum. 2011. Scalable knowledge harvesting with
high precision and high recall. In Proceedings of the
Fourth International Conference on Web Search and
Web Data Mining (WSDM 2011), pages 227?236.
Joakim Nivre and Jens Nilsson. 2004. Memory-based
dependency parsing. In Proceedings of the Conference
on Natural Language Learning (CoNLL-04), pages
49?56.
Patrick Pantel and Marco Pennacchiotti. 2006. Espresso:
Leveraging generic patterns for automatically harvest-
ing semantic relations. In Proceedings of 21st Interna-
tional Conference on Computational Linguistics and
533
44th Annual Meeting of the Association for Computa-
tional Linguistics (ACL?06).
P. Resnik. 1996. Selectional constraints: an information-
theoretic model and its computational realization.
Cognition.
Sebastian Riedel, Limin Yao, and Andrew McCallum.
2010. Modeling relations and their mentions without
labeled text. In ECML/PKDD (3), pages 148?163.
Alan Ritter, Mausam, and Oren Etzioni. 2010. A latent
dirichlet alation method for selectional preferences.
In Proceedings of the 48th Annual Meeting of the As-
sociation for Computational Linguistics (ACL ?10).
Karin Kipper Schuler. 2006. VerbNet: A Broad-
Coverage, Comprehensive Verb Lexicon. Ph.D. thesis,
University of Pennsylvania.
Y. Shinyama and S. Sekine. 2006. Preemptive informa-
tion extraction using unrestricted relation discovery.
In Procs. of HLT/NAACL.
Fabian M. Suchanek, Georgiana Ifrim, and Gerhard
Weikum. 2006. Combining linguistic and statistical
analysis to extract relations from web documents. In
Procs. of KDD, pages 712?717.
Fabian M. Suchanek, Mauro Sozio, and Gerhard
Weikum. 2009. Sofie: a self-organizing framework
for information extraction. In Proceedings of WWW,
pages 631?640.
Gang Wang, Yong Yu, and Haiping Zhu. 2007. Pore:
Positive-only relation extraction from wikipedia text.
In Proceedings of 6th International Semantic Web
Conference and 2nd Asian Semantic Web Conference
(ISWC/ASWC?07), pages 580?594.
Fei Wu and Daniel S. Weld. 2010. Open information
extraction using Wikipedia. In Proceedings of the 48th
Annual Meeting of the Association for Computational
Linguistics (ACL ?10).
Shubin Zhao and Ralph Grishman. 2005. Extracting re-
lations with integrated information using kernel meth-
ods. In Procs. of ACL.
Jun Zhu, Zaiqing Nie, Xiaojiang Liu, Bo Zhang, and
Ji-Rong Wen. 2009. StatSnowball: a statistical ap-
proach to extracting entity relationships. In WWW
?09: Proceedings of the 18th international conference
on World Wide Web, pages 101?110, New York, NY,
USA. ACM.
534
Proceedings of the ACL 2011 Workshop on Relational Models of Semantics (RELMS 2011), pages 63?71,
Portland, Oregon, USA, June 23, 2011. c?2011 Association for Computational Linguistics
A Joint Model of Implicit Arguments for Nominal Predicates
Matthew Gerber and Joyce Y. Chai
Department of Computer Science
Michigan State University
East Lansing, Michigan, USA
{gerberm2,jchai}@cse.msu.edu
Robert Bart
Computer Science and Engineering
University of Washington
Seattle, Washington, USA
rbart@cs.washington.edu
Abstract
Many prior studies have investigated the re-
covery of semantic arguments for nominal
predicates. The models in many of these stud-
ies have assumed that arguments are indepen-
dent of each other. This assumption simpli-
fies the computational modeling of semantic
arguments, but it ignores the joint nature of
natural language. This paper presents a pre-
liminary investigation into the joint modeling
of implicit arguments for nominal predicates.
The joint model uses propositional knowledge
extracted from millions of Internet webpages
to help guide prediction.
1 Introduction
Much recent work on semantic role labeling has fo-
cused on joint models of arguments. This work is
motivated by the fact that one argument can either
promote or inhibit the presence of another argument.
Because most of this work has been done for verbal
SRL, nominal SRL has lagged behind somewhat. In
particular, the ?implicit? nominal SRL model cre-
ated by Gerber and Chai (2010) does not address
joint argument structures. Implicit arguments are
similar to standard SRL arguments, a primary differ-
ence being their ability to cross sentence boundaries.
In the model created by Gerber and Chai, implicit ar-
gument candidates are classified independently and
a heuristic post-processing method is applied to de-
rive the final structure. This paper presents a prelim-
inary joint implicit argument model.
Consider the following sentences:1
1We will use the notation of Gerber and Chai (2010), where
(1) [c1 The president] is currently struggling to
manage [c2 the country?s economy].
(2) If he cannot get it under control, [p loss] of
[arg1 the next election] might result.
In Example 2, we are searching for the iarg0 of loss
(the entity that is losing). The sentence in Exam-
ple 1 supplies two candidates c1 and c2. If one only
considers the predicate loss, then c1 and c2 would
both be reasonable fillers for the iarg0: presidents
often lose things (e.g., votes and allegiance) and
economies often lose things (e.g., jobs and value).
However, the sentence in Example 2 supplies addi-
tional information. It tells the reader that the next
election is the entity being lost. Given this infor-
mation, one would likely prefer c1 over c2 because
economies don?t generally lose elections, whereas
presidents often do. This type of inference is com-
mon in textual discourses because authors assume
a shared knowledge base with their readers. This
knowledge base contains information about events
and their typical participants (e.g., the fact that pres-
idents lose elections but economies do not).
The model presented in this paper relies on a
knowledge base constructed by automatically min-
ing semantic propositions from Internet webpages.
These propositions help to identify likely joint im-
plicit argument configurations. In the following sec-
tion, we review work on joint inference within se-
mantic role labeling. In Sections 4 and 5, we present
the joint implicit argument model and its features.
Evaluation results for this model are given in Sec-
standard nominal arguments are indicated with argn and im-
plicit arguments are indicated with iargn.
63
tion 6. The joint model contains many simplifying
assumptions, which we address in Section 7. We
conclude in Section 8.
2 Related work
A number of recent studies have shown that seman-
tic arguments are not independent and that system
performance can be improved by taking argument
dependencies into account. Consider the following
examples, due to Toutanova et al (2008):
(3) [Temporal The day] that [arg0 the ogre]
[Predicate cooked] [arg1 the children] is still
remembered.
(4) [arg1 The meal] that [arg0 the ogre]
[Predicate cooked] [Beneficiary the children]
is still remembered.
These examples demonstrate the importance of
inter-argument dependencies. The change from day
in Example 3 to meal in Example 4 affects more
than just the Temporal label: additionally, the arg1
changes to Beneficiary, even though the underlying
text (the children) does not change. To capture this
dependency, Toutanova el al. first generate an n-
best list of argument labels for a predicate instance.
They then re-rank this list using joint features that
describe multiple arguments simultaneously. The
features help prevent globally invalid argument con-
figurations (e.g., ones with multiple arg0 labels).
Punyakanok et al (2008) formulate a variety of
constraints on argument configurations. For exam-
ple, arguments are not allowed to overlap the predi-
cate, nor are they allowed to overlap each other. The
authors treat these constraints as binary variables
within an integer linear program, which is optimized
to produce the final labeling.
Ritter et al (2010) investigated joint selectional
preferences. Traditionally, a selectional preference
model provides the strength of association between
a predicate-argument position and a specific textual
expression. Returning to Examples 1 and 2, one
sees that the selectional preference for president and
economy in the iarg0 position of loss should be high.
Ritter et al extended this single-argument model
using a joint formulation of Latent Dirichlet Allo-
cation (LDA) (Blei et al, 2003). In the generative
version of joint LDA, text for the argument posi-
tions is generated from a common hidden variable.
This approach reflects the intuition behind Exam-
ples 1 and 2 and would help identify president as the
iarg0. Training data for the model was drawn from
a large corpus of two-argument tuples extracted by
the TextRunner system, which we describe next.
Both Ritter et al?s model and the model described
in this paper rely heavily on information extracted
by the TextRunner system (Banko et al, 2007).
The TextRunner system extracts tuples from Inter-
net webpages in an unsupervised fashion. One key
difference between TextRunner and other informa-
tion extraction systems is that TextRunner does not
use a closed set of relations (compare to the work
described by ACE (2008)). Instead, the relation set
is left open, leading to the notion of Open Informa-
tion Extraction (OIE). Although OIE often has lower
precision than traditional information extraction, it
is able to extract a wider variety of relations at preci-
sion levels that are often useful (Banko and Etzioni,
2008).
3 Using TextRunner to assess joint
argument assignments
Returning again to Examples 1 and 2, one can query
TextRunner in the following way:
arg0 : ?
Predicate : lose2
arg1 : election
In the TextRunner system, arg0 typically indicates
the Agent and arg1 typically indicates the Theme.
TextRunner provides many tuples in response to this
query, two of which are shown below:
(5) Usually, [arg0 the president?s party]
[Predicate loses] [arg1 seats in the mid-term
election].
(6) [arg0 The president] [Predicate lost] [arg1 the
election].
The tuples present in these sentences give strong in-
dicators about the type of entity that loses elections.
2Nominal predicates are mapped to their verbal forms using
information provided by the NomBank lexicon.
64
Given all of the returned tuples, only a single one
involves economy in the arg0 position:
(7) Any president will take credit for [arg0 a good
economy] or [Predicate lose] [arg1 an
election] over a bad one.
In Example 7, TextRunner has not analyzed the ar-
guments correctly (president should be the arg0, not
economy).3 In Section 5, we show how evidence
from the tuple lists can be aggregated such that cor-
rect analyses (5 and 6) are favored over incorrect
analyses (7). The primary contribution of this paper
is an exploration of how the aggregated evidence can
be used to identify implicit arguments (e.g., presi-
dent in Example 1).
4 Joint model formulation
To simplify the experimental setting, the model de-
scribed in this paper targets the specific situation
where a predicate instance p takes an implicit iarg0
and an implicit iarg1.4 Whereas the model proposed
by Gerber and Chai (2010) classifies candidates for
these positions independently, the model in this pa-
per classifies joint structures by evaluating the fol-
lowing binary prediction function:
P (+| ?p, iarg0, ci, iarg1, cj?) (8)
Equation 8 gives the probability of the joint assign-
ment of ci to iarg0 and cj to iarg1. Given a set of n
candidates c1, . . . , cn ? C , the best labeling is found
by considering all possible assignments of ci and cj :
argmax
(ci,cj)?CxC s.t. i 6=j
P (+| ?p, iarg0, ci, iarg1, cj?)
(9)
Consider modified versions of Examples 1 and 2:
(10) [c1 The president] is currently struggling to
manage [c2 the country?s economy].
(11) If he cannot get it under control before [c3 the
next election], a [p loss] might result.
3Banko and Etzioni (2008) cite a precision score of 88% for
their system.
4This simplifying assumption does not hold for real data,
and is addressed further in Section 7.2.
In this case, we are looking for the iarg0 as well as
the iarg1 for the loss predicate. Three candidates c1,
c2, and c3 are marked. The joint model would eval-
uate the following probabilities, taking the highest
scoring to be the final assignment:
P (+| ?loss, iarg0, president, iarg1, economy?)
*P (+| ?loss, iarg0, president, iarg1, election?)
P (+| ?loss, iarg0, economy, iarg1, president?)
P (+| ?loss, iarg0, economy, iarg1, election?)
P (+| ?loss, iarg0, election, iarg1, president?)
P (+| ?loss, iarg0, election, iarg1, economy?)
Intuitively, only the starred item should have a high
probability. In the following section, we describe
how these probabilities can be estimated using in-
formation extracted by TextRunner.
5 Joint model features
As mentioned in Section 2, the TextRunner system
has been extracting massive amounts of knowledge
in the form of tuples such as the following:
?president, lose, election?
The database of tuples can be queried by supplying
one or more of the tuple arguments. For example,
the following is a partial result list for the query
?president, lose, ??:
?Kenyan president, lose, election?
?president?s party, lose seat in, election?
?president, lose, ally?
The final position in each of these tuples (e.g.,
election) provides a single answer to the question
?What might a president lose??. Aggregation begins
by generalizing each answer to its WordNet synset
(glosses are shown after the arrows):
?Kenyan president, lose, election? ? a vote
?president?s party, lose seat in, election? (same)
?president, lose, ally? ? friendly nation
In cases where a tuple argument has multiple
WordNet senses, the tuple is mapped to the most
common sense as listed in the WordNet database.
65
Having mapped each tuple to its synset, each synset
is ranked according to the number of tuples that
it covers. For the query ?president, lose, ??, this
produces the following ranked list of WordNet
synsets (only the top five are shown, with the
number in parentheses indicating how many tuples
are covered):
1. election (77)
2. war (51)
3. vote (39)
4. people (34)
5. support (26)
...
The synsets above indicate likely answers to the pre-
vious question of ?What might a president lose??.
In a similar manner, one can answer a question
such as ?What might lose an election?? using tu-
ples extracted by TextRunner. The procedure de-
scribed above produces the following ranked list of
WordNet synsets to answer this question:
...
9. people (62)
10. Republican (51)
11. Republican party (51)
12. Hillary (50)
13. president (49)
...
In this case, the expected answer (president) ranks
13th in the list of answer synsets. It is important
to note that lower ranked answers are not necessar-
ily incorrect answers. It is a simple fact that a wide
variety of entities can lose an election. Items 9-13
are all reasonable answers to the original question
of what might lose an election.
The two symmetric questions defined and an-
swered above are closely connected to the implicit
argument situation discussed in Examples 10 and
11. In Example 11, one is searching for the implicit
iarg0 and iarg1 to the loss predicate. Candidates ci
and cj that truly fill these positions should be com-
patible with questions in the following forms:
Question: What did ci lose?
Answer: cj
Question: What entity lost cj?
Answer: ci
If either of these question-answer pairs is not satis-
fied, then the joint assignment of ci to iarg0 and cj
to iarg1 should be considered unlikely. Using the
first question-answer pair above as an example, sat-
isfaction is determined in the following way:
1. Query TextRunner for ?ci, lose, ??, retrieving
the top n tuples.
2. Map the final argument of each tuple to its
WordNet synset and rank the synsets by fre-
quency, producing the ranked list A of answer
synsets.
3. Map cj to its most common WordNet synset
synsetcj and determine whether synsetcj ex-
ists in A. If it does, the question-answer pair is
satisfied.
Some additional processing is required to determine
whether synsetcj exists in A. This is due to the hi-
erarchical organization of WordNet. For example,
suppose that synsetcj is the synset containing ?pri-
mary election? and A contains synsets paraphrased
as follows:
1. election
2. war
3. vote
...
synsetcj does not appear directly in this list; how-
ever, its existence in the list is implied by the follow-
ing hypernymy path within WordNet:
primary election is-a??? election
Intuitively, if synsetcj is connected to a highly
ranked synset in A by a short path, then one has ev-
idence that synsetcj answers the original question.
66
The evidence is weaker if the path is long, as in the
following example:
open primary is-a??? direct primary
is-a??? primary election is-a??? election
Additionally, a path between more specific synsets
(i.e., those lower in the hierarchy) indicates a
stronger relationship than a path between more gen-
eral synsets (i.e., those higher in the hierarchy).
These two situations are depicted in Figure 1. The
synset similarity metric defined by Wu and Palmer
(1994) combines the path length and synset depth
intuitions into a single numeric score that is defined
as follows:
2 ? depth(lca(synset1, synset2))
depth(synset1) + depth(synset2)
(12)
In Equation 12, lca returns the lowest common an-
cestor of the two synsets within the WordNet is-a
hierarchy.
To summarize, Equation 12 indicates the strength
of association between synsetcj (e.g., primary elec-
tion) and a ranked synset synseta from A that an-
swers a question such as ?What might a president
lose??. If the association between synsetcj and
synseta is small, then the assignment of cj to iarg1
is unlikely. The process works similarly for assess-
ing ci as the filler of iarg0. In what follows, we
quantify this intuition with features used to repre-
sent the conditioning information in Equation 8.
Feature 1: Maximum association strength. Given
the conditioning variables in Equation 8, there are
two questions that can be asked:
Question: What did ci p?
Answer: cj
Question: What entity p cj?
Answer: ci
Each of these questions produces a ranked list of
answer synsets using the approach described previ-
ously. The synset for each answer string will match
zero or more of the answer synsets, and each of these
matches will be associated with a similarity score as
defined in Equation 12. Feature 1 considers all such
similarity scores and selects the maximum. A high
value for this feature indicates that one (or both) of
the candidates (ci or cj) is likely to fill its associated
implicit argument position.
Feature 2: Maximum reciprocal rank. Of all the
answer matches described for Feature 1, Feature 2
selects the highest ranking and forms the reciprocal
rank. Thus, values for Feature 2 are in [0,1] with
larger values indicating matches with higher ranked
answer synsets.
Feature 3: Number of matches. This feature
records the total number of answer string matches
from either of the questions described for Feature 1.
Feature 4: Sum reciprocal rank. Feature 2 consid-
ers answer synset matches from either of the posed
questions; ideally, each question-answer pair should
have some influence on the probability estimate in
Equation 8. Feature 4 looks at the answer synset
matches from each question individually. The match
with highest rank for each question is selected, and
the reciprocal rank 2r1 + r2 is computed. The value
of this feature is zero if either of the questions fails
to produce a matching answer synset.
Features 5 and 6: Local classification scores. The
joint model described in this paper does not replace
the local prediction model presented by Gerber and
Chai (2010). The latter uses a wide variety of impor-
tant features that cannot be ignored. Like previous
joint models (e.g., the one described by Toutanova et
al. (2008)), the joint model works on top of the lo-
cal prediction model, whose scores are incorporated
into the joint model as feature-value pairs. Given the
local prediction scores for the iarg0 and iarg1 posi-
tions in Equation 8, the joint model forms two fea-
tures: (1) the sum of the scores for ci filling iarg0
and cj filling iarg1, and (2) the product of these two
scores.
6 Evaluation
We evaluated the joint model described in the pre-
vious sections over the manually annotated implicit
67
entity (a)
physical entity (b)
thing
body of water (c)
bay (d)
matter
abstract entity
Figure 1: Effect of depth on WordNet synset similarity. All links indicate is-a relationships. Although the link
distance from (a) to (b) equals the distance from (c) to (d), the latter are more similar due to their lower depth within
the WordNet hierarchy.
argument data created by Gerber and Chai (2010).
This dataset contains full-text implicit argument
annotations for approximately 1,200 predicate in-
stances within the Penn TreeBank. As mentioned
in Section 4, all experiments were conducted us-
ing predicate instances that take an iarg0 and iarg1
in the ground-truth annotations. We used a ten-
fold cross-validation setup and the evaluation met-
rics proposed by Ruppenhofer et al (2009), which
were also used by Gerber and Chai. For each evalu-
ation fold, features were selected using only the cor-
responding training data and the greedy selection al-
gorithm proposed by Pudil et al (1994), which starts
with an empty feature set and incrementally adds
features that provide the highest gains.
For comparison with Gerber and Chai?s model,
we also evaluated the local prediction model on the
evaluation data. Because this model predicted im-
plicit arguments independently, it continued to use
the heuristic post-processing algorithm to arrive at
the final labeling. However, the prediction threshold
t was eliminated because the system could safely as-
sume that a true filler for the iarg0 and iarg1 posi-
tions existed.
Table 1 presents the evaluation results. The first
thing to note is that these results are not comparable
to the results presented by Gerber and Chai (2010).
In general, performance is much higher because
predicate instances reliably take implicit arguments
in the iarg0 and iarg1 positions. The overall perfor-
mance increase versus the local model is relatively
small (approximately 1 percentage point); however,
the bid predicate in particular showed a substantial
increase (greater than 11 percentage points).
7 Discussion
7.1 Example improvement versus local model
The bid and investment predicates showed the
largest increase for the joint model versus the local
model. Below, we give an example of the investment
predicate for which the joint model correctly identi-
fied the iarg0 and the local model did not.
(13) [Big investors] can decide to ride out market
storms without jettisoning stock.
(14) Most often, [c they] do just that, because
stocks have proved to be the best-performing
long-term [Predicate investment], attracting
about $1 trillion from pension funds alone.
Both models identified the iarg1 as money from a
prior sentence (not shown). The local model in-
correctly predicted $1 trillion in Example 14 as the
iarg0 for the investment event. This mistake demon-
strates a fundamental limitation of the local model:
it cannot detect simple incompatibilities in the pre-
dicted argument structure. It does not know that
?money investing money? is a rare or impossible
event in the real world.
For the joint model?s prediction, consider the con-
stituent marked with c in Example 14. This con-
68
Local model Joint model
# Imp. args. P R F1 P R F1
price 40 65.0 65.0 65.0 67.5 67.5 67.5
sale 34 86.5 86.5 86.5 84.3 84.3 84.3
plan 30 60.0 60.0 60.0 56.7 56.7 56.7
bid 26 66.7 66.7 66.7 78.2 78.2 78.2
fund 18 83.3 83.3 83.3 83.3 83.3 83.3
loss 14 100.0 100.0 100.0 100.0 100.0 100.0
loan 12 63.6 58.3 60.9 50.0 50.0 50.0
investment 8 57.1 50.0 53.3 62.5 62.5 62.5
Overall 182 72.6 71.8 72.2 73.1 73.1 73.1
Table 1: Joint implicit argument evaluation results. The second column gives the total number of implicit arguments
in the ground-truth annotations. P , R, and F1 indicate precision, recall, and f-measure (? = 1) as defined by Ruppen-
hofer et al (2009).
stituent is resolved to Big investors in the preceding
sentence. Thus, the two relevant questions are as
follows:
Question: What did big investors invest?
Answer: money
Question: What entity invested money?
Answer: big investors
The first question produces the following ranked list
of answer synsets (the number in parentheses indi-
cates the number of answer tuples mapped to the
synset):
money (71)
amount (38)
million (38)
billion (22)
capital (21)
As shown, the answer string of money matches the
top-ranked answer synset. The second question pro-
duces the following ranked list of answer synsets:
company (642)
people (460)
government (275)
business (75)
investor (70)
In this case, the answer string Big investors matches
the fifth answer synset. The combined evidence
of these two question-answer pairs allows the joint
system to successfully identify Big investors as the
iarg0 of the investment predicate in Example 14.
7.2 Toward a generally applicable joint model
The joint model presented in this paper assumes that
all predicate instances take an iarg0 and iarg1. This
assumption clearly does not hold for real data (these
positions are often not expressed in the text), but re-
laxing it will require investigation of the following
issues:
1. Explicit arguments should also be considered
when determining whether a candidate c fills
an implicit argument position iargn. The mo-
tivation here is similar to that given elsewhere
in this paper: arguments (whether implicit or
explicit) are not independent. This is demon-
strated by Example 2 at the beginning of this
paper, where election is an explicit argument to
the predicate and affects the implicit argument
inference. The model developed in this paper
only considers jointly occurring implicit argu-
ments.
2. Other implicit argument positions (e.g.,
iarg2, iarg3, etc.) need to be accounted
for as well. This will present a challenge
when it comes to extracting the necessary
69
propositions from TextRunner. Currently,
TextRunner only handles tuples of the form
?arg0, p, arg1?. Other argument positions are
not directly analyzed by the system; however,
because TextRunner also returns the sentence
from which a tuple is extracted, these addi-
tional argument positions could be extracted in
the following way:
(a) For an instance of the sale predicate
with an arg0 of company, to find
likely arg2 fillers (the entity purchas-
ing the item), query TextRunner with
?company, sell, ??.
(b) Perform standard verbal SRL on the sen-
tences for the resulting tuples, identifying
any arg2 occurrences.
(c) Cluster and rank the arg2 fillers according
to the method described in this paper.
This approach combines Open Information Ex-
traction with traditional information extraction
(i.e., verbal SRL).
3. Computational complexity and probability
estimation is a problem for many joint mod-
els. The model presented in this paper quickly
becomes computationally intractable when the
number of candidates and implicit argument
positions becomes moderately large. This is
because Equation 9 considers all possible as-
signments of candidates to implicit argument
positions. With as few as thirty candidates and
five argument positions (not uncommon), one
must evaluate 30!/25! = 17, 100, 720 possible
assignments. Although this particular formula-
tion is not tractable, one based on dynamic pro-
gramming or heuristic search might give rea-
sonable results. Efficient estimation of the joint
probability via Gibbs sampling would also be a
possible approach (Resnik and Hardisty, 2010).
8 Conclusions
Many prior studies have investigated the recovery
of semantic arguments for nominal predicates. The
models in many of these studies have assumed that
the arguments are independent of each other. This
assumption simplifies the computational modeling
of semantic arguments, but it ignores the joint na-
ture of natural language. In order to take advantage
of the information provided by jointly occurring ar-
guments, the independent prediction models must be
enhanced.
This paper has presented a preliminary investiga-
tion into the joint modeling of implicit arguments
for nominal predicates. The model relies heavily
on information extracted by the TextRunner extrac-
tion system, which pulls propositional tuples from
millions of Internet webpages. These tuples encode
world knowledge that is necessary for resolving se-
mantic arguments in general and implicit arguments
in particular. This paper has proposed methods of
aggregating tuple knowledge to guide implicit argu-
ment resolution. The aggregated knowledge is ap-
plied via a re-ranking model that operates on top
of the local prediction model described in previous
work.
The performance gain across all predicate in-
stances is relatively small; however, larger gains are
observed for the bid and investment predicates. The
improvement in Example 14 shows that the joint
model is capable of correcting a bad local predic-
tion using information extracted by the TextRunner
system. This type of information is not used by the
local prediction model.
Although the results in this paper show that some
improvement is possible through the use of a joint
model of implicit arguments, a significant amount
of future work will be required to make the model
widely applicable.
References
ACE, 2008. The ACE 2008 Evaluation Plan. NIST, 1.2d
edition, August.
Michele Banko and Oren Etzioni. 2008. The tradeoffs
between open and traditional relation extraction. In
Proceedings of ACL-08: HLT, pages 28?36, Colum-
bus, Ohio, June. Association for Computational Lin-
guistics.
Michele Banko, Michael J Cafarella, Stephen Soderland,
Matt Broadhead, and Oren Etzioni. 2007. Open in-
formation extraction from the web. In Proceedings of
the 20th International Joint Conference on Artificial
Intelligence.
David M. Blei, Andrew Y. Ng, and Michael I. Jordan.
70
2003. Latent dirichlet alocation. J. Mach. Learn.
Res., 3:993?1022.
Matthew Gerber and Joyce Chai. 2010. Beyond Nom-
Bank: A study of implicit arguments for nominal pred-
icates. In Proceedings of the 48th Annual Meeting of
the Association for Computational Linguistics, pages
1583?1592, Uppsala, Sweden, July. Association for
Computational Linguistics.
P. Pudil, J. Novovicova, and J. Kittler. 1994. Floating
search methods in feature selection. Pattern Recogni-
tion Letters, 15:1119?1125.
Vasin Punyakanok, Dan Roth, and Wen-tau Yih. 2008.
The importance of syntactic parsing and inference in
semantic role labeling. Comput. Linguist., 34(2):257?
287.
Philip Resnik and Eric Hardisty. 2010. Gibbs sampling
for the uninitiated. Technical report, University of
Maryland, June.
Alan Ritter, Mausam, and Oren Etzioni. 2010. A latent
dirichlet alocation method for selectional preferences.
In Proceedings of the 48th Annual Meeting of the As-
sociation for Computational Linguistics.
Josef Ruppenhofer, Caroline Sporleder, Roser Morante,
Collin Baker, and Martha Palmer. 2009. Semeval-
2010 task 10: Linking events and their participants in
discourse. In Proceedings of the Workshop on Seman-
tic Evaluations: Recent Achievements and Future Di-
rections (SEW-2009), pages 106?111, Boulder, Col-
orado, June. Association for Computational Linguis-
tics.
Kristina Toutanova, Aria Haghighi, and Christopher D.
Manning. 2008. A global joint model for semantic
role labeling. Comput. Linguist., 34(2):161?191.
Zhibiao Wu and Martha Palmer. 1994. Verb seman-
tics and lexical selection. In Proceedings of the 32nd
Annual Meeting of the Association for Computational
Linguistics, pages 133?138, Las Cruces, New Mex-
ico, USA, June. Association for Computational Lin-
guistics.
71
