Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 912?920,
Jeju, Republic of Korea, 8-14 July 2012. c?2012 Association for Computational Linguistics
A Ranking-based Approach to Word Reordering
for Statistical Machine Translation?
Nan Yang?, Mu Li?, Dongdong Zhang?, and Nenghai Yu?
?MOE-MS Key Lab of MCC
University of Science and Technology of China
v-nayang@microsoft.com, ynh@ustc.edu.cn
?Microsoft Research Asia
{muli,dozhang}@microsoft.com
Abstract
Long distance word reordering is a major
challenge in statistical machine translation re-
search. Previous work has shown using source
syntactic trees is an effective way to tackle
this problem between two languages with sub-
stantial word order difference. In this work,
we further extend this line of exploration and
propose a novel but simple approach, which
utilizes a ranking model based on word or-
der precedence in the target language to repo-
sition nodes in the syntactic parse tree of a
source sentence. The ranking model is auto-
matically derived from word aligned parallel
data with a syntactic parser for source lan-
guage based on both lexical and syntactical
features. We evaluated our approach on large-
scale Japanese-English and English-Japanese
machine translation tasks, and show that it can
significantly outperform the baseline phrase-
based SMT system.
1 Introduction
Modeling word reordering between source and tar-
get sentences has been a research focus since the
emerging of statistical machine translation. In
phrase-based models (Och, 2002; Koehn et al,
2003), phrase is introduced to serve as the funda-
mental translation element and deal with local re-
ordering, while a distance based distortion model is
used to coarsely depict the exponentially decayed
word movement probabilities in language transla-
tion. Further work in this direction employed lexi-
?This work has been done while the first author was visiting
Microsoft Research Asia.
calized distortion models, including both generative
(Koehn et al, 2005) and discriminative (Zens and
Ney, 2006; Xiong et al, 2006) variants, to achieve
finer-grained estimations, while other work took into
account the hierarchical language structures in trans-
lation (Chiang, 2005; Galley and Manning, 2008).
Long-distance word reordering between language
pairs with substantial word order difference, such as
Japanese with Subject-Object-Verb (SOV) structure
and English with Subject-Verb-Object (SVO) struc-
ture, is generally viewed beyond the scope of the
phrase-based systems discussed above, because of
either distortion limits or lack of discriminative fea-
tures for modeling. The most notable solution to this
problem is adopting syntax-based SMT models, es-
pecially methods making use of source side syntac-
tic parse trees. There are two major categories in this
line of research. One is tree-to-string model (Quirk
et al, 2005; Liu et al, 2006) which directly uses
source parse trees to derive a large set of translation
rules and associated model parameters. The other
is called syntax pre-reordering ? an approach that
re-positions source words to approximate target lan-
guage word order as much as possible based on the
features from source syntactic parse trees. This is
usually done in a preprocessing step, and then fol-
lowed by a standard phrase-based SMT system that
takes the re-ordered source sentence as input to fin-
ish the translation.
In this paper, we continue this line of work and
address the problem of word reordering based on
source syntactic parse trees for SMT. Similar to most
previous work, our approach tries to rearrange the
source tree nodes sharing a common parent to mimic
912
the word order in target language. To this end, we
propose a simple but effective ranking-based ap-
proach to word reordering. The ranking model is
automatically derived from the word aligned parallel
data, viewing the source tree nodes to be reordered
as list items to be ranked. The ranks of tree nodes are
determined by their relative positions in the target
language ? the node in the most front gets the high-
est rank, while the ending word in the target sentence
gets the lowest rank. The ranking model is trained
to directly minimize the mis-ordering of tree nodes,
which differs from the prior work based on maxi-
mum likelihood estimations of reordering patterns
(Li et al, 2007; Genzel, 2010), and does not require
any special tweaking in model training. The ranking
model can not only be used in a pre-reordering based
SMT system, but also be integrated into a phrase-
based decoder serving as additional distortion fea-
tures.
We evaluated our approach on large-scale
Japanese-English and English-Japanese machine
translation tasks, and experimental results show that
our approach can bring significant improvements to
the baseline phrase-based SMT system in both pre-
ordering and integrated decoding settings.
In the rest of the paper, we will first formally
present our ranking-based word reordering model,
then followed by detailed steps of modeling train-
ing and integration into a phrase-based SMT system.
Experimental results are shown in Section 5. Section
6 consists of more discussions on related work, and
Section 7 concludes the paper.
2 Word Reordering as Syntax Tree Node
Ranking
Given a source side parse tree Te, the task of word
reordering is to transform Te to T ?e, so that e
? can
match the word order in target language as much as
possible. In this work, we only focus on reordering
that can be obtained by permuting children of every
tree nodes in Te. We use children to denote direct de-
scendants of tree nodes for constituent trees; while
for dependency trees, children of a node include not
only all direct dependents, but also the head word
itself. Figure 1 gives a simple example showing the
word reordering between English and Japanese. By
rearranging the position of tree nodes in the English
I am trying to play music
?? ??? ?? ???? ????
PRP VBP VBG TO VB NN
NP
VP
VP
NP
S
VP
VP
S
I amtryingtoplaymusic
PRP VBPVBGTOVBNN
NP
VP
VP
NP
S
VP
VP
?? ??? ?? ???? ????
Original 
Tree
Reordered Tree
S
j0 j1 j2 j3 j4
e0 e1 e2 e3 e4 e5
j0 j1 j2 j3 j4
e0 e1 e2 e3 e4 e5
Figure 1: An English-to-Japanese sentence pair. By
permuting tree nodes in the parse tree, the source
sentence is reordered into the target language or-
der. Constituent tree is shown above the source
sentence; arrows below the source sentences show
head-dependent arcs for dependency tree; word
alignment links are lines without arrow between the
source and target sentences.
parse tree, we can obtain the same word order of
Japanese translation. It is true that tree-based re-
ordering cannot cover all word movement operations
in language translation, previous work showed that
this method is still very effective in practice (Xu et
al., 2009, Visweswariah et al, 2010).
Following this principle, the word reordering task
can be broken into sub-tasks, in which we only
need to determine the order of children nodes for
all non-leaf nodes in the source parse tree. For a
tree node t with children {c1, c2, . . . , cn}, we re-
arrange the children to target-language-like order
{cpi(i1), cpi(i2), . . . , cpi(in)}. If we treat the reordered
position pi(i) of child ci as its ?rank?, the reorder-
913
ing problem is naturally translated into a ranking
problem: to reorder, we determine a ?rank? for each
child, then the children are sorted according to their
?ranks?. As it is often impractical to directly assign
a score for each permutation due to huge number of
possible permutations, a widely used method is to
use a real valued function f to assign a value to each
node, which is called a ranking function (Herbrich
et al, 2000). If we can guarantee (f(i)? f(j)) and
(pi(i) ? pi(j)) always has the same sign, we can get
the same permutation as pi because values of f are
only used to sort the children. For example, con-
sider the node rooted at trying in the dependency
tree in Figure 1. Four children form a list {I, am, try-
ing, play} to be ranked. Assuming ranking function
f can assign values {0.94, ?1.83, ?1.50, ?1.20}
for {I, am, trying, play} respectively, we can get a
sorted list {I, play, trying, am}, which is the desired
permutation according to the target.
More formally, for a tree node t with children
{c1, c2, . . . , cn}, our ranking model assigns a rank
f(ci, t) for each child ci, then the children are sorted
according to the rank in a descending order. The
ranking function f has the following form:
f(ci, t) =
?
j
?j(ci, t) ? wj (1)
where the ?j is a feature representing the tree node t
and its child ci, and wj is the corresponding feature
weight.
3 Ranking Model Training
To learn ranking function in Equation (1), we need to
determine the feature set ? and learn weight vector
w from reorder examples. In this section, we first
describe how to extract reordering examples from
parallel corpus; then we show our features for rank-
ing function; finally, we discuss how to train the
model from the extracted examples.
3.1 Reorder Example Acquisition
For a sentence pair (e, f, a) with syntax tree Te on
the source side, we need to determine which re-
ordered tree T ?e? best represents the word order in
target sentence f . For a tree node t in Te, if its chil-
dren align to disjoint target spans, we can simply ar-
range them in the order of their corresponding target
Prob lem w ith latter procedure
??
lies
? ?? ??? ? ?
in ?
? ??
Prob lem w ith latter procedure
??
lies
? ?? ??? ? ?
in ?
? ??
( a)  gold alignment
( b )  auto alignment
Figure 2: Fragment of a sentence pair. (a) shows
gold alignment; (b) shows automatically generated
alignment which contains errors.
spans. Figure 2 shows a fragment of one sentence
pair in our training data. Consider the subtree rooted
at word ?Problem?. With the gold alignment, ?Prob-
lem? is aligned to the 5th target word, and ?with
latter procedure? are aligned to target span [1, 3],
thus we can simply put ?Problem? after ?with latter
procedure?. Recursively applying this process down
the subtree, we get ?latter procedure with Problem?
which perfectly matches the target language.
As pointed out by (Li et al, 2007), in practice,
nodes often have overlapping target spans due to er-
roneous word alignment or different syntactic struc-
tures between source and target sentences. (b) in
Figure 2 shows the automatically generated align-
ment for the sentence pair fragment. The word
?with? is incorrectly aligned to the 6th Japanese
word ?ha?; as a result, ?with latter procedure? now
has target span [1, 6], while ?Problem? aligns to
[5, 5]. Due to this overlapping, it becomes unclear
which permutation of ?Problem? and ?with latter
procedure? is a better match of the target phrase; we
need a better metric to measure word order similar-
ity between reordered source and target sentences.
We choose to find the tree T ?e? with minimal align-
ment crossing-link number (CLN) (Genzel, 2010)
to f as our golden reordered tree.1 Each crossing-
1A simple solution is to exclude all trees with overlapping
target spans from training. But in our experiment, this method
914
link (i1j1, i2j2) is a pair of alignment links crossing
each other. CLN reaches zero if f is monotonically
aligned to e?, and increases as there are more word
reordering between e? and f . For example, in Fig-
ure 1, there are 6 crossing-links in the original tree:
(e1j4, e2j3), (e1j4, e4j2), (e1j4, e5j1), (e2j3, e4j2),
(e2j3, e5j1) and (e4j2, e5j1); thus CLN for the origi-
nal tree is 6. CLN for the reordered tree is 0 as there
are no crossing-links. This metric is easy to com-
pute, and is not affected by unaligned words (Gen-
zel, 2010).
We need to find the reordered tree with minimal
CLN among all reorder candidates. As the number
of candidates is in the magnitude exponential with
respect to the degree of tree Te 2, it is not always
computationally feasible to enumerate through all
candidates. Our solution is as follows.
First, we give two definitions.
? CLN(t): the number of crossing-links
(i1j1, i2j2) whose source words e?i1 and e
?
i2
both fall under sub span of the tree node t.
? CCLN(t): the number of crossing-links
(i1j1, i2j2) whose source words e?i1 and e
?
i2 fall
under sub span of t?s two different children
nodes c1 and c2 respectively.
Apparently CLN of a tree T ? equals to
CLN(root of T ?), and CLN(t) can be recur-
sively expressed as:
CLN(t) = CCLN(t) +
?
child c of t
CLN(c)
Take the original tree in Figure 1 for example. At the
root node trying, CLN(trying) is 6 because there are
six crossing-links under its sub-span: (e1j4, e2j3),
(e1j4, e4j2), (e1j4, e5j1), (e2j3, e4j2), (e2j3, e5j1)
and (e4j2, e5j1). On the other hand, CCLN(trying)
is 5 because (e4j2, e5j1) falls under its child node
play, thus does not count towards CCLN of trying.
From the definition, we can easily see that
CCLN(t) can be determined solely by the order of
t?s direct children, and CLN(t) is only affected by
discarded too many training instances and led to degraded re-
ordering performance.
2In our experiments, there are nodes with more than 10 chil-
dren for English dependency trees.
the reorder in the subtree of t. This observation en-
ables us to divide the task of finding the reordered
tree T ?e? with minimal CLN into independently find-
ing the children permutation of each node with min-
imal CCLN. Unfortunately, the time cost for the sub-
task is stillO(n!) for a node with n children. Instead
of enumerating through all permutations, we only
search the Inversion Transduction Grammar neigh-
borhood of the initial sequence (Tromble, 2009). As
pointed out by (Tromble, 2009), the ITG neighbor-
hood is large enough for reordering task, and can be
searched through efficiently using a CKY decoder.
After finding the best reordered tree T ?e? , we can
extract one reorder example from every node with
more than one child.
3.2 Features
Features for the ranking model are extracted from
source syntax trees. For English-to-Japanese task,
we extract features from Stanford English Depen-
dency Tree (Marneffe et al, 2006), including lexi-
cons, Part-of-Speech tags, dependency labels, punc-
tuations and tree distance between head and depen-
dent. For Japanese-to-English task, we use a chunk-
based Japanese dependency tree (Kudo and Mat-
sumoto, 2002). Different from features for English,
we do not use dependency labels because they are
not available from the Japanese parser. Additionally,
Japanese function words are also included as fea-
tures because they are important grammatical clues.
The detailed feature templates are shown in Table 1.
3.3 Learning Method
There are many well studied methods available to
learn the ranking function from extracted examples.,
ListNet (?) etc. We choose to use RankingSVM
(Herbrich et al, 2000), a pair-wised ranking method,
for its simplicity and good performance.
For every reorder example t with children
{c1, c2, . . . , cn} and their desired permutation
{cpi(i1), cpi(i2), . . . , cpi(in)}, we decompose it into a
set of pair-wised training instances. For any two
children nodes ci and cj with i < j , we extract a
positive instance if pi(i) < pi(j), otherwise we ex-
tract a negative instance. The feature vector for both
positive instance and negative instance is (?ci??cj ),
where ?ci and ?cj are feature vectors for ci and cj
915
E-J
cl cl ? dst cl ? pct
cl ? dst ? pct cl ? lcl cl ? rcl
cl ? lcl ? dst cl ? rcl ? dst cl ? clex
cl ? clex cl ? clex ? dst cl ? clex ? dst
cl ? hlex cl ? hlex cl ? hlex ? dst
cl ? hlex ? dst cl ? clex ? pct cl ? clex ? pct
cl ? hlex ? pct cl ? hlex ? pct
J-E
ctf ctf ? dst ctf ? lct
ctf ? rct ctf ? lct ? dst cl ? rct ? dst
ctf ? clex ctf ? clex ctf ? clex ? dst
ctf ? clex ? dst ctf ? hf ctf ? hf
ctf ? hf ? dst ctf ? hf ? dst ctf ? hlex
ctf ? hlex ctf ? hlex ? dst ctf ? hlex ? dst
Table 1: Feature templates for ranking function. All
templates are implicitly conjuncted with the pos tag
of head node.
c: child to be ranked; h: head node
lc: left sibling of c; rc: right sibling of c
l: dependency label; t: pos tag
lex: top frequency lexicons
f : Japanese function word
dst: tree distance between c and h
pct: punctuation node between c and h
respectively. In this way, ranking function learning
is turned into a simple binary classification problem,
which can be easily solved by a two-class linear sup-
port vector machine.
4 Integration into SMT system
There are two ways to integrate the ranking reorder-
ing model into a phrase-based SMT system: the pre-
reorder method, and the decoding time constraint
method.
For pre-reorder method, ranking reorder model
is applied to reorder source sentences during both
training and decoding. Reordered sentences can go
through the normal pipeline of a phrase-based de-
coder.
The ranking reorder model can also be integrated
into a phrase based decoder. Integrated method takes
the original source sentence e as input, and ranking
model generates a reordered e? as a word order ref-
erence for the decoder. A simple penalty scheme
is utilized to penalize decoder reordering violating
ranking reorder model?s prediction e?. In this paper,
our underlying decoder is a CKY decoder follow-
ing Bracketing Transduction Grammar (Wu, 1997;
Xiong et al, 2006), thus we show how the penalty
is implemented in the BTG decoder as an example.
Similar penalty can be designed for other decoders
without much effort.
Under BTG, three rules are used to derive transla-
tions: one unary terminal rule, one straight rule and
one inverse rule:
A ? e/f
A ? [A1, A2]
A ? ?A1, A2?
We have three penalty triggers when any rules are
applied during decoding:
? Discontinuous penalty fdc: it fires for all rules
when source span of either A, A1 or A2 is
mapped to discontinuous span in e?.
? Wrong straight rule penalty fst: it fires for
straight rule when source spans of A1 and A2
are not mapped to two adjacent spans in e? in
straight order.
? Wrong inverse rule penalty fiv: it fires for in-
verse rule when source spans of A1 and A2 are
not mapped to two adjacent spans in e? in in-
verse order.
The above three penalties are added as additional
features into the log-linear model of the phrase-
based system. Essentially they are soft constraints
to encourage the decoder to choose translations with
word order similar to the prediction of ranking re-
order model.
5 Experiments
To test our ranking reorder model, we carry out ex-
periments on large scale English-To-Japanese, and
Japanese-To-English translation tasks.
5.1 Data
5.1.1 Evaluation Data
We collect 3,500 Japanese sentences and 3,500
English sentences from the web. They come from
916
a wide range of domains, such as technical docu-
ments, web forum data, travel logs etc. They are
manually translated into the other language to pro-
duce 7,000 sentence pairs, which are split into two
parts: 2,000 pairs as development set (dev) and the
other 5,000 pairs as test set (web test).
Beside that, we collect another 999 English sen-
tences from newswire domain which are translated
into Japanese to form an out-of-domain test data set
(news test).
5.1.2 Parallel Corpus
Our parallel corpus is crawled from the web,
containing news articles, technical documents, blog
entries etc. After removing duplicates, we have
about 18 million sentence pairs, which contain about
270 millions of English tokens and 320 millions of
Japanese tokens. We use Giza++ (Och and Ney,
2003) to generate the word alignment for the parallel
corpus.
5.1.3 Monolingual Corpus
Our monolingual Corpus is also crawled from the
web. After removing duplicate sentences, we have a
corpus of over 10 billion tokens for both English and
Japanese. This monolingual corpus is used to train
a 4-gram language model for English and Japanese
respectively.
5.2 Parsers
For English, we train a dependency parser as (Nivre
and Scholz, 2004) on WSJ portion of Penn Tree-
bank, which are converted to dependency trees us-
ing Stanford Parser (Marneffe et al, 2006). We con-
vert the tokens in training data to lower case, and
re-tokenize the sentences using the same tokenizer
from our MT system.
For Japanese parser, we use CABOCHA, a
chunk-based dependency parser (Kudo and Mat-
sumoto, 2002). Some heuristics are used to adapt
CABOCHA generated trees to our word segmenta-
tion.
5.3 Settings
5.3.1 Baseline System
We use a BTG phrase-based system with a Max-
Ent based lexicalized reordering model (Wu, 1997;
Xiong et al, 2006) as our baseline system for
both English-to-Japanese and Japanese-to-English
Experiment. The distortion model is trained on the
same parallel corpus as the phrase table using a
home implemented maximum entropy trainer.
In addition, a pre-reorder system using manual
rules as (Xu et al, 2009) is included for the English-
to-Japanese experiment (ManR-PR). Manual rules
are tuned by a bilingual speaker on the development
set.
5.3.2 Ranking Reordering System
Ranking reordering model is learned from the
same parallel corpus as phrase table. For efficiency
reason, we only use 25% of the corpus to train our
reordering model. LIBLINEAR (Fan et al, 2008) is
used to do the SVM optimization for RankingSVM.
We test it on both pre-reorder setting (Rank-PR)
and integrated setting (Rank-IT).
5.4 End-to-End Result
system dev web test news test
E-J
Baseline 21.45 21.12 14.18
ManR-PR 23.00 22.42 15.61
Rank-PR 22.92 22.51 15.90
Rank-IT 23.14 22.85 15.72
J-E
Baseline 25.39 24.20 14.26
Rank-PR 26.57 25.56 15.42
Rank-IT 26.72 25.87 15.27
Table 2: BLEU(%) score on dev and test data for
both E-J and J-E experiment. All settings signifi-
cantly improve over the baseline at 95% confidence
level. Baseline is the BTG phrase system system;
ManR-PR is pre-reorder with manual rule; Rank-PR
is pre-reorder with ranking reorder model; Rank-IT
is system with integrated ranking reorder model.
From Table 2, we can see our ranking reordering
model significantly improves the performance for
both English-to-Japanese and Japanese-to-English
experiments over the BTG baseline system. It also
out-performs the manual rule set on English-to-
Japanese result, but the difference is not significant.
5.5 Reordering Performance
In order to show whether the improved performance
is really due to improved reordering, we would like
to measure the reorder performance directly.
917
As we do not have access to a golden re-
ordered sentence set, we decide to use the align-
ment crossing-link numbers between aligned sen-
tence pairs as the measure for reorder performance.
We train the ranking model on 25% of our par-
allel corpus, and use the rest 75% as test data
(auto). We sample a small corpus (575 sentence
pairs) and do manual alignment (man-small). We
denote the automatic alignment for these 575 sen-
tences as (auto-small). From Table 3, we can see
setting auto auto-small man-small
None 36.3 35.9 40.1
E-J
Oracle 4.3 4.1 7.4
ManR 13.4 13.6 16.7
Rank 12.1 12.8 17.2
J-E
Oracle 6.9 7.0 9.4
Rank 15.7 15.3 20.5
Table 3: Reorder performance measured by
crossing-link number per sentence. None means the
original sentences without reordering; Oracle means
the best permutation allowed by the source parse
tree; ManR refers to manual reorder rules; Rank
means ranking reordering model.
our ranking reordering model indeed significantly
reduces the crossing-link numbers over the original
sentence pairs. On the other hand, the performance
of the ranking reorder model still fall far short of or-
acle, which is the lowest crossing-link number of all
possible permutations allowed by the parse tree. By
manual analysis, we find that the gap is due to both
errors of the ranking reorder model and errors from
word alignment and parser.
Another thing to note is that the crossing-link
number of manual alignment is higher than auto-
matic alignment. The reason is that our annotators
tend to align function words which might be left un-
aligned by automatic word aligner.
5.6 Effect of Ranking Features
Here we examine the effect of features for ranking
reorder model. We compare their influence on Rank-
ingSVM accuracy, alignment crossing-link number,
end-to-end BLEU score, and the model size. As
Table 4 shows, a major part of reduction of CLN
comes from features such as Part-of-Speech tags,
Features Acc. CLN BLEU Feat.#
E-J
tag+label 88.6 16.4 22.24 26k
+dst 91.5 13.5 22.66 55k
+pct 92.2 13.1 22.73 79k
+lex100 92.9 12.1 22.85 347k
+lex1000 94.0 11.5 22.79 2,410k
+lex2000 95.2 10.7 22.81 3,794k
J-E
tag+fw 85.0 18.6 25.43 31k
+dst 90.3 16.9 25.62 65k
+lex100 91.6 15.7 25.87 293k
+lex1000 92.4 14.8 25.91 2,156k
+lex2000 93.0 14.3 25.84 3,297k
Table 4: Effect of ranking features. Acc. is Rank-
ingSVM accuracy in percentage on the training data;
CLN is the crossing-link number per sentence on
parallel corpus with automatically generated word
alignment; BLEU is the BLEU score in percentage
on web test set on Rank-IT setting (system with in-
tegrated rank reordering model); lexn means n most
frequent lexicons in the training corpus.
dependency labels (for English), function words (for
Japanese), and the distance and punctuations be-
tween child and head. These features also corre-
spond to BLEU score improvement for End-to-End
evaluations. Lexicon features generally continue to
improve the RankingSVM accuracy and reduce CLN
on training data, but they do not bring further im-
provement for SMT systems beyond the top 100
most frequent words. Our explanation is that less
frequent lexicons tend to help local reordering only,
which is already handled by the underlying phrase-
based system.
5.7 Performance on different domains
From Table 2 we can see that pre-reorder method has
higher BLEU score on news test, while integrated
model performs better on web test set which con-
tains informal texts. By error analysis, we find that
the parser commits more errors on informal texts,
and informal texts usually have more flexible trans-
lations. Pre-reorder method makes ?hard? decision
before decoding, thus is more sensitive to parser er-
rors; on the other hand, integrated model is forced
to use a longer distortion limit which leads to more
search errors during decoding time. It is possible to
918
use system combination method to get the best of
both systems, but we leave this to future work.
6 Discussion on Related Work
There have been several studies focusing on compil-
ing hand-crafted syntactic reorder rules. Collins et
al. (2005), Wang et al (2007), Ramanathan et al
(2008), Lee et al (2010) have developed rules for
German-English, Chinese-English, English-Hindi
and English-Japanese respectively. Xu et al (2009)
designed a clever precedence reordering rule set for
translation from English to several SOV languages.
The drawback for hand-crafted rules is that they de-
pend upon expert knowledge to produce and are lim-
ited to their targeted language pairs.
Automatically learning syntactic reordering rules
have also been explored in several work. Li et
al. (2007) and Visweswariah et al (2010) learned
probability of reordering patterns from constituent
trees using either Maximum Entropy or maximum
likelihood estimation. Since reordering patterns
are matched against a tree node together with all
its direct children, data sparseness problem will
arise when tree nodes have many children (Li et
al., 2007); Visweswariah et al (2010) also men-
tioned their method yielded no improvement when
applied to dependency trees in their initial experi-
ments. Genzel (2010) dealt with the data sparseness
problem by using window heuristic, and learned re-
ordering pattern sequence from dependency trees.
Even with the window heuristic, they were unable
to evaluate all candidates due to the huge num-
ber of possible patterns. Different from the pre-
vious approaches, we treat syntax-based reordering
as a ranking problem between different source tree
nodes. Our method does not require the source
nodes to match some specific patterns, but encodes
reordering knowledge in the form of a ranking func-
tion, which naturally handles reordering between
any number of tree nodes; the ranking function is
trained by well-established rank learning method to
minimize the number of mis-ordered tree nodes in
the training data.
Tree-to-string systems (Quirk et al, 2005; Liu et
al., 2006) model syntactic reordering using minimal
or composed translation rules, which may contain
reordering involving tree nodes from multiple tree
levels. Our method can be naturally extended to deal
with such multiple level reordering. For a tree-to-
string rule with multiple tree levels, instead of rank-
ing the direct children of the root node, we rank all
leaf nodes (Most are frontier nodes (Galley et al,
2006)) in the translation rule. We need to redesign
our ranking feature templates to encode the reorder-
ing information in the source part of the translation
rules. We need to remember the source side con-
text of the rules, the model size would still be much
smaller than a full-fledged tree-to-string system be-
cause we do not need to explicitly store the target
variants for each rule.
7 Conclusion and Future Work
In this paper we present a ranking based reorder-
ing method to reorder source language to match the
word order of target language given the source side
parse tree. Reordering is formulated as a task to rank
different nodes in the source side syntax tree accord-
ing to their relative position in the target language.
The ranking model is automatically trained to min-
imize the mis-ordering of tree nodes in the training
data. Large scale experiment shows improvement on
both reordering metric and SMT performance, with
up to 1.73 point BLEU gain in our evaluation test.
In future work, we plan to extend the ranking
model to handle reordering between multiple lev-
els of source trees. We also expect to explore bet-
ter way to integrate ranking reorder model into SMT
system instead of a simple penalty scheme. Along
the research direction of preprocessing the source
language to facilitate translation, we consider to not
only change the order of the source language, but
also inject syntactic structure of the target language
into source language by adding pseudo words into
source sentences.
Acknowledgements
Nan Yang and Nenghai Yu were partially supported
by Fundamental Research Funds for the Central
Universities (No. WK2100230002), National Nat-
ural Science Foundation of China (No. 60933013),
and National Science and Technology Major Project
(No. 2010ZX03004-003).
919
References
David Chiang. 2005. A Hierarchical Phrase-Based
Model for Statistical Machine Translation. In Proc.
ACL, pages 263-270.
Michael Collins, Philipp Koehn and Ivona Kucerova.
2005. Clause restructuring for statistical machine
translation. In Proc. ACL.
R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang, and
C.-J. Lin. 2008. LIBLINEAR: A library for large lin-
ear classification. In Journal of Machine Learning Re-
search.
Michel Galley, Jonathan Graehl, Kevin Knight, Daniel
Marcu, Steve DeNeefe, Wei Wang, and Ignacio
Thayer. 2006. Scalable Inference and Training of
Context-Rich Syntactic Translation Models. In Proc.
ACL-Coling, pages 961-968.
Michel Galley and Christopher D. Manning. 2008. A
Simple and Effective Hierarchical Phrase Reordering
Model. In Proc. EMNLP, pages 263-270.
Dmitriy Genzel. 2010. Automatically Learning Source-
side Reordering Rules for Large Scale Machine Trans-
lation. In Proc. Coling, pages 376-384.
Ralf Herbrich, Thore Graepel, and Klaus Obermayer
2000. Large Margin Rank Boundaries for Ordinal Re-
gression. In Advances in Large Margin Classifiers,
pages 115-132.
Philipp Koehn, Amittai Axelrod, Alexandra Birch
Mayne, Chris Callison-Burch, Miles Osborne and
David Talbot. 2005. Edinborgh System Description
for the 2005 IWSLT Speech Translation Evaluation. In
International Workshop on Spoken Language Transla-
tion.
Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical Phrase-Based Translation. In Proc. HLT-
NAACL, pages 127-133.
Taku Kudo, Yuji Matsumoto. 2002. Japanese Depen-
dency Analysis using Cascaded Chunking. In Proc.
CoNLL, pages 63-69.
Young-Suk Lee, Bing Zhao and Xiaoqiang Luo. 2010.
Constituent reordering and syntax models for English-
to-Japanese statistical machine translation. In Proc.
Coling.
Chi-Ho Li, Minghui Li, Dongdong Zhang, Mu Li and
Ming Zhou and Yi Guan 2007. A Probabilistic Ap-
proach to Syntax-based Reordering for Statistical Ma-
chine Translation. In Proc. ACL, pages 720-727.
Yang Liu, Qun Liu, and Shouxun Lin. 2006. Tree-
to-String Alignment Template for Statistical Machine
Translation. In Proc. ACL-Coling, pages 609-616.
Marie-Catherine de Marneffe, Bill MacCartney and
Christopher D. Manning. 2006. Generating Typed
Dependency Parses from Phrase Structure Parses. In
LREC 2006
Joakim Nivre and Mario Scholz 2004. Deterministic De-
pendency Parsing for English Text. In Proc. Coling.
Franz J. Och. 2002. Statistical Machine Translation:
From Single Word Models to Alignment Template.
Ph.D.Thesis, RWTH Aachen, Germany
Franz J. Och and Hermann Ney. 2003. A Systematic
Comparison of Various Statistical Alignment Models.
Computational Linguistics, 29(1): pages 19-51.
Chris Quirk, Arul Menezes, and Colin Cherry. 2005. De-
pendency Treelet Translation: Syntactically Informed
Phrasal SMT. In Proc. ACL, pages 271-279.
A. Ramanathan, Pushpak Bhattacharyya, Jayprasad
Hegde, Ritesh M. Shah and Sasikumar M. 2008.
Simple syntactic and morphological processing can
help English-Hindi Statistical Machine Translation.
In Proc. IJCNLP.
Roy Tromble. 2009. Search and Learning for the Lin-
ear Ordering Problem with an Application to Machine
Translation. Ph.D. Thesis.
Karthik Visweswariah, Jiri Navratil, Jeffrey Sorensen,
Vijil Chenthamarakshan and Nandakishore Kamb-
hatla. 2010. Syntax Based Reordering with Automat-
ically Derived Rules for Improved Statistical Machine
Translation. In Proc. Coling, pages 1119-1127.
Chao Wang, Michael Collins, Philipp Koehn. 2007. Chi-
nese syntactic reordering for statistical machine trans-
lation. In Proc. EMNLP-CoNLL.
Dekai Wu. 1997. Stochastic Inversion Transduction
Grammars and Bilingual Parsing of Parallel Corpora.
Computational Linguistics, 23(3): pages 377-403.
Deyi Xiong, Qun Liu, and Shouxun Lin. 2006. Maxi-
mum Entropy Based Phrase Reordering Model for Sta-
tistical Machine Translation. In Proc. ACL-Coling,
pages 521-528.
Peng Xu, Jaeho Kang, Michael Ringgaard, Franz Och.
2009. Using a Dependency Parser to Improve SMT
for Subject-Object-Verb Languages. In Proc. HLT-
NAACL, pages 376-384.
Richard Zens and Hermann Ney. 2006. Discriminative
Reordering Models for Statistical Machine Transla-
tion. In Proc. Workshop on Statistical Machine Trans-
lation, HLT-NAACL, pages 127-133.
920
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 166?175,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
Word Alignment Modeling with Context Dependent Deep Neural Network
Nan Yang1, Shujie Liu2, Mu Li2, Ming Zhou2, Nenghai Yu1
1University of Science and Technology of China, Hefei, China
2Microsoft Research Asia, Beijing, China
{v-nayang,shujliu,muli,mingzhou}@microsoft.com
ynh@ustc.edu.cn
Abstract
In this paper, we explore a novel bilin-
gual word alignment approach based on
DNN (Deep Neural Network), which has
been proven to be very effective in var-
ious machine learning tasks (Collobert
et al, 2011). We describe in detail
how we adapt and extend the CD-DNN-
HMM (Dahl et al, 2012) method intro-
duced in speech recognition to the HMM-
based word alignment model, in which
bilingual word embedding is discrimina-
tively learnt to capture lexical translation
information, and surrounding words are
leveraged to model context information
in bilingual sentences. While being ca-
pable to model the rich bilingual corre-
spondence, our method generates a very
compact model with much fewer parame-
ters. Experiments on a large scale English-
Chinese word alignment task show that the
proposed method outperforms the HMM
and IBM model 4 baselines by 2 points in
F-score.
1 Introduction
Recent years research communities have seen a
strong resurgent interest in modeling with deep
(multi-layer) neural networks. This trending topic,
usually referred under the name Deep Learning, is
started by ground-breaking papers such as (Hin-
ton et al, 2006), in which innovative training pro-
cedures of deep structures are proposed. Unlike
shallow learning methods, such as Support Vector
Machine, Conditional Random Fields, and Maxi-
mum Entropy, which need hand-craft features as
input, DNN can learn suitable features (represen-
tations) automatically with raw input data, given a
training objective.
DNN did not achieve expected success until
2006, when researchers discovered a proper way
to intialize and train the deep architectures, which
contains two phases: layer-wise unsupervised pre-
training and supervised fine tuning. For pre-
training, Restricted Boltzmann Machine (RBM)
(Hinton et al, 2006), auto-encoding (Bengio et al,
2007) and sparse coding (Lee et al, 2007) are pro-
posed and popularly used. The unsupervised pre-
training trains the network one layer at a time, and
helps to guide the parameters of the layer towards
better regions in parameter space (Bengio, 2009).
Followed by fine tuning in this region, DNN is
shown to be able to achieve state-of-the-art per-
formance in various area, or even better (Dahl et
al., 2012) (Kavukcuoglu et al, 2010). DNN also
achieved breakthrough results on the ImageNet
dataset for objective recognition (Krizhevsky et
al., 2012). For speech recognition, (Dahl et al,
2012) proposed context-dependent neural network
with large vocabulary, which achieved 16.0% rel-
ative error reduction.
DNN has also been applied in Natural Lan-
guage Processing (NLP) field. Most works con-
vert atomic lexical entries into a dense, low di-
mensional, real-valued representation, called word
embedding; Each dimension represents a latent as-
pect of a word, capturing its semantic and syntac-
tic properties (Bengio et al, 2006). Word embed-
ding is usually first learned from huge amount of
monolingual texts, and then fine-tuned with task-
specific objectives. (Collobert et al, 2011) and
(Socher et al, 2011) further apply Recursive Neu-
ral Networks to address the structural prediction
tasks such as tagging and parsing, and (Socher
et al, 2012) explores the compositional aspect of
word representations.
Inspired by successful previous works, we pro-
pose a new DNN-based word alignment method,
which exploits contextual and semantic similari-
ties between words. As shown in example (a) of
Figure 1, in word pair {?juda? ??mammoth?},
the Chinese word ?juda? is a common word, but
166
mammothwill be a
jiang shi yixiang juda gongcheng
job
(a)
? ? ?? ?? ??
A :farmer Yibula said
nongmin yibula shuo : ?
?
(b)
?? ??? ?
Figure 1: Two examples of word alignment
the English word ?mammoth? is not, so it is very
hard to align them correctly. If we know that
?mammoth? has the similar meaning with ?big?,
or ?huge?, it would be easier to find the corre-
sponding word in the Chinese sentence. As we
mentioned in the last paragraph, word embedding
(trained with huge monolingual texts) has the abil-
ity to map a word into a vector space, in which,
similar words are near each other.
For example (b) in Figure 1, for the word pair
{?yibula? ? ?Yibula?}, both the Chinese word
?yibula? and English word ?Yibula? are rare name
entities, but the words around them are very com-
mon, which are {?nongmin?, ?shuo?} for Chinese
side and {?farmer?, ?said?} for the English side.
The pattern of the context {?nongmin X shuo?
? ?farmer X said?} may help to align the word
pair which fill the variableX , and also, the pattern
{?yixiang X gongcheng?? ?a X job?} is helpful
to align the word pair {?juda???mammoth?} for
example (a).
Based on the above analysis, in this paper, both
the words in the source and target sides are firstly
mapped to a vector via a discriminatively trained
word embeddings, and word pairs are scored by a
multi-layer neural network which takes rich con-
texts (surrounding words on both source and target
sides) into consideration; and a HMM-like distor-
tion model is applied on top of the neural network
to characterize structural aspect of bilingual sen-
tences.
In the rest of this paper, related work about
DNN and word alignment are first reviewed in
Section 2, followed by a brief introduction of
DNN in Section 3. We then introduce the details
of leveraging DNN for word alignment, including
the details of our network structure in Section 4
and the training method in Section 5. The mer-
its of our approach are illustrated with the experi-
ments described in Section 6, and we conclude our
paper in Section 7.
2 Related Work
DNN with unsupervised pre-training was firstly
introduced by (Hinton et al, 2006) for MNIST
digit image classification problem, in which, RBM
was introduced as the layer-wise pre-trainer. The
layer-wise pre-training phase found a better local
maximum for the multi-layer network, thus led to
improved performance. (Krizhevsky et al, 2012)
proposed to apply DNN to do object recognition
task (ImageNet dataset), which brought down the
state-of-the-art error rate from 26.1% to 15.3%.
(Seide et al, 2011) and (Dahl et al, 2012) apply
Context-Dependent Deep Neural Network with
HMM (CD-DNN-HMM) to speech recognition
task, which significantly outperforms traditional
models.
Most methods using DNN in NLP start with a
word embedding phase, which maps words into
a fixed length, real valued vectors. (Bengio et
al., 2006) proposed to use multi-layer neural net-
work for language modeling task. (Collobert et al,
2011) applied DNN on several NLP tasks, such
as part-of-speech tagging, chunking, name entity
recognition, semantic labeling and syntactic pars-
ing, where they got similar or even better results
than the state-of-the-art on these tasks. (Niehues
and Waibel, 2012) shows that machine transla-
tion results can be improved by combining neural
language model with n-gram traditional language.
(Son et al, 2012) improves translation quality of
n-gram translation model by using a bilingual neu-
ral language model. (Titov et al, 2012) learns a
context-free cross-lingual word embeddings to fa-
cilitate cross-lingual information retrieval.
For the related works of word alignment, the
most popular methods are based on generative
models such as IBM Models (Brown et al, 1993)
and HMM (Vogel et al, 1996). Discriminative ap-
proaches are also proposed to use hand crafted fea-
tures to improve word alignment. Among them,
(Liu et al, 2010) proposed to use phrase and rule
pairs to model the context information in a log-
linear framework. Unlike previous discriminative
methods, in this work, we do not resort to any hand
crafted features, but use DNN to induce ?features?
from raw words.
167
3 DNN structures for NLP
The most important and prevalent features avail-
able in NLP are the words themselves. To ap-
ply DNN to NLP task, the first step is to trans-
form a discrete word into its word embedding, a
low dimensional, dense, real-valued vector (Ben-
gio et al, 2006). Word embeddings often implic-
itly encode syntactic or semantic knowledge of
the words. Assuming a finite sized vocabulary V ,
word embeddings form a (L?|V |)-dimension em-
bedding matrix WV , where L is a pre-determined
embedding length; mapping words to embed-
dings is done by simply looking up their respec-
tive columns in the embedding matrix WV . The
lookup process is called a lookup layer LT , which
is usually the first layer after the input layer in neu-
ral network.
After words have been transformed to their em-
beddings, they can be fed into subsequent classi-
cal network layers to model highly non-linear re-
lations:
zl = fl(M lzl?1 + bl) (1)
where zl is the output of lth layer, M l is a |zl| ?
|zl?1| matrix, bl is a |zl|-length vector, and fl
is an activation function. Except for the last
layer, fl must be non-linear. Common choices for
fl include sigmoid function, hyperbolic function,
?hard? hyperbolic function etc. Following (Col-
lobert et al, 2011), we choose ?hard? hyperbolic
function as our activation function in this work:
htanh(x) =
?
?
?
1 if x is greater than 1
?1 if x is less than -1
x otherwise
(2)
If probabilistic interpretation is desired, a softmax
layer (Bridle, 1990) can be used to do normaliza-
tion:
zli =
ezl?1i
|zl|?
j=1
ez
l?1
j
(3)
The above layers can only handle fixed sized in-
put and output. If input must be of variable length,
convolution layer and max layer can be used, (Col-
lobert et al, 2011) which transform variable length
input to fixed length vector for further processing.
Multi-layer neural networks are trained with
the standard back propagation algorithm (LeCun,
1985). As the networks are non-linear and the
task specific objectives usually contain many lo-
cal maximums, special care must be taken in the
optimization process to obtain good parameters.
Techniques such as layerwise pre-training(Bengio
et al, 2007) and many tricks(LeCun et al, 1998)
have been developed to train better neural net-
works. Besides that, neural network training also
involves some hyperparameters such as learning
rate, the number of hidden layers. We will address
these issues in section 4.
4 DNN for word alignment
Our DNN word alignment model extends classic
HMM word alignment model (Vogel et al, 1996).
Given a sentence pair (e, f), HMM word alignment
takes the following form:
P (a, e|f) =
|e|?
i=1
Plex(ei|fai)Pd(ai ? ai?1) (4)
where Plex is the lexical translation probability
and Pd is the jump distance distortion probability.
One straightforward way to integrate DNN
into HMM is to use neural network to compute
the emission (lexical translation) probability Plex.
Such approach requires a softmax layer in the neu-
ral network to normalize over all words in source
vocabulary. As vocabulary for natural languages
is usually very large, it is prohibitively expen-
sive to do the normalization. Hence we give up
the probabilistic interpretation and resort to a non-
probabilistic, discriminative view:
sNN (a|e, f) =
|e|?
i=1
tlex(ei, fai |e, f)td(ai, ai?1|e, f)
(5)
where tlex is a lexical translation score computed
by neural network, and td is a distortion score.
In the classic HMM word alignment model,
context is not considered in the lexical translation
probability. Although we can rewrite Plex(ei|fai)
to Plex(ei|context of fai) to model context, it in-
troduces too many additional parameters and leads
to serious over-fitting problem due to data sparse-
ness. As a matter of fact, even without any con-
texts, the lexical translation table in HMM al-
ready contains O(|Ve| ? |Vf |) parameters, where
|Ve| and Vf denote source and target vocabulary
sizes. In contrast, our model does not maintain
a separate translation score parameters for every
source-target word pair, but computes tlex through
a multi-layer network, which naturally handles
contexts on both sides without explosive growth
of number of parameters.
168
Input
Source window e Target window f
)( 323 bzM ??
)( 212 bzM ??
ii-1 i+1 j-1 j j+1
Lookup 
LT
0zLayer f1 1zLayer f2 2z
?? ??? ? farmer yibula said
)( 101 bzM ??htanh
htanh
Layer f3 ),|,( fefet jilex
Figure 2: Network structure for computing context
dependent lexical translation scores. The example
computes translation score for word pair (yibula,
yibulayin) given its surrounding context.
Figure 2 shows the neural network we used
to compute context dependent lexical transla-
tion score tlex. For word pair (ei, fj), we take
fixed length windows surrounding both ei and fj
as input: (ei? sw2 , . . . , ei+ sw2 , fj? tw2 , . . . , fj+ tw2 ),where sw, tw stand window sizes on source and
target side respectively. Words are converted to
embeddings using the lookup table LT , and the
catenation of embeddings are fed to a classic neu-
ral network with two hidden-layers, and the output
of the network is the our lexical translation score:
tlex(ei, fj |e, f)
= f3 ? f2 ? f1 ? LT (window(ei), window(fj))
(6)
f1 and f2 layers use htanh as activation functions,
while f3 is only a linear transformation with no
activation function.
For the distortion td, we could use a lexicalized
distortion model:
td(ai, ai?1|e, f) = td(ai ? ai?1|window(fai?1))
(7)
which can be computed by a neural network sim-
ilar to the one used to compute lexical transla-
tion scores. If we map jump distance (ai ? ai?1)
to B buckets, we can change the length of the
output layer to B, where each dimension in the
output stands for a different bucket of jump dis-
tances. But we found in our initial experiments
on small scale data, lexicalized distortion does not
produce better alignment over the simple jump-
distance based model. So we drop the lexicalized
distortion and reverse to the simple version:
td(ai, ai?1|e, f) = td(ai ? ai?1) (8)
Vocabulary V of our alignment model consists
of a source vocabulary Ve and a target vocabu-
lary Vf . As in (Collobert et al, 2011), in addition
to real words, each vocabulary contains a special
unknown word symbol ?unk? to handle unseen
words; two sentence boundary symbols ?s? and
?/s?, which are filled into surrounding window
when necessary; furthermore, to handle null align-
ment, we must also include a special null symbol
?null?. When fj is null word, we simply fill the
surrounding window with the identical null sym-
bols.
To decode our model, the lexical translation
scores are computed for each source-target word
pair in the sentence pair, which requires going
through the neural network (|e| ? |f|) times; af-
ter that, the forward-backward algorithm can be
used to find the viterbi path as in the classic HMM
model.
The majority of tunable parameters in our
model resides in the lookup table LT , which is
a (L ? (|Ve| + |Vf |))-dimension matrix. For a
reasonably large vocabulary, the number is much
smaller than the number of parameters in classic
HMM model, which is in the order of (|Ve|?|Vf |).
1
The ability to model context is not unique to
our model. In fact, discriminative word alignment
can model contexts by deploying arbitrary features
(Moore, 2005). Different from previous discrim-
inative word alignment, our model does not use
manually engineered features, but learn ?features?
automatically from raw words by the neural net-
work. (Berger et al, 1996) use a maximum en-
tropy model to model the bag-of-words context for
word alignment, but their model treats each word
as a distinct feature, which can not leverage the
similarity between words as our model.
5 Training
Although unsupervised training technique such as
Contrastive Estimation as in (Smith and Eisner,
2005), (Dyer et al, 2011) can be adapted to train
1In practice, the number of non-zero parameters in clas-
sic HMM model would be much smaller, as many words do
not co-occur in bilingual sentence pairs. In our experiments,
the number of non-zero parameters in classic HMM model
is about 328 millions, while the NN model only has about 4
millions.
169
our model from raw sentence pairs, they are too
computational demanding as the lexical transla-
tion probabilities must be computed from neu-
ral networks. Hence, we opt for a simpler su-
pervised approach, which learns the model from
sentence pairs with word alignment. As we do
not have a large manually word aligned corpus,
we use traditional word alignment models such as
HMM and IBM model 4 to generate word align-
ment on a large parallel corpus. We obtain bi-
directional alignment by running the usual grow-
diag-final heuristics (Koehn et al, 2003) on uni-
directional results from both directions, and use
the results as our training data. Similar approach
has been taken in speech recognition task (Dahl et
al., 2012), where training data for neural network
model is generated by forced decoding with tradi-
tional Gaussian mixture models.
Tunable parameters in neural network align-
ment model include: word embeddings in lookup
table LT , parametersW l, bl for linear transforma-
tions in the hidden layers of the neural network,
and distortion parameters sd of jump distance. We
take the following ranking loss with margin as our
training criteria:
loss(?) =
?
every (e,f)
max{0, 1? s?(a+|e, f) + s?(a?|e, f)}
(9)
where ? denotes all tunable parameters, a+ is
the gold alignment path, a? is the highest scor-
ing incorrect alignment path under ?, and s? is
model score for alignment path defined in Eq. 5
. One nuance here is that the gold alignment af-
ter grow-diag-final contains many-to-many links,
which cannot be generated by any path. Our solu-
tion is that for each source word alignment multi-
ple target, we randomly choose one link among all
candidates as the golden link.
Because our multi-layer neural network is in-
herently non-linear and is non-convex, directly
training against the above criteria is unlikely to
yield good results. Instead, we take the following
steps to train our model.
5.1 Pre-training initial word embedding with
monolingual data
Most parameters reside in the word embeddings.
To get a good initial value, the usual approach is
to pre-train the embeddings on a large monolin-
gual corpus. We replicate the work in (Collobert
et al, 2011) and train word embeddings for source
and target languages from their monolingual cor-
pus respectively. Our vocabularies Vs and Vt con-
tain the most frequent 100,000 words from each
side of the parallel corpus, and all other words are
treated as unknown words. We set word embed-
ding length to 20, window size to 5, and the length
of the only hidden layer to 40. Follow (Turian et
al., 2010), we randomly initialize all parameters
to [-0.1, 0.1], and use stochastic gradient descent
to minimize the ranking loss with a fixed learn-
ing rate 0.01. Note that embedding for null word
in either Ve and Vf cannot be trained from mono-
lingual corpus, and we simply leave them at the
initial value untouched.
Word embeddings from monolingual corpus
learn strong syntactic knowledge of each word,
which is not always desirable for word align-
ment between some language pairs like English
and Chinese. For example, many Chinese words
can act as a verb, noun and adjective without any
change, while their English counter parts are dis-
tinct words with quite different word embeddings
due to their different syntactic roles. Thus we
have to modify the word embeddings in subse-
quent steps according to bilingual data.
5.2 Training neural network based on local
criteria
Training the network against the sentence level
criteria Eq. 5 directly is not efficient. Instead, we
first ignore the distortion parameters and train neu-
ral networks for lexical translation scores against
the following local pairwise loss:
max{0, 1? t?((e, f)+|e, f) + t?((e, f)?|e, f)}
(10)
where (e, f)+ is a correct word pair, (e, f)? is a
wrong word pair in the same sentence, and t? is as
defined in Eq. 6 . This training criteria essentially
means our model suffers loss unless it gives cor-
rect word pairs a higher score than random pairs
from the same sentence pair with some margin.
We initialize the lookup table with embed-
dings obtained from monolingual training, and
randomly initialize all W l and bl in linear layers
to [-0.1, 0.1]. We minimize the loss using stochas-
tic gradient descent as follows. We randomly cy-
cle through all sentence pairs in training data; for
each correct word pair (including null alignment),
we generate a positive example, and generate two
negative examples by randomly corrupting either
170
side of the pair with another word in the sentence
pair. We set learning rate to 0.01. As there is no
clear stopping criteria, we simply run the stochas-
tic optimizer through parallel corpus for N itera-
tions. In this work, N is set to 50.
To make our model concrete, there are still
hyper-parameters to be determined: the window
size sw and tw, the length of each hidden layer
Ll. We empirically set sw and tw to 11, L1 to
120, and L2 to 10, which achieved a minimal loss
on a small held-out data among several settings we
tested.
5.3 Training distortion parameters
We fix neural network parameters obtained from
the last step, and tune the distortion parameters
sd with respect to the sentence level loss using
standard stochastic gradient descent. We use a
separate parameter for jump distance from -7 and
7, and another two parameters for longer for-
ward/backward jumps. We initialize all parame-
ters in sd to 0, set the learning rate for the stochas-
tic optimizer to 0.001. As there are only 17 param-
eters in sd, we only need to run the optimizer over
a small portion of the parallel corpus.
5.4 Tuning neural network based on sentence
level criteria
Up-to-now, parameters in the lexical translation
neural network have not been trained against the
sentence level criteria Eq. 5. We could achieve
this by re-using the same online training method
used to train distortion parameters, except that we
now fix the distortion parameters and let the loss
back-propagate through the neural networks. Sen-
tence level training does not take larger context in
modeling word translations, but only to optimize
the parameters regarding to the sentence level loss.
This tuning is quite slow, and it did not improve
alignment on an initial small scale experiment; so,
we skip this step in all subsequent experiment in
this work.
6 Experiments and Results
We conduct our experiment on Chinese-to-English
word alignment task. We use the manually aligned
Chinese-English alignment corpus (Haghighi et
al., 2009) which contains 491 sentence pairs as
test set. We adapt the segmentation on the Chinese
side to fit our word segmentation standard.
6.1 Data
Our parallel corpus contains about 26 million
unique sentence pairs in total which are mined
from web.
The monolingual corpus to pre-train word em-
beddings are also crawled from web, which
amounts to about 1.1 billion unique sentences for
English and about 300 million unique sentences
for Chinese. As pre-processing, we lowercase all
English words, and map all numbers to one spe-
cial token; and we also map all email addresses
and URLs to another special token.
6.2 Settings
We use classic HMM and IBM model 4 as our
baseline, which are generated by Giza++ (Och and
Ney, 2000). We train our proposed model from re-
sults of classic HMM and IBM model 4 separately.
Since classic HMM, IBM model 4 and our model
are all uni-directional, we use the standard grow-
diag-final to generate bi-directional results for all
models.
Models are evaluated on the manually aligned
test set using standard metric: precision, recall and
F1-score.
6.3 Alignment Result
It can be seen from Table 1, the proposed model
consistently outperforms its corresponding base-
line whether it is trained from alignment of classic
HMM or IBM model 4. It is also clear that the
setting prec. recall F-1
HMM 0.768 0.786 0.777
HMM+NN 0.810 0.790 0.798
IBM4 0.839 0.805 0.822
IBM4+NN 0.885 0.812 0.847
Table 1: Word alignment result. The first row
and third row show baseline results obtained by
classic HMM and IBM4 model. The second row
and fourth row show results of the proposed model
trained from HMM and IBM4 respectively.
results of our model also depends on the quality
of baseline results, which is used as training data
of our model. In future we would like to explore
whether our method can improve other word align-
ment models.
We also conduct experiment to see the effect
on end-to-end SMT performance. We train hier-
171
archical phrase model (Chiang, 2007) from dif-
ferent word alignments. Despite different align-
ment scores, we do not obtain significant differ-
ence in translation performance. In our C-E exper-
iment, we tuned on NIST-03, and tested on NIST-
08. Case-insensitive BLEU-4 scores on NIST-08
test are 0.305 and 0.307 for models trained from
IBM-4 and NN alignment results. The result is not
surprising considering our parallel corpus is quite
large, and similar observations have been made in
previous work as (DeNero and Macherey, 2011)
that better alignment quality does not necessarily
lead to better end-to-end result.
6.4 Result Analysis
6.4.1 Error Analysis
From Table 1 we can see higher F-1 score of our
model mainly comes from higher precision, with
recall similar to baseline. By analyzing the results,
we found out that for both baseline and our model,
a large part of missing alignment links involves
stop words like English words ?the?, ?a?, ?it? and
Chinese words ?de?. Stop words are inherently
hard to align, which often requires grammatical
judgment unavailable to our models; as they are
also extremely frequent, our model fully learns
their alignment patterns of the baseline models,
including errors. On the other hand, our model
performs better on low-frequency words, espe-
cially proper nouns. Take person names for ex-
ample. Most names are low-frequency words, on
which baseline HMM and IBM4 models show the
?garbage collector? phenomenon. In our model,
different person names have very similar word em-
beddings on both English side and Chinese side,
due to monolingual pre-training; what is more, dif-
ferent person names often appear in similar con-
texts. As our model considers both word embed-
dings and contexts, it learns that English person
names should be aligned to Chinese person names,
which corrects errors of baseline models and leads
to better precision.
6.4.2 Effect of context
To examine how context contribute to alignment
quality, we re-train our model with different win-
dow size, all from result of IBM model 4. From
Figure 3, we can see introducing context increase
the quality of the learned alignment, but the ben-
efit is diminished for window size over 5. On the
other hand, the results are quite stable even with
large window size 13, without noticeable over-
0.740.76
0.780.8
0.820.84
0.86
1 3 5 7 9 11 13
Figure 3: Effect of different window sizes on word
alignment F-score.
fitting problem. This is not surprising consider-
ing that larger window size only requires slightly
more parameters in the linear layers. Lastly, it
is worth noticing that our model with no context
(window size 1) performs much worse than set-
tings with larger window size and baseline IBM4.
Our explanation is as follows. Our model uses
the simple jump distance based distortion, which
is weaker than the more sophisticated distortions
in IBM model 4; thus without context, it does not
perform well compared to IBM model 4. With
larger window size, our model is able to produce
more accurate translation scores based on more
contexts, which leads to better alignment despite
the simpler distortions.
IBM4+NN F-1
1-hidden-layer 0.834
2-hidden-layer 0.847
3-hidden-layer 0.843
Table 3: Effect of different number of hidden lay-
ers. Two hidden layers outperform one hidden
layer, while three hidden layers do not bring fur-
ther improvement.
6.4.3 Effect of number of hidden layers
Our neural network contains two hidden layers be-
sides the lookup layer. It is natural to ask whether
adding more layers would be beneficial. To an-
swer this question, we train models with 1, 2 and
3 layers respectively, all from result of IBM model
4. For 1-hidden-layer setting, we set the hidden
layer length to 120; and for 3-hidden-layer set-
ting, we set hidden layer lengths to 120, 100, 10
respectively. As can be seen from Table 3, 2-
hidden-layer outperforms the 1-hidden-layer set-
ting, while another hidden layer does not bring
172
word good history british served labs zetian laggards
LM
bad tradition russian worked networks hongzhang underperformers
great culture japanese lived technologies yaobang transferees
strong practice dutch offered innovations keming megabanks
true style german delivered systems xingzhi mutuals
easy literature canadian produced industries ruihua non-starters
WA
nice historical uk offering lab hongzhang underperformers
great historic britain serving laboratories qichao illiterates
best developed english serve laboratory xueqin transferees
pretty record classic delivering exam fuhuan matriculants
excellent recording england worked experiments bingkun megabanks
Table 2: Nearest neighbors of several words according to their embedding distance. LM shows neighbors
of word embeddings trained by monolingual language model method; WA shows neighbors of word
embeddings trained by our word alignment model.
improvement. Due to time constraint, we have
not tuned the hyper-parameters such as length of
hidden layers in 1 and 3-hidden-layer settings, nor
have we tested settings with more hidden-layers.
It would be wise to test more settings to verify
whether more layers would help.
6.4.4 Word Embedding
Following (Collobert et al, 2011), we show some
words together with its nearest neighbors using the
Euclidean distance between their embeddings. As
we can see from Table 2, after bilingual training,
?bad? is no longer in the nearest neighborhood of
?good? as they hold opposite semantic meanings;
the nearest neighbor of ?history? is now changed
to its related adjective ?historical?. Neighbors of
proper nouns such as person names are relatively
unchanged. For example, neighbors of word
?zetian? are all Chinese names in both settings.
As Chinese language lacks morphology, the single
form and plural form of a noun in English often
correspond to the same Chinese word, thus it is
desirable that the two English words should have
similar word embeddings. While this is true for
relatively frequent nouns such as ?lab? and ?labs?,
rarer nouns still remain near their monolingual
embeddings as they are only modified a few times
during the bilingual training. As shown in last
column, neighborhood of ?laggards? still consists
of other plural forms even after bilingual training.
7 Conclusion
In this paper, we explores applying deep neu-
ral network for word alignment task. Our model
integrates a multi-layer neural network into an
HMM-like framework, where context dependent
lexical translation score is computed by neural
network, and distortion is modeled by a sim-
ple jump-distance scheme. Our model is dis-
criminatively trained on bilingual corpus, while
huge monolingual data is used to pre-train word-
embeddings. Experiments on large-scale Chinese-
to-English task show that the proposed method
produces better word alignment results, compared
with both classic HMM model and IBM model 4.
For future work, we will investigate more set-
tings of different hyper-parameters in our model.
Secondly, we want to explore the possibility of
unsupervised training of our neural word align-
ment model, without reliance of alignment result
of other models. Furthermore, our current model
use rather simple distortions; it might be helpful
to use more sophisticated model such as ITG (Wu,
1997), which can be modeled by Recursive Neural
Networks (Socher et al, 2011).
Acknowledgments
We thank anonymous reviewers for insightful
comments. We also thank Dongdong Zhang, Lei
Cui, Chunyang Wu and Zhenyan He for fruitful
discussions.
References
Yoshua Bengio, Holger Schwenk, Jean-Se?bastien
Sene?cal, Fre?deric Morin, and Jean-Luc Gauvain.
2006. Neural probabilistic language models. Inno-
vations in Machine Learning, pages 137?186.
Yoshua Bengio, Pascal Lamblin, Dan Popovici, and
173
Hugo Larochelle. 2007. Greedy layer-wise training
of deep networks. Advances in neural information
processing systems, 19:153.
Yoshua Bengio. 2009. Learning deep architectures for
ai. Foundations and Trends R? in Machine Learning,
2(1):1?127.
Adam L. Berger, Vincent J. Della Pietra, and Stephen
A. Della Pietra. 1996. A maximum entropy ap-
proach to natural language processing. Comput.
Linguist., 22(1):39?71, March.
JS Bridle. 1990. Neurocomputing: Algorithms, archi-
tectures and applications, chapter probabilistic inter-
pretation of feedforward classification network out-
puts, with relationships to statistical pattern recogni-
tion.
Peter F Brown, Vincent J Della Pietra, Stephen A Della
Pietra, and Robert L Mercer. 1993. The mathemat-
ics of statistical machine translation: Parameter esti-
mation. Computational linguistics, 19(2):263?311.
David Chiang. 2007. Hierarchical phrase-based trans-
lation. computational linguistics, 33(2):201?228.
Ronan Collobert, Jason Weston, Le?on Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
scratch. The Journal of Machine Learning Re-
search, 12:2493?2537.
George E Dahl, Dong Yu, Li Deng, and Alex Acero.
2012. Context-dependent pre-trained deep neural
networks for large-vocabulary speech recognition.
Audio, Speech, and Language Processing, IEEE
Transactions on, 20(1):30?42.
John DeNero and Klaus Macherey. 2011. Model-
based aligner combination using dual decomposi-
tion. In Proc. ACL.
Chris Dyer, Jonathan Clark, Alon Lavie, and Noah A
Smith. 2011. Unsupervised word alignment with ar-
bitrary features. In Proceedings of the 49th Annual
Meeting of the Association for Computational Lin-
guistics: Human Language Technologies-Volume 1,
pages 409?419. Association for Computational Lin-
guistics.
Aria Haghighi, John Blitzer, John DeNero, and Dan
Klein. 2009. Better word alignments with su-
pervised itg models. In Proceedings of the Joint
Conference of the 47th Annual Meeting of the ACL
and the 4th International Joint Conference on Natu-
ral Language Processing of the AFNLP: Volume 2-
Volume 2, pages 923?931. Association for Compu-
tational Linguistics.
Geoffrey E Hinton, Simon Osindero, and Yee-Whye
Teh. 2006. A fast learning algorithm for deep be-
lief nets. Neural computation, 18(7):1527?1554.
Koray Kavukcuoglu, Pierre Sermanet, Y-Lan Boureau,
Karol Gregor, Michae?l Mathieu, and Yann LeCun.
2010. Learning convolutional feature hierarchies for
visual recognition. Advances in Neural Information
Processing Systems, pages 1090?1098.
Philipp Koehn, Franz Josef Och, and Daniel Marcu.
2003. Statistical phrase-based translation. In
Proceedings of the 2003 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics on Human Language Technology-
Volume 1, pages 48?54. Association for Computa-
tional Linguistics.
Alex Krizhevsky, Ilya Sutskever, and Geoff Hinton.
2012. Imagenet classification with deep convolu-
tional neural networks. In Advances in Neural Infor-
mation Processing Systems 25, pages 1106?1114.
Yann LeCun, Le?on Bottou, Yoshua Bengio, and Patrick
Haffner. 1998. Gradient-based learning applied to
document recognition. Proceedings of the IEEE,
86(11):2278?2324.
Yann LeCun. 1985. A learning scheme for asymmet-
ric threshold networks. Proceedings of Cognitiva,
85:599?604.
Honglak Lee, Alexis Battle, Rajat Raina, and An-
drew Y Ng. 2007. Efficient sparse coding algo-
rithms. Advances in neural information processing
systems, 19:801.
Shujie Liu, Chi-Ho Li, and Ming Zhou. 2010. Dis-
criminative pruning for discriminative itg alignment.
In Proceedings of the 48th Annual Meeting of the As-
sociation for Computational Linguistics, ACL, vol-
ume 10, pages 316?324.
Y MarcAurelio Ranzato, Lan Boureau, and Yann Le-
Cun. 2007. Sparse feature learning for deep belief
networks. Advances in neural information process-
ing systems, 20:1185?1192.
Robert C Moore. 2005. A discriminative framework
for bilingual word alignment. In Proceedings of
the conference on Human Language Technology and
Empirical Methods in Natural Language Process-
ing, pages 81?88. Association for Computational
Linguistics.
Jan Niehues and Alex Waibel. 2012. Continuous
space language models using restricted boltzmann
machines. In Proceedings of the nineth Interna-
tional Workshop on Spoken Language Translation
(IWSLT).
Franz Josef Och and Hermann Ney. 2000. Giza++:
Training of statistical translation models.
Frank Seide, Gang Li, and Dong Yu. 2011. Conversa-
tional speech transcription using context-dependent
deep neural networks. In Proc. Interspeech, pages
437?440.
174
Noah A Smith and Jason Eisner. 2005. Contrastive
estimation: Training log-linear models on unlabeled
data. In Proceedings of the 43rd Annual Meeting
on Association for Computational Linguistics, pages
354?362. Association for Computational Linguis-
tics.
Richard Socher, Cliff C Lin, Andrew Y Ng, and
Christopher D Manning. 2011. Parsing natural
scenes and natural language with recursive neu-
ral networks. In Proceedings of the 26th Inter-
national Conference on Machine Learning (ICML),
volume 2, page 7.
Richard Socher, Brody Huval, Christopher D Manning,
and Andrew Y Ng. 2012. Semantic compositional-
ity through recursive matrix-vector spaces. In Pro-
ceedings of the 2012 Joint Conference on Empiri-
cal Methods in Natural Language Processing and
Computational Natural Language Learning, pages
1201?1211. Association for Computational Linguis-
tics.
Le Hai Son, Alexandre Allauzen, and Franc?ois Yvon.
2012. Continuous space translation models with
neural networks. In Proceedings of the 2012 confer-
ence of the north american chapter of the associa-
tion for computational linguistics: Human language
technologies, pages 39?48. Association for Compu-
tational Linguistics.
Ivan Titov, Alexandre Klementiev, and Binod Bhat-
tarai. 2012. Inducing crosslingual distributed rep-
resentations of words.
Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010.
Word representations: a simple and general method
for semi-supervised learning. Urbana, 51:61801.
Stephan Vogel, Hermann Ney, and Christoph Tillmann.
1996. Hmm-based word alignment in statistical
translation. In Proceedings of the 16th conference
on Computational linguistics-Volume 2, pages 836?
841. Association for Computational Linguistics.
Dekai Wu. 1997. Stochastic inversion transduction
grammars and bilingual parsing of parallel corpora.
Computational linguistics, 23(3):377?403.
175
