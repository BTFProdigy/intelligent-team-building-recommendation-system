Generation in the Lambek Calculus Framework:  an Approach with 
Semantic Proof Nets 
Sylvain Pogodalla 
sylvain.pogodalla @ xrce.xerox.com 
Xerox Researce Centre Europe 
6, chemin de Maupertuis 
38240 Meylan - -  France 
1 Introduction 
Thc lincar logic (Girard, 1987) provides a power- 
ful framcwork to cxprcss categorial gt'ammars (Aj- 
dukicwicx, 1935) and Lambek calculus (Lambek, 1958), 
and a lot of work has presented proof nets uses for lin- 
guistic purposcs, with a special look at proof nets for 
Lambek calculus (Roorda, 1991; Lamarche and Retor6, 
1996). But they have mainly explored the syntactic a- 
pabilities of proof nets, describing parsing processes. 
This paper wants to focus on the generation capa- 
bilities of proof nets thanks to their semantic readings 
as expressed in (de Groote and Retor6, 1996). The 
main features of our proposal consist in the use of proof 
nets lot Lambek calculus, of the Curry-Howard iso- 
morplaisna (Howard, 1980; Girard et al, 1988), of se- 
mantic proof nets with semantic expressions ?t la Mon- 
tagu? (Montague, 1974; Dowry et al, 1981), and in an 
algorithm for proof search with a target proof net. 
Unlike a previous proposal for generation in the Lam- 
bek calculus framework (Merenciano and Mort'ill, 1997), 
this point of view avoids the use of the A-term unification 
to lead the generation process. And the algorithmic un- 
decidability of this latter mechanism (from second order 
unification) does not occur any more. 
In this work, we do not consider the choice of lexi- 
cal items from a given semantic expression the syntactic 
rcalization of which we want to generate, but rather tile 
way we can associate given lexical entries to fit the given 
semantic expression and generate a syntactically correct 
cxpression. For this purpose, we express our problem as 
a proof search one in (multiplicative) linear logic which 
is decidable. Moreover, we characterize the semantic 
recipes of lexical items that provide a polynomial solu- 
tion for the generation process. 
2 Multi Usage Proof Nets 
2.1 Proof Nets 
(Girard, 1987) introduced proof nets formalism as the 
natural deduction syntax for linear logic, also studied 
in (Retor6, 1993). They represent proofs in linear logic 
with more accuracy than sequential proofs: on one hand 
they are more compact, on the other hand they identify 
unessentially different sequential proofs (for instance in 
the order of the rules introduction). 
From a one-sided sequent and a sequential proof of 
it, we obtain a proof net by unfolding every formula as 
a tree (whose nodes are the binary connectives and the 
leaves are formulas, e.g. atomic ones) and linking to- 
gether the formulas occurring in the same axiom rule of 
tile sequent calculus. 
But proof nets have a more intrinsic definition that pre- 
vents us to come back every time to sequential proofs. 
They can be defined as graphs with a certain property 
(i.e. verifying a correctness criterion) such that every 
proof net with this property corresponds to a sequential 
proof and such that every proof net built from a sequen- 
tial proof has this property. So that we do not present he 
sequent calculus but only the proof net calculus. 
In this paper, we do not consider all the proof nets, but 
a part of the multiplicative ones: those of the intuition- 
istic implicative linear logic. In this case, sequents are 
made of several antecedent \[brmulas, but only one succe- 
dent formula. To deal with tile intuitionistic notion with 
proof nets (since we consider one-sided sequents), we 
use the notion of polarities with the input (,: negative) 
and the output (o: positive) (Danos, 1990; Lamarche, 
1995) to decorate formulas. Positive ones correspond to 
succedent formulas and negative ones to antecedent for- 
mulas. 
Given the links of table 1, we define proof structures 
as graphs made of these links such that: 
1. any premise of any link is connected to exactly one 
conclusion of some other link; 
2. any conclusion of any link is connected to at most 
one premise of some other link; 
3. input (resp. output) premises are connected to input 
(resp. output) conclusions of the same type. 
Note that the two links for tile negative and positive 
implications correspond to the two connectives of the lin- 
ear logic: Tensor and Par, so that we name these links 
after these latter connectives. But in the following, only 
the graphical forms of the links play a role. 
Proof nets are proof structures that respect he correct- 
ness criterion. 
We mentioned the intrinsic definition of proof nets that 
enables the complete representation f sequential proofs. 
Tile cut elimination property of sequent calculus also ap- 
pears intrinsically in the proof net formalism with a sire- 
"/1131 70
Table 1: Links 
Name Axiom Tensor Par Cut 
Link CI C2 ~ 2 
C 
~, g2 
" ' \ l / /  
C 
P, 'cmises none  t)1, P2 Pl , P2 Pl ,  P2 
Conc lus ions  c l ,  c2 c none  
C 1 :A  + 
o , :A -  
Pl : ,4- 
P2 : B + 
e : (A -o  B)+ 
C 
Pl : A + 
P2 : /3 -  
c : (A  ---0 B) -  
,,O I :A -  
P2 :A+ 
Types 
Table 2: Cut-elimination rewriting rules 
x x y y 
i ......................... ! ............................... 
Y Y x x 
,l' 1 ./3 2 
Y 
Yi Y2 
Y 
xl x:) Yl Y2 
L J 
pie rewriting process described in table 2 (in case of com- 
plex formulas as in the third rewriting rule, those rules 
can apply again on the result and propagate until reach- 
ing atoms). 
2.2 Syntactic Proof Nets 
Definitions of proof nets tbr Lambek calculus first ap- 
peared in (Roorda, 1991 ). They naturally raised as Lam- 
bek calculus is an intuitionistic fragment of non commu- 
tative linar logic (with two linear implications: "'\" on 
the left and " /"  on tile right), and the consequences on 
the proof net calculus we presented in section 2.1 are: 
. we get two tensor links: one for the formulas 
(B /A) -  (the one in table 1) and one lbr the for- 
mula (B \A) -  (just inverse the polarities of the 
premises). And two par links : one for the lbrmula 
(A \B)  + and one for (A /B)  + (idem); 
? formulas in Lambek's equents are ordered, so that 
conclusions of the proof nets are cyclically ordered 
and axiom links may not cross. 
If T v is the set of basic types (e.g. S, NP . . .  ), the set 
T of syntactic types ~bllows T ::= ~\[T \T \ [T /T .  
Note that from a syntactic ategory, we can untbld the 
formula to obtain a graph which only lacks axiom links 
to become a proof structure. So that the parsing process 
in this framework is, given the syntactic ategories of the 
items and their order, to put non crossing axiom links 
such that the proof structure is a proof net. It means there 
is a proof of .b' given types in a certain order. For tech- 
nical reasons, the order of the conclusions (i.e. the types 
used) in the proof net to prove S is the reverse order of 
the words associated to these types. 
As an example, with the lexicon of table 3, proving 
that John lives in Paris is a correct sentence leads to find 
axiom links between the atoms in the figure l(a). Fig- 
ure I(b) shows it actually happens and proves the syn- 
tactic correctness of the sentence. 
Table 3: Lexicon 
lexical entry syntaxiccategory 
John NP 
Paris N P 
lives N P\,b' 
in (,S'\,S') / N P 
2.3 Semantic Proof Nets 
In this section, we present how (de Groote and RetortL 
1996) propose to use proof nets as semantic recipes. As 
a slight difference with this work, we only deal in this 
paper with semantic recipes that correspond to linear A- 
terms in the Montague's semantics framework. 
The idea of expressing the semantics with proof 
nets refers to the fact that both the A-terms (with the 
Curry-Howard isomorphism) and the proof nets repre- 
sent prooS; of intuitionistic implicative linear logic. And 
indeed, the linear A-terms may be encoded as proof nets. 
On the other hand, given an intuitionistic implicative 
proof net, a simple algorithm (given in (de Groote and 
71 
.S'- ,q'+ 
II<~---.i- o 
~ ,5'- .,?~+ 
? .V P -  \], N P i  
Paris in 1" " Ives John 
(a) Unfolding of the syntactic types 
o S+ 
Figure I: Parsing 
Rotor6, 1996), based on (Lamarche, 1995)'s dependency 
paths), wc can obtain a A-term. 
Then, instead of associating a A-term to a \[exical entry, 
wc can associate a proof net. For instance, on the seman- 
tic side, we can use the Montagovian types e and t and 
typed constants. Of course, we want to keep the compo- 
sitionalily principle of Montague's emantics that maps 
any syntactic association rule with a semantic associa- 
tion rule. We express it in a straightforward way with the 
ft~llowing homomorphism (for as many basic categories 
as required): 
"H(.:VP) = e 7?(A \B)  = "K(A)  ~ "H(B) 
"H(,~') = t "H(A/B)  = "H(B) --o "H(A) 
And for a lexical item, given its syntactic type, we as- 
SUlne its semantic proof net to verify: 
? the type of its unique output conclusion is the ho- 
momorplaic image of the syntactic type: 
? its input conclusions (if any) are decorated with 
typed constants. 
An example of such a lexicon is given in table 4. 
Figure 2: Syntactic proof net for John lives in Paris 
Let us illustrate the process on a short example. We 
use the lexicon of table 4 to parse the sentence John lives 
in Paris. The first thing is to define with the syntactic at- 
egories of the different lexical items the syntactic proof 
net of figure 2. It provides the way we should compose 
the semantic recipes of each lexical item: we take its ho- 
momorphic image as in figure 4(a), and we substitute to 
every input its semantic definition with cut-links. 
Then the cut-elimination on the resulting proof net 
gives a new proof net (on figure 4(b)) we can use as the 
semantic analysis of Jolm lives in Paris. If necessary, we 
can come back to the A-term expression:(in p) ( l i ve  j). 
i 
(b) Matching the dual atoms to obtain a 
proof net 
of John lives in Paris 
3 Generation: Stating the Problem 
Let us now consider the problem of generation. We have 
a given semantic proof net (like the one in figure 4(b)) 
and we want to gather syntactic entries with axiom links 
such that: 
I. this yields a correct (syntactic) proof net; 
2. the meaning of the resulting proof net matches the 
given semantic expression. 
As we already said it, we assume that we have some lex- 
ical entries, and we try to make the generation with these 
entries, each one used once and only once. 
Thus, if we define: 
* I/0 the semantic proof net of the expression we want 
to generate; 
* IIi the semantic proof nets associated to the given 
lexical entries i we use; 
* Ti the unfolding in proof structure of the syntactic 
formula of the lexical item i; 
? F the forest made of the syntactic trees of all the 
considered lexical entries plus the output (the type 
we want to derive). 
The generation problem (see figure 5) is to find a match- 
ing M of atomic formulas of F such that: 
1. F endowed with M (let us call this proof structure 
F ' )  is a correct proof net; 
2. when cut-linking H(F' )  with the Hi, and eliminat- 
ing these cuts, we obtain H0. 
This problem is not an original one: making proof 
search with proof nets always leads to look for match- 
ing between atomic formulas of opposite polarities. So 
that an answer to this problem would consist in taking f '  
and try every possible matching. This brute-force tech- 
nique would of course appear essentially inefficient, and 
our purpose is to use everything we know to prune tile 
search domain. 
Nevertheless, note that even with such an algorithm, 
we already reach the decidability (because the finitness 
of the number of the matchings) without making any as- 
sumption on the form of the semantic entries (neither on 
the order of the associated A-terms, nor the presence of a 
free variable). And we want to keep these good proper- 
ties in our algorithm. 
72 
Table 4: Lexicon 
lexical entry syntaxic ategory 
Jo h n N P 
Mary N P m 
Pa,is p 
Lives 
In 
Seeks 
XP 
mP\S 
(,5'\,s')/:vP 
(.VP'~,S')/(((NP\,S')/XP)\(Xp\,b')) 
associated A-term 
J 
Aa: . l i ve  x 
A~..A~/.(in .r).q 
A.r .(try(xf ind))  
semantic proof net 
II john (cf. figure 3(a)) 
\[IMary (cf. figure 3(b)) 
IIPari s (cf. figure 3(c)) 
\[Iliv? (cf. figure 3(d)) 
gin (cf. figure 3(e)) 
(cf. figure 3(t)) 
(a) 
1 ljohn 
, , i  i 
1 9 
,L<- <% ,p- ~+; 
i m <+~~nl~ - ,,!o y 'W 
(b) (c) (d) Fllive (e) Flin 
FIMary 1-!. Paris 
find 
i 
. . . . . . . . .  <-1 
\] , 
4 5 6 16 17 , - _ IY  ) ,+ 
try 
(f) Hseek s 
Figure 3: Semantic proof nets of the lexicon of table 4 
4 Cut -e l iminat ionas  Matr ix  Computat ion  
This section first establishes ome equivalent relations 
between cut-elimination on proof nets and matrix equa- 
lions. We then show how to use these equations in the 
generation process and how we can solve them. It en- 
ables us to characterize the properties required by the se- 
mantic proof nets to have a polynomial resolution of the 
generation process. 
4.1 Principles 
First, as expressed in (Girard, 1989) and refornmlated 
in (Retord, 1990: Girard, 1993; Girard, 1995), we state 
the algebraic representation f cuFeliminalion on proof 
nets. Due to lack of space, we can not develop it, but tile 
principle is to express cut-elimination between axioms 
with incidence matrices and paths in graphs. 
Let us consider aproof net U. We denote by (e i ) 1 < i<.~ 
all the vertices taking place for atoms in ft. We can 
define U the incidence matrix of axiom links, cr the in- 
cidence matrix of cut links (we assume without loss of 
generality that they happen only between axiom links), 
and II the incidence matrix of axiom links of-ff where ~- 
is the proof net resulting from all the cut eliminations on 
73 
1 llJohn 
I t - t  + 
L - - -  ? ........................................................................................................... 
\[IParis 
6-  
iiii iii 
I t  
(a) Before cut-elimination (b) After cut-elimination 
Figure 4: Semantic proof nets tor (in p)( l ive \]) 
Match ing  :11  
- ! ,,, 
Figure 5: The generation problem 
Then we have (Girard, 1989): 
I1 = (1 - o.a)U(l + ~-" (o .U)k ) (1 -  o. :') (1) 
1 
~1 (e/~) ) is  U = Moreover, s ince(c rU) i sn i lpotent , ( l+~  k
inversible, and its inverse is (1 - crU). The next section 
make explicit he relation ( I ) with a special choice of the 
base (~ i ). 
4.2 Matrix Relation for Cut Elimination 
In tile problem we are dealing with, we know II and some 
of the axiom links in/~'. Let us assume that Vi E \[1,p\], 
both ? i and 13(ei ) i are not cut-linked in L; (this assump- 
tion entails no loss of generality). 
4.3 Expressing the Reduction of U into II 
In this section, we want to give a relation equivalent to ( I ) 
which focuses on some axiom links we are interested in. 
As mentioned in section 4.2, we can consider the (ei) 
such that in ~" : 
? Vi E \[1,p\], ei is not cut-linked (then, because of 
the hypothesis made in section 4.2, B(ei)  is cut- 
linked); 
? '7'i E \ [p+ 1. p+ m\], ei is cut-linked but B(ei) is not 
cut-linked; 
? Vi E \[p + m + 1, p + 1~ + n\], both e.i and B(ei ) are 
cut-linked. 
Note: Remember we assume that there is no axiom link 
such that both its conclusions are not cut-linked. So p = 
I I I .  
I B(e ) is the atom in \[7 such that here is an axiom link between e 
and BIe). 
I 
cul -elilninal~,~n lit, 
I 
Then in this base, we express tile matrices (every ax- 
iom link of t--7 has at least one of its conclusion involved 
in a cut link): 
0 Uj !  0 \] 6 \] 
6 ..... 6 
ro : :o io~ 
o.= / ::ai   il 
\[rl~:: o ::o \] 
n =/6 i676 i i  
LO:,O ioJ 
If we define A = ( tU l I I1  - o . l tU l ) ( - r l  and X = 
Uz(1 - o'4U3) -1,  we can state the theorem: 
Theorem 1 Let -U be a correct proof net reducing in 
Res(cr, U) after cut elimination. These relations are 
equivalent: 
? Res(cr, U) = (1 - o:-')U(1 - o .U) - l (1  - o "2) 
? ( tUlII1 - o.1 tLil)U1 = o.=,~,h(1 - o'4t'3) -1 to.._, 
? A = tcr,_Xcr'., arrd U3 = X -1  -~ 0"4. 
Of course, all tire terms are defined. 
We base the proof search algorithm corresponding to the 
generation process we are dealing with on this third rela- 
tion, as explained in the next sections. 
4.4 Solving the Equations 
In this section (proof search oriented), we consider" that 
the axiom links we are looking for are those whose two 
conclusions are involved in cut links. That is we want to 
complete U3. As in the previous ection we proceeded 
74 
by equivalence, solving the equation (1) correponds to 
solving the equation 
.4 = ?r,.Y tcr._, (2) 
in .Y with X inversible. Then, we have to solve 
(r3 : X -1  +0"4  
such that tU3 = (ra and U a = 1. 
Let 0"._, ? .~,,,,,,(1R), X = (xi, j)  E A4,+(IR)and 
.1 E .XA,,(LR). Let the two sequences 1 < it < . . .  < 
i/ < m and 1 < Ji < . . .  < j/ < m be such that with 
(( , ,  6) ? \ [ i ,  ,1l\] ? \ [ \ [ ,  l l \ ] ,  Eab = (5iaSjb)i,jEtl,m\]x\[1,,1\] 2 
<, : E,,j, : ),,+ 
I l 
In other words, 0.'-uj = 1 ca> Ell E \[1,1\] A i = i h A j = 
i l l  ? 
Then 
l / 
cr.,X tcr.-_, = ( E EittJq ) * X * t( E Ei,.+j,.., )
/ t= l  /-,=1 
l / 
= E E (a i i l l+t>Jq J+2OJ i la ) l<- i ' JS rn  
l l  =1 lz=l 
It follows that i fA  = (aij)i,j = o'2-'~-" to2 then 
V(11,12) E \[1,1\]'+',xj,,j,~ = aiqi,2. (3) 
A consequence of this result is that if o4 = 0, then 
/ = n and we determine X completely with relation (3), 
and then the same for  Ua. This configuration correspond 
to the fact that in the (given) semantic proof nets, no out- 
put contains the two conclusions of a same axiom link. 
In this latter case, the computation is not so simple and 
should be mixed with word o,'der constraints. 
5 Example  
Let us process on an example the previous results. We 
still use the lexicon of table 4, and we want to generate 
(if possible) a sentence whose meaning is given by the 
proof net of ligure 7: (try(find j ))m. 
We first need to associate very atom with all index (in 
the figures, we only indicate a number i beside the atom 
to express it is el). Of course, we have to know how to 
recognize the ei that are the same in U (figure 6) and in 
11 (figure 7). This can be done by looking at the typed 
constants decorating the input conclusions (for the mo- 
ment. we don't have a general procedure in the complex 
cases). 
We also assume in this numbering that we know which 
of the atoms in H(F)  are linked to t + (the unique out- 
put). In our case where 0.4 = 0, it is not a problem to 
, { l i f i= j  
-5 , j  = Oi f i#  j 
make such a statement. In other cases, tile complexity 
would increase polynomially. 
Then, the given matrices are: 
"00010000 
00001000 
00100000 
01000000 
10000000 
00000100 
00000010 
00000001 
00000000 
-00000000 
00" 
00 
00 
00 
00 H i= 
O0 
O0 
O0 
10 
O1 
000010000~ 
000100000 
0000000010 
0100000000 
1000000000 
0000000100 
0000000001 
0000010000 
0010000000 
00000100 
0" 1 _~_ 
So 
0000000000"  
0000000000 
0000000000 
0000000000 
0000000000 
0000000100 
0000000000 
0000010000 
0000000000 
0000000000.  
0" 2 = 
00001000-  
00010000 
10000000 
01000000 
00100000 
00000000 
0O0O0100 
00000000 
00000010 
00000001 
.4 = (U-11 I I1  - o" 1 tu1) tUl l  = 
0001000000 
0000100000 
0000000010 
1000000000 
0100000000 
0000000000 
0000000001 
0000000000 
0010000000 
-000000100 
According to the definition of the (it) and tile (jr) fami- 
lies such that 0.2 = E l  El+j+, we have: 
; 4 +2 ,o I 
2 3 4 5 6 7 8 
Then 
.1;5,2 - -  1 - -  a l ,  4 
.1~3,4 - -  1 - -  a5 ,  2 
ah:;,8 ~ 1 ~ a7 ,10  
./?2, 5 -= 1 --~ a4,1 
./.'i, 7 ~ 1 - a3 ,  9 
;l~8, 6 ~-- 1 --~ a lo ,7  
X4, 3 -= I = a2, 5 
397,1 = 1 = ag, 3 
and in this case 0"4 = 0, so according to tile preceeding 
notes . \  is completely determined and 
X = Ua = 
i ooooo il 000100~ 
001000 
010000 
000000  oooooo  
C 000010 3 
We can add this matching to the syntactic forest of fig- 
ure 8(a) (do not forget that//3 represents the edges be- 
tween ei with i E \[17,22\])and obtain on F the matching 
of figure 8(b). 
75 
~L 
m 
B 
- ! i  
rl 
+ 
% 
+- \ i/ 
/" /" 
+ 
\ 
\ / 
/ 
" \  
i ;  =~ 
i ,  / 
+ 
t*'. 
e-  
c 
t " -  
21 
i 
,1 51 16 7 
Y ' "C  : : 
try j m 
find F igure 7: Marking atoms on I I  
8 
t + 
t! 22 23 24 25 ; ~ _ ~  26 e+ 
t+ 
t- ~.--- 
seeks 
e + 
27 
(a) The syntactic forest 
e-  
J~4m 
28 
e-~ t 4 
Mao" 
21 22 23 24 25 
26 
e i ~ 5 "1" 
seeks 
27 ~ 
I 
1 
28 
J~,hn Mary 
8 
t ? 
(b) The syntactic forest endowed with the matching described by 
Figure 8: Applying the matching on the syntactic forest 
We still have to ensure the correctness of this proof net 
(because we add all the tensor and par links), but it has a 
quadratic complexity (less than the matrix computation). 
In this case, it is correct. 
Note: 
? Actually, this only gives us the axiom links. It still 
necessitates to compute the word order to have no 
crossing axiom link. This can be done from the ax- 
iom links easier than quadratic time: it is a well- 
bracketing check. Here, it is easy to see that putting 
76  
the John item on the left would achieve the result of 
Mary seeks John, 
? The choice of seeks and its high order type (for in- 
tcnsionnality) shows there is no limitation on the or- 
der of the A-term. 
6 Conc lus ion  
We took advantage of proof nets on the semantic point 
of view and we expressed the generation process as a 
guided proof search. On top of keeping the decidability 
property of this framework, we characterized the seman- 
tic proof nets that enable a polynomial time process. 
Such properties are crucial because it is the central part 
of the generation process (considering Lambek calculus). 
But there are other things left to look at. As the very next 
steps, we should work on the atoms numbering and the 
choice of the lexical items. Appropriate interactions be- 
tween word order contraints and matrix resolution in the 
hard case should also be considered. Moreover, another 
point is to benefit from the power of linear logic and deal 
with non linear A-terms. 
Finally. since different extensions of Lambek calcu- 
lus based on proof nets (Moortgat, 1996; Lecomte and 
Retor6, 1995) have been considered, we hope our pro- 
posal and its good properties to apply to other linguistic 
approaches. 
Acknowledgments  
I would like to thank Christian Retor6 who pointed out 
to me Girard's algebraic interpretation of the cut elimi- 
nation. 
Re ferences  
Kazimierz Ajdukiewicz. 1935. Die syntaktische Kon- 
nexitat. Studia Philosophica, 1:1-27. English trans- 
lation in Storrs McCall (ed), Polish Logic 1920-1939, 
Oxford University Press, pp. 207-231. 
Vincent Danos. 1990. Une Application de la Logique 
Lin6aire fs I'F.tude des Processus de Normalisation 
(principalement duA-calcul). Ph.D. thesis, Universit6 
Paris VII, June. 
Philippe de Groote and Chritian Retor& 1996. On 
the semantic readings of proof-nets. In Glyn Morrill 
Gccrt-Jaal Kruijff and Dick Oehrle, editors, Formal 
Grammar, pages 57-70, Prague, August. FoLLI. 
David R. Dowty, Robert E. Wall, and Stanley Peters. 
1981. hztroduction to Montague Semantics. Kluwer 
Academic Publishers. 
Jean-Yves Girard, Yves Lafont, and P. Taylor. 1988. 
Proofs" and Tyl?es. Cambridge Tracts in Theoretical 
Computer Science 7. Cambridge University Press. 
Jean-Yves Girard. 1987. Linear logic. Theoretical 
Computer Science, 50: I - 102. 
Jean-Yves Girard. 1989. Geometry of interaction I: In- 
terpretation of system F. In C. Bonotto, R. Ferro, 
S. Valentini, and A. Zanardo, editors, Logic Collo- 
quium '88, pages 221-260. North-Holland. 
Jean-Yves Girard. 1993. Linear logic: Its syntax and se- 
mantics. In J.-Y. Girard NS Y. Latont and L. Regnier. 
editors, Advances in Linear Logic, Ithaca, New York, 
June, 
Jean-Yves Girard. 1995. Geometry of interaction III: 
The general case. In J.-Y. Girard, Y. Lafont, and 
L. Regnier, editors, Advances in Linear Logic, pages 
329-389. Cambridge University Press. Proceedings 
of the Workshop on Linear Logic, Ithaca, New York, 
June 1993. 
W. A. Howard, 1980. To H. B. Curry: Essays on combi- 
natory logic, Lambda Calculus and Formalism, chap- 
ter The Formula~-as-Types Notion of Construction, 
pages 479-490. Academic Press, 
Franqois Lamarche and Christian Retor6. 1996. Proof- 
nets for the lambek calculus - an overview. In 
V. Michele Abrusci and Claudio Casadio, editors, 
Proceedings 1996 Roma Workshop. Proofs and Lin- 
guistic Categories, pages 241-262. Editrice CLUEB, 
Bologna, April. 
Franqois Lamarche. 1995. Games semantics for full 
propositional linear logic. In Proceedings, Tenth An- 
nual IEEE Symposium on Logic in Computer Science, 
pages 464-473, San Diego, California, 26-29 June. 
IEEE Computer Society Press. 
Joachim Lambek. 1958. The mathematics of sen- 
tence structure. American Mathematical Monthly, 
65(3):! 54-170. 
Alain Lecomte and Christian Retor6. 1995. Pomset 
logic as an alternative categorial grammar. In Formal 
Grammar, Barcelona. 
Josep M. Merenciano and Glyn Morrill. 1997. Genera- 
tion as deduction on labelled proof nets. In Christian 
Retor6, editor, Proceedings of the 1st International 
Conference on Logical Aspects of Computational Lin- 
guistics (LACL-96), volume 1328 of LNAI, pages 310- 
328, Berlin, September23-25. Springer. 
Richard Montague. 1974. Formal Philosophy: Selected 
Papers of Richard Montague. Yale University Press, 
New Haven, CT. 
Michael Moortgat. 1996. Categorial type logics. In Jo- 
han van Benthem and Alice ter Meulen, editors, Hand- 
book of Logic attd Language, pages 5-91. Elsevier 
Science Publishers, Amsterdam. 
Christian Retor6. 1990. A note on turbo cut elimination. 
Manuscript, September. 
Christian Retor6. 1993. R~seaux et s~quents ordonn~s. 
Ph.D. thesis, University of Paris VII. 
Dirk Roorda. 1991. Resource Logics: Proof-theoretical 
htvestigations. Ph.D. thesis, University of Amster- 
dam, September. 
77 
Generation, Lambek Calculus, Montague's Semantics 
and Semantic Proof Nets 
Syivain Pogodalla 
Sylvain.Pogodalla@xrce.xerox.com 
Xerox Research Centre Europe 
6, chemin de Maupertuis 
38240 Meylan - -  France 
Abstract 
Most of the studies in the framework of Lambek 
calculus have considered the parsing process and 
ignored the generation process. This paper wants 
to rely on the close link between Lambek calculus 
and linear logic to present a method for the genera- 
tion process with semantic proof nets. We express 
the process as a proof search procedure based on a 
graph calculus and the solutions appear as a matrix 
computation preserving the decidability properties, 
and we characterize a polynomial time case. 
1 Introduction 
From the type logical grmnmars point of view, the 
parametric part of the language analysis is the lexi- 
con, and the constant one is the logical rules. This 
should of course hold both for parsing and genera- 
tion, hence we can consider the reversibility proper- 
ties of such grammars. And a relevant problem is to 
compare the complexity of the two cases. 
For Lambek calculus (Lambek, 1958), the pars- 
ing complexity is still an open problem. But the 
question arises to know how to generate in this 
framework, and how d(~cult (on the computational 
side) it is. (Merenciano and Morrill, 1997) an- 
swered with a labelled deductive system guided 
with A-term unification. But a drawback of this lat- 
ter mechanism consists in its algorithmic undecid- 
ability (from second order unification). 
Relying on the linear logic (Girard, 1987) (which 
provides a powerful framework to express Lam- 
bek calculus, specially with proof nets for the lat- 
ter (Roorda, 1991; Lamarche and Retor6, 1996)), 
this paper wants to adress the problem of finding 
the way we can associate given lexical entries to fit 
a given semantic expression and generate a syntacti- 
cally correct expression (for the moment, we do not 
care to the choice of the lexical items). For this pur- 
pose, we express our problem as a proof search one 
in (multiplicative) linear logic which is decidable. 
Moreover, we characterize the semantic recipes of 
lexical items that provide a polynomial solution for 
the syntactic realization process. Then we give an 
example of this process. 
2 Proof Nets for Linear Logic 
Linear logic (Girard, 1987) proposes for proofs a 
morn compact and accurate syntax than sequent cal- 
culus: proof nets (they group distinct sequential 
proofs that only have inessential differences). They 
have both a related to sequential proof definition 
and a geometrical definition: they can be defined 
as a class of graphs (proof structures) satisfying a 
geometrical property so that every proof net corre- 
sponds to a sequential proof and every proof struc- 
ture built from a sequential proof has this prop- 
erty (Retor6, 1998). 
In this paper, we only consider proof nets of the 
intuitionistic implicative linear logic: sequents are 
made of several antecedent formulas, but only one 
succedent formula. To deal with the intuitionis- 
tic notion for proof nets (since we consider one- 
sided sequents), we use the notion of polarities with 
the input (o: negative) and the output (o: posi- 
tive) (Danes, 1990; Lamarche, 1995) to decorate 
formulas. Positive ones correspond to succedent 
formulas and negative ones to antecedent formulas. 
Given the links of table 1, we define proof struc- 
tures (we consider implicative fragment) as graphs 
made of these links such that: 
1. any premise of any link is connected to exactly 
one conclusion of some other link; 
2. any conclusion of any link is connected to at 
most one premise of some other link; 
3. input (resp. output) premises are connected to 
input (resp. output) conclusions of the same 
type. 
Proof nets are proof structures that respect he cor- 
rectness criterion. 
628 
Table 1: Links 
Name Axiom Tensor Par Cut 
pl 1)~ Pl P2 
Premises none P l ,  P2 P l  ~ P2 P l ,  P2 
Conclusions Cl, c2 c none 
Types cl :A + c2 :A -  
C 
Pl :A + 
p2:B-  
c : (A - -o /3) -  
p l  :A -  
P2 : 13 + 
c: (A -o B)+ 
pl :A -  
P2 : A + 
The last link of table 1, the Cut link, allows the 
combination of proofs of 17 I- A and of A, A t- /3 
into a single proof of I', A I- /3. In sequential cal- 
culs, tile cut-elimination property states that there 
exists a normal (not using the Cut rule) proof for 
the same sequent only IYom premises of 17 and A 
(and builds it). 
Of course, this property hokls for proof nets too. 
And to enforce the intrinsic definition of these latter, 
a simple rewriting process (described in table 2) ac- 
tually performs the cut-elimination (in case of com- 
plex fornmlas as in the third rewriting rule, those 
rules can apply again on the result and propagate 
until reaching atoms). 
2.1 Proof Nets for Lambek Calculus 
As Lambek calculus is an intuitionistic l'ragment of 
non commutative linar logic (with two linear impli- 
cations: "\"  on the left and "/"  on the right), proof 
nets for it naturally appeared in (Roorda, 1991). 
They slightly differ from those of table 1 : 
? we get two tensor links: one for the fornmla 
( /3 /A) -  (the one in table 1) and one for the 
formula ( /3 \A) -  (just inverse the polarities of 
the premises). And two par links: one for the 
fommla (A \B)  + and one for (A /B)  + (idem); 
? formulas in Lambek's equents arc ordered, so 
that conclusions of the proof nets are cyclically 
ordered and axiom links may not cross. 
From a syntactic ategory, we can unfold the for- 
mula to obtain a graph which only lacks axiom links 
to become aproof structure. So that the parsing pro- 
cess in this framework is, given the syntactic ate- 
gories of the items and their order, to put non cross- 
ing axiom links such that the proof structure is a 
proof net. It means there is a proof of ,5' given types 
in a certain order. Proving that John lives in Palls 
is a correct sentence w.r.t, the lexicon of table 3 
(the two first columns) is finding axiom links be- 
tween the atoms in the figme 1 (a) so that the proof 
structure is correct. Figure l(b) shows it actually 
happens (for technical reasons, ill the proof net, the 
order ot' the syntactic ategories i the inverse of the 
order of the words in the sentence to be analysed. 
Figure 1 (c) shows John lives Palls in cannot be suc- 
cessfully parsed). 
2.2 Proof Nets for Montague's Semantics 
Capitalizing on tile fact that both A-torms (with the 
Curry-Howmzl isomorphism) and proof nets repre- 
sent proofs of intuitionistic implicative linear logic, 
(de Groote and Retor6, 1996) propose to use proof 
nets as semantic recipes: since proof nets encode 
linear A-terms, instead of associating a )~-term in tile 
Montagovian style to a lexicai entry, they associate 
a proof net (decorated with typed constants). An ex- 
ample of such a lexicon is given in table 31 (par links 
encode abstraction, and tensor links encode applica- 
tion). 
Of course, to respect semantic types based on 
Montagovian basic types e and t, they use the fol- 
lowing homomorphism: 
7\[(NP) = e "H(S) : I 7t (A\B)  = 7t(A) --o'H(B) 
7t(N) = e --o I 7t(A/13) = ~(B)  --o 7t(A) 
Let us illustrate the process in parsing tile sen- 
tence John lives in Paris. First we have to find 
the syntactic proof net of figure l(b) as explained 
in 2.1. It provides the way syntactic omponants 
combine, hence how semantic recipes of each lexi- 
cal item combine: we take its homomorphic image 
I Unlike in (de Groote and Retor6, 1996), we restrict our- 
selves for llle moment to linear ~-terms. 
629 
Table 2: Cut-elimination rewriting rules 
Y 
r - -q  ............... + 
Y x 
L , q l  
x I x.2 Yl Y'2 
Y 
;13 
S- ,5 '+ "q9  
N P --q\]/S- N P + 
OC------------ ? ? .............. 0 ? / /  ~'-,\ /," 
o l\r l)- ~ X~V c I\r P, O,S "+ 
Paris in li "s John 
(a) Unfolding of the syntac- 
tic typos 
,d :itrl ........ j
l 'S'+ 
(b) Matching the dual atoms 
to obtain a prool' net 
i !  N/')ri! ;~' ; i ' \ r~ht  S+ 
(c) Incorrect prool' structure 
for parsing Jolm lives I'aris in 
Figure 1 : Parsing of John lives in Paris 
as in figure 3(a). The substitution of every input 
with its semantic definition we would like to per- 
form on the ~-calculus ide appears on the logical 
side as plugging selnantic proof nets with cut-links. 
Then, the fl-reduction we would like to perforln 
has its logical counterpart in the cut-elimination on 
the resulting proof net. it gives a new proof net (on 
figure 3(b)) we can use as the semantic analysis of 
John lives in Paris. If necessary, we can come back 
to the k-term expression: (in p)(live j). 
In other words, the syntactic proof net yields a 
term t expressing how the elementary parts combine 
(in this case t = (ab)(cd)). Then the resulting proof 
net of figure 3(b) corresponds to the/3-normal form 
of t\[)~x.*y.(in x )y/a, p/b, Az.live z / c, j/d\]. 
3 What is Generation? 
We can now state the problem we arc dealing with: 
given a semantic proof net (like the one in fig- 
ure 3(b)), we want to put together syntactic entries 
with axiom links such that: 
1. this yields a correct (syntactic) proof net; 
2. the meaning of the resulting proof net matches 
the given semantic expression. 
Thus, if we define: 
* l\]o the semantic proof net of the expression we 
want to generate; 
? Hi the semantic proof nets associated to the 
given lexical entries i we use; 
. Ti the nnfolding in proof slructure of the syn- 
tactic formula of the lexical item i (as in fig- 
ure 1 (a)); 
? F the forest made of the syntactic trees (7~) of 
all the considered lexical entries plus the out- 
put (the type we want to derive), 
the generation problem (see figure 4) is to find a 
matching M of atomic formulas of F such that: 
1. F endowed with M (let us call this proof struc- 
ture F/) is a correct proof net; 
2. when cut-linking 7\[(1 v/) with tile lIi, and elim- 
inating these cuts, we obtain 110. 
We note that the problem is intrinsically decidable 
(because the finitness of the number of the match- 
ings) without making any assumption on the form 
of tile semantic entries. Of course, we want to keep 
these good properties in our algorithm. 
630 
Table 3: Lexicon 
lexical entw syntaxic category associated.k-term 
John NP  j 
Mary N / ~ m 
Paris N l ~ p 
Lives N / ~\,5' Xa:. l ive :c 
in (S\ ,S ' ) /NI"  k:c.)~j.(in ,~)~j 
semantic proof net 
\] \[John (cf. tigure 2(a)) 
\]\[Mary (cf. ligure 2(b)) 
l lpari s (cf. figure 2(c)) 
lltive (cf. figure 2(d)) 
\]lin (cf. figure 2(el) 
c' + ~ . . . . .  Ja c- c-'- ~--~,m c- c-' ~-----ap c- ,i!e '"\[/ 
(a) tljohn (b) \]I John (c) Ill,aris (d) lllivc 
" . / / 
1 , 
in 
(el \]\]in 
Figure 2: Semantic proof nets of the lexicon of table 3 
4 Cut-el iminat ionas Matrix Computation 
U:dng proof nets resulling from a cut-elimination 
to guide a proof search on proof nets b@)re cut- 
elimination relies on the algebraic representation f 
cut-elimination on proof nets expressed in (Girard, 
1989) and rel'ormulated in (Retor6, 1990; Girard, 
1995). Due Io lack of space, we can not developp 
il, but tile principle is to express cut-elimination be- 
tween axioms with incidence matrices and paths in 
graphs. 
Let us consider a proof net U. We can define 
U the incidence matrix of axiom links', c, tile inci- 
dence matrix of cut links (we assume wilhout loss 
of generality that llley happen only between axiom 
links), and \]\[ the incidence matrix of axiom links of 
1I where 111 is lhe proof net resulting from all lhe cut- 
eliminations on U. Then we have (Girard, 1989): 
\ ] l - -  (:l - ~2)U(:l - ~l:;)- '( : l  - ~)  ( l )  
We want to give an equiwflent relation to (1) fo- 
cusing on some axiom links we are interested in. 
Without loss of generality, we assume tile lack of 
any axiom link in U such that none of its conclu- 
sions are involved in cut links. 
Then we can choose an el'tier for tile atoms (from 
lhe proof net before the cut-elimination, there is 
three subsets of atoms: those not involved in a cut 
link, those involved in a cut link and whose dual is 
not involved in a cut link, and those involved in a 
cut link and their dual as well) such that: 
f o :: o 1 n t::o o l  
u = o- 
\["(Y'~0"IU;iJ, , . 0 i<~ic4\] 
Note that all the atoms belonging to the matching 
we are looking for in the generation process (see 
ligure 4) are in U:I. 
If we detine A = ( llJ 1111 - o~ eU 1 l/J1 and X = 
U:~(1 - ~r.l U3)- J, we can state tilt theorem: 
Theorem 1 Lel g/ be a correcl proof net reducing 
in Res(o, U) after cul-eliminalion. These relations 
are equivalenl: 
? u)  = (: i  -   )cr(t - - 
? (q / j i l l  - a:l *(/1 )U1 = o'21&(l - o,lU3) -1 l~r u 
? A - -  I (T2X(T  2 andU:~ = X -1 + o4. 
Of course, all the terms are defined. 
We bast the proof search algorithm corresponding 
to the generation process we are dealing with on this 
third relation. 
Indeed, the axiom links we are looking for are 
those whose two conclusions are involved in cut 
links. That is we want Io complete U3 (knowing 
all the other matrices). The previous theorem states 
that solving tile equation (1) correponds to solving 
631 
' I 
=================================== i:i::::\]:::::: :i }iiiiiiiiiiiiiiiii :: 
(a) Before cut-elimination 
% __~g 7:1 
p m l ive j 
(b) After cut-elimination 
It 
Figure 3: Semantic proof nets for (in p)(live j) 
~ - " ' ~ ' ' ;L cut -c l im ina lkm I l l )  l 
Figure 4: The generation problem 
the equation A = cr2X tcr2 in X with X inversible. 
Then, we have to solve U3 = X -1 + or4 such that 
tU~ = U3 and U~ -- 1. 
Theorem 2 If or4 = 0 and there exists a solution, 
then the latter is unique and completely defined (as 
matrices product)from A and ~2. 
If cq 7~ 0 we generally have many solutions, and we 
have to investigate this case to obtain good compu- 
tational properties for example in adding word order 
constraints. 
Nevertheless, we can decide the case we are han- 
dling as soon as we are given the lexical entries. 
5 Example  
Let us process on an example the previous results. 
We still use the lexicon of table 3, and we want to 
generate (if possible) a sentence whose meaning is 
given by the proof net of figure 3(b). 
We first need to associate very atom with an in- 
dex (in the figures, we indicate a number i beside 
the atom). Of course, we have to know how to rec- 
ognize the atoms that are the same in U (figure 5(b)) 
and in I\[ (figure 5(a)). This can be done by looking 
at the typed constants decorating the input conclu- 
sions (for the moment, we don't have a general pro- 
cedure). 
We also assume in this numbering that we know 
which of the atoms in ~(F )  is linked to t + (the 
unique output). In our case where ?4 = 0, it is 
not a problem to make such a statement. In other 
cases, the complexity would increase at most poly- 
nomially. 
Then, the given 
\] 000000 
0100000 
0010000 
Ut = 0001000 
0000100 
0 0 0 0 0 1 0 
000000 l 
0000000 
000000 
000000 
000000 
000010 
~1 = 000100 
000000 
000000 
000  
And the unique 
matrices are: 
0 
0 
0 
0 117 = 
0 
0 
0 
1 
0 0- 
O0 
O0 
O0 
00 ~2 = 
O0 
00 
00000.  
solution is: 
x=u~= 
0:1000000 
10000000 
00000010 
0000 \] 000  
00010000 
00000001 
00100000 
.00000100.  
-100000 
0 \ ]0000 
001000 
000000 
000000 
000010 
000100 
.000001.  
\[;'???i\]  oooo  0010 0100 0000 0001 
632 
We can add this matching to the syntactic forest of 
figure 6(a) (do not forget that the link between S+ 
alld c~,- is in U1 and not in U3, and that U:3 represents 
edges between atoms with i E \[17, 22\]) and obtain 
on F the matching of figure 6(b). 
We still have to ensure the correctness of this 
proof net (because we add all the tensor and par 
links), but it has a quadratic omplexity (less than 
the matricial computation). In this case, it is cor- 
rect. 
Actually, this only gives us the axiom links. It 
still requires to compute the word order to have no 
crossing axiom link. This can be done from the ax- 
iom links easier than quadratic time (it is a bracket- 
ing problem). 
6 Conclusion 
We showed that the problem of generation in the 
Lambek calculus fi-amework is decidable, and we 
relied on selnantic proof nets to express it as a 
guided proof search. On top of keeping the decid- 
ability property of this framework, we characterized 
the semantic proof nets that euable a polynomial 
time processing. 
Nevertheless, some work remains: we should 
soon work on the atom numbering and the choice 
of the lexical items to enable a practical ilnplemen- 
tation of this work. Moreover, we want to benefit 
from the power of linear logic (and modalities) to 
deal with non linear A-terms. 
Finally, since different extensions of Lambek cal- 
culus based on proof nets (Moortgat, 1996; Lecomte 
and Retord, 1995) have been considered, we hope 
our proposal and its good properties to apply to 
other linguistic approaches. 
Acknowledgments 
I would like to thank Christian Retord who pointed 
out to me Girard's algebraic interpretation of the cut 
elimination, and the anonymous reviewers for their 
helpful colnments. 
References 
Vincent Danos. 1990. Une Application tie la 
Logique Lin&tire ?t I Etude des Processus tie Nor- 
malisation (principalement du A-calcul). Ph.D. 
thesis, Universitd Paris VII, June. 
Philippe de Groote and Chritian Retord. 1996. 
On the semantic readings of proof-nets. In 
Glyn Morrill Geert-Jan Kmijff and Dick Oehrle, 
editors, Formal Grammar, pages 57-70, Prague, 
August. FoLLI. 
Jean-Yves Girard. 1987. Linear logic. Theoretical 
Conq)uter Science, 50:1-102. 
Jean-Yves Girard. 1989. Geometry of interaction 
I: Interpretation of system F. In C. Bonotto, 
R. Ferro, S. Valentini, and A. Zanardo, editors, 
Logic Colloquium '88, pages 221-260. Nortll- 
Holland. 
Jean-Yves Girard. 1995. Geometry of interaction 
III: The general case. In J.-Y. Girard, Y. La- 
font, and L. Regniel; editors, Advances in Lin- 
ear Logic, pages 329-389. Cambridge University 
Press, Proceedings of the Workshop on Linear 
Logic, ithaca, New York, June 1993. 
Franqois Lamarche and Christian Retor6. 1996. 
Proof-nets for the lambek calculus - an overview. 
In V. Michele Abrusci and Claudio Casadio, edi- 
tors, PIvceedings 1996 Roma Workshop. Proof~ 
and Linguistic Categories, pages 241-262. Ed- 
itrice CLUEB, Bologna, April. 
Franqois Lamarche. 1995. Games semantics for 
full propositional linear logic. In Proceedings, 
Tenth Annual IEEE Symposittm on l_z~gic in Com- 
puter Science, pages 464-473, San Diego, Cal- 
ifornia, 26-29 June. IEEE Computer Society 
Press. 
Joachim Lambek. 1958. The mathematics of 
sentence structure. American Mathematical 
Monthly, 65(3):154-170. 
Alain Lecomte and Christian Retord. 1995. Pore- 
set logic as an alternative categorial grammar. In 
Formal Grammar, Barcelona. 
Josep M. Merenciano and Glyn Morrill. 1997. 
Generation as deduction on labelled proof nets. 
In Christian Retord, editor, hvceedings of LACL- 
96, volume 1328 of LNA I, pages 310-328, Bed in. 
Springer. 
Michael Moortgat. 1996. Categorial type logics. In 
Johan van Benthem and Alice ter Meulen, edi- 
tors, Handbook of lx~gic and Lzmguage, pages 5- 
91. Elsevier Science Publishers, Amsterdam. 
Christian Retor6. 1990. A note on turbo cut elimi- 
nation. Manuscript, September. 
Christian Retor6,. 1998. Handsome proofilets: 
R&b-graphs, series-parallel graphs and perfect 
matchings. Technical Report 1234, IRISA. 
l)irk Roorda. 1991. Resource Lz)gics: Proof- 
theoretical hlvestigations. Ph.D. thesis, Univer- 
sity of Amsterdam, September. 
633 
3 4 
t __Z- 6 7 
(a) Marking atoms on \]I 
. . . . .  F . i ,~  . . . . . . . . . . . . . . . . . . . . . .  ..- 
,1 12,! 18 '_e~_+:3 _~./ 
) 
e- -  
19 22 20 21 
l ives 
gIq 
Pc. 
17 
. . . . . .  ~lives . . . . . . . . . . . . .  
,5 I 7 
~-,:+/~/~+ ~-/ 
, ,  ~A ? oc-----~:" !~to,~ np,:,~ . . . . . .  
,4 - .7  \~  : ,:::: ....... , i 
...... --:'- ............. live :: :: 116...!.. ! ::l~ ..... .P. :: 
I~_~77ZT-Z7272 ~!............ _ \ ]  
(b) Marking atoms oll U 
I 
Figure 5: Defining the indices on U and \]1 
l 
r 
- 20Np+21 
'~ N, . - i  72 
Pearls 11"~ lives Jol~l S + S+ 
(a) The syntactic forest (b) The syntactic forest endowed with 
the matching described by U3 
Figure 6: App ly ing the matching on the syntactic forest 
634 
Proceedings of the 8th International Natural Language Generation Conference, pages 35?44,
Philadelphia, Pennsylvania, 19-21 June 2014. c?2014 Association for Computational Linguistics
An ACG Analysis of the G-TAG Generation Process?
Laurence Danlos
Universite? Paris Diderot (Paris 7)
ALPAGE, INRIA Paris?Rocquencourt
Institut Universitaire de France, Paris, France
laurence.danlos@inria.fr
Aleksandre Maskharashvili and Sylvain Pogodalla
INRIA Villers-le`s-Nancy, France
Universite? de Lorraine,
CNRS, LORIA, UMR 7503
Vand?uvre-le`s-Nancy, France
aleksandre.maskharashvili@inria.fr
sylvain.pogodalla@inria.fr
Abstract
This paper presents an encoding of
Generation-TAG (G-TAG) within Abstract
Categorial Grammars (ACG). We show
how the key notions of G-TAG have a nat-
ural interpretation in ACG, allowing us to
use its reversibility property for text gen-
eration. It also offers solutions to several
limitations of G-TAG.
1 Motivations
G-TAG (Danlos, 1998; Danlos, 2000) is a formal-
ism based on the Tree Adjoining Grammar (TAG)
formalism (Joshi et al., 1975; Joshi and Schabes,
1997) dedicated to text generation. It focuses on
providing several notions to support useful data
structures, such as g-derivation trees or lexical
databases, to effectively relate a surface form (a
derived tree or a string) to a conceptual represen-
tation. An actual implementation in ADA was first
provided for French (Meunier, 1997), and it has re-
cently been implemented in the .NET framework
as the EasyText NLG system and is operational
at Kantar Media, a French subsidiary company of
TNS-Sofres (Danlos et al., 2011).
The G-TAG proposal can be seen as a result
of the observation of the mismatch between the
derivation tree notion of TAG and the expected se-
mantic dependencies (Schabes and Shieber, 1994)
from a generation perspective. Several approaches
that extend the derivation tree notion of TAG have
been proposed to overcome this difficulty. Other
approaches showed that the derivation trees still
could be used without additional modifications.
Such approaches rely on unification (Kallmeyer
and Romero, 2004; Kallmeyer and Romero, 2007)
or a functional approach to TAG (Pogodalla, 2004;
?This work has been supported by the French agency
Agence Nationale de la Recherche (ANR-12-CORD-0004).
Pogodalla, 2009)1 based on Abstract Categorial
Grammars (ACG) (de Groote, 2001). The latter
is intrinsically reversible: the grammars and the
algorithms are the same for parsing and for gener-
ation.
We propose then to study G-TAG under the
ACG perspective. We show that the key notion
of g-derivation tree naturally express itself in this
framework. The surface form construction from
a conceptual representation can then use the gen-
eral algorithms of ACG, the very same ones that
can be used in parsing to analyze mildly con-
text sensitive languages (TAG generated language,
LCFRS) (de Groote and Pogodalla, 2004), follow-
ing (Kanazawa, 2007)?s proposal here applied to
give an ACG account of G-TAG. We do not con-
sider here the G-TAG treatment of preferences be-
tween the different realizations of the same input.
Similarly, we do not consider the generation of
pronouns used in G-TAG and we will work on
integrating a theory of generation of referring ex-
pressions.
2 Sketching G-TAG
G-TAG deals with the How to say it? task of gen-
eration. The input is a conceptual representation.
A G-TAG grammar includes elementary trees, as
any TAG grammar. But it also makes g-derivation
trees primary objects, relating them to the elemen-
tary trees and considering them as pivot to the con-
ceptual representation level.
Conceptual Representation G-TAG concep-
tual representation makes use of notions as sec-
ond order relation, first order relation and thing.
Second order relations have two arguments which
are relations (either first or second order ones)
and typically correspond to discourse relations,
1Synchronous approaches (Nesson and Shieber, 2006) are
similar in many respects, as shown in (Storoshenk and Frank,
2012).
35
whereas first order relations have things as their
arguments. While (Danlos, 2000) uses reified for-
mulas of a logical conceptual representation lan-
guage as G-TAG inputs, it can also be represented
as a higher-order logical formula (Meunier, 1997)
or as a SDRT-like formula (Danlos et al., 2001).
We follow here this presentation. Equation (1) ex-
emplifies an input that could be realized as Jean
a passe? l?aspirateur pour e?tre re?compense? par
Marie. Puis il a fait une sieste (John has vacumed
in order to be rewarded by Mary. Then he took a
nap).
SUCCESSION(GOAL(VACUUMING(Jean),
REWARDING(Marie, Jean)),
NAPPING(Jean)) (1)
G-TAG Lexical Database A lexical entry of G-
TAG corresponds to a lemma. For each lexical en-
try (i.e. lemma) there is a set of TAG elementary
trees which corresponds to it. Among the TAG el-
ementary trees that correspond to a given lexical
entry, there is the canonical representative, and all
the other representatives are represented by adding
features to the canonical representative. For exam-
ple, if the lexical entry is to love, then the canon-
ical representative will be the active form of the
verb to love. Then the passive alternation is rep-
resented by adding a feature [+passive] to to love.
Moreover, all the lexical entries attached to a con-
cept (such as SUCCESSION) belong to a same lexi-
cal base. So for a concept, there can be a lexical
entry describing verbal realizations of the concept.
These realizations can correspond to the active or
to the passive forms, etc. There can also be a lex-
ical entry which corresponds to nominal realiza-
tions, etc.
G-Derivation Trees A TAG derivation tree can
be seen as a record of the substitutions and adjunc-
tion occurring during a TAG analysis. The same is
true for g-derivation tree. However, while TAG
derivation trees are considered as a by-product,
with inflected anchors, G-TAG derivation trees are
first class structures that are combined in order to
reflect the conceptual input. To abstract from the
surface form and from the derived tree they can
relate to, they don?t correspond to inflected forms
but bear features that are used in a post-processing
step. Complex g-derivation trees are built by going
through the dynamic selection process of a lexi-
cal item from the set of appropriate candidates for
a given concept. So contrary to TAG derivation
trees, they are not fully instantiated trees: their ar-
guments are represented by variables whose lexi-
calization are not carried out yet.
G-Derived Trees A g-derivation tree defines a
unique g-derived tree corresponding to it. This
correspondance is maintained all along the real-
ization process and a post-processing module out-
puts the surface representation (text) from the g-
derived tree. In addition to inflecting forms using
the feature values it can make some rewriting to
propose different versions of the initial text. In
this particular sense, g-derived tree corresponds
to possibly multiple text outputs generated by the
post-processing module.
3 The G-TAG Generation Process
Let us assume the input of Equation 1. The G-TAG
process starts by lexicalizing relations that have
the widest scope in the conceptual representation:
typically second order relations, then first order re-
lations, and things.2 Back to the example, we first
lexicalize the second order relation SUCCESSION.
Several items are associated with this relation:
apre`s (after), avant (before), ensuite (afterwards),
auparavant (beforehand), puis (then), etc. Each of
them has two arguments, however, some of them
produce texts comprising two or more sentences,
like ensuite(afterwards); some of them can pro-
duce either two sentence texts or one sentence text,
while others produce only one sentence. For in-
stance, Jean a passe? l?aspirateur. Ensuite, il a fait
une sieste (John has vacuumed. Afterwards, he
took a nap) is a two sentences text while John a
fait une sieste apre`s avoir passe? l?aspirateur (John
took a nap after having vacuumed) is a one sen-
tence text. For this reason, items describing the
arguments or the result of second order relations
have features expressing the following constraints:
(+T,+S) indicates it is a text (two ore more sen-
tences); (+S) indicates it is either a single sen-
tence or a text; (?T,+S) indicates it is a sentence
(not a text). Every second order relation has three
features: one for output, and two for inputs. 3
2Correctness of the process is ensured because the gram-
mars don?t contain auxiliary trees that would reverse the pred-
ication order. (Danlos, 2000) argues such cases don?t occur in
technical texts, the first target of G-TAG. We don?t elaborate
on this point since the ACG approach we propose remove this
constraint for free.
3In G-TAG, any discourse connective has exactly two ar-
guments. A discussion about this point is provided in (Dan-
36
Let us assume that the G-TAG g-derivation tree
ensuite(+T,+S) belonging to the lexical database
associated with the concept SUCCESSION is first
chosen, resulting in a text rather than a sentence
(illustrated by the leftmost g-derivation tree of Fig-
ure 1 . The process then tries to realize its two ar-
guments. The first one involves the GOAL relation
that can be realized either by pour (in order to) or
by pour que (so that), as exemplified by the right-
most g-derivation trees of Figure 1. Both have fea-
tures (?T,+S) for the inputs (i.e. arguments) and
return a tree labeled at the root by (?T,+S).
ensuite
(+T,+S)
(1st event)
(+S) (2nd event)(+S)
arg1 arg2
pour
(?T,+S)
(ACTION)
(?T,+S) (PURPOSE)(?T,+S)
arg1 arg2
pour que
(?T,+S)
(ACTION)
(?T,+S) (PURPOSE)(?T,+S)
arg1 arg2
Figure 1: G-derivation trees samples
Despite pour and pour que bearing the same
features, the syntactic trees corresponding to pour
and pour que are quite different. For pour que
S substitution nodes can be substituted by two
tensed sentences, while pour takes a finite sen-
tence and a ?sentence? in the infinitive form with-
out any nominal subject. Figure 2 shows the asso-
ciated elementary trees. Selecting one or the other
during the generation process restricts the possible
realizations for the arguments. This is enforced by
a feature associated to the elementary tree, namely
the (+reduc-subj) feature as shown in Fig. 3.
Again, we may assume that G-TAG selects pour,
S
S (arg1) PP
Prep
pour
S
C
que
S(arg2)
(mood:subj)
S
S (arg1) PP
Prep
pour
S(arg2)
(mood:inf)
Figure 2: Elementary trees of pour que (so that)
and pour (in order to)
which will enforce, because of the associated ele-
mentary trees, that the subject of the first and the
second arguments are the same. Afterwards, we
need to lexicalize these two arguments with a com-
mon subject Jean. From a semantic point of view,
the agent of VACUUMING has to be the beneficiary
of REWARDING (the rewardee). VACUUMING can
only be lexicalized as passer-l?aspirateur (run-the-
vacuum-cleaner), while there are several lexical-
los, 2000).
ization options for the REWARDING: re?compenser
(to reward), donner-re?compense (to give-reward),
and recevoir-re?compense (to receive-reward). Let
us notice that donner-re?compense does not meet
the constraint on a shared subject as it cannot
have the rewardee as its subject4. The remaining
options are: recevoir-re?compense, whose canon-
ical representation has the rewardee as subject;
and re?compense whose passive construction has
the rewardee as subject. s Assuming a choice of
re?compenser[+passive],5 the lexicalizations of the
arguments of the first order relations remain. As
Marie occurs only once and in subject position,
it can only be lexicalized as Marie. On the other
hand, Jean three times: one will be the implicit
subject of the subordinate, then as argument of
VACUUMING and NAPPING. Therefore it can be ei-
ther lexicalized in both of the cases as Jean, or
Jean and the pronoun il (he). In G-TAG, there
are some post-processing rules that take care of
the generation of referring expressions, but not in
a really principled way so we do not demonstrate
them here. We assume a lexicalization by Jean in
both cases. Figure 3 shows the g-derivation tree
associated with the input of Equation 1 and Fig. 4
show the unique resulting (non-flected) derived
tree. The post-processing modules then outputs:
Jean a passe? l?aspirateur pour e?tre re?compense?
par Marie. Ensuite, il a fait une sieste. (John
vacuumed in order to be rewarded by Mary. Af-
terwards, he took a nap.)
ensuite
pour
(+reduc-subj)
passer-l?aspirateur
Jean
recompenser
(+reduc-subj,+passive)
Marie 
faire-la-sieste
Jean
arg1
arg1
arg1
arg2
arg1 arg2
arg2
arg1
Figure 3: Fully instantiated g-derivation tree
4 ACG Definition
Abstract Categorial Grammars
(ACGs) (de Groote, 2001) are a type theo-
4It lacks passivation in French and there is no form equiv-
alent to: John was given a reward by Mary.
5Of course, all these branching points offer several real-
izations of the same entry. But for explanatory purposes, we
describe only one at each step.
37
S
S
S
NP
Jea
n
V
pa
sse
rl?
asp
ira
teu
r
PP
Prep
po
ur
S
NP

Va
e?tr
e
V
re?c
om
pe
nse
r
PP
Prep
pa
r
Ma
rie
. S
Adv
en
sui
te
S
NP
Jea
n
V
fai
tu
ne
sie
ste
Figure 4: Non-inflected derived tree
retical framework that is able to encode several
grammatical formalisms (de Groote and Pogo-
dalla, 2004). An ACG defines two languages:
the abstract one and the object one. The abstract
level describe the admissible parse structures and
a lexicon maps these structures to the ones we
observe at the object level (strings for surface
forms, logical formulas for semantic forms). In
all cases, the considered languages are sets of
?-terms that generalize string and tree languages.
Definition. A higher-order linear signature (also
called a vocabulary) is defined to be a triple ? =
?A,C, ??, where:
? A is a finite set of atomic types (also noted
A?),
? C is a finite set of constants (also noted C?),
? and ? is a mapping from C to TA the set of
types built on A: TA ::= A|TA ? TA (also
noted T?).
Given a higher-order linear signature ?, ?(?) is
the set of ?-terms built on ?, and for t ? ?(?)
and ? ? T? such that t has type ?, we note t :? ?
(the ? subscript is omitted when obvious from the
context).
Definition. An abstract categorial grammar is a
quadruple G = ??,?,L, s? where:
1. ? and ? are two higher-order linear signa-
tures, which are called the abstract vocabu-
lary and the object vocabulary, respectively;
2. L : ? ?? ? is a lexicon from the abstract
vocabulary to the object vocabulary. It is
a homomorphism that maps types and terms
built on ? to types and terms built on ? as
follows:
? if ? ? ? ? T? then L(? ? ?) =
L(?)? L(?)
? if x ? ?(?) (resp. ?x.t ? ?(?) and
t u ? ?(?)) then L(x) = x (resp.
L(?x.t) = ?x.L(t) and L(t u) =
L(t)L(u))
It is then enough to define L on the atomic
types and on the constants of ? to define it
on all types and terms, provided that for any
constant c : ? of ? we have L(c) : L(?).
We note t:=G u if L(t) = u and omit the G
subscript if obvious from the context.
3. s ? T? is a type of the abstract vocabulary,
which is called the distinguished type of the
grammar.
Table 1 provides an ACG example Gd-ed trees
where the abstract typed constants of ?der? en-
code the combinatorial properties of the associated
(through the lexicon Ld-ed trees) elementary trees.
Definition. The abstract language of an ACG G =
??,?,L, s? is A(G ) = {t ? ?(?) | t :? s}
The object language of the grammar O(G ) =
{t ? ?(?) | ?u ? A(G ). t = LG(u)}
For instance, the term Creward IS Iv CMary CJean :
S ? Gd-ed trees, and its image, the derived tree for
Marie re?compense Jean (Mary rewards John).
It is important to note that, from a purely math-
ematical point of view, there is no structural differ-
ence between the abstract and the object vocabu-
lary: both are higher-order signatures. This allows
for combining ACGs in different ways:
? by having a same abstract vocabulary shared
by several ACGs: this can be used to make
two object terms (for instance a string and
a logical formula) share the same underlying
structure. Gd-ed trees and GLog in Fig. 5 illustrate
such a composition.
? by making the abstract vocabulary of one
ACG the object vocabulary of another ACG,
allowing for the control of the admissible
structures of the former by the latter. Gyield
and Gd-ed trees in Fig. 5 illustrate such a com-
position.
?(?der?)
?(?trees)
Gd-ed trees
?(?string)
Gyield
?(?Log)
GLog
Figure 5: ACG architecture for TAG
38
Crucial to our analysis is that ACG parsing of
a term u amounts to finding an abstract term t
such that t:= u, no matter whether u represents
a string, a tree, or a logical formula. This can be
done in polynomial time for ACGs whose abstract
constant types are at most of order 2: second order
ACGs as (Kanazawa, 2007) shows.6 The result re-
lies on a reduction of the parsing problem to Data-
log querying where the term to be parsed is stored
in a database. Interestingly, this database can rep-
resent a set of terms (Kanazawa, 2011, Section
4.2) and the query reduces to checking whether at
least one of them can be retrieved. This allows the
query associated with a term representing a logical
formula to extend to all the terms that are equiva-
lent modulo the associativity and the commutativ-
ity of the conjunction.
5 ACG Encoding
5.1 TAG as ACG
Because ACG considers both the abstract lan-
guage and the object language, the encoding of
TAG into ACG makes (abstract) terms represent-
ing derivation trees primary. The encoding uses
two ACGs Gd-ed trees = ??der?,?trees,Ld-ed trees,S?
and Gyield = ??trees,?string,Lyield, ??.
We exemplify the encoding7 of a TAG analyz-
ing (2) in Fig. 6.8
(2) Marie
Mary
re?compense
rewards
ensuite
then
Jean
John
This sentence is usually analyzed in TAG with a
derivation tree where the adverb adjoins at the v
node.
The three higher-order signatures are:
?der?: Its atomic types include S, v, np, SA,
vA. . . where the X types stand for the cate-
gories X of the nodes where a substitution
can occur while the XA types stand for the
categories X of the nodes where an adjunc-
tion can occur. For each elementary tree
?lex. entry it contains a constant Clex. entry whose
type is based on the adjunction and substitu-
tion sites as Table 1 shows. It additionally
contains constants IX : XA that are meant
to provide a fake auxiliary tree on adjunction
6It actually extends this result to almost linear object
terms where variables with atomic type can be duplicated,
as it commonly happens at the semantic level.
7This corresponds to the systematic encoding of (Pogo-
dalla, 2009) of TAG and its semantics into ACG.
8We follow the grammar of (Abeille?, 2002).
sites where no adjunction actually takes place
in a TAG derivation.
?trees: Its unique atomic type is ? the type of
trees. Then, for any X of arity n belong-
ing to the ranked alphabet describing the ele-
mentary trees of the TAG, we have a constant
Xn :
n times? ?? ?
? ( ? ? ?( ? ( ?
?string: Its unique atomic type is ? the type of
strings. The constants are the terminal sym-
bols of the TAG (with type ?), the concatena-
tion + : ? ( ? ( ? and the empty string
? : ?.
Table 1 illustrates Ld-ed trees.9 Lyield is defined as
follows:
? Lyield(?) = ?;
? for n > 0, Lyield(Xn) = ?x1 ? ? ?xn.x1 +
? ? ?+ xn;
? for n = 0, X0 : ? represents a terminal sym-
bol and Lyield(X0) = X .
Then, the derivation tree, the derived tree, and the
yield of Fig. 6 are represented by:
?reward
?Jean?Marie?then
(a) Derivation tree
S
np
Jean
v
ensuitev
re?compense
np
Marie
(b) Derived tree
Figure 6: Marie re?compense ensuite Jean
?5 = Creward IS (Cvthen IS) CMarie CJean
Ld-ed trees(?5)
= S3 (np1 Marie)
(v2 (v1 re?compense) ensuite) (np1 Jean)
Lyield(Ld-ed trees(?5)) = Marie + re?compense
+ ensuite + Jean
5.2 G-TAG as ACG
In order to model G-TAG in ACG, first we need to
design the abstract signature ?g-der? in which we
can have entries for G-TAG. This entries will re-
flect the ideology that G-TAG is based on. For
instance, in G-TAG discourse level words like en-
suite can take as its arguments texts and sentences
and produces text. In order to model this, we
introduce types S and T. Then, we can define
DSSthen: S ( S ( T, which means that DSSthen has
takes two arguments of type S and returns a re-
sult of type T. As in G-TAG, ensuite can take two
9With Ld-ed trees(XA) = ? ( ? and for any other type
X , Ld-ed trees(XA) = ? .
39
Abstract constants of ?der? Their images by Ld-ed trees The corresponding TAG trees
CJean : np cJean : ?= np1 Jean ?Jean =
np
Jean
Cvthen : vA ( vA cvthen : (? ( ?) ( (? ( ?)= ?ovx.v (v2 xensuite) ?then = v
ensuitev?
Creward : SA ( vA ( np( np ( S creward
: (? ( ?) ( (? ( ?) ( ?( ? ( ?
= ?oavso.a (S3 s (v (v1 re?compense)) o)
?reward = S
npv
re?compense
np
IX : XA ?x.x : ? ( ?
Table 1: A TAG as an ACG: Ld-ed trees and Llog.sem lexicons
texts as arguments and return text as well, we need
to do have another entry for modeling this fact.
This makes us to introduce another constant DTTthen :
T ( T ( T. For the same kind of reason, we in-
troduce following constants: DSTthen: S ( T ( T,
DTSthen and T ( S ( T. Other relations, like au-
paravant is modeled in the same way as ensuite in
?g-der?.
Apart from ensuite and auparavant, there are
connectives as avant (before) and apre`s (after) that
need to be modeled differently from ensuite. In-
deed, while ensuite results in a text, placing side
by side a text and a sentence separated with a pe-
riod, avant and apre`s in French combine in a sin-
gle sentence a (full) clause and an infinitive clause
with an implicit subject: the one of the first clause.
It is clear that in order to type avant and apre`s in
the ?g-der? signature, one should use a type which
schematically looks as . . . ( S. On the other
hand, one needs to give the exact type to them.
Despite that in TAG and G-TAG avant and apre`s
take two sentential arguments (labelled by S), the
second argument bears a feature indicating it lacks
the subject and that the latter has to be shared with
the first sentence. For instance: Jean a fait une
sieste apre`s avoir passe? l?aspirateur (John took
a nap after having vacuumed), here the subject
of avoir passe? l?aspirateur (having vacuumed) is
Jean, which comes from the sentence Jean a fait
une sieste (John took a nap). So, Jean a fait une
sieste (John took a nap) can be seen as a sentence
whose subject is shared by another sentence as
well. In order to model this point, we use fol-
lowing type: Sws ( Sh ( np ( S. Indeed,
the Sws and the Sh types correspond to the type
of sentences missing a subject. Furthermore, we
need to model pour and pour que, which were in-
troduced in order to lexicalize the GOAL relation in
G-TAG. First, let us have a look at pour que. It can
take as its arguments two complete (from a syntax
point of view) sentences and results in a sentence
as in: Il travaille pour que vous puissiez manger.
So, Dpour que, which is an entry corresponding to
pour que, can be assigned a S ( S ( S type.
The syntactic difference between pour que and
pour was highlighted in Section 3: pour takes
as arguments a complete sentence and an infini-
tive form of a sentence missing a subject whose
subject comes from the first argument. Thus, in
this case, similarly to case of avant and apre`s,
pour has to be modeled as an entry that has type
Sws ( Sinf ( np ( S, where Sinf stands for
the type of an infinitive form of a clause missing a
subject. We also need to deal with encoding differ-
ent forms of a verb. For instance, re?compenser has
an active and a passive form. In G-TAG deriva-
tion, both of them can be encountered. In order
to model this fact, two different entries are intro-
duced: one for the passive form and one for the
active form, which is the canonical construction
for re?compenser. So, we need to have two distinct
entries Dpassiverecompense and Dactiverecompense, and both of them
have type SA ( vA ( np ( np ( S. More-
over, (Danlos, 2000) poses the problem that G-
TAG cannot handle a text where the adverb adjoin
at the v node rather than on the S node as in: Jean
a passe? l?aspirateur. Il a ensuite fait une sieste
(John vacuumed. He then took a nap.) According
to (Danlos, 2000) modelling such text production
requires a formalism more powerful than TAG. In
the ACG framework, this observations translates
into defining an entry Dvthen : S ( (vA ( S) (
T in ?g-der? which is third order and that is, as such,
beyond the TAC into ACG encoding (that only re-
quires second-order types).10 This also offers a
10Currently, there is no theoretical complexity result for
parsing such ACG fragments. However, in this particu-
40
general mechanism for providing constants encod-
ing adverbial connectives with two arguments as
in discourse grammars such as D-STAG (Danlos,
2011), but contrary to D-LTAG where one of the
arguments is anaphorically given from the preced-
ing discourse (Webber, 2004).
G-Derivation Trees to Derivation Trees We
translate terms of ?g-der?, which correspond to g-
derivation trees, into the TAG derivation tree lan-
guage defined on ?der? using the lexicon Lder-der
of Table 2. It is interesting to see how to inter-
Lder-der(S) = Lder-der(T) = Lder-der(Sws)
= Lder-der(Sinf) = Lder-der(Sh)
= S
Lder-der(SA) = SA
Lder-der(vA) = vA
Lder-der(np) = np
Lder-der(IS) = IS
Lder-der(Iv) = Iv
Table 2: The Lder-der lexicon
pret Dvthen: S ( (vA ( S) ( T into ?der?.
For this reason, we introduce in ?der? the follow-
ing constant: s2 : S ( S ( S that allows
for combining two sentences with a period. Now,
it is possible to translate Dvthen into ?der? as fol-
lows: Lder-der(Dvthen) = ?oS1 S2.s2 S1(S2Cvthen).
It means that Dvthen is interpreted as performing
both the operation of combining two sentences
with a period and the adjunction of ensuite on the
v node of the second sentence.
G-Derived Trees as Interpretation of G-
Derivation Trees As soon as g-derivation trees
as term built on ?g-der? are interpreted as term
built on ?der?, we can map them to derived trees.
Thus, by composing the two lexicons Lder-der and
Ld-ed trees we can get directly from G-TAG into de-
rived trees
5.3 From G-TAG to Montague Style
Semantics Using ACGs
(Pogodalla, 2009) defines a signature ?Log and a
lexicon LLog from ?der? to ?Log. The entries in
?Log have Montague like semantics. The lexicon
translates a derivation tree into a corresponding
formula. We will use the same kind of semantic
language for conceptual representations. In other
words, our language will produce the formulas
lar case, we could use a second-order?and polynomial?
encoding of multi-component TAG into ACG.
that are used in the conceptual representation of
G-TAG, while we will stick to the Montague style
translations from syntax to semantics.
So, we define a signature ?conrep of conceptual
representation that is similar to the one of (Pogo-
dalla, 2009). ?conrep defines two atomic types e
and t and constants such as: j, m . . . of type e, the
constant REWARD of type e ( e ( t, the con-
stant CLAIM of type e ( t ( t and the constant
SEEM of type t( t. Moreover, we have constants
SUCC, GOAL of type t( t( t.
We are able to translate ?g-der? into ?conrep
with the help of the lexicon Lder-con. The
lexicon Lder-con is extension of the lexicon
defined in (Pogodalla, 2009), because we
are adding to the domain (i.e. abstract lan-
guage) the constants that are not in the ?der?.
Lder-con(S) = Lder-con(T) = t
Lder-con(vA) = (e? t) ( (e? t)
Lder-con(SA) = t( t
Lder-con(np) = (e? t) ( t
Lder-con(Djean) = ?oP.P (j)
Lder-con(DSTthen) = Lder-con(DSSthen)
= Lder-con(DSTthen)
= Lder-con(DTSthen)
= Lder-con(DTTthen )
= ?s2s1.SUCC s2 s1
Lder-con(DSTbef. ) = Lder-con(DSSbef. )
= Lder-con(DSTbef. )
= Lder-con(DTSbef. )
= Lder-con(DTTbef. )
= ?o s1s2. SUCC s2 s1
Lder-con(Drewards) = ?os a O S.s(S(a(?ox.O(?oy.
(REWARD x y))))
Note that the interpretation of np is JnpK =
(e ? t) ( t, using a non-linear implication (but
almost linear). Typically, the sharing of the sub-
ject by the two clauses related by pour or avant de
induces non linearity.
The Sinf, Sh, and Sws types all are interpreted
as JnpK ( JSK = ((e ? t) ( t) ( t as they
denote clauses lacking a subject. Then we trans-late the constants Dpour, Dapre`s, and Davant in
the following way:
Lder-con(Dpour ) =
?os1.?os2.?oN.N(?x.(GOAL(s1(?P.P x))
(s2(?P.P x))))
Lder-con(Dapres) =
?os1.?os2.?oN.N(?x.(SUCC(s1(?P.P x))
(s2(?P.P x))))
41
Lder-con(Davant) =
?os1.?os2.?oN.N(?x.(SUCC(s2(?P.P x))
(s1(?P.P x))))
5.4 The G-TAG Process as a Morphism
Composition
We exemplify the whole process using the term
T0 = SUCC(VAC(jean),REWARD(marie, jean))
of type t.11 The terms representing the g-
derivation trees that generate this conceptual rep-
resentation are the antecedents of To by L ?1der-con:
L ?1der-con(T0) = {t1, . . . , t8} that all are of type
T. They are given in Figure 7. Each of these re-
trieved terms t1, . . . , t8 are then mapped to terms
representing TAG derivation trees, i.e. built on
?der? via the lexicon Lder-der. They can be can
in turn be interpreted as syntactic derived trees
via the lexicon Ld-ed trees, and the latter can be
interpreted as strings using the lexicon Lyield.
So from T0 we can have eight surface forms:
Lyield(Ld-ed trees(Lder-der(ti))), i ? [1, 8]. Let us
show this process on the example of t512. It il-
lustrates the generation of the example (3).13
(3) Jean
John
a passe? l?aspirateur.
vacuumed.
Marie
Mary
a re?compense?
rewarded
ensuite
afterwards
Jean.
John.
Lder-der(t5) = s2 (CvacISIvCjean)
(CrewardISCvthenCmarieCjean)
Ld-ed trees(Lder-der(t5) =
S3 (S2 (np1 Jean)(v1 a passe? l?aspirateur))
?
(S3(np1 Marie)(v2 (v1 a re?compense?) ensuite)(np1 Jean))
And the surface forms is given by composing the
interpretations:
Lyield(Ld-ed trees(Lder-der(t5)) =
Jean + a passe? + l?aspirateur + . +
Marie + a recompense? + ensuite + Jean
11The associated conceptual input is a simplified version of
the conceptual input of Equation 1 without the GOAL concept
and a replacement of the NAP one by the REWARDING one.
12t5 is such that Lder-der(t5) = ?5 and the term ?5 wasused as example at Section 5.1.
13For sake of simplicity we assume the adverb adjoins on
the whole auxiliary+verb phrase rather than only on the aux-
iliary as it would be in French.
t1 = DSSthen(DvacISIvDjean)(DrewardISIvDmarieDjean)
t2 = DSSthen(DvacISIvDjean)(DpassiverewardISIvDmarieDjean)
t3 = DSSbef.(DrewardISIvDmarieDjean)(DvacISIvDjean)
t4 = DSSbef.(DpassiverewardISIvDjeanDmarie)(DvacISIvDjean)
t5 = Dvthen(DvacISIvDjean)(?oa.Dreward IS a DmarieDjean)
t6 = Dvthen(DvacISIvDjean)(DpassiverewardISIvDjeanDmarie)
t7 = Dafter (DswsvacISIv)(Dreceive-rew.ISIvDjean)Dmarie
t8 = Dbef.(DswsvacISIv)(Dreceive-rew.ISIvDjean)Dmarie
Figure 7: Antecedents of T0 by Lder-con
6 Related Work
We can only quickly mention two related pieces
of work. On the one hand, (Gardent and Perez-
Beltrachini, 2010) also takes advantage of the
formal properties underlying the tree language
of derivation trees to propose a generation pro-
cess using TAG grammars. On the other hand,
(Nakatsu and White, 2010) also includes discourse
relations in the grammar with Discourse Combi-
natory Categorial Grammar and a type-theoretical
framework to provide a text (rather than sentence)
generation process.
7 Conclusion
This paper shows how G-TAG can be encoded as
ACG. It relies on the fact that both G-TAG and the
encoding of TAG within ACG make the deriva-
tion tree a primary notion. Then we can bene-
fit from the polynomial reversibility of the ACG
framework. It also offers a generalization of the
process to all kinds of adjunctions, including the
predicative ones. It also offers a new insight on
discourse grammars for the adverbial connective
encoding (Danlos, 2011). Note that contrary to an
important part of G-TAG that offers a way (based
on a semantic and a linguistic analysis) to rank the
different realizations of a conceptual representa-
tion, we do not deal here with such preferences.
As syntactic ambiguity treatment is not usually
part of the syntactic formalism, we prefer the ?re-
alization ambiguity? treatment not to be part of the
generation formalism. Finally, a crucial perspec-
tive is to integrate a theory of generation of re-
ferring expressions relying on type-theoretical ap-
proaches to dynamics semantics (de Groote, 2006;
de Groote and Lebedeva, 2010) that would ensure
a large compatibility with the ACG framework.
42
References
[Abeille?2002] Anne Abeille?. 2002. Une grammaire
e?lectronique du franc?ais. Sciences du langage.
CNRS E?ditions.
[Danlos et al.2001] Laurence Danlos, Bertrand Gaiffe,
and Laurent Roussarie. 2001. Document sructuring
a` la SDRT. In Helmut Horacek, Nicolas Nicolov,
and Leo Wanner, editors, Proceedings of the ACL
2001 Eighth European Workshop on Natural Lan-
guage Generation (EWNLG). http://aclweb.
org/anthology/W/W01/W01-0803.pdf.
[Danlos et al.2011] Laurence Danlos, Fre?de?ric Meu-
nier, and Vanessa Combet. 2011. EasyText: an
operational NLG system. In ENLG 2011, 13th
European Workshop on Natural Language Gener-
ation, September. http://hal.inria.fr/
inria-00614760/en/.
[Danlos1998] Laurence Danlos. 1998. G-TAG :
Un formalisme lexicalise? pour la ge?ne?ration de
textes inspire? de TAG. Traitement Automatique
des Langues, 39(2). http://hal.inria.fr/
inria-00098489.
[Danlos2000] Laurence Danlos. 2000. G-TAG: A lex-
icalized formalism for text generation inspired by
tree adjoining grammar. In Anne Abeille? and Owen
Rambow, editors, Tree Adjoining Grammars: For-
malisms, Linguistic Analysis, and Processing, pages
343?370. CSLI Publications.
[Danlos2011] Laurence Danlos. 2011. D-STAG:
a formalism for discourse analysis based on
SDRT and using synchronous TAG. In Philippe
de Groote, Markus Egg, and Laura Kallmeyer, ed-
itors, 14th conference on Formal Grammar - FG
2009, volume 5591 of LNCS/LNAI, pages 64?84.
Springer. http://dx.doi.org/10.1007/
978-3-642-20169-1_5.
[de Groote and Lebedeva2010] Philippe de Groote and
Ekaterina Lebedeva. 2010. Presupposition ac-
commodation as exception handling. In Proceed-
ings of the SIGDIAL 2010 Conference, pages 71?74,
Tokyo, Japan, September. Association for Computa-
tional Linguistics. http://www.aclweb.org/
anthology/W/W10/W10-4313.
[de Groote and Pogodalla2004] Philippe de Groote and
Sylvain Pogodalla. 2004. On the expressive power
of Abstract Categorial Grammars: Representing
context-free formalisms. Journal of Logic, Lan-
guage and Information, 13(4):421?438. http:
//hal.inria.fr/inria-00112956.
[de Groote2001] Philippe de Groote. 2001. Towards
Abstract Categorial Grammars. In Association
for Computational Linguistics, 39th Annual Meet-
ing and 10th Conference of the European Chap-
ter, Proceedings of the Conference, pages 148?
155. http://aclweb.org/anthology/P/
P01/P01-1033.pdf.
[de Groote2006] Philippe de Groote. 2006. To-
wards a montagovian account of dynam-
ics. In Masayuki Gibson and Jonathan
Howell, editors, Proceedings of Semantics
and Linguistic Theory (SALT) 16. http:
//elanguage.net/journals/index.
php/salt/article/view/16.1/1791.
[Gardent and Perez-Beltrachini2010] Claire Gardent
and Laura Perez-Beltrachini. 2010. RTG based sur-
face realisation for TAG. In Proceedings of the 23rd
International Conference on Computational Lin-
guistics (COLING 2010), pages 367?375, Beijing,
China, August. Coling 2010 Organizing Committee.
http://www.aclweb.org/anthology/
C10-1042.
[Joshi and Schabes1997] Aravind K. Joshi and Yves
Schabes. 1997. Tree-adjoining grammars. In
G. Rozenberg and A. Salomaa, editors, Handbook
of formal languages, volume 3, chapter 2. Springer.
[Joshi et al.1975] Aravind K. Joshi, Leon S. Levy, and
Masako Takahashi. 1975. Tree adjunct gram-
mars. Journal of Computer and System Sciences,
10(1):136?163.
[Kallmeyer and Romero2004] Laura Kallmeyer and
Maribel Romero. 2004. LTAG semantics with
semantic unification. In Proceedings of TAG+7,
pages 155?162.
[Kallmeyer and Romero2007] Laura Kallmeyer and
Maribel Romero. 2007. Scope and situation
binding for LTAG. Research on Language and
Computation, 6(1):3?52. http://dx.doi.
org/10.1007/s11168-008-9046-6.
[Kanazawa2007] Makoto Kanazawa. 2007. Pars-
ing and generation as datalog queries. In Pro-
ceedings of the 45th Annual Meeting of the
Association of Computational Linguistics (ACL),
pages 176?183. http://www.aclweb.org/
anthology/P/P07/P07-1023.
[Kanazawa2011] Makoto Kanazawa, 2011. Parsing
and generation as Datalog query evaluation. Un-
der review. http://research.nii.ac.jp/
?kanazawa/publications/pagadqe.pdf.
[Meunier1997] Fre?de?ric Meunier. 1997. Implantation
du formalisme de ge?ne?ration G-TAG. Ph.D. thesis,
Universite? Paris 7 ? Denis Diderot.
[Nakatsu and White2010] Crytal Nakatsu and Michael
White. 2010. Generating with discourse com-
binatory categorial grammar. Linguistic Is-
sues in Language Technology, 4(1). http:
//elanguage.net/journals/index.
php/lilt/article/view/1277/871.
[Nesson and Shieber2006] Rebecca Nesson and
Stuart M. Shieber. 2006. Simpler TAG seman-
tics through synchronization. In Proceedings
of the 11th Conference on Formal Grammar,
Malaga, Spain, 29?30 July. CSLI Publications.
43
http://cslipublications.stanford.
edu/FG/2006/nesson.pdf.
[Pogodalla2004] Sylvain Pogodalla. 2004. Comput-
ing Semantic Representation: Towards ACG Ab-
stract Terms as Derivation Trees. In Proceedings
of TAG+7, pages 64?71. http://hal.inria.
fr/inria-00107768.
[Pogodalla2009] Sylvain Pogodalla. 2009. Advances
in Abstract Categorial Grammars: Language The-
ory and Linguistic Modeling. ESSLLI 2009 Lec-
ture Notes, Part II. http://hal.inria.fr/
hal-00749297.
[Schabes and Shieber1994] Yves Schabes and Stu-
art M. Shieber. 1994. An alternative conception
of tree-adjoining derivation. Computational Lin-
guistics, 20(1):91?124. http://aclweb.org/
anthology/J/J94/J94-1004.pdf.
[Storoshenk and Frank2012] Dennis Ryan Storoshenk
and Robert Frank. 2012. Deriving syntax-semantics
mappings: node linking, type shifting and scope am-
biguity. In Proceedings of TAG+11, pages 10?18.
[Webber2004] Bonnie Webber. 2004. D-LTAG: Ex-
tending :exicalized TAG to discourse. Cognitive Sci-
ence, 28:751?779. http://dx.doi.org/0.
1207/s15516709cog2805_6.
44
