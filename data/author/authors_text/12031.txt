Proceedings of the 11th International Conference on Parsing Technologies (IWPT), pages 242?253,
Paris, October 2009. c?2009 Association for Computational Linguistics
Dependency Constraints for Lexical Disambiguation
Guillaume Bonfante
LORIA INPL
guillaume.bonfante@loria.fr
Bruno Guillaume
LORIA INRIA
bruno.guillaume@loria.fr
Mathieu Morey
LORIA Nancy-Universite?
mathieu.morey@loria.fr
Abstract
We propose a generic method to per-
form lexical disambiguation in lexicalized
grammatical formalisms. It relies on de-
pendency constraints between words. The
soundness of the method is due to invariant
properties of the parsing in a given gram-
mar that can be computed statically from
the grammar.
1 Introduction
In this work, we propose a method of lexical dis-
ambiguation based on the notion of dependencies.
In modern linguistics, Lucien Tesnie`re devel-
oped a formal and sophisticated theory with de-
pendencies (Tesnie`re, 1959). Nowadays, many
current grammatical formalisms rely more or less
explicitly on the notion of dependencies between
words. The most straightforward examples are
formalisms in the Dependency Grammars family
but it is also true of the phrase structure based for-
malisms which consider that words introduce in-
complete syntactic structures which must be com-
pleted by other words. This idea is at the core of
Categorial Grammars (CG) (Lambek, 1958) and
all its trends such as Abstract Categorial Gram-
mars (ACG) (de Groote, 2001) or Combinatory
Categorial Grammars (CCG) (Steedman, 2000),
being mostly encoded in their type system. De-
pendencies in CG were studied in (Moortgat and
Morrill, 1991) and for CCG in (Clark et al,
2002; Koller and Kuhlmann, 2009). Other for-
malisms can be viewed as modeling and using
dependencies, such as Tree Adjoining Grammars
(TAG) (Joshi, 1987) with their substitution and ad-
junction operations. Dependencies for TAG were
studied in (Joshi and Rambow, 2003). More re-
cently, Marchand et al (2009) showed that it is
also possible to extract a dependency structure
from a syntactic analysis in Interaction Grammars
(IG) (Guillaume and Perrier, 2008).
Another much more recent concept of polarity
can be used in grammatical formalisms to express
that words introduce incomplete syntactic struc-
tures. IG directly use polarities to describe these
structures but it is also possible to use polarities
in other formalisms in order to make explicit the
more or less implicit notion of incomplete struc-
tures: for instance, in CG (Lamarche, 2008) or in
TAG (Kahane, 2006; Bonfante et al, 2004; Gar-
dent and Kow, 2005). On this regard, Marchand
et al (2009) exhibited a direct link between polar-
ities and dependencies. This encourages us to say
that in many respects dependencies and polarities
are two sides of the same coin.
The aim of this paper is to show that dependen-
cies can be used to express constraints on the tag-
gings of a sentence and hence these dependency
constraints can be used to partially disambiguate
the words of a sentence. We will see that, in prac-
tice, using the link between dependencies and po-
larities, these dependency constraints can be com-
puted directly from polarized structures.
Exploiting the dependencies encoded in lexical
entries to perform disambiguation is the intuition
behind supertagging (Bangalore and Joshi, 1999),
a method introduced for LTAG and successfully
applied since then to CCG (Clark and Curran,
2004) and HPSG (Ninomiya et al, 2006). These
approaches select the most likely lexical entry (en-
tries) for each word, based on Hidden Markov
Models or Maximum Entropy Models. Like the
work done by Boullier (2003), our method is not
based on statistics nor heuristics, but on a neces-
sary condition of the deep parsing. Consequently,
we accept to have more than one lexical tagging
for a sentence, as long as we can ensure to have
the good ones (when they exist!). This property is
particulary useful to ensure that the deep parsing
will not fail because of an error at the disambigua-
tion step.
In wide-coverage lexicalized grammars, a word
242
typically has about 10 corresponding lexical de-
scriptions, which implies that for a short sentence
of 10 words, we get 1010 possible taggings. It is
not reasonable to treat them individually. To avoid
this, it is convenient to use an automaton to rep-
resent the set of all paths. This automaton has lin-
ear size with regard to the initial lexical ambiguity.
The idea of using automata is not new. In partic-
ular, methods based on Hidden Markov Models
(HMM) use such a technique for part-of-speech
tagging (Kupiec, 1992; Merialdo, 1994). Using
automata, we benefit from dynamic programming
procedures, and consequently from an exponential
temporal and space speed up.
2 Abstract Grammatical Framework
Our filtering method is applicable to any lexical-
ized grammatical formalism which exhibits some
basic properties. In this section we establish these
properties and define from them the notion of Ab-
stract Grammatical Framework (AGF).
Formally, an Abstract Grammatical Frame-
work is an n-tuple (V, S,G,anc,F,p,dep)
where:
? V is the vocabulary: a finite set of words of
the modeled natural language;
? S is the set of syntactic structures used by
the formalism;
? G ? S is the grammar: the finite set of initial
syntactic structures; a finite list [t1, . . . , tn] of
elements of G is called a lexical tagging;
? anc : G ? V maps initial syntactic struc-
tures to their anchors;
? F ? S is the set of final syntactic structures
that the parsing process builds (for instance
trees);
? p is the parsing function from lexical tag-
gings to finite subsets of F;
? dep is the dependency function which maps
a couple composed of a lexical tagging and a
final syntactic structure to dependency struc-
tures.
Note that the anc function implies that the
grammar is lexicalized: each initial structure in G
is associated to an element of V. Note also that no
particular property is required on the dependency
structures that are obtained with the dep function,
they can be non-projective for instance.
We call lexicon the function (written `) from V
to subsets of G defined by:
`(w) = {t ? G | anc(t) = w}.
We will say that a lexical tagging L =
[t1, . . . , tn] is a lexical tagging of the sentence
[anc(t1), . . . ,anc(tn)].
The final structures in p (L) ? F are called the
parsing solutions of L.
Henceforth, in our examples, we will consider
the ambiguous French sentence (1).
(1) ?La belle ferme la porte?
Example 1 We consider the following toy AGF,
suited for parsing our sentence:
? V = { ?la?, ?belle?, ?ferme?, ?porte? };
? the grammar G is given in the table be-
low: each ? corresponds to an element in
G, written with the category and the French
word as subscript. For instance, the French
word ?porte? can be either a common noun
(?door?) or a transitive verb (?hangs?);
hence G contains the 2 elements CNporte and
TrVporte .
la belle ferme porte
Det ?
LAdj ? ?
RAdj ? ?
CN ? ? ? ?
Clit ?
TrV ? ?
IntrV ?
In our example, categories stand for, respec-
tively: determiner, left adjective, right adjec-
tive, common noun, clitic pronoun, transitive
verb and intransitive verb.
With respect to our lexicon, for sentence (1),
there are 3 ? 3 ? 5 ? 3 ? 2 = 270 lexical tag-
gings.
The parsing function p is such that 3 lexical
taggings have one solution and the 267 remaining
ones have no solution; we do not need to precise
the final structures, so we only give the English
translation as the result of the parsing function:
243
? p([Detla , CNbelle , TrVferme , Detla , CNporte ]) =
{?The nice girl closes the door?}
? p([Detla , LAdjbelle , CNferme , Clitla , TrVporte ]) =
{?The nice farm hangs it?}
? p([Detla , CNbelle , RAdjferme , Clitla , TrVporte ]) =
{?The firm nice girl hangs it?}
3 The Companionship Principle
We have stated in the previous section the frame-
work and the definitions required to describe our
principle.
3.1 Potential Companion
We say that u ? G is a companion of t ? G if
anc(t) and anc(u) are linked by a dependency
in dep(L,m) for some lexical tagging L which
contains t and u and some m ? p(L). The subset
of elements of G that are companions of t is called
the potential companion set of t.
The Companionship Principle says that if a lex-
ical tagging contains some t but no potential com-
panion of t, then it can be removed.
In what follows, we will generalize a bit this
idea in two ways. First, the same t can be implied
in more than one kind of dependency and hence it
can have several different companion sets with re-
spect to the different kinds of dependencies. Sec-
ondly, it can be the case that some companion t
has to be on the right (resp. on the left) to fulfill its
duty. These generalizations are done through the
notion of atomic constraints defined below.
3.2 Atomic constraints
We say that a pair (L,R) of subsets of G is an
atomic constraint for an initial structure t ? G
if for each lexical tagging L = [t1, . . . , tn] such
that p(L) 6= ? and t = ti for some i then:
? either there is some j < i such that tj ? L,
? or there is some j > i such that tj ? R.
In other words, (L,R) lists the potential com-
panions of t, respectively on the left and on the
right.
A system of constraints for a grammar G is a
function C which associates a finite set of atomic
constraints to each element of G.
The Companionship Principle is an immedi-
ate consequence of the definition of atomic con-
straints. It can be stated as the necessary condi-
tion:
The Companionship Principle
If a lexical tagging [t1, . . . , tn] has a solution
then for all i and for all atomic constraints
(L,R) ? C(ti)
? {t1, . . . , ti?1} ? L 6= ?
? or {ti+1, . . . , tn} ? R 6= ?.
Example 2 Often, constraints can be expressed
independently of the anchors. In our example, we
use the category to refer to the subset of G of struc-
tures defined with this category: LAdj for instance
refers to the subset {LAdjbelle , LAdjferme}.
We complete the example of the previous section
with the following constraints1:
? t ? CN? (Det, ?) ? C(t)
? t ? LAdj? (?, CN) ? C(t)
? t ? RAdj? (CN, ?) ? C(t)
? t ? Det? (?, CN) ? C(t)
? t ? Det? (TrV, TrV ? IntrV) ? C(t)
? t ? TrV? (Clit, Det) ? C(t)
? t ? TrV? (Det, ?) ? C(t)
? t ? IntrV? (Det, ?) ? C(t)
? t ? Clit? (?, TrV) ? C(t)
The two constraints ? and ? for instance ex-
press that every determiner is implied in two de-
pendencies. First, it must find a common noun on
its right to build a noun phrase. Second, the noun
phrase has to be used in a verbal construction.
Now, let us consider the lexical tagging:
[Detla , LAdjbelle , TrVferme , Clitla , CNporte ] and
the constraint ? (a clitic is waiting for a transitive
verb on its right). This constraint is not fulfilled
by the tagging so this tagging has no solution.
3.3 The ?Companionship Principle?
language
Actually, a lexical tagging is an element of the
formal language G? and we can consider the fol-
lowing three languages. First, G? itself. Second,
the set C ? G? corresponds to the lexical tag-
gings which can be parsed. The aim of lexical
disambiguation is then to exhibit for each sen-
tence [w1, . . . , wn] all the lexical taggings that are
within C. Third, the Companionship Principle de-
fines the language P of lexical taggings which ver-
ify this Principle. P squeezes between the two lat-
1These constraints are relative to our toy grammar and are
not linguistically valid in a larger context.
244
ter sets C ? P ? G?. Remarkably, the language
P can be described as a regular language. Since C
is presumably not a regular language (at least for
natural languages!), P is a better regular approxi-
mation than the trivial G?.
Let us consider one lexical entry t and an atomic
constraint (L,R) ? C(t). Then, the set of lexical
taggings verifying this constraint can be described
as
Lt:(L,R) = {(({L)?t({R)?)
where { denotes the complement of a set.
Since P is defined as the lexical taggings verify-
ing all constraints, P is a regular language defined
by :
P = ?
(L,R)?C(t)
Lt:(L,R)
From the Companionship Principle, we derive
a lexical disambiguation Principle which simply
tests tagging candidates with P . Notice that P can
be statically computed (at least, in theory) from
the grammar itself.
Example 3 For instance, for our example gram-
mar, this automaton is given in the figure 1 where
c=Clit, n=CN, d=Det, i=IntrV, l=LAdj, r=RAdj
and t=TrV.
A rough approximation of the size of the au-
tomaton corresponding to P can be easily com-
puted. Since each automaton Lt:(L,R) has 4 states,
P has at most 4m states where m is the num-
ber of atomic constraints. For instance, the gram-
mar used in the experiments contains more than
one atomic constraint for each lexical entry, and
m > |G| > 106. Computing P by brute-force is
then intractable.
4 Implementation of the Companionship
Principle with automata
In this section we show how to use the Compan-
ionship Principle for disambiguation. Actually, we
propose two implementations based on the princi-
ple, an exact one and an approximate one. The
latter is really fast and can be used as a first step
before applying the first one.
4.1 Automaton to represent sets of lexical
taggings
The number of lexical taggings grows exponen-
tially with the length of sentences. To avoid that,
we represent sets of lexical taggings as the sets of
paths of some acyclic automata where transitions
are labeled by elements of G . We call such an
automaton a lexical taggings automaton (LTA).
Generally speaking, such automata save a lot of
space. For instance, given a sentence [w1, . . . , wn]
the number of lexical taggings to consider at the
beginning of the parsing process is ?1?i?n|`(wi)|.
This set of taggings can be efficiently represented
as the set of paths of the automaton with n + 1
states s0, . . . , sn and with a transition from si?1
to si with the label t for each t ? `(wi). This
automaton has?1?i?n |`(wi)| transitions.
Example 4 With the data of the previous exam-
ples, we have the initial automaton:
0 1DetCN
Clit
2LAdjRAdj
CN
3
TrV
IntrVLAdjRAdj
CN
4DetCN
Clit
5CNTrV
To improve readability, only the categories are
given on the edges, while the French words can be
inferred from the position in the automaton.
4.2 Exact Companionship Principle (ECP)
Suppose we have a LTA A for a sentence
[w1, . . . , wn]. For each transition t and for each
atomic constraint in (L,R) ? C(t), we construct
an automaton At,L,R in the following way.
Each state s of At,L,R is labeled with a triple
composed of a state of the automaton A and
two booleans. The intended meaning of the first
boolean is to say that each path reaching this
state passes through the transition t. The second
boolean means that the atomic constraint (L,R) is
necessarily fulfilled.
The initial state is labeled (s0, F, F) where s0 is
the initial state of A and other states are labeled as
follows: if s u?? s? in A then, in At,L,R, we have:
1. (s, F, b) u?? (s?, T, b) if u = t
2. (s, F, b) u?? (s?, F, T) if u ? L
3. (s, F, b) u?? (s?, F, b) if u /? L
4. (s, T, b) u?? (s?, T, T) if u ? R
5. (s, T, b) u?? (s?, T, b) if u /? R
where b ? {T, F}.
245
Det
CN
li
L
AdjRjTr
V
t
I
N
n
i
LD

AdjRjTjr
t LL
ANjir

AdjRjTr
t

L
ANjir
Atjir
Le
N
ANjir
Ld
t
LC

Ll
R
t
N
i
AtjdjRjTr
LV
ANjir
ANjijTr
d

R
t
R N AdjijTr

t
AdjijRjTjr
N
D
t
R
ANjdjijTjr
t
R
ANjdjijTr
t
RN
Adjir
t

R
AtjNjdjir
LI
R
Adjijr
Ln
t
N
d
t
ANjir ARjTr
R

AtjNjdjijTr
R
t
ANjdjijr
N
AtjdjirR
L

N
AtjdjijRjTr


N
tAdjijr
R
R
t

ANjdjir
N
tAdjijRjTjr
Figure 1: The P language for G
It is then routine to show that, for each state la-
beled (s, b1, b2):
? b1 is T iff all paths from the initial state to s
contain the transition t;
? b2 is T iff for all paths p reaching this state,
either there is some u ? L or p goes through
t and there is some u ? R. In other words,
the constraint is fulfilled.
In conclusion, a path ending with (sf , T, F) with
sf a final state of A is built with transitions 1, 3
and 5 only and hence contains t but no transition
able to fulfill the constraint. The final states are:
? (sf , F, b): each path ending here does not
contain the edge t and thus the constraint
does not apply here,
? (sf , T, T) each path ending here contains the
edge t but it contains also either a transition
2 or 4, so the constraint is fulfilled by these
paths.
The size of these automata is easily bounded by
4n where n is the size of A. Using a slightly more
intricated presentation, we built automata of size
2n.
Example 5 We give below the automaton A for
the atomic constraint ? (an intransitive verb is
waiting for a determiner on its left):
Detet
CeteNliL
Cetet
AdAjRL
TeteNrVInVIn
Ad
Tetet
rVInVInAd
eteN
rVIn
VIn
Ad
N
eNeNL
etet
rVIn
VInAdN
eNet
L
eteNliLAdAjRL
etet
liLAdAjRL
eNeNliLAdAjRL
eNet
liLAdAjRL
eteNAdN
etetAdN
eNeNAdN
eNetAdN
The dotted part of the graph corresponds to the
part of the automaton that can be safely removed.
After minimization, we finally obtain:
D
etCN
el
iLiAdN
jRTrVITrV
iL
jl
RTrVITrViL
n
RTrV
ITrV
iL
 N
RTrV
ITrViL
tCNiLiAdN iL
This automaton contains 234 paths (36 lexical
taggings are removed by this constraint).
For each transition t of the lexical taggings au-
tomaton and for each constraint (L,R) ? C(t),
we construct the atomic constraint automaton
At,L,R. The intersection of these automata rep-
resents all the possible lexical taggings of the sen-
tence which respect the Companionship Principle.
246
That is, we output :
ACP =
?
1?i?n, t?A;(L,R)?C(t)
At,L,R
It can be shown that the automaton is the same
as the one obtained by intersection with the au-
tomaton of the language defined in 3.3:
ACP = A ? P
Example 6 In our example, the intersection of
the 9 automata built for the atomic constraints is
given below:
D etCN
liLAd
l
jR
Tr
jR TVIn
TNn
jR
LAd
In
TANn jN
tCN
jR
jN
jR In
jR
This automaton has 8 paths: there are 8 lexical
taggings which fulfill every constraint.
4.3 Approximation: the Quick
Companionship Principle (QCP)
The issue with the previous algorithm is that it in-
volves a large number of automata (actuallyO(n))
where n is the size of the input sentence. Each
of these automata has size O(n). The theoreti-
cal complexity of the intersection is then O(nn).
Sometimes, we face the exponential. So, let
us provide an algorithm which approximates the
Principle. The idea is to consider at the same time
all the paths that contain some transition.
We consider a LTA A. We write ?A the prece-
dence relation on transitions in an automaton A.
We define lA(t) = {u ? G, u ?A t} and rA(t) =
{u ? G, t ?A u}.
For each transition s t?? s? and each constraint
(L,R) ? C(t), if lA(t) ? L = ? and rA(t) ? R =
?, then none of the lexical taggings which use the
transition t has a solution and the transition t can
be safely removed from the automaton.
This can be computed by a double-for loop: for
each atomic constraint of each transition, verify
that either the left context or the right context of
the transition contains some structure to solve the
constraint. Observe that the cost of this algorithm
is O(n2), where n is the size of the input automa-
ton.
Note that one must iterate this algorithm until a
fixpoint is reached. Indeed, removing a transition
which serves as a potential companion breaks the
verification. Nevertheless, since for each step be-
fore the fixpoint is reached, we remove at least one
transition, we iterate the double-for at most O(n)
times. The complexity of the whole algorithm is
thenO(n3). In practice, we have observed that the
complexity is closer to O(n2): only 2 or 3 loops
are enough to reach the fixpoint.
Example 7 If we apply the QCP to the automaton
of Example 4, in the first step, only the transition
0 CN?? 1 is removed by applying the atomic con-
straint ?. In the next step, the transition 1 RAdj???? 2
is removed by applying the atomic constraint ?.
The fixpoint is reached and the output automaton
(with 120 paths) is:
0 1DetCNlt 2iLAdCj 3
iLAd
RLAd
CjTrV
IntrV
4DetCjCNlt 5CjTrV
5 The Generalized Companionship
Principle
In practice, of course, we have to face the problem
of the computation of the constraints. In a large
coverage grammar, the size of G is too big to com-
pute all the constraints in advance. However, as
we have seen in example 2 we can identify sub-
sets of G that have the same constraints; the same
way, we can use these subsets to give a more con-
cise presentation of the L and R sets of the atomic
constraints. This motivates us to define a General-
ized Principle which is stated on a quotient set of
G.
5.1 Generalized atomic constraints
Let U be a set of subsets of G that are a partition
of G. For t ? G, we write t the subset of U which
contains t.
We say that a pair (L,R) of subsets of U is a
generalized atomic constraint for u ? U if for
each lexical tagging L = [t1, . . . , tn] such that
p(L) 6= ? and u = ti for some i then:
? either there is some j < i such that tj ? L,
? or there is some j > i such that tj ? R.
A system of generalized constraints for a par-
titionU of a grammar G is a function Cwhich asso-
247
ciates a finite set of generalized atomic constraints
to each element of U.
5.2 The Generalized Principle
The Generalized Companionship Principle is then
an immediate consequence of the previous defini-
tion and can be stated as the necessary condition:
The Generalized Companionship Principle
If a lexical tagging [t1, . . . , tn] has a solution
then for all i and for all generalized atomic con-
straints (L,R) ? C(ti)
? {t1, . . . , ti?1} ? L 6= ?
? or {ti+1, . . . , tn} ? R 6= ?.
Example 8 The constraints given in example 2
are in fact generalized atomic constraints on the
set (recall that we write LAdj for the 2 elements
set {LAdjbelle , LAdjferme}):
U = {Det, LAdj, RAdj, CN, Clit, TrV, IntrV}.
Then the constraints are expressed on |U| = 7 el-
ements and not on |G| = 13.
A generalized atomic constraint on U can, of
course, be expressed as a set of atomic constraints
on G: let u ? U and t ? G such that t = u
(L,R) ? C(u) =?
(?
L?L
L,
?
R?R
R
)
? C(t)
5.3 Implementation of lexicalized grammars
In implementations of large coverage linguistic re-
sources, it is very common to have, first, the de-
scription of the set of ?different? structures needed
to describe the modeled natural language and then
an anchoring mechanism that explains how words
of the lexicon are linked to these structures. We
call unanchored grammar the set U of differ-
ent structures (not yet related to words) that are
needed to describe the grammar. In this context,
the lexicon is split in two parts:
? a function ` from V to subsets of U,
? an anchoring function ? which builds the
grammar elements from a word w ? V and
an unanchored structure u ? `(w); we sup-
pose that ? verifies that anc(?(w, u)) = w.
In applications, we suppose that U, ` and ? are
given. In this context, we define the grammar as
the codomain of the anchoring function:
G = ?
w?V,u?`(w)
?(w, u)
Now, we can define generalized constraints on
the unanchored grammar, which are independent
of the lexicon and can be computed statically for a
given unanchored grammar.
6 Application to Interaction Grammars
In this section, we apply the Companionship Prin-
ciple to the Interaction Grammars formalism. We
first give a short and simplified description of IG
and an example to illustrate them at work; we re-
fer the reader to (Guillaume and Perrier, 2008) for
a complete and detailed presentation.
6.1 Interaction Grammars
We illustrate some of the important features on
the French sentence (2). In this sentence, ?la?
is an object clitic pronoun which is placed before
the verb whereas the canonical place for the (non-
clitic) object is on the right of the verb.
(2) ?Jean la demande.? [John asks for it]
The set F of final structures, used as output of
the parsing process, contains ordered trees called
parse trees (PT). An example of a PT for the sen-
tence (2) is given in Figure 2. A PT for a sentence
contains the words of the sentence or the empty
word  in its leaves (the left-right order of the tree
leaves follows the left-right order of words in the
input sentence). The internal nodes of a PT repre-
sent the constituents of the sentence. The morpho-
syntactic properties of these constituents are de-
scribed with feature structures (only the category
is shown in the figure).
As IG use the Model-Theoretic Syntax (MTS)
framework, a PT is defined as the model of a set
of constraints. Constraints are defined at the word
level: words are associated to a set of constraints
formally described as a polarized tree descrip-
tion (PTD). A PTD is a set of nodes provided with
relations between these nodes. The three PTDs
used to build the model above are given in Fig-
ure 3. The relations used in the PTDs are: imme-
diate dominance (lines) and immediate sisterhood
(arrows). Nodes represent syntactic constituents
248
A2-A3=S
B1-B3=NP C2-C3=V D2-D3=NP
Jean E2=Cl F2-F3=V ?
la demande
Figure 2: The PT of sentence (2)
and relations express structural dependencies be-
tween these constituents.
Moreover, nodes carry a polarity: the set of po-
larities is {+,?,=,?}. A + (resp.?) polarity
represents an available (resp. needed) resource, a
? polarity describes a node which is unsaturated.
Each + must be associated to exactly one ? (and
vice versa) and each ? must be associated to at
least another polarity.
A2-3=
SB1N
PCVD
JCVe aC-3=
nCEJl FCVe ?
l1
PdED
Adm3= JdEe adm3=
FdEe
B1NB
Figure 3: PTDs for the sentence (2)
Now, we define a PT to be a model of a set of
PTDs if there is a surjective function I from nodes
of the PTDs to nodes of the PT such that:
? relations in the PTDs are realized in the PT:
if M is a daughter (resp. immediate sister)
of N in some PTD then I(M) is a daughter
(resp. immediate sister) of I(N);
? each node N in the PT is saturated: the
composition of the polarities of the nodes in
I?1(N) with the associative and commuta-
tive rule given in Table 4 is =;
? the feature structure of a node N in the PT is
the unification of the feature structures of the
nodes in I?1(N).
One of the strong points of IG is the flexibility
given by the MTS approach: PTDs can be partially
superposed to produce the final tree (whereas su-
perposition is limited in usual CG or in TAG for
instance). In our example, the four grey nodes
in the PTD which contains ?la? are superposed
to the four grey nodes in the PTD which contains
?demande? to produce the four grey nodes in the
model.
? ? + =
? ? ? + =
? ? =
+ + =
= =
Figure 4: Polarity composition
In order to give an idea of the full IG system,
we briefly give here the main differences between
our presentation and the full system.
? Dominance relations can be underspecified:
for instance a PTD can impose a node to be an
ancestor of another one without constraining
the length of the path in the model. This is
mainly used to model unbounded extraction.
? Sisterhood relations can also be underspeci-
fied: when the order on subconstituents is not
total, it can be modeled without using several
PTDs.
? Polarities are attached to features rather than
nodes: it sometimes gives more freedom
to the grammar writer when the same con-
stituent plays a role in different constructions.
? Feature values can be shared between several
nodes: once again, this is a way to factorize
the unanchored grammar.
The application of the Companionship Princi-
ple is described on the reduced IG but it can
be straightforwardly extended to full IG with
unessential technical details.
Following the notation given in 5.3, an IG is
made of:
? A finite set V of words;
? A finite set U of unanchored PTDs (without
any word attached to them);
? A lexicon function ` from V to subsets of U.
249
When t ? `(w), we can construct the anchored
PTD ?(w, u). Technically, in each unanchored
PTD u, a place is marked to be the anchor, i.e.
to be replaced by the word during the anchoring
process. Moreover, the anchoring process can also
be used to refine some features. The fact that
the feature can be refined gives more flexibility
and more compactness to the unanchored gram-
mar construction. In the French IG grammar, the
same unanchored PTD can be used for masculine
or feminine common nouns and the gender is spec-
ified during the anchoring to produce distinct an-
chored PTDs for masculine and feminine nouns. G
is defined by:
G = ?
w?V,u?`(w)
?(w, u)
The parsing solutions of a lexical tagging is the
set of PTs that are models of the list of PTDs de-
scribed by the lexical tagging:
p(L) = {m ? F | m is a model of L}
With the definitions of this section, an IG is a
special case of AGF as defined in section 2.
6.2 Companionship Principle for IG
In order to apply the Companionship Principle, we
have to explain how the generalized atomic con-
straints are built for a given grammar. One way
is to look at dependency structures but in IG po-
larities are built in and then we can read the de-
pendency information we need directly on polari-
ties. A requirement to build a model is the satura-
tion of all the polarities. This requirement can be
expressed using atomic constraints. Each time a
PTD contains an unsaturated polarity +, ? or ?,
we have to find some other compatible dual po-
larity somewhere else in the grammar to saturate
it.
From the general MTS definition of IG above,
we can define a step by step process to build mod-
els of a lexical tagging. The idea is to build in-
crementally the interpretation function I with the
atomic operation of node merging. In this atomic
operation, we choose two nodes and make the hy-
pothesis that they have the same image through I
and hence that they can be identified.
Now, suppose that the unanchored PTD u con-
tains some unsaturated polarity p. We can use the
atomic operation of node merging to test if the
unanchored PTD u? can be used to saturate the po-
larity p. Let L (resp R) be the set of PTDs that
can be used on the left (resp. on the right) of u
to saturate p, then (L,R) is a generalized atomic
constraint in C(u).
7 Companionship Principle for other
formalisms
As we said in the introduction, many current gram-
matical formalisms can more or less directly be
used to generate dependency structures and hence
are candidate for disambiguation with the Com-
panionship Principle. With IG, we have seen that
dependencies are strongly related to polarities: de-
pendency constraints in IG are built with the polar-
ity system.
We give below two short examples of polarity
use to define atomic constraints on TAG and on
CG. We use, as for IG, the polarity view of depen-
dencies to describe how the constraints are built.
7.1 Tree Adjoining Grammars
Feature-based Tree Adjoining Grammars (here-
after FTAG) (Joshi, 1987) are a unification based
version of Tree Adjoining Grammars. An FTAG
consists of a set of elementary trees and of two
tree composition operations: substitution and ad-
junction. There are two kinds of trees: auxiliary
and initial. Substitution inserts a tree t with root
r onto a leaf node l of another tree t? under the
condition that l is marked as a place for substitu-
tion and l and r have compatible feature structures.
Adjunction inserts an auxiliary tree t into a tree t?
by splitting a node n of t? under the condition that
the feature structures of the root and foot nodes of
t are compatible with the top and bottom ones of
n.
Getting the generalized atomic constraints and
the model building procedure for lexical tagging
is extremely similar to what was previously de-
scribed for IG if we extend the polarization pro-
cedure which was described in (Gardent and Kow,
2005) to do polarity based filtering in FTAG. The
idea is that for each initial tree t, its root of cate-
gory C is marked as having the polarity +C, and
its substitution nodes of category S are marked as
having the polarity ?S. A first constraint set con-
tains trees t? whose root is polarized +S and such
that feature structures are unifiable. A second con-
straint set contains trees t?? which have a leaf that
is polarized ?C. We can extend this procedure to
250
auxiliary trees: each auxiliary tree t of category A
needs to be inserted in a node of category A of an-
other tree t?. This gives us a constraint in the spirit
of the ? polarity in IG: C(t) contains all the trees
t? in which t could be inserted2.
7.2 Categorial Grammars
In their type system, Categorial Grammars en-
code linearity constraints and dependencies be-
tween constituents. For example, a transitive verb
is typed NP\S/NP , meaning that it waits for a
subject NP on its left and an object NP on its
right. This type can be straightforwardly decom-
posed as two ?NP and one +S polarities. Then
again, getting the generalized atomic constraints
is immediate and in the same spirit as what was
described for IG.
7.3 Non-lexicalized formalisms
The lexicalization condition stated in section 2
excludes non-lexicalized formalisms like LFG or
HPSG. Nothing actually prevents our method
from being applied to these, but adding non-
lexicalized combinators requires to complexify the
formal account of the method. Adapting our
method to HPSG would result in a generaliza-
tion and unification of some of the techniques de-
scribed in (Kiefer et al, 1999).
8 Experimental results
8.1 Setup
The experiments are performed using a French IG
grammar on a set of 31 000 sentences taken from
the newspaper Le Monde.
The French grammar we consider (Perrier,
2007) contains |U| = 2 088 unanchored trees.
It covers 88% of the grammatical sentences and
rejects 85% of the ungrammatical ones on the
TSNLP (Lehmann et al, 1996) corpus.
The constraints have been computed on the
unanchored grammar as explained in section 5:
each tree contains several polarities and therefore
several atomic constraints. Overall, the grammar
contains 20 627 atomic constraints. It takes 2 days
to compute the set of constraints and the results
can be stored in a constraints file of 10MB. Of
course, an atomic constraint is more interesting
when the sizes of L and R are small. In our gram-
mar, 50% of the constraints set (either R or L)
2Note that in the adjunction case, the constraint is not ori-
ented and then L= R.
contain at most 40 elements and 80% of these sets
contain at most 200 elements over 2 088.
We give in figure 5 the number of sentences of
each length in the corpus we consider.
0?
500?
1000?
1500?
2000?
2500?
3000?
3500?
4000?
4500?
5000?
6? 7? 8? 9? 10? 11? 12? 13? 14? 15? 16? 17? 18? 19?
num
ber?o
f?sen
tenc
es?
sentence?length?(number?of?words)?
Figure 5: number of sentences of each length
8.2 Results
Two preliminary comments need to be made on
the treatment of the results.
First, as we observed above, the number n
of lexical taggings is a priori exponential in the
length of the sentence. We thus consider its log.
Moreover, because we use a raw corpus, some
sentences are considered as ungrammatical by the
grammar; in this case it may happen that the dis-
ambiguation method removes all taggings. In or-
der to avoid undefined values when n = 0, we in
fact consider log10(1 + n).
Second, as expected, the ECP method is more
time consuming and for some sentences the time
and/or memory required is problematic. To be able
to apply the ECP to a large number of sentences,
we have used it after another filtering method
based on polarities and described in (Bonfante et
al., 2004).
Thus, for each sentence we have computed 3
different filters, each one finer than the previous:
? QCP the Quick Companionship Principle;
? QCP+POL QCP followed by a filtering tech-
nique based on polarity counting;
? QCP+POL+ECP the Exact Companionship
Principle applied to the previous filter.
Figure 6 displays the mean computation time
for each length: it confirms that the ECP is more
time consuming and goes up to 5s for our long sen-
tences.
251
Finally, we report the number of lexical tag-
gings that each method returns. Figure 7 displays
the mean value of log10(1 + n) where n is either
the initial number of lexical taggings or the num-
ber of lexical taggings left by the filter.
0.01?
0.1?
1?
10?
6? 7? 8? 9? 10? 11? 12? 13? 14? 15? 16? 17? 18? 19?
?es?(in
?s)?
sentence?length?(number?of?words)?
QCP?
QCP+POL?
QCP+POL+ECP?
Figure 6: mean execution time (in s)
0?
2?
4?
6?
8?
10?
12?
14?
16?
18?
6? 7? 8? 9? 10? 11? 12? 13? 14? 15? 16? 17? 18? 19?
Log?(
1+n)
?
sentence?length?(number?of?words)?
QCP?
QCP+POL?
QCP+POL+ECP?
Ini?l?
Figure 7: number of taggings (initial and after the
3 disambiguation methods)
We can observe that the slope of the lines cor-
responds to the mean word ambiguity: if the
mean ambiguity is a then the number of taggings
for a sentence of length n is about an and then
log(an) = n ? log(a). As a consequence, the mean
ambiguity can be read as 10s where s is the slope
in the last figure.
An illustration is given in figure 8 which ex-
hibits the mean word ambiguity for sentences of
length 16.
init QCP QCP+POL QCP+POL+ECP
6.13 3.41 1.93 1.41
Figure 8: mean word ambiguity for sentences of
length 16
9 Conclusion
We have presented a disambiguation method
based on dependency constraints which allows to
filter out many wrong lexical taggings before en-
tering the deep parsing. As this method relies on
the computation of static constraints on the lin-
guistic data and not on a statistical model, we can
be sure that we will never remove any correct lex-
ical tagging. Moreover, we manage to apply our
methods to an interesting set of data and prove that
it is efficient for a large coverage grammar and not
only for a toy grammar.
These results are also an encouragement to de-
velop further this kind of disambiguation methods.
In the near future, we would like to explore some
improvements.
First, we have seen that our principle cannot be
computed on the whole grammar and that in its im-
plementation we consider unanchored structures.
We would like to explore the possibility of com-
puting finer constraints (relative to the full gram-
mar) on the fly for each sentence. We believe that
this can eliminate some more taggings before en-
tering the deep parsing.
Concerning the ECP, as we have seen, there is a
kind of interplay between the efficiency of the fil-
tering and the time of the computation. We would
like to explore the possibility to define some in-
termediate way between QCP and ECP either by
using approximate automata or using the ECP but
only on a subset of elements where it is known to
be efficient.
Another challenging method we would like to
investigate is to use the Companionship Principle
not only as a disambiguation method but as a guide
for the deep parsing. Actually, we have observed
for at least 20% of the words that dependencies are
completely determined by the filtering methods. If
deep parsing can be adapted to use this observation
(this is the case for IG), this can be of great help.
Finally, we can improve the filtering using both
worlds: the Companionship Principle and the po-
larity counting method. Two different constraints
cannot be fulfilled by the same potential compan-
ion: this may allow to discover some more lexical
taggings that can be safely removed.
Acknowledgments
We would like to thank the anonymous reviewers
for their helpful comments and suggestions.
252
References
Srinivas Bangalore and Aravind K. Joshi. 1999. Su-
pertagging: an approach to almost parsing. Comput.
Linguist., 25(2):237?265.
G. Bonfante, B. Guillaume, and G. Perrier. 2004.
Polarization and abstraction of grammatical for-
malisms as methods for lexical disambiguation. In
CoLing 2004, pages 303?309, Gene`ve, Switzerland.
P. Boullier. 2003. Supertagging : A non-statistical
parsing-based approach. In Pro- ceedings of the
8th International Workshop on Parsing Technologies
(IWPT 03), pages 55?65, Nancy, France.
Stephen Clark and James R. Curran. 2004. The impor-
tance of supertagging for wide-coverage CCG pars-
ing. In COLING ?04: Proceedings of the 20th in-
ternational conference on Computational Linguis-
tics, page 282, Morristown, NJ, USA. Association
for Computational Linguistics.
S. Clark, J. Hockenmaier, and M. Steedman. 2002.
Building Deep Dependency Structures with a Wide-
Coverage CCG Parser. In Proceedings of ACL?02,
pages 327?334, Philadephia, PA.
Ph. de Groote. 2001. Towards abstract categorial
grammars. In Association for Computational Lin-
guistics, 39th Annual Meeting and 10th Conference
of the European Chapter, Proceedings of the Confer-
ence, pages 148?155.
C. Gardent and E. Kow. 2005. Generating and se-
lecting grammatical paraphrases. Proceedings of the
ENLG, Aug.
B. Guillaume and G. Perrier. 2008. Interaction Gram-
mars. Research Report RR-6621, INRIA.
A. Joshi and O. Rambow. 2003. A Formalism for De-
pendency Grammar Based on Tree Adjoining Gram-
mar. In Proceedings of the Conference on Meaning-
Text Theory.
A. Joshi. 1987. An Introduction to Tree Adjoining
Grammars. Mathematics of Language.
S. Kahane. 2006. Polarized unification grammar. In
Proceedings of Coling-ACL?02, Sydney.
Bernd Kiefer, Hans-Ulrich Krieger, John Carroll, and
Rob Malouf. 1999. A bag of useful techniques for
efficient and robust parsing. In Proceedings of the
37th annual meeting of the Association for Compu-
tational Linguistics on Computational Linguistics,
pages 473?480, Morristown, NJ, USA. Association
for Computational Linguistics.
A. Koller and M. Kuhlmann. 2009. Dependency
trees and the strong generative capacity of CCG. In
EACL? 2009, Athens, Greece.
J. Kupiec. 1992. Robust Part-of-Speech Tagging Us-
ing a Hidden Markov Model. Computer Speech and
Language, 6(3):225?242.
F. Lamarche. 2008. Proof Nets for Intuitionistic Linear
Logic: Essential Nets. Technical report, INRIA.
J. Lambek. 1958. The mathematics of sentence struc-
ture. American mathematical monthly, pages 154?
170.
S. Lehmann, S. Oepen, S. Regnier-Prost, K. Netter,
V. Lux, J. Klein, K. Falkedal, F. Fouvry, D. Esti-
val, E. Dauphin, H. Compagnion, J. Baur, L. Balkan,
and D. Arnold. 1996. TSNLP: Test Suites for Nat-
ural Language Processing. In Proceedings of the
16th conference on Computational linguistics, pages
711?716.
J. Marchand, B. Guillaume, and G. Perrier. 2009.
Analyse en de?pendances a` l?aide des grammaires
d?interaction. In Actes de TALN 09, Senlis, France.
B. Merialdo. 1994. Tagging English Text with a Prob-
abilistic Model. Computational linguistics, 20:155?
157.
M. Moortgat and G. Morrill. 1991. Heads and phrases.
Type calculus for dependency and constituent struc-
ture. In Journal of Language, Logic and Informa-
tion.
Takashi Ninomiya, Takuya Matsuzaki, Yoshimasa Tsu-
ruoka, Yusuke Miyao, and Jun?ichi Tsujii. 2006.
Extremely lexicalized models for accurate and fast
HPSG parsing. In Proceedings of the 2006 Con-
ference on Empirical Methods in Natural Language
Processing, pages 155?163, Sydney, Australia, July.
Association for Computational Linguistics.
G. Perrier. 2007. A French Interaction Grammar. In
RANLP 2007, pages 463?467, Borovets Bulgarie.
M. Steedman. 2000. The Syntactic Process. MIT
Press.
L. Tesnie`re. 1959. E?le?ments de syntaxe structurale.
Klinksieck.
253
Modular Graph Rewriting to Compute Semantics
Guillaume Bonfante
Nancy-Universite? - LORIA
bonfante@loria.fr
Bruno Guillaume
INRIA - LORIA
guillaum@loria.fr
Mathieu Morey
Nancy-Universite? - LORIA
moreymat@loria.fr
Guy Perrier
Nancy-Universite? - LORIA
perrier@loria.fr
Abstract
Taking an asynchronous perspective on the syntax-semantics interface, we propose to use modu-
lar graph rewriting systems as the model of computation. We formally define them and demonstrate
their use with a set of modules which produce underspecified semantic representations from a syn-
tactic dependency graph. We experimentally validate this approach on a set of sentences. The results
open the way for the production of underspecified semantic dependency structures from corpora an-
notated with syntactic dependencies and, more generally, for a broader use of modular rewriting
systems for computational linguistics.
Introduction
The aim of our work is to produce a semantic representation of sentences on a large scale using a formal
and exact approach based on linguistic knowledge. In this perspective, the design of the syntax-semantics
interface is crucial.
Based on the compositionality principle, most models of the syntax-semantics interface use a syn-
chronous approach: the semantic representation of a sentence is built step by step in parallel with its
syntactic structure. According to the choice of the syntactic formalism, this approach is implemented in
different ways: in a Context-Free Grammars (CFG) style framework, every syntactic rule of a grammar
is associated with a semantic composition rule, as in the classical textbook by Heim and Kratzer (1998);
following the principles introduced by Montague, Categorial Grammars use an homomorphism from the
syntax to the semantics (Carpenter (1992)). HPSG integrates the semantic and syntactic representations
in feature structures which combine by unification (Copestake et al (2005)). LFG follows a similar prin-
ciple (Dalrymple (2001)). In a synchronous approach, the syntax-semantics interface closely depends on
the grammatical formalism. Building such an interface can be very costly, especially if we aim at a large
coverage for the grammar.
In our work, we have chosen an asynchronous approach in the sense that we start from a given
syntactic analysis of a sentence to produce a semantic representation. With respect to the synchronous
approach, a drawback is that the reaction of the semantics on the syntax is delayed. On the other hand,
the computation of the semantics is made relatively independent from the syntactic formalism. The only
constraint is the shape of the output of the syntactic analysis.
In the formalisms mentioned above, the syntactic structure most often takes the form of a phrase
structure, but the choice of constituency for the syntax makes the relationship with the semantics more
complicated. We have chosen dependency graphs, because syntactic dependencies are closely related
to predicate-argument relations. Moreover, they can be enriched with relations derived from the syntax,
which are usually ignored, such as the arguments of infinitives or the anaphora determined by the syntax.
One may observe that our syntactic representation of sentences involves plain graphs and not trees.
Indeed, these relations can give rise to multiple governors and dependency cycles. On the semantic side,
65
we have also chosen graphs, which are widely used in different formalisms and theories, such as DMRS
(Copestake (2009)) or MTT (Mel?c?uk (1988)) .
The principles being fixed, our problem was then to choose a model of computation well suited
to transforming syntactic graphs into semantic graphs. The ?-calculus, which is widely used in formal
semantics, is not a good candidate because it is appropriate for computing on trees but not on graphs. Our
choice naturally went to graph rewriting. Graph rewriting is barely used in computational linguistics;
it could be due to the difficulty to manage large sets of rules. Among the pioneers in the use of graph
rewriting, we mention Hyvo?nen (1984); Bohnet and Wanner (2001); Crouch (2005); Jijkoun and de Rijke
(2007); Be?daride and Gardent (2009); Chaumartin and Kahane (2010).
A graph rewriting system is defined as a set of graph rewrite rules and a computation is a sequence
of rewrite rule applications to a given graph. The application of a rule is triggered via a mechanism of
pattern matching, hence a sub-graph is isolated from its context and the result is a local modification of
the input. This allows a linguistic phenomenon to be easily isolated for applying a transformation.
Since each step of computation is fired by some local conditions in the whole graph, it is well known
that one has no grip on the sequence of rewriting steps. The more rules, the more interaction between
rules, and the consistency of the whole rule system becomes difficult to maintain. This bothers our
ambition of a large coverage for the grammar. To solve this problem, we propose to organize rules in
modules. A module is a set of rules that is linguistically consistent and represents a particular step of
the transformation. For instance, in our proposal, there is a module transforming the syntactic arguments
of verbs, predicative nouns and adjectives into their semantic arguments. Another module resolves the
anaphoric links which are internal to the sentence and determined by the syntax.
From a computational point of view, the grouping of a small number of rules inside a module allows
some optimizations in their application, thus leading to efficiency. For instance, the confluence of rewrit-
ing is a critical feature ? one computes only one normal form, not all of them ? for the performance
of the program. Since the underlying relation from syntax to semantics is not functional but relational,
the system cannot be globally confluent. Then, it is particularly interesting to isolate subsets of conflu-
ent rules. Second point, with a small number of rules, one gets much more control on their output. In
particular, it is possible to automatically infer some invariant properties of graphs along the computation
within a particular module. Thus, it simplifies the writing of the rules for the next modules. It is also
possible to plan a strategy in the global evaluation process.
It is well known that syntactic parsers produce outputs in various formats. As a by-product of our
approach, we show that the choice of the input format (that is the syntax) seems to be of low importance
overall. Indeed, as far as two formats contain the same linguistic information with different representa-
tions, a system of rewrite rules can be designed to transform any graph from one format to another as a
preliminary step. The same remark holds for the output formats.
To illustrate our proposal, we have chosen the Paris7 TreeBank (hereafter P7TB) dependency format
defined by Candito et al (2010) as the syntactic input format and the Dependency MRS format (hereafter
DMRS) defined by Copestake (2009) as the semantic output format. We chose those two formats because
the information they represent, if it is not complete, is relatively consensual and because both draw on
large scale experiments: statistical dependency parsing for French1 on the one hand and the DELPH-IN
project2 on the other hand.
Actually, in our experiments, since we do not have an appropriate corpus annotated according to the
P7TB standard, we used our syntactic parser LEOPAR3 whose outputs differ from this standard and we
designed a rewriting system to go from one format to the other.
The paper is organized as follows. In section 1, we define our graph rewriting calculus, the ?-calculus.
In Section 2, we describe the particular rewriting system that is used to transform graphs from the syn-
tactic P7TB format into the DMRS semantic format. In Section 3, we present experimental results on a
test suite of sentences.
1http://alpage.inria.fr/statgram/frdep/fr_stat_dep_parsing.html
2http://www.delph-in.net/
3http://leopar.loria.fr
66
1 The ?-calculus, a graph rewriting calculus
Term rewriting and tree rewriting can be defined in a straightforward and canonical way. Graph rewriting
is much more problematic and there is unfortunately no canonical definition of a graph rewriting system.
Graph rewriting can be defined through a categorical approach like SPO or DPO (Rozenberg (1997)).
But, in practice, it is much easier to use a more operational view of rewriting where modification of
the graph (the ?right-hand side? of a rule) is defined by means of a set of commands; the control of the
way rules are applied (the ?left hand-side?) still uses pattern matching as this is done in traditional graph
rewriting.
In this context, a rule is a pair of a pattern and a sequence of commands. We give below the formal
materials about graphs, patterns, matchings and commands. We illustrate the section with examples of
rules and of rewriting.
1.1 Graph definition
In the following, we suppose given a finite set L of edge labels corresponding to the kind of dependencies
used to describe sentences. They may correspond to syntax or to semantics. For instance, we use
L = {SUJ, OBJ, ARG1, ANT, . . .}.
To decorate vertices, we use the standard notion of feature structures. Let N be a finite set of
feature names and A be a finite set of atomic feature values. In our example, N = {cat,mood, . . .} and
A = {passive, v, n, . . .}. A feature is a pair made of a feature name and a set of atomic values. The
feature (cat, {v, aux}) means that the feature name cat is associated to either the value v or aux. In the
sequel, we use the notation cat = v|aux for this feature. Two features f = v and f ? = v? are compatible
whenever f = f ? and v ? v? 6= ?.
A feature structure is a finite set of features such that each feature name occurs at most once. F de-
notes the set of feature structures. Two feature structures are compatible if their respective features with
the same name are pairwise compatible.
A graph G is then defined by a 6-tuple (V, fs, E , lab, ?, ?) with:
? a finite set V of vertices;
? a labelling function fs from V to F ;
? a finite set E of edges;
? a labelling function lab from E to L;
? two functions ? and ? from E to V which give the source and the target of each edge.
Moreover, we require that two edges between the same couple of nodes cannot have the same label.
1.2 Patterns and matchings
Formally, a pattern is a graph and a matching ? of a pattern P = (V ?, fs?, E ?, lab?, ??, ? ?) into a graph
G = (V, fs, E , lab, ?, ?) is an injective graph morphism from P to G. More precisely, ? is a couple of
injective functions: ?V from V ? to V and ?E from E ? to E which:
? respects vertex labelling: fs(?V(v)) and fs?(v) are compatible;
? respects edge labelling: lab(?E(e)) = lab?(e);
? respects edge sources: ?(?E(e)) = ?V(??(e));
? respects edge targets: ?(?E(e)) = ?V(? ?(e)).
67
1.3 Commands
Commands are low-level operations on graphs that are used to describe the rewriting of the graph within
a rule application. In the description below, we suppose to be given a pattern matching ? : P ? G. We
describe here the set of commands which we used in our experiment so far. Naturally, this set could be
extended.
? del edge(?, ?, `) removes the edge labelled ` between ? and ?. More formally, we suppose that
? ? VP , ? ? VP andP contains an edge e from? to ? with label ` ? L. Then, del edge(?, ?, `)(G)
is the graph G without the edge ?(e). In the following, we give only the intuitive definition of the
command: thanks to injectivity of the matching ?, we implicitly forget the distinction between x
and ?(x).
? add edge(?, ?, `) adds an edge labelled ` between ? and ?. Such an edge is supposed not to exist
in G.
? shift edge(?, ?) modifies all edges that are incident to ?: each edge starting from ? is moved to
start from ?; similarly each edge ending on ? is moved to end on ?;
? del node(?) removes the ? node in G. If G contains edges starting from ? or ending on ?, they
are silently removed.
? add node(?) adds a new node with identifier ? (a fresh name).
? add feat(?, f = v) adds the feature f = v to the node ?. If ? already contains a feature name f ,
it is replaced by the new one.
? copy feat(?, ?, f) copies the value of the feature named f from the node ? to the node ?. If ?
does not contain a feature named f , nothing is done. If ? already contains a feature named f , it is
replaced by the new value.
Note that commands define a partial function on graphs: the action add edge(?, ?, `) is undefined
on a graph which already contains an edge labelled ` from ? to ?.
The action of a sequence of commands is the composition of actions of each command. Sequences
of commands are supposed to be consistent with the pattern:
? del edge always refers to an edge described in the pattern and not previously modified by a
del edge or a shift edge command;
? each command refers only to identifiers defined either in the pattern or in a previous add node;
? no command refers to a node previously deleted by a del node command.
Finally, we define a rewrite rule to be a pair of a pattern and a consistent sequence of commands.
A first example of a rule is given below with the pattern on the left and the sequence of commands
on the right. This rule called INIT PASSIVE is used to remove the node corresponding to the auxiliary
of the passive construction and to modify the features accordingly.
INIT PASSIVE
?
cat = v
voice = active
?
cat = v
voice = unk
AUX PASS
c1 = copy feat(?, ?,mood)
c2 = copy feat(?, ?, tense)
c3 = add feat(?, voice = passive)
c4 = del edge(?, ?, AUX PASS)
c5 = shift edge(?, ?)
c6 = del node(?)
Our second example (PASSIVE ATS) illustrates the add node command. It is used in a passive
construction where the semantic subject of the verb is not realized syntactically.
68
PASSIVE ATS
?
cat = v
voice = passive
? ?
SUJ ATS c1 = del edge(?, ?, SUJ)
c2 = add edge(?, ?, OBJ)
c3 = del edge(?, ?, ATS)
c4 = add edge(?, ?, ATO)
c5 = add feat(?, voice = active)
c6 = add node(?)
c7 = add edge(?, SUJ, ?)
1.4 Rewriting
We consider a graph G and a rewrite rule r = (P, [c1, . . . , ck]). We say that G? is obtained from G by a
rewrite step with the r rule (written G ??r G?) if there is a matching morphism ? : P ? G and G? is
obtained from G by applying the composition of commands ck ? . . . ? c1.
Let us now illustrate two rewrite steps with the rules above. Consider the first graph below which is
a syntactic dependency structure for the French sentence ?Marie est conside?re?e comme brillante? [Mary
is considered as bright]. The second graph is obtained by application of the INIT PASSIVE rewrite rule
and the last one with the PASSIVE ATS rewrite rule.
Marie
cat = np
lemma = MARIE
est
cat = v
lemma = E?TRE
voice = active
tense = present
conside?re?e
cat = v
lemma = CONSIDE?RER
voice = unk
comme
cat = prep
lemma = COMME
brillante
cat = adj
lemma = BRILLANT
SUJ
AUX PASS ATS OBJ
Marie
cat = np
lemma = MARIE
est conside?re?e
cat = v
lemma = CONSIDE?RER
voice = passive
tense = present
comme
cat = prep
lemma = COMME
brillante
cat = adj
lemma = BRILLANT
SUJ ATS OBJ
 Marie
cat = np
lemma = MARIE
est conside?re?e
cat = v
lemma = CONSIDE?RER
voice = active
tense = present
comme
cat = prep
lemma = COMME
brillante
cat = adj
lemma = BRILLANT
SUJ
OBJ ATO OBJ
1.5 Modules and normal forms
A module contains a set of rewrite rules but, in order to have a finer control on the output of these
modules, it is useful to declare some forbidden patterns. Hence a module is defined by a set R of rules
and a set P of forbidden patterns.
For a given module M = (R,P), we say that G? is an M-normal form of the graph G if there is a
sequence of rewriting steps with rules of R from G to G?: G ??r1 G1 ??r2 G2 . . . ??rk G?, if no rule
of R can be applied to G? and no pattern of P matches in G?.
In our experiment, forbidden patterns are often used to control the subset of edges allowed in normal
forms. For instance, the NORMAL module contains the forbidden pattern: AUX PASS . Hence, we
can then safely suppose that no graph contains any AUX PASS edge afterward.
2 From syntactic dependency graphs to semantic graphs
Linguistic theories diverge on many issues including the exact definition of the linguistic levels and
the relationships between them. Our aim here is not to commit to any linguistic theory but rather to
69
demonstrate that graph rewriting is an adequate and realistic computational framework for the syntax-
semantics interface. Consequently, our approach is bound to neither the (syntactic and semantic) formats
we have chosen nor the transformation modules we have designed; both are mainly meant to exemplify
our proposal.
2.1 Representational formats
Our syntactic and semantic formats both rely on the notion of linguistic dependency. The syntactic
format is an enrichment of the one which was designed to annotate the French Treebank (Abeille? and
Barrier (2004)) with surface syntactic dependencies (Candito et al (2010)). The enrichment is twofold:
? if they are present in the sentence, the deep arguments of infinitives and participles (from participial
subordinate clauses) are marked with the usual labels of syntactic functions,
? the anaphora relations that are predictable from the syntax (i.e. the antecedents of relative, reflexive
and repeated pronouns) are marked with a special label ANT.
This additional information can already be provided by many syntactic parsers and is particularly inter-
esting to compute semantics.
The semantic format is DependencyMinimal Recursion Semantics (DMRS) which was introduced by
Copestake (2009) as a compact and easily readable equivalent to Robust Minimal Recursion Semantics
(RMRS), which was defined by Copestake (2007). This underspecified semantic formalism was designed
for large scale experiments without committing to fine-grained semantic choices. DMRS graphs contain
the predicate-argument relations, the restriction of generalized quantifiers and the mode of combination
between predicates. Predicate-argument relations are labelled ARGi, where i is an integer following a
fixed order of obliqueness SUJ, OBJ, ATS, ATO, A-OBJ, DE-OBJ. . . . Naturally, the lexicon must be consistent
with this ordering. The restrictions of generalized quantifiers are labelled RSTR ; their bodies are not
overtly expressed but can be retrieved from the graph. There are three ways of combining predicates:
? EQ when two predicates are elements of a same conjunction;
? H when a predicate is in the scope of another predicate; it is not necessarily one of its arguments
because quantifiers may occur between them;
? NEQ for all other cases.
2.2 Modular rewriting system
Graph rewriting allows to proceed step by step to the transformation of a syntactic graph into a semantic
one, by associating a rewrite rule to each linguistic rule. While the effect of every rule is local, grouping
rules in modules allows a better control on the global effect of all rules.
We do not have the space here to propose a system of rules that covers the whole French grammar.
We however propose six modules which cover a significative part of this grammar (cleft clauses, coor-
dination, enumeration, comparatives and ellipses are left aside but they can be handled by other rewrite
modules):
? NORMAL handles the regular syntactic transformations involving predicates: it computes tense
and transforms all redistributions of arguments (passive and middle voices, impersonal construc-
tions and the combination of them) to the active canonical form. This reduces the number of rules
required to produce the predicate-argument relations in the ARG module below.
? PREP removes affixes, prepositions and complementizers.
? ARG transforms the verbal, nominal and adjectival predicative phrases into predicate-argument
relations.
70
? DET translates the determiner dependencies (denoted DET) to generalized quantifiers.
? MOD interprets the various modifier dependencies (denoted MOD), according to their specificity:
adjectives, adverbs, adjunct prepositional phrases, participial clauses, relative clauses, adjunct
clauses.
? ANA interprets all anaphoric relations that are determined by the syntax (denoted ANT).
Modules provide an easy way to control the order in which rules are fired. In order to properly set up the
rules in modules, we first have to fix the global ordering of the modules. Some ordering constraints are
evident: for instance, NORMAL must precede PREP, which must precede ARG. The rules we present in
the following are based on the order NORMAL, PREP, ARG, DET, MOD, ANA.
2.2.1 Normalization of syntactic dependencies
The NORMAL module has two effects: it merges tense and voice auxiliaries with their past participle
and brings all the argument redistributions back to the canonical active form. This module accounts
for the passive and middle voices and the impersonal construction for verbs that are not essentially
impersonal. The combination of the two voices with the impersonal construction is naturally expressed
by the composition of the corresponding rewrite rules. The two rules given in section 1.4 are part of this
module. The first rule (INIT PASSIVE) merges the past participle of the verb with its passive auxiliary.
The auxiliary brings its mood and tense to the verb, which is marked as being passive. The second rule
(PASSIVE ATS) transforms a passive verb with a subject and an attribute of the subject into its active
equivalent with a semantically undetermined subject, an object (which corresponds to the subject of the
passive form) and an attribute of the object (which corresponds to the attribute of the subject of the
passive form).
2.2.2 Erasure of affixes, prepositions and complementizers
The PREP module removes affixes, prepositions and complementizers. For example, the rule given here
merges prepositions with the attribute of the object that they introduce. The value of the preposition is
kept to compute the semantics.
PREP ATO
?
voice = active
?
cat = prep
prep = ?
?
ATO OBJ c1 = copy feat(?, ?, prep)
c2 = del edge(?, ?, OBJ)
c3 = shift edge(?, ?)
c4 = del node(?)
2.2.3 From lexical predicative phrases to semantic predicates
The ARG module transforms the syntactic arguments of a predicative word (a verb, a common noun or
an adjective) into its semantic arguments. Following DMRS, the predicate-argument relations are not
labelled with thematic roles but only numbered. The numbering reflects the syntactic obliqueness.
ARG OBJ
? ?
cat = n|np|pro
OBJ
c1 = del edge(?, ?, OBJ)
c2 = add edge(?, ?, ARG2)
c3 = add edge(?, ?, NEQ)
2.2.4 From determiners to generalized quantifiers
DET reverts the determiner dependencies (labelled DET) from common nouns to determiners into depen-
dencies of type RSTR from the corresponding generalized quantifier to the nominal predicate which is
the core of their restriction.
71
DET
?
cat = det
?
cat = n
DET
c1 = del edge(?, ?, DET)
c2 = add edge(?, ?, RSTR)
c3 = add edge(?, ?, H)
2.2.5 Interpretation of different kinds of modification
MOD deals with the modifier dependencies (labelled MOD, MOD REL and MOD LOC), providing rules
for the different kinds of modifiers. Adjectives and adverbs are translated as predicates whose first
argument is the modified entity. The modifier and modified entities are in a conjunction (EQ), except
for scopal adverbs which take scope (H) over the modified predicate. Because only lexical information
enables to differentiate scopal from non-scopal adverbs, we consider all adverbs to be systematically
ambiguous at the moment. Adjunct prepositional phrases (resp. clauses) have a similar rule except that
their corresponding predicate is the translation of the preposition (resp. complementizer), which has
two arguments: the modified entity and the noun (resp. verb) which heads the phrase (resp. clause).
Participial and relative clauses exhibit a relation labelled EQ or NEQ between the head of the clause and
the antecedent, depending on the restrictive or appositive type of the clause.
2.2.6 Resolution of syntactic anaphora
ANA deals with dependencies of type ANT and merges their source and their target. We apply them to
reflexive, relative and repeated pronouns.
3 Experiments
For the experimentation, we are interested in a test suite which is at the same time small enough to be
manually validated and large enough to cover a rich variety of linguistic phenomena. As said earlier, we
use the P7 surface dependency format as input, so the first attempt at building a test suite is to consider
examples in the guide which describes the format. By nature, an annotation guide tries to cover a large
range of phenomena with a small set of examples.
The latest version4 of this guide (Candito et al (2010)) contains 186 linguistic examples. In our cur-
rent implementation of the semantic constructions, we leave out clefts, coordinations and comparatives.
We also leave out a small set of exotic sentences for which we are not able to give a sensible syntactic
structure. Finally, our experiment runs on 116 French sentences. Syntactic structures following P7 spec-
ifications are obtained with some graph rewriting on the output of our parser. Each syntactic structure
was manually checked and corrected when needed. Then, graph rewriting with the modules described in
the previous section is performed.
For all of these sentences, we produce at least one normal form. Even if DMRS is underspecified, our
system can output several semantic representations for one syntactic structure (for instance, for appositive
and restrictive relative clauses). We sometimes overgenerate because we do not use lexical information
like the difference between scopal and non-scopal adverbs.
The result for three sentences is given below and the full set is available on a web page 5.
4version 1.1, january 2010
5http://leopar.loria.fr/doku.php?id=iwcs2011
72
[012] ?Le franc?ais se parle de moins en moins dans les confe?rences.? [The French language is less and
less spoken in conferences.]
le
cat=det
fran?ais
cat=n
se
cat=pro
parle
cat=v
mood=ind
tense=pres
voice=unk
de moins en moins
cat=adv
dans
cat=prep
prep=loc
les
cat=det
conf?rences
cat=n
DET AFF_MOYEN MOD DET
SUJ MOD_LOC OBJ
/la/ct=dea=
/s?tritnR/ct=dr
S THPT
/pt?la/ct=do?vvednre=arRadp?aRovncadtc=noa
mTEQ NAG
//
mTE1 NAG
/eaf?vnrRfarf?vnrR/ct=dteo
mTE1 AG
/etrR/ct=dp?app?apdlvc
AG mTE1
/cvrs2?arcaR/ct=dr
NAG mTEQ
/laR/ct=dea=
S THPT
[057] ?J?encourage Marie a` venir.? [I invite Mary to come.]
je
cat=pro
encourage
cat=v
mood=ind
tense=pres
voice=unk
Marie
cat=np
?
cat=prep
prep=?
venir
cat=v
mood=inf
voice=unk
SUJ OBJ OBJ
A-OBJ
SUJ
/je/cat=pro
/encourage/cat=vmood=indtense=presvoice=active
ARG1 NEQ
/Marie/cat=np
ARG2 NEQ
/venir/cat=vmood=infprep=?voice=active
ARG3 EQ
ARG1 NEQ
[106] ?La se?rie dont Pierre conna??t la fin? [The story Peter knows the end of]
la
cat=det
s?rie
cat=n
dont
cat=pro
Pierre
cat=np
conna?t
cat=v
mood=ind
tense=pres
voice=unk
la
cat=det
fin
cat=n
DET ANT SUJ DET
OBJMOD_REL
DE-OBJ
/la/cat=det
/s?rie/cat=n
RSTR H
/Pierre/cat=np
/conna?t/cat=vmood=indtense=presvoice=active
EQ
NEQ ARG1
/fin/cat=n
NEQ ARG2
/la/cat=det
RSTR H
ARG1 NEQ
73
Conclusion
In this paper, we have shown the relevance of modular graph rewriting to compute semantic representa-
tions from graph-shaped syntactic structures. The positive results of our experiments on a test suite of
varied sentences make us confident that the method can apply to large corpora.
The particular modular graph rewriting system presented in the paper was merely here to illustrate
the method, which can be used for other input and output formats. There is another aspect to the flexi-
bility of the method: we may start from the same system of rules and enrich it with new rules to get a
finer semantic analysis ? if DMRS is considered as providing a minimal analysis ? or integrate lexi-
cal information. The method allows the semantic ambiguity to remain unsolved within underspecified
representations or to be solved with a rule system aiming at computing models of underspecified rep-
resentations. Moreover, we believe that its flexibility makes graph rewriting a convenient framework to
deal with idiomatic expressions.
References
Abeille?, A. and N. Barrier (2004). Enriching a french treebank. In Proceedings of LREC.
Be?daride, P. and C. Gardent (2009). Semantic Normalisation : a Framework and an Experiment. In
Proceedings of IWCS, Tilburg Netherlands.
Bohnet, B. and L. Wanner (2001). On using a parallel graph rewriting formalism in generation. In
Proceedings of EWNLG ?01, pp. 1?11. Association for Computational Linguistics.
Candito, M., B. Crabbe?, and P. Denis (2010). Statistical french dependency parsing: Treebank conversion
and first results. Proceedings of LREC2010.
Candito, M., B. Crabbe?, and M. Falco (2010). De?pendances syntaxiques de surface pour le fran?cais.
Carpenter, B. (1992). The logic of typed feature structures. Cambridge: Cambridge University Press.
Chaumartin, F.-R. and S. Kahane (2010). Une approche paresseuse de l?analyse se?mantique ou comment
construire une interface syntaxe-se?mantique a` partir d?exemples. In TALN 2010, Montreal, Canada.
Copestake, A. (2007). Semantic composition with (robust) minimal recursion semantics. In Proceedings
of the Workshop on Deep Linguistic Processing, pp. 73?80. Association for Computational Linguistics.
Copestake, A. (2009). Invited Talk: Slacker semantics: Why superficiality, dependency and avoidance
of commitment can be the right way to go. In Proceedings of EACL 2009, Athens, Greece, pp. 1?9.
Copestake, A., D. Flickinger, C. Pollard, and I. Sag (2005). Minimal Recursion Semantics - an Introduc-
tion. Research on Language and Computation 3, 281?332.
Crouch, D. (2005). Packed Rewriting for Mapping Semantics to KR. In Proceedings of IWCS.
Dalrymple, M. (2001). Lexical Functional Grammar. New York: Academic Press.
Heim, I. and A. Kratzer (1998). Semantics in generative grammar. Wiley-Blackwell.
Hyvo?nen, E. (1984). Semantic Parsing as Graph Language Transformation - a Multidimensional Ap-
proach to Parsing Highly Inflectional Languages. In COLING, pp. 517?520.
Jijkoun, V. and M. de Rijke (2007). Learning to transform linguistic graphs. In Second Workshop on
TextGraphs: Graph-Based Algorithms for Natural Language Processing, Rochester, NY, USA.
Mel?c?uk, I. (1988). Dependency Syntax: Theory and Practice. Albany: State Univ. of New York Press.
Rozenberg, G. (Ed.) (1997). Handbook of Graph Grammars and Computing by Graph Transformations,
Volume 1: Foundations. World Scientific.
74
