Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 667?674,
Sydney, July 2006. c?2006 Association for Computational Linguistics
URES : an Unsupervised Web Relation Extraction System 
Benjamin Rosenfeld 
Computer Science Department 
Bar-Ilan University 
Ramat-Gan, ISRAEL 
grurgrur@gmail.com 
Ronen Feldman 
Computer Science Department 
Bar-Ilan University 
Ramat-Gan, ISRAEL 
feldman@cs.biu.ac.il 
 
 
Abstract 
Most information extraction systems ei-
ther use hand written extraction patterns 
or use a machine learning algorithm that 
is trained on a manually annotated cor-
pus. Both of these approaches require 
massive human effort and hence prevent 
information extraction from becoming 
more widely applicable. In this paper we 
present URES (Unsupervised Relation 
Extraction System), which extracts rela-
tions from the Web in a totally unsuper-
vised way. It takes as input the 
descriptions of the target relations, which 
include the names of the predicates, the 
types of their attributes, and several seed 
instances of the relations. Then the sys-
tem downloads from the Web a large col-
lection of pages that are likely to contain 
instances of the target relations. From 
those pages, utilizing the known seed in-
stances, the system learns the relation 
patterns, which are then used for extrac-
tion. We present several experiments in 
which we learn patterns and extract in-
stances of a set of several common IE re-
lations, comparing several pattern 
learning and filtering setups. We demon-
strate that using simple noun phrase tag-
ger is sufficient as a base for accurate 
patterns. However, having a named en-
tity recognizer, which is able to recog-
nize the types of the relation attributes 
significantly, enhances the extraction 
performance. We also compare our ap-
proach with KnowItAll?s fixed generic 
patterns. 
1 Introduction 
The most common preprocessing technique for 
text mining is information extraction (IE). It is 
defined as the task of extracting knowledge out 
of textual documents. In general, IE is divided 
into two main types of extraction tasks ? Entity 
tagging and Relation extraction. 
The main approaches used by most informa-
tion extraction systems are the knowledge engi-
neering approach and the machine learning 
approach. The knowledge engineering (mostly 
rule based) systems traditionally were the top 
performers in most IE benchmarks, such as 
MUC (Chinchor, Hirschman et al 1994), ACE 
and the KDD CUP (Yeh and Hirschman 2002). 
Recently though, the machine learning systems 
became state-of-the-art, especially for simpler 
tagging problems, such as named entity recogni-
tion (Bikel, Miller et al 1997), or field extrac-
tion (McCallum, Freitag et al 2000). The 
general idea is that a domain expert labels the 
target concepts in a set of documents. The sys-
tem then learns a model of the extraction task, 
which can be applied to new documents auto-
matically. 
Both of these approaches require massive hu-
man effort and hence prevent information extrac-
tion from becoming more widely applicable. In 
order to minimize the huge manual effort in-
volved with building information extraction sys-
tems, we have designed and developed URES 
(Unsupervised Relation Extraction System) 
which learns a set of patterns to extract relations 
from the web in a totally unsupervised way. The 
system takes as input the names of the target re-
lations, the types of its arguments, and a small 
set of seed instances of the relations. It then uses 
a large set of unlabeled documents downloaded 
from the Web in order to build extraction pat-
terns. URES patterns currently have two modes 
of operation. One is based upon a generic shal-
low parser, able to extract noun phrases and their 
667
heads. Another mode builds patterns for use by 
TEG (Rosenfeld, Feldman et al 2004). TEG is a 
hybrid rule-based and statistical IE system. It 
utilizes a trained labeled corpus in order to com-
plement and enhance the performance of a rela-
tively small set of manually-built extraction 
rules. When it is used with URES, the relation 
extraction rules and training data are not built 
manually but are created automatically from the 
URES-learned patterns. However, URES does 
not built rules and training data for entity extrac-
tion. For those, we use the grammar and training 
data we developed separately. 
It is important to note that URES is not a clas-
sic IE system. Its purpose is to extract as many 
as possible different instances of the given rela-
tions while maintaining a high precision. Since 
the goal is to extract instances and not mentions, 
we are quite willing to miss a particular sentence 
containing an instance of a target relation ? if the 
instance can be found elsewhere. In contrast, the 
classical IE systems extract mentions of entities 
and relations from the input documents. This 
difference in goals leads to different ways of 
measuring the performance of the systems. 
The rest of the paper is organized as follows: 
in Section 2 we present the related work. In Sec-
tion 3 we outline the general design principles of 
URES and the architecture of the system and 
then describe the different components of URES 
in details while giving examples to the input and 
output of each component. In Section 4 we pre-
sent our experimental evaluation and then wrap 
up with conclusions and suggestions for future 
work. 
2 Related Work 
Information Extraction (IE) is a sub-field of 
NLP, aims at aiding people to sift through large 
volume of documents by automatically identify-
ing and tagging key entities, facts and events 
mentioned in the text.  
Over the years, much effort has been invested 
in developing accurate and efficient IE systems. 
Some of the systems are rule-based (Fisher, So-
derland et al 1995; Soderland 1999), some are 
statistical (Bikel, Miller et al 1997; Collins and 
Miller 1998; Manning and Schutze 1999; Miller, 
Schwartz et al 1999) and some are based on in-
ductive-logic-based (Zelle and Mooney. 1996; 
Califf and Mooney 1998). Recent IE research 
with bootstrap learning  (Brin 1998; Riloff and 
Jones 1999; Phillips and Riloff 2002; Thelen and 
Riloff 2002) or learning from documents tagged 
as relevant (Riloff 1996; Sudo, Sekine et al 
2001) has decreased, but not eliminated hand-
tagged training. 
Snowball (Agichtein and Gravano 2000) is an 
unsupervised system for learning relations from 
document collections. The system takes as input 
a set of seed examples for each relation, and uses 
a clustering technique to learn patterns from the 
seed examples. It does rely on a full fledges 
Named Entity Recognition system. Snowball 
achieved fairly low precision figures (30-50%) 
on relations such as merger and acquisition on 
the same dataset used in our experiments. 
KnowItAll system is a direct predecessor of 
URES. It is developed at University of Washing-
ton by Oren Etzioni and colleagues (Etzioni, 
Cafarella et al 2005). KnowItAll is an autono-
mous, domain-independent system that extracts 
facts from the Web.  The primary focus of the 
system is on extracting entities (unary predi-
cates).  The input to KnowItAll is a set of entity 
classes to be extracted, such as ?city?, ?scien-
tist?, ?movie?, etc., and the output is a list of 
entities extracted from the Web. KnowItAll uses 
a set of manually-built generic rules, which are 
instantiated with the target predicate names, pro-
ducing queries, patterns and discriminator 
phrases. The queries are passed to a search en-
gine, the suggested pages are downloaded and 
processed with patterns. Every time a pattern is 
matched, the extraction is generated and evalu-
ated using Web statistics ? the number of search 
engine hits of the extraction alone and the ex-
traction together with discriminator phrases. 
KnowItAll has also a pattern learning module 
(PL) that is able to learn patterns for extracting 
entities. However, it is unsuitable for learning 
patterns for relations. Hence, for extracting rela-
tions KnowItAll currently uses only the generic 
hand written patterns. 
3 Description of URES 
The goal of URES is extracting instances of rela-
tions from the Web without human supervision. 
Accordingly, the input of the system is limited to 
(reasonably short) definition of the target rela-
tions. The output of the system is a large list of 
relation instances, ordered by confidence. The 
system consists of several largely independent 
components. The Sentence Gatherer generates 
(e.g., downloads from the Web) a large set of 
sentences that may contain target instances. The 
Pattern Learner uses a small number of known 
seed instances to learn likely patterns of relation 
668
occurrences. The Sentence Classifier filters the 
set of sentences, removing those that are unlikely 
to contain instances of the target relations. The 
Instance Extractor extracts the attributes of the 
instances from the sentences, and generates the 
output of the system.  
3.1 Sentence Gatherer 
The Sentence Gatherer is currently implemented 
in a very simple way. It gets a set of keywords as 
input, and proceeds to download all documents 
that contain one of those keywords. From the 
documents, it extracts all sentences that contain 
at least one of the keywords. 
The keywords for a relation are the words that 
are indicative of instances of the relation. The 
keywords are given to the system as part of the 
relation definition. Their number is usually 
small. For instance, the set of keywords for Ac-
quisition in our experiments contains two words 
? ?acquired? and ?acquisition?. Additional key-
words (such as ?acquire?, ?purchased?, and 
?hostile takeover?) can be added automatically 
by using WordNet (Miller 1995).  
3.2 Pattern Learner 
The task of the Pattern Learner is to learn the 
patterns of occurrence of relation instances. This 
is an inherently supervised task, because at least 
some occurrences must be known in order to be 
able to find patterns among them. Consequently, 
the input to the Pattern Learner includes a small 
set (10-15 instances) of known instances for 
each target relation. Our system assumes that the 
seeds are a part of the target relation definition. 
However, the seeds need not be created manu-
ally. Instead, they can be taken from the top-
scoring results of a high-precision low-recall 
unsupervised extraction system, such as 
KnowItAll. The seeds for our experiments were 
produced in exactly this way. 
The Pattern Learner proceeds as follows: first, 
the gathered sentences that contain the seed in-
stances are used to generate the positive and 
negative sets. From those sets the pattern are 
learned. Then, the patterns are post-processed 
and filtered. We shall now describe those steps 
in detail. 
Preparing the positive and negative sets 
The positive set of a predicate (the terms predi-
cate and relation are interchangeable in our 
work) consists of sentences that contain a known 
instance of the predicate, with the instance at-
tributes changed to ?<AttrN>?, where N is the 
attribute index. For example, assuming there is a 
seed instance Acquisition(Oracle, PeopleSoft), 
the sentence 
The Antitrust Division of the U.S. De-
partment of Justice evaluated the likely 
competitive effects of Oracle's proposed 
acquisition of PeopleSoft. 
will be changed to 
The Antitrust Division? ?of <Attr1>'s 
proposed acquisition of <Attr2>. 
The positive set of a predicate P is generated 
straightforwardly, using substring search. 
The negative set of a predicate consists of 
similarly modified sentences with known false 
instances of the predicate. We build the negative 
set as a union of two subsets. The first subset is 
generated from the sentences in the positive set 
by changing the assignment of one or both at-
tributes to some other suitable entity. In the first 
mode of operation, when only a shallow parser is 
available, any suitable noun phrase can be as-
signed to an attribute. Continuing the example 
above, the following sentences will be included 
in the negative set:  
<Attr1> of <Attr2> evaluated the likely? 
<Attr2> of the U.S. ? ?acquisition of 
<Attr1>. 
etc. 
In the second mode of operation, when the 
NER is available, only entities of the correct 
type get assigned to an attribute. 
The other subset of the negative set contains 
all sentences produced in a similar way from the 
positive sentences of all other target predicates. 
We assume without loss of generality that the 
predicates that are being extracted simultane-
ously are all disjoint. In addition, the definition 
of each predicate indicates whether the predicate 
is symmetric (like ?merger?) or antisymmetric 
(like ?acquisition?). In the former case, the sen-
tences produced by exchanging the attributes in 
positive sentences are placed into the positive 
set, and in the later case ? into the negative set of 
the predicate. 
The following pseudo code shows the process 
of generating the positive and negative sets in 
detail: 
669
Let S be the set of gathered sentences.  
For each predicate P 
    For each s?S containing a word from Keywords(P) 
        For each known seed P(A1, A2) of the predicate P 
            If A1 and A2 are each found exactly once inside s 
                For all entities e1, e2 ? s, such that e2 ? e1, and 
                            Type(e1) = type of Attr1 of P, and 
                            Type(e2) = type of Attr2 of P 
                    Let s' := s  with eN changed to ?<AttrN>?. 
                    If e1 = A1 and e2 = A2 
                        Add  s'  to the PositiveSet(P). 
                    Elseif e1 = A2 and e2 = A1 and symmetric(P) 
                        Add s' to the PositiveSet(P). 
                    Else 
                        Add s' to the NegativeSet(P). 
For each predicate P 
    For each predicate P2 ? P 
        For each sentence s ? PositiveSet(P2) 
            Put s into the NegativeSet(P). 
Generating the patterns 
The patterns for predicate P are generalizations 
of pairs of sentences from the positive set of P. 
The function Generalize(S1, S2)  is applied to 
each pair of sentences S1 and S2 from the positive 
set of the predicate. The function generates a 
pattern that is the best (according to the objective 
function defined below) generalization of its two 
arguments. The following pseudo code shows 
the process of generating the patterns: 
For each predicate P 
    For each pair S1, S2 from PositiveSet(P) 
        Let Pattern := Generalize(S1, S2). 
        Add Pattern to PatternsSet(P). 
The patterns are sequences of tokens, skips 
(denoted *), limited skips (denoted *?) and slots. 
The tokens can match only themselves, the skips 
match zero or more arbitrary tokens, and slots 
match instance attributes.  The limited skips 
match zero or more arbitrary tokens, which must 
not belong to entities of the types equal to the 
types of the predicate attributes. The General-
ize(s1, s2) function takes two patterns (note, that 
sentences in the positive and negative sets are 
patterns without skips) and generates the least 
(most specific) common generalization of both. 
The function does a dynamical programming 
search for the best match between the two pat-
terns (Optimal String Alignment algorithm), 
with the cost of the match defined as the sum of 
costs of matches for all elements. We use the 
following numbers:  two identical elements 
match at cost 0, a token matches a skip or an 
empty space at cost 10, a skip matches an empty 
space at cost 2, and different kinds of skip match 
at cost 3. All other combinations have infinite 
cost. After the best match is found, it is con-
verted into a pattern by copying matched identi-
cal elements and adding skips where non-
identical elements are matched. For example, 
assume the sentences are 
Toward this end, <Attr1> in July acquired 
<Attr2> 
Earlier this year, <Attr1> acquired <Attr2> 
from X 
After the dynamical programming-based 
search, the following match will be found: 
 
Table 1 - Best Match between Sentences 
Toward (cost 10)
Earlier   (cost 10)
this this (cost 0)
end (cost 10)
year (cost 10)
, , (cost 0)
<Attr1 > <Attr1 > (cost 0)
in  July (cost 20)
acquired acquired (cost 0)
<Attr2 > <Attr2 > (cost 0)
from (cost 10)
X (cost 10)  
 
at total cost = 80. The match will be converted to 
the pattern (assuming the NER mode, so the only 
entity belonging to the same type as one of the 
attributes is ?X?): 
*? *? this *? *? , <Attr1> *? acquired <Attr2> *? * 
which becomes, after combining adjacent skips, 
*?  this  *?  ,  <Attr1>  *?  acquired  <Attr2>   * 
Note, that the generalization algorithm allows 
patterns with any kind of elements beside skips, 
such as CapitalWord, Number, CapitalizedSe-
quence, etc. As long as the costs and results of 
matches are properly defined, the Generalize 
function is able to find the best generalization of 
any two patterns. However, in the present work 
we stick with the simplest pattern definition as 
described above. 
Post-processing, filtering, and scoring 
The number of patterns generated at the previous 
step is very large. Post-processing and filtering 
tries to reduce this number, keeping the most 
useful patterns and removing the too specific and 
irrelevant ones. 
First, we remove from patterns all ?stop 
words? surrounded by skips from both sides, 
670
such as the word ?this? in the last pattern in the 
previous subsection. Such words do not add to 
the discriminative power of patterns, and only 
needlessly reduce the pattern recall. The list of 
stop words includes all functional and very 
common English words, as well as puncuation 
marks. Note, that the stop words are removed 
only if they are surrounded by skips, because 
when they are adjacent to slots or non-stop 
words they often convey valuable information. 
After this step, the pattern above becomes 
       *?  ,  <Attr1>  *?  acquired  <Attr2>   * 
In the next step of filtering, we remove all pat-
terns that do not contain relevant words. For 
each predicate, the list of relevant words is 
automatically generated from WordNet by fol-
lowing all links to depth at most 2 starting from 
the predicate keywords. For example, the pattern 
       *   <Attr1>  *  by  <Attr2>   *   
will be removed, while the pattern 
       *   <Attr1>  *  purchased  <Attr2>  *   
will be kept, because the word ?purchased? can 
be reached from ?acquisition? via synonym and 
derivation links. 
The final (optional) filtering step removes all 
patterns, that contain slots surrounded by skips 
on both sides, keeping only the patterns, whose 
slots are adjacent to tokens or to sentence 
boundaries. Since both the shallow parser and 
the NER system that we use are far from perfect, 
they often place the entity boundaries incor-
rectly. Using only patterns with anchored slots 
significantly improves the precision of the whole 
system. In our experiments we compare the per-
formance of anchored and unanchored patterns. 
The filtered patterns are then scored by their 
performance on the positive and negative sets.  
Currently we use a simple scoring method ? the 
score of a pattern is the number of positive 
matches divided by the number of negative 
matches plus one: 
| { : matches } |
( )
|{ : matches } | 1
S PositiveSet Pattern S
Score Pattern
S NegativeSet Pattern S
?= ? +  
This formula is purely empirical and produces 
reasonable results. The threshold is applied to 
the set of patterns, and all patterns scoring less 
than the threshold (currently, it is set to 6) are 
discarded. 
3.3 Sentence Classifier 
The task of the Sentence Classifier is to filter out 
from the large pool of sentences produced by the 
Sentence Gatherer the sentences that do not con-
tain the target predicate instances. In the current 
version of our system, this is only done in order 
to reduce the number of sentences that need to 
be processed by the Slot Extractor. Therefore, in 
this stage we just remove the sentences that do 
not match any of the regular expressions gener-
ated from the patterns. Regular expressions are 
generated from patterns by replacing slots with 
skips. 
3.4 Instance Extractor 
The task of the Instance Extractor is to use the 
patterns generated by the Pattern Learner on the 
sentences that were passed through by the Sen-
tence Classifier. However, the patterns cannot be 
directly matched to the sentences, because the 
patterns only define the placeholders for instance 
attributes and cannot by themselves extract the 
values of the attributes. 
We currently have two different ways to solve 
this problem ? using a general-purpose shallow 
parser, which is able to recognize noun phrases 
and their heads, and using an information extrac-
tion system called TEG (Rosenfeld, Feldman et 
al. 2004), together with a trained grammar able 
to recognize the entities of the types of the 
predicates? attributes. We shall briefly describe 
the two modes of operation. 
Shallow Parser mode 
In the first mode of operation, the predicates 
may define attributes of two different types: 
ProperName and CommonNP. We assume that 
the values of the ProperName type are always 
heads of proper noun phrases. And the values of 
the 
CommonNP type are simple common noun 
phrases (with possible proper noun modifiers, 
e.g. ?the Kodak camera?). 
We use a Java-written shallow parser from the 
OpenNLP (http://opennlp.sourceforge.net/) 
package. Each sentence is tokenized, tagged with 
part-of-speech, and tagged with noun phrase 
boundaries. The pattern matching and extraction 
is straightforward. 
TEG mode 
TEG (Trainable Extraction Grammars) 
(Rosenfeld, Feldman et al 2004) is general-
671
purpose hybrid rule-based and statistical IE sys-
tem, able to extract entities and relations at the 
sentence level. It is adapted to any domain by 
writing a suitable set of rules, and training them 
using an annotated corpus. The TEG rule lan-
guage is a straightforward extension of a con-
text-free grammar syntax. A complete set of 
rules is compiled into a PCFG (Probabilistic 
Context Free Grammar), which is then trained 
upon the training corpus. 
Some of the nonterminals inside the TEG 
grammar can be marked as target concepts. 
Wherever such nonterminal occurs in a final 
parse of a sentence, TEG generates an output 
label. The target concept rules may specify some 
of their parts as attributes. Then the concept is 
considered to be a relation, with the values of the 
attributes determined by the concept parse. Con-
cepts without attributes are entities.  
For the TEG-based instance extractor we util-
ize the NER ruleset of TEG and an internal train-
ing corpus called INC, as described in 
(Rosenfeld, Feldman et al 2004). The ruleset 
defines a grammar with a set of concepts for 
Person, Location, and Organization entities. In 
addition, the grammar defines a generic Noun-
Phrase concept, which can be used for capturing 
the entities that do not belong to any of the entity 
types above. 
 
In order to do the extraction, the patterns gener-
ated by the Pattern Learner are converted to the 
TEG syntax and added to the pre-built NER 
grammar. This produces a grammar, which is 
able to extract relations. This grammar is trained 
upon the automatically labeled positive set from 
the Pattern Learning. The resulting trained 
model is applied to the sets of sentences pro-
duced by the Sentence Classifier. 
 
4 Experimental Evaluation 
In order to evaluate URES, we used five predi-
cates 
Acquisition(BuyerCompany, BoughtCom-
pany), 
Merger(Company1, Company2), 
CEO_Of(Company, Name), 
MayorOf(City, Name), 
InventorOf(InventorName, Invention). 
Merger is symmetric predicate, in the sense that 
the order of its attributes does not matter. Acqui-
sition is antisymmetric, and the other three are 
tested as bound in the first attribute. For the 
bound predicates, we are only interested in the 
instances with particular prespecified values of 
the first attribute. 
 We test both modes of operation ? using shal-
low parser and using TEG. In the shallow parser 
mode, the Invention attribute of the InventorOf 
predicate is of type CommonNP, and all other 
attributes are of type ProperName. In the TEG 
mode, the ?Company? attributes are of type Or-
ganization, the ?Name? attributes are of type 
Person, the ?City? attribute is of type Location, 
and the ?Invention? attribute is of type Noun-
Phrase. 
We evaluate our system by running it over a 
large set of sentences, counting the number of 
extracted instances, and manually checking a 
random sample of the instances to estimate pre-
cision. In order to be able to compare our results 
with KnowItAll-produced results, we used the 
set of sentences collected by the KnowItAll?s 
crawler as if they were produced by the Sentence 
Gatherer.  
The set of sentences for the Acquisition and 
Merger predicates contained around 900,000 
sentences each. For the other three predicates, 
each of the sentences contained one of the 100 
predefined values for the first attribute. The val-
ues (100 companies for CEO_Of, 100 cities for 
MayorOf, and 100 inventors for InventorOf) are 
entities collected by KnowItAll, half of them are 
frequent entities (>100,000 hits), and another 
half are rare (<10,000 hits). 
In all of the experiments, we use ten top 
predicate instances extracted by KnowItAll for 
the relation seeds needed by the Pattern Learner. 
The results of our experiments are summa-
rized in the Table 2. The table displays the num-
ber of extracted instances and estimated 
precision for three different URES setups, and 
for the KnowItAll manually built patterns. Three 
results are shown for each setup and each rela-
tion ? extractions supported by at least one, at 
least two, and at least three different sentences, 
respectively. 
Several conclusions can be drawn from the re-
sults. First, both modes of URES significantly 
outperform KnowItAll in recall (number of ex-
tractions), while maintaining the same level of 
precision or improving it. This demonstrates util-
ity of our pattern learning component. Second, it 
is immediately apparent, that using only an-
chored patterns significantly improves precision 
of NP Tagger-based URES, though at a high cost 
in recall. The NP tagger-based URES with an-
chored patterns performs somewhat worse than 
672
 
Table 2 - Experimental results. 
 
   Acquisition CEO_Of InventorOf MayorOf Merger 
  support Count Prec Count Prec Count Prec Count Prec Count Prec
? 1 10587 0.74 545 0.7 1233 0.84 2815 0.6 25071 0.71
? 2 815 0.87 221 0.92 333 0.92 717 0.74 2981 0.8 
NP Tagger 
All patterns 
 ? 3 234 0.9 133 0.94 185 0.96 442 0.84 1245 0.88
? 1 5803 0.84 447 0.8 1035 0.86 2462 0.65 17107 0.8 
? 2 465 0.96 186 0.94 284 0.92 652 0.78 2481 0.83
NP Tagger 
Anchored  
patterns ? 3 148 0.98 123 0.96 159 0.96 411 0.88 1084 0.9 
? 1 8926 0.82 618 0.83 2322 0.65 2434 0.85 15002 0.8 
? 2 1261 0.94 244 0.94 592 0.85 779 0.93 2932 0.86
TEG 
All patterns 
 ? 3 467 0.98 158 0.98 334 0.88 482 0.98 1443 0.9 
? 1 2235 0.84 421 0.81 604 0.8 725 0.76 3233 0.82KnowItAll 
 ? 2 257 0.98 190 0.98 168 0.92 308 0.92 352 0.92
 
 
 
 
TEG-based URES on all predicates except In-
ventorOf, as expected. For the InventorOf, TEG 
performs worse, because of overly simplistic 
implementation of the NounPhrase concept in-
side the TEG grammar ? it is defined as a se-
quence of zero or more adjectives followed by a 
sequence of nouns. Such definition often leads to 
only part of a correct invention name being ex-
tracted. 
5 Conclusions and Future Work 
We have presented the URES system for autono-
mously extracting relations from the Web. 
URES bypasses the bottleneck created by classic 
information extraction systems that either relies 
on manually developed extraction patterns or on 
manually tagged training corpus. Instead, the 
system relies upon learning patterns from a large 
unlabeled set of sentences downloaded from 
Web. 
One of the topics we would like to further ex-
plore is the complexity of the patterns that we 
learn. Currently we use a very simple pattern 
language that just has 4 types of elements, slots, 
constants and two types of skips. We want to see 
if we can achieve higher precision with more 
complex patterns. In addition we would like to 
test URES on n-ary predicates, and to extend the 
system to handle predicates that are allowed to 
lack some of the attributes. 
 
 
References  
Agichtein, E. and L. Gravano (2000). Snowball: Ex-
tracting Relations from Large Plain-Text Collec-
tions. Proceedings of the 5th ACM International 
Conference on Digital Libraries (DL). 
Bikel, D. M., S. Miller, et al (1997). Nymble: a high-
performance learning name-finder. Proceedings of 
ANLP-97: 194-201. 
Brin, S. (1998). Extracting Patterns and Relations 
from the World Wide Web. WebDB Workshop, 
EDBT '98. 
Califf, M. E. and R. J. Mooney (1998). Relational 
Learning of Pattern-Match Rules for Information 
Extraction. Working Notes of AAAI Spring Sym-
posium on Applying Machine Learning to    Dis-
course Processing. Menlo Park, CA, AAAI Press: 
6-11. 
Chinchor, N., L. Hirschman, et al (1994). "Evaluat-
ing Message Understanding Systems: An Analysis 
of the Third Message Understanding Conference 
(MUC-3)." Computational Linguistics 3(19): 409-
449. 
Collins, M. and S. Miller (1998). Semantic Tagging 
using a Probabilistic Context Free Grammar. Pro-
ceedings of the Sixth Workshop on Very Large 
Corpora. 
Etzioni, O., M. Cafarella, et al (2005). "Unsupervised 
named-entity extraction from the Web: An ex-
perimental study." Artificial Intelligence. 
Fisher, D., S. Soderland, et al (1995). Description of 
the UMass Systems as Used for MUC-6. 6th Mes-
sage Understanding Conference: 127-140. 
673
Manning, C. and H. Schutze (1999). Foundations of 
Statistical Natural Language Processing. Cam-
bridge, US, The MIT Press. 
McCallum, A., D. Freitag, et al (2000). Maximum 
Entropy Markov Models for Information Extrac-
tion and    Segmentation. Proc. 17th International 
Conf. on Machine Learning, Morgan Kaufmann, 
San Francisco, CA: 591-598. 
Miller, D., R. Schwartz, et al (1999). Named entity 
extraction from broadcast news. Proceedings of 
DARPA Broadcast News Workshop. Herndon, 
VA. 
Miller, G. A. (1995). "WordNet: A lexical database 
for English." CACM 38(11): 39-41. 
Phillips, W. and E. Riloff (2002). Exploiting Strong 
Syntactic Heuristics and Co-Training to Learn 
Semantic Lexicons. Conference on Empirical 
Methods in Natural Language Processing 
(EMNLP 2002). 
Riloff, E. (1996). Automatically Generating Extrac-
tion Patterns from Untagged Text. AAAI/IAAI, 
Vol. 2: 1044-1049. 
Riloff, E. and R. Jones (1999). Learning Dictionaries 
for Information Extraction by Multi-level Boot-
strapping. Proceedings of the Sixteenth National 
Conference on Artificial    Intelligence, The AAAI 
Press/MIT Press: 1044-1049. 
Rosenfeld, B., R. Feldman, et al (2004). TEG: a hy-
brid approach to information extraction. CIKM 
2004, Arlington, VA. 
Soderland, S. (1999). "Learning Information Extrac-
tion Rules for Semi-Structured and Free Text." 
Machine Learning 34(1-3): 233-272. 
Sudo, K., S. Sekine, et al (2001). Automatic pattern 
acquisition for Japanese information extraction. 
Human Language Technology Conference 
(HTL2001). 
Thelen, M. and E. Riloff (2002). A Bootstrapping 
Method for Learning Semantic Lexicons using 
Extraction Pattern Contexts. Conference on Em-
pirical Methods in Natural Language Processing 
(EMNLP 2002). 
Yeh, A. and L. Hirschman (2002). "Background and 
overview for kdd cup 2002 task 1: Information ex-
traction from biomedical articles." KDD Ex-
plorarions 4(2): 87-89. 
Zelle, J. M. and R. J. Mooney. (1996). Learning to 
parse database queries using inductive logic pro-
gramming. 13th National Conference on Artificial 
Intelligence (AAAI-96). 
 
 
674
Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing (EMNLP 2006), pages 473?481,
Sydney, July 2006. c?2006 Association for Computational Linguistics
Boosting Unsupervised Relation Extraction by Using NER 
Ronen Feldman 
Computer Science Department 
Bar-Ilan University 
Ramat-Gan, ISRAEL 
feldman@cs.biu.ac.il 
Benjamin Rosenfeld 
Computer Science Department 
Bar-Ilan University 
Ramat-Gan, ISRAEL 
grurgrur@gmail.com 
 
Abstract 
Web extraction systems attempt to use 
the immense amount of unlabeled text 
in the Web in order to create large lists 
of entities and relations. Unlike 
traditional IE methods, the Web 
extraction systems do not label every 
mention of the target entity or relation, 
instead focusing on extracting as many 
different instances as possible while 
keeping the precision of the resulting 
list reasonably high. URES is a Web 
relation extraction system that learns 
powerful extraction patterns from 
unlabeled text, using short descriptions 
of the target relations and their 
attributes. The performance of URES is 
further enhanced by classifying its 
output instances using the properties of 
the extracted patterns. The features we 
use for classification and the trained 
classification model are independent 
from the target relation, which we 
demonstrate in a series of experiments. 
In this paper we show how the 
introduction of a simple rule based 
NER can boost the performance of 
URES on a variety of relations. We 
also compare the performance of 
URES to the performance of the state-
of-the-art KnowItAll system, and to the 
performance of its pattern learning 
component, which uses a simpler and 
less powerful pattern language than 
URES. 
1   Introduction 
Information Extraction (IE) (Riloff 1993; 
Cowie and Lehnert 1996; Grishman 1996; 
Grishman 1997; Kushmerick, Weld et al 1997; 
Freitag 1998; Freitag and McCallum 1999; 
Soderland 1999)  is the task of extracting 
factual assertions from text. 
Most IE systems rely on knowledge 
engineering or on machine learning to generate 
extraction patterns ? the mechanism that 
extracts entities and relation instances from 
text. In the machine learning approach, a 
domain expert labels instances of the target 
relations in a set of documents. The system 
then learns extraction patterns, which can be 
applied to new documents automatically. 
Both approaches require substantial human 
effort, particularly when applied to the broad 
range of documents, entities, and relations on 
the Web.   In order to minimize the manual 
effort necessary to build Web IE systems, we 
have designed and implemented URES 
(Unsupervised Relation Extraction System). 
URES takes as input the names of the target 
relations and the types of their arguments. It 
then uses a large set of unlabeled documents 
downloaded from the Web in order to learn the 
extraction patterns. 
URES is most closely related to the 
KnowItAll system developed at University of 
Washington by Oren Etzioni and colleagues 
(Etzioni, Cafarella et al 2005), since both are 
unsupervised and both leverage relation-
independent extraction patterns to 
automatically generate seeds, which are then 
fed into a pattern-learning component.  
KnowItAll is based on the observation that the 
Web corpus is highly redundant. Thus, its 
selective, high-precision extraction patterns 
readily ignore most sentences, and focus on 
sentences that indicate the presence of relation 
instances with very high probability. 
 In contrast, URES is based on the 
observation that, for many relations, the Web 
corpus has limited redundancy, particularly 
when one is concerned with less prominent 
instances of these relations (e.g., the 
acquisition of Austria Tabak).  Thus, URES 
utilizes a more expressive extraction pattern 
language, which enables it to extract 
information from a broader set of sentences.  
URES relies on a sophisticated mechanism to 
473
assess its confidence in each extraction, 
enabling it to sort extracted instances, thereby 
improving its recall without sacrificing 
precision. 
 
Our main contributions are as follows: 
 
? We introduce the first domain-
independent system to extract relation 
instances from the Web with both high 
precision and high recall. 
? We show how to minimize the human 
effort necessary to deploy URES for 
an arbitrary set of relations, including 
automatically generating and labeling 
positive and negative examples of the 
relation.  
? We show how we can integrate a 
simple NER component into the 
classification scheme of URES in 
order to boost recall between 5-15% 
for similar precision levels. 
? We report on an experimental 
comparison between URES, URES-
NER and the state-of-the-art 
KnowItAll system, and show that 
URES can double or even triple the 
recall achieved by KnowItAll for 
relatively rare relation instances. 
 
The rest of the paper is organized as 
follows:  Section 2 describes previous work.  
Section 3 outlines the general design principles 
of URES, its architecture, and then describes 
each URES component in detail.  Section 4 
presents our experimental evaluation.  Section 
5 contains conclusions and directions for future 
work. 
2   Related Work 
The IE systems most similar to URES are 
based on bootstrap learning: Mutual 
Bootstrapping (Riloff and Jones 1999), the 
DIPRE system (Brin 1998), and the Snowball 
system (Agichtein and Gravano 2000 ). 
(Ravichandran and Hovy 2002) also use 
bootstrapping, and learn simple surface 
patterns for extracting binary relations from the 
Web. 
Unlike those unsupervised IE systems, 
URES patterns allow gaps that can be matched 
by any sequences of tokens. This makes URES 
patterns much more general, and allows to 
recognize instances in sentences inaccessible 
to the simple surface patterns of systems such 
as (Brin 1998; Riloff and Jones 1999; 
Ravichandran and Hovy 2002). The greater 
power of URES requires different and more 
complex methods for learning, scoring, and 
filtering of patterns. 
Another direction for unsupervised relation 
learning was taken in (Hasegawa, Sekine et al 
2004; Chen, Ji et al 2005). These systems use 
a NER system to identify pairs of entities and 
then cluster them based on the types of the 
entities and the words appearing between the 
entities. Only pairs that appear at least 30 times 
were considered. The main benefit of this 
approach is that all relations between two 
entity types can be discovered simultaneously 
and there is no need for the user to supply the 
relations definitions. Such a system could have 
been used as a preliminary step to URES, 
however its relatively low precision makes it 
unfeasible. Unlike URES, the evaluations 
performed in these papers ignored errors that 
were introduced by the underlying NER 
component. The precision reported by these 
systems (77% breakeven for the COM-COM 
domain) is inferior to that of URES. 
We compared our results directly to two 
other unsupervised extraction systems, the 
Snowball (Agichtein and Gravano 2000 ) and 
KnowItAll. Snowball is an unsupervised 
system for learning relations from document 
collections. The system takes as input a set of 
seed examples for each relation, and uses a 
clustering technique to learn patterns from the 
seed examples. It does rely on a full fledged 
Named Entity Recognition system. Snowball 
achieved fairly low precision figures (30-50%) 
on relations such as Merger and Acquisition on 
the same dataset we used in our experiments. 
KnowItAll is a system developed at 
University of Washington by Oren Etzioni and 
colleagues (Etzioni, Cafarella et al 2005). We 
shall now briefly describe it and its pattern 
learning component. 
Brief description of KnowItAll 
KnowItAll uses a set of generic extraction 
patterns, and automatically instantiates rules by 
combining those patterns with user supplied 
relation labels. For example, KnowItAll has 
patterns for a generic ?of? relation: 
NP1  <relation>  NP2 
NP1  's  <relation>  ,  NP2 
NP2  ,  <relation>  of  NP1 
474
where NP1 and NP2 are simple noun phrases 
that extract values of attribute1 and attribute2 
of a relation, and <relation> is a user-supplied 
string associated with the relation. The rules 
may also constrain NP1 and NP2 to be proper 
nouns. 
The rules have alternating context strings 
(exact string match) and extraction slots 
(typically an NP or head of an NP).  Each rule 
has an associated query used to automatically 
find candidate sentences from a Web search 
engine. 
KnowItAll also includes mechanisms to 
control the amount of search, to merge 
redundant extractions, and to assign a 
probability to each extraction based on 
frequency of extraction or on Web statistics 
(Downey, Etzioni et al 2004). 
KnowItAll-PL.  While those generic rules 
lead to high precision extraction, they tend to 
have low recall, due to the wide variety of 
contexts describing a relation. KnowItAll 
includes a simple pattern learning scheme 
(KnowItAll-PL) that builds on the generic 
extraction mechanism (KnowItAll-baseline). 
Like URES, this is a self-supervised method 
that bootstraps from seeds that are 
automatically extracted by the baseline system. 
KnowItAll-PL creates a set of positive 
training sentences by downloading sentences 
that contain both argument values of a seed 
tuple and also the relation label. Negative 
training is created by downloading sentences 
with only one of the seed argument values, and 
considering a nearby NP as the other argument 
value. This does not guarantee that the 
negative example will actually be false, but 
works well in practice. 
Rule induction tabulates the occurrence of 
context tokens surrounding the argument 
values of the positive training sentences. Each 
candidate extraction pattern has a left context 
of zero to k tokens immediately to the left of 
the first argument, a middle context of all 
tokens between the two arguments, and a right 
context of zero to k tokens immediately to the 
right of the second argument.  A pattern can be 
generalized by dropping the furthest terms 
from the left or right context. KnowItAll-PL 
retains the most general version of each pattern 
that has training frequency over a threshold 
and training precision over a threshold. 
 
 
3   Description of URES 
The goal of URES is extracting instances of 
relations from the Web without human 
supervision. Accordingly, the input of the 
system is limited to (reasonably short) 
definition of the target relations (composed of 
the relation's schema and a few keywords that 
enable gathering relevant sentences). For 
example, this is the description of the 
acquisition relation: 
 
     Acquisition(ProperNP, ProperNP) ordered 
          keywords={"acquired" "acquisition"} 
 
The word ordered indicates that Acquisition 
is not a symmetric relation and the order of its 
arguments matters. The ProperNP tokens 
indicate the types of the attributes. In the 
regular mode, there are only two possible 
attribute types ? ProperNP and CommonNP, 
meaning proper and common noun phrases, 
respectively. When using the NER Filter 
component described in the section 4.1 we 
allow further subtypes of ProperNP, and the 
predicate definition becomes: 
          acquisition(Company, Company) ? 
The keywords are used for gathering 
sentences from the Web and for instantiating 
the generic patterns for seeds generation. 
Additional keywords (such as ?acquire?, 
?purchased?, ?hostile takeover?, etc), which 
can be used for gathering more sentences, are 
added automatically by using WordNet [18]. 
URES consists of several largely 
independent components; their layout is shown 
on the Figure 1. The Sentence Gatherer 
generates (e.g., downloads from the Web) a 
large set of sentences that may contain target 
instances. The Seeds Generator, which is 
essentially equal to the KnowItAll-baseline 
system, uses a small set of generic patterns 
instantiated with the predicate keywords to 
extract a small set of high-confidence instances 
of the target relations. The Pattern Learner uses 
the seeds to learn likely patterns of relation 
occurrences. Then, the Instance Extractor uses 
the patterns to extracts the instances from the 
sentences. Those instances can be filtered by a 
NER Filter, which is an optional part of the 
system. Finally, the Classifier assigns the 
confidence score to each extraction. 
 
 
475
 Sentence 
Gatherer 
Input: 
Target Relations 
Definitions 
Web 
Sentences 
keywords 
Pattern 
Learner 
Instance 
Extractor 
Output: 
Extractions 
Seeds 
Generator 
seeds 
patterns 
NER Filter 
(optional) 
instances 
Classifier 
 
Figure 1. The architecture of URES 
3.1  Pattern Learner 
The task of the Pattern Learner is to learn the 
patterns of occurrence of relation instances. 
This is an inherently supervised task, because 
at least some occurrences must be known in 
order to be able to find patterns among them. 
Consequently, the input to the Pattern Learner 
includes a small set (10 instances in our 
experiments) of known instances for each 
target relation. Our system assumes that the 
seeds are a part of the target relation definition. 
However, the set of seeds need not be created 
manually. Instead, the seeds can be taken 
automatically from the top-scoring results of a 
high-precision low-recall unsupervised 
extraction system, such as KnowItAll. The 
seeds for our experiments were produced in 
exactly this way: we used two generic patterns 
instantiated with the relation name and 
keywords. Those patterns have a relatively 
high precision (although low recall), and the 
top-confidence results, which are the ones 
extracted many times from different sentences, 
have close to 100% probability of being 
correct. 
The Pattern Learner proceeds as follows: 
first, the gathered sentences that contain the 
seed instances are used to generate the positive 
and negative sets. From those sets the patterns 
are learned. Finally, the patterns are post-
processed and filtered. We shall now describe 
those steps in detail. 
 
PREPARING THE POSITIVE AND NEGATIVE 
SETS 
The positive set of a predicate (the terms 
predicate and relation are interchangeable in 
our work) consists of sentences that contain a 
known instance of the predicate, with the 
instance attributes changed to ?<AttrN>?, 
where N is the attribute index. For example, 
assuming there is a seed instance 
Acquisition(Oracle, PeopleSoft), the sentence 
The Antitrust Division of the U.S. Department of 
Justice evaluated the likely competitive effects of 
Oracle's proposed acquisition of PeopleSoft. 
will be changed to 
The Antitrust Division? ?of <Attr1>'s proposed 
acquisition of <Attr2>. 
The positive set of a predicate P is generated 
straightforwardly, using substring search. The 
negative set of a predicate consists of 
sentences with known false instances of the 
predicate similarly marked (with <AttrN> 
substituted for attributes). The negative set is 
used by the pattern learner during the scoring 
and filtering step, to filter out the patterns that 
are overly general. We generate the negative 
set from the sentences in the positive set by 
476
changing the assignment of one or both 
attributes to other suitable entities in the 
sentence. In the shallow parser based mode of 
operation, any suitable noun phrase can be 
assigned to an attribute. 
 
GENERATING THE PATTERNS 
The patterns for the predicate P are 
generalizations of pairs of sentences from the 
positive set of P. The function Generalize(s1, 
s2)  is applied to each pair of sentences s1 and 
s2 from the positive set of the predicate.  The 
function generates a pattern that is the best 
(according to the objective function defined 
below) generalization of its two arguments. 
The following pseudocode shows the 
process of generating the patterns for the 
predicate P: 
 
For each pair s1, s2 from PositiveSet(P) 
    Let Pattern = Generalize(s1, s2). 
    Add Pattern to PatternsSet(P). 
The patterns are sequences of tokens, skips 
(denoted *), limited skips (denoted *?) and 
slots. The tokens can match only themselves, 
the skips match zero or more arbitrary tokens, 
and slots match instance attributes.  The 
limited skips match zero or more arbitrary 
tokens, which must not belong to entities of the 
types equal to the types of the predicate 
attributes. In the shallow parser based mode, 
there are only two different entity types ? 
ProperNP and CommonNP, standing for 
proper and common noun phrases. 
The Generalize(s1, s2) function takes two 
sentences and generates the least (most 
specific) common generalization of both.  The 
function does a dynamical programming 
search for the best match between the two 
patterns (Optimal String Alignment algorithm), 
with the cost of the match defined as the sum 
of costs of matches for all elements. The exact 
costs of matching elements are not important 
as long as their relative order is maintained. 
We use the following numbers:  two identical 
elements match at cost 0, a token matches a 
skip or an empty space at cost 10, a skip 
matches an empty space at cost 2, and different 
kinds of skip match at cost 3. All other 
combinations have infinite cost. After the best 
match is found, it is converted into a pattern by 
copying matched identical elements and 
adding skips where non-identical elements are 
matched. For example, assume the sentences 
are 
   Toward this end, <Attr1> in July acquired 
<Attr2> 
   Earlier this year, <Attr1> acquired <Attr2> from 
X 
After the dynamic programming-based 
search, the following match will be found: 
Toward (cost 10)
Earlier   (cost 10)
this this (cost 0)
end (cost 10)
year (cost 10)
, , (cost 0)
<Attr1 > <Attr1 > (cost 0)
in   July (cost 20)
acquired acquired (cost 0)
<Attr2 > <Attr2 > (cost 0)
from (cost 10)
X (cost 10)  
 
at total cost = 80. Assuming that ?X? 
belongs to the same type as at least one of the 
attributes while the other tokens are not 
entities, the match will be converted to the 
pattern 
     *?  this  *?  ,  <Attr1>  *?  acquired  <Attr2>   
* 
3.2  Classifying the Extractions 
The goal of the final classification stage is to 
filter the list of all extracted instances, keeping 
the correct extractions and removing mistakes 
that would always occur regardless of the 
quality of the patterns. It is of course 
impossible to know which extractions are 
correct, but there exist properties of patterns 
and pattern matches that increase or decrease 
the confidence in the extractions that they 
produce. Thus, instead of a binary classifier, 
we seek a real-valued confidence function c, 
mapping the set of extracted instances into the 
[0, 1] segment. 
Since confidence value depends on the 
properties of particular sentences and patterns, 
it is more properly defined over the set of 
single pattern matches. Then, the overall 
confidence of an instance is the maximum of 
the confidence values of the matches that 
produce the instance. 
Assume that an instance E was extracted 
from a match of a pattern P at a sentence S. 
477
The following set of binary features may 
influence the confidence c(E, P, S): 
f1(E, P, S) = 1,  if the number of sentences  
                     producing E  is greater than one. 
f2(E, P, S) = 1,  if the number of sentences  
                     producing E is greater than two. 
f3(E, P, S) = 1,  if at least one slot of the pattern P is 
                      adjacent to a non-stop-word token. 
f4(E, P, S) = 1,  if both slots of the pattern P are 
                       adjacent to non-stop-word tokens. 
f5?f9(E, P, S)  = 1,  if the number of nonstop                    
                       words in P is 0 (f5), 1 or greater (f6),  
                       2 or greater (f7), 3 or greater (f8), and  
                       4 or greater (f9). 
f10?f15(E, P, S)  = 1, if the number of words 
                       between the slots of the match M                                  
                       that were matched to skips of the 
                       pattern P is 0 (f10), 1 or less (f11), 2  
                       or less (f12) , 3 or less(f13),  5 or less 
                       (f14), and 10 or less (f15). 
 
Utilizing the NER 
In the URES-NER version the entities of each 
candidate instance are passed through a simple 
rule-based NER filter, which attaches a score 
(?yes?, ?maybe?, or ?no?) to the argument(s) 
and optionally fixes the arguments boundaries. 
The NER is capable of identifying entities of 
type PERSON and COMPANY (and can be 
extended to identify additional types).   
 
The scores mean: 
   ?yes? ? the argument is of the correct 
entity type. 
   ?no? ? the argument is not of the right 
entity type, and hence 
              the candidate instance should be 
removed. 
   ?maybe? ? the argument type is uncertain, 
can be either 
                    correct or no.  
 
If ?no? is returned for one of the arguments, 
the instance is removed. Otherwise, an 
additional binary feature is added to the 
instance's vector: 
     f16 = 1 iff the score for both arguments is 
?yes?. 
For bound predicates, only the second 
argument is analyzed, naturally. 
As can be seen, the set of features above is 
small, and is not specific to any particular 
predicate. This allows us to train a model using 
a small amount of labeled data for one 
predicate, and then use the model for all other 
predicates: 
Training: The patterns for a single model 
predicate are run over a relatively small set of 
sentences (3,000-10,000 sentences in our 
experiments), producing a set of extractions 
(between 150-300 extractions in our 
experiments). 
The extractions are manually labeled 
according to whether they are correct or not. 
For each pattern match Mk = (Ek, Pk, Sk), the 
value of the feature vector fk = (f1(Mk), ?, 
f15(Mk)) is calculated, and the label Lk = ?1  
is set according to whether the extraction Ek is 
correct or no. 
A regression model estimating the function 
L(f) is built from the training data {(fk, Lk)}. 
For our classifier we used the BBR (Genkin, 
Lewis et al 2004), but other models, such as 
SVM or NaiveBayes are of course also 
possible. 
Confidence estimation: For each pattern 
match M, its score L(f(M)) is calculated by the 
trained regression model. Note that we do not 
threshold the value of L, instead using the raw 
probability value between zero and one. 
The final confidence estimates c(E) for the 
extraction E is set to the maximum of L(f(M)) 
over all matches M that produced E. 
4   Experimental Evaluation 
Our experiments aim to answer three 
questions: 
  
1. Can we train URES?s classifier once, and 
then use the results on all other relations?  
2. What boost will we get by introducing a 
simple NER into the classification scheme of 
URES?   
3. How does URES?s performance compare 
with KnowItAll and KnowItAll-PL? 
 
Our experiments utilized five relations: 
Acquisition(BuyerCompany,AcquiredCompan
y), 
Merger(Company1, Company2), 
CEO_Of(Company, Person), 
MayorOf(City, Person), 
InventorOf(Person, Invention). 
 
Merger is a symmetric predicate, in the 
sense that the order of its attributes does not 
matter. Acquisition is antisymmetric, and the 
other three are tested as bound in the first 
478
attribute. For the bound predicates, we are only 
interested in the instances with particular 
prespecified values of the first attribute. The 
Invention attribute of the InventorOf predicate 
is of type CommonNP. All other attributes are 
of type ProperName. 
The data for the experiments were collected 
by the KnowItAll crawler. The data for the 
Acquisition and Merger predicates consist of 
about 900,000 sentences for each of the two 
predicates, where each sentence contains at 
least one predicate keyword. The data for the 
bounded predicates consist of sentences that 
contain a predicate keyword and one of a 
hundred values of the first (bound) attribute. 
Half of the hundred are frequent entities 
(>100,000 search engine hits), and another half 
are rare (<10,000 hits). 
The pattern learning for each of the 
predicates was performed using the whole 
corpus of sentences for the predicate. For 
testing the precision of each of the predicates 
in each of the systems we manually evaluated 
sets of 200 instances that were randomly 
selected out of the full set of instances 
extracted from the whole corpus. 
In the first experiment, we test the 
performance of the classification component 
using different predicates for building the 
model. In the second experiment we evaluate 
the full system over the whole dataset. 
 
4.1  Cross-Predicate Classification 
Performance 
In this experiment we test whether the choice 
of the model predicate for training the 
classifier is significant. 
The pattern learning for each of the 
predicates was performed using the whole 
corpus of sentences for the predicate. For 
testing we used a small random selection of 
sentences, run the Instance Extractor over 
them, and manually evaluated each extracted 
instance. The results of the evaluation for 
Acquisition, CEO_Of, and Merger are 
summarized in Figure 2. As can be seen, using 
any of the predicates as the model produces 
similar results. The graphs for the other two 
predicates are similar. We have used only the 
first 15 features, as the NER-based feature (f16) 
is predicate-dependent.  
 
 
Acquisition
0.7
0.75
0.8
0.85
0.9
0.95
1
0 50 100 150
P
re
ci
si
on
CEO_Of
0 50 100 150 200 250
Extractions count
Merger
0 50 100 150 200 250
Acq.
CEO
Inventor
Mayor
Merger
 
Figure 2.  Cross-predicate classification performance results. Each graph shows the five precision-recall curves produced by 
using the five different model predicates. As can be seen, the curves on each graph are very similar. 
 
479
CeoOf
0.60
0.65
0.70
0.75
0.80
0.85
0.90
0.95
1.00
0 50 100 150 200 250 300
Correct Extractions
P
re
ci
si
o
n
KIA KIA-PL URES U_NER
 
InventorOf
0.60
0.65
0.70
0.75
0.80
0.85
0.90
0.95
1.00
0 200 400 600 800 1,000 1,200
Correct Extractions
P
re
ci
si
o
n
KIA KIA-PL URES
  
Acquisition
0.60
0.65
0.70
0.75
0.80
0.85
0.90
0.95
1.00
0 2,000 4,000 6,000 8,000 10,000
Correct Extractions
P
re
ci
si
on
KIA KIA-PL URES U_NER
 
Merger
0.60
0.65
0.70
0.75
0.80
0.85
0.90
0.95
1.00
0 2,000 4,000 6,000 8,000 10,000 12,000 14,000
Correct Extractions
P
re
ci
si
on
KIA KIA-PL URES U_NER
 
Figure 3.  Comparision between URES, URES-NER, KnowItAll-baseline, and KnowItAll-PL. 
 
4.2  Performance of the whole system 
In this experiment we compare the 
performance of URES with classification to the 
performance of KnowItAll. To carry out the 
experiments, we used extraction data kindly 
provided by the KnowItAll group. They 
provided us with the extractions obtained by 
the KnowItAll system and by its pattern 
learning component (KnowItAll-PL). Both are 
sketched in Section 2.1 and are described in 
detail in (Etzioni, Cafarella et al 2005). 
In this experiment we used Acquisition as 
the model predicate for testing all other 
predicates except itself.  For testing 
Acquisition we used CEO_Of as the model 
predicate.  The results are summarized in the 
five graphs in the Figure 3. 
For three relations (Acquisition, Merger, and 
InventorOf) URES clearly outperforms 
KnowItAll. Yet for the other two (CEO_Of 
and MayorOf), the simpler method of 
KnowItAll-PL or even the KnowItAll-baseline 
do as well as URES. Close inspection reveals 
that the key difference is the amount of 
redundancy of instances of those relations in 
the data. Instances of CEO_Of and MayorOf 
are mentioned frequently in a wide variety of 
sentences whereas instances of the other 
relations are relatively infrequent. 
KnowItAll extraction works well when 
redundancy is high and most instances have a 
good chance of appearing in simple forms that 
KnowItAll is able to recognize. The additional 
machinery in URES is necessary when 
redundancy is low. Specifically, URES is more 
effective in identifying low-frequency 
instances, due to its more expressive rule 
representation, and its classifier that inhibits 
those rules from overgeneralizing. 
In the same graphs we can see that URES-
NER outperforms URES by 5-15% in recall 
for similar precision levels. We can also see 
that for Person-based predicates the 
improvement is much more pronounced, 
because Person is a much simpler entity to 
recognize.  Since in the InventorOf predicate 
the 2nd attribute is of type CommonNP, the 
NER component adds no value and URES-
NER and URES results are identical for this 
predicate. 
 
 
480
5   Conclusions 
We have presented the URES system for 
autonomously extracting relations from the 
Web. We showed how to improve the 
precision of the system by classifying the 
extracted instances using the properties of the 
patterns and sentences that generated the 
instances and how to utilize a simple NER 
component. The cross-predicate tests showed 
that classifier that performs well for all 
relations can be built using a small amount of 
labeled data for any particular relation. We 
performed an experimental comparison 
between URES, URES-NER and the state-of-
the-art KnowItAll system, and showed that 
URES can double or even triple the recall 
achieved by KnowItAll for relatively rare 
relation instances, and get an additional 5-15% 
boost in recall by utilizing a simple NER. In 
particular we have shown that URES is more 
effective in identifying low-frequency 
instances, due to its more expressive rule 
representation, and its classifier (augmented by 
NER) that inhibits those rules from 
overgeneralizing. 
References 
Agichtein, E. and L. Gravano (2000 ). Snowball: 
Extracting Relations from Large Plain-Text 
Collections. Proceedings of the 5th ACM 
International Conference on Digital Libraries 
(DL). 
Brin, S. (1998). Extracting Patterns and Relations 
from the World Wide Web. WebDB Workshop at 
6th International Conference on Extending 
Database Technology, EDBT?98, Valencia, 
Spain. 
Chen, J., D. Ji, et al (2005). Unsupervised Feature 
Selection for Relation Extraction IJCNLP-05, Jeju 
Island, Korea. 
Cowie, J. and W. Lehnert (1996). "Information 
Extraction." Communications of the Association 
of Computing Machinery 39(1): 80-91. 
Downey, D., O. Etzioni, et al (2004). Learning 
Text Patterns for Web Information Extraction and 
Assessment (Extended Version). Technical 
Report UW-CSE-04-05-01. 
Etzioni, O., M. Cafarella, et al (2005). 
"Unsupervised named-entity extraction from the 
Web: An experimental study." Artificial 
Intelligence 165(1): 91-134. 
Freitag, D. (1998). Machine Learning for 
Information Extraction in Informal Domains. 
Computer Science Department. Pittsburgh, PA, 
Carnegie Mellon University: 188. 
Freitag, D. and A. K. McCallum (1999). 
Information extraction with HMMs and 
shrinkage. Proceedings of the AAAI-99 
Workshop on Machine Learning for Information 
Extraction. 
Genkin, A., D. D. Lewis, et al (2004). Large-Scale 
Bayesian Logistic Regression for Text 
Categorization. New Brunswick, NJ, DIMACS: 
1-41. 
Grishman, R. (1996). The role of syntax in 
Information Extraction. Advances in Text 
Processing: Tipster Program Phase II, Morgan 
Kaufmann. 
Grishman, R. (1997). Information Extraction: 
Techniques and Challenges. SCIE: 10-27. 
Hasegawa, T., S. Sekine, et al (2004). Discovering 
Relations among Named Entities from Large 
Corpora. ACL 2004. 
Kushmerick, N., D. S. Weld, et al (1997). Wrapper 
Induction for Information Extraction. IJCAI-97: 
729-737. 
Ravichandran, D. and E. Hovy (2002). Learning 
Surface Text Patterns for a Question Answering 
System. 40th ACL Conference. 
Riloff, E. (1993). Automatically Constructing a 
Dictionary for Information Extraction Tasks. 
AAAI-93. 
Riloff, E. and R. Jones (1999). Learning 
Dictionaries for Information Extraction by Multi-
level Boot-strapping. AAAI-99. 
Soderland, S. (1999). "Learning Information 
Extraction Rules for Semi-Structured and Free 
Text." Machine Learning 34(1-3): 233-272. 
 
 
481
Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 600?607,
Prague, Czech Republic, June 2007. c?2007 Association for Computational Linguistics
Using Corpus Statistics on Entities to Improve Semi-supervised  
Relation Extraction from the Web 
Benjamin Rosenfeld 
Information Systems 
HU School of Business, 
Hebrew University, Jerusalem, Israel 
grurgrur@gmail.com 
Ronen Feldman 
Information Systems 
HU School of Business, 
Hebrew University, Jerusalem, Israel 
ronen.feldman@huji.ac.il 
 
 
Abstract 
Many errors produced by unsupervised and 
semi-supervised relation extraction (RE) 
systems occur because of wrong recogni-
tion of entities that participate in the rela-
tions. This is especially true for systems 
that do not use separate named-entity rec-
ognition components, instead relying on 
general-purpose shallow parsing. Such sys-
tems have greater applicability, because 
they are able to extract relations that 
contain attributes of unknown types. 
However, this generality comes with the 
cost in accuracy. In this paper we show 
how to use corpus statistics to validate and 
correct the arguments of extracted relation 
instances, improving the overall RE 
performance. We test the methods on 
SRES ? a self-supervised Web relation 
extraction system. We also compare the 
performance of corpus-based methods to 
the performance of validation and correc-
tion methods based on supervised NER 
components.  
 
1 Introduction 
Information Extraction (IE) is the task of extract-
ing factual assertions from text. Most IE systems 
rely on knowledge engineering or on machine 
learning to generate the ?task model? that is subse-
quently used for extracting instances of entities and 
relations from new text. In the knowledge engi-
neering approach the model (usually in the form of 
extraction rules) is created manually, and in the 
machine learning approach the model is learned 
automatically from a manually labeled training set 
of documents. Both approaches require substantial 
human effort, particularly when applied to the 
broad range of documents, entities, and relations 
on the Web.  In order to minimize the manual ef-
fort necessary to build Web IE systems, semi-
supervised and completely unsupervised systems 
are being developed by many researchers.  
The task of extracting facts from the Web has 
significantly different aims than the regular infor-
mation extraction. The goal of regular IE is to 
identify and label all mentions of all instances of 
the given relation type inside a document or inside 
a collection of documents. Whereas, in the Web 
Extraction (WE) tasks we are only interested in 
extracting relation instances and not interested in 
particular mentions. 
This difference in goals leads to a difference in 
the methods of performance evaluation. The usual 
measures of performance of regular IE systems are 
precision, recall, and their combinations ? the 
breakeven point and F-measure. Unfortunately, the 
true recall usually cannot be known for WE tasks. 
Consequently, for evaluating the performance of 
WE systems, the recall is substituted by the num-
ber of extracted instances. 
WE systems usually order the extracted in-
stances by the system?s confidence in their cor-
rectness. The precision of top-confidence extrac-
tions is usually very high, but it gets progressively 
lower when lower-confidence candidates are con-
sidered. The curve that plots the number of extrac-
tions against precision level is the best indicator of 
system?s quality. Naturally, for a comparision be-
600
tween different systems to be meaningful, the 
evaluations must be performed on the same corpus. 
In this paper we are concerned with Web RE 
systems that extract binary relations between 
named entities. Most of such systems utilize sepa-
rate named entity recognition (NER) components, 
which are usualy trained in a supervised way on a 
separate set of manually labeled documents. The 
NER components recognize and extract the values 
of relation attributes (also called arguments, or 
slots), while the RE systems are concerned with 
patterns of contexts in which the slots appear. 
However, good NER components only exist for 
common and very general entity types, such as 
Person, Organization, and Location. For some re-
lations, the types of attributes are less common, 
and no ready NER components (or ready labeled 
training sets) exist for them. Also, some Web RE 
systems (e.g., KnowItAll (Etzioni, Cafarella et al 
2005)) do not use separate NER components even 
for known entity types, because such components 
are usually domain-specific and may perform 
poorly on cross-domain text collections extracted 
from the Web. 
In such cases, the values for relation attributes 
must be extracted by generic methods ? shallow 
parsing (extracting noun phrases), or even simple 
substring extraction. Such methods are naturally 
much less precise and produce many entity-
recognition errors (Feldman and Rosenfeld 2006). 
In this paper we propose several methods of us-
ing corpus statistics to improve Web RE precision 
by validating and correcting the entities extracted 
by generic methods. The task of Web Extraction is 
particularly suited for the corpus statistics-based 
methods because of very large size of the corpora 
involved, and because the system is not required to 
identify individual mentions of the relations. 
Our methods of entity validation and correction 
are based on the following two observations: 
First, the entities that appear in target relations 
will often also appear in many other contexts, 
some of which may strongly discriminate in favor 
of entities of specific type. For example, assume 
the system encounters a sentence ?Oracle bought 
PeopleSoft.? If the system works without a NER 
component, it only knows that ?Oracle? and ?Peo-
pleSoft? are proper noun phrases, and its confi-
dence in correctness of a candidate relation in-
stance  Acquisition(Oracle, PeopleSoft)  cannot be 
very high. However, both entities occur many 
times elsewhere in the corpus, sometimes in 
strongly discriminating contexts, such as ?Oracle 
is a company that?? or ?PeopleSoft Inc.? If the 
system somehow learned that such contexts indi-
cate entities of the correct type for the Acquisition 
relation (i.e., companies), then the system would 
be able to boost its confidence in both entities 
(?Oracle? and ?PeopleSoft?) being of correct types 
and, consequently, in (Oracle, PeopleSoft) being a 
correct instance of the Acquisition relation. 
Another observation that we can use is the fact 
that the entities, in which we are interested, usually 
have sufficient frequency in the corpus for statisti-
cal term extraction methods to perform reasonably 
well. These methods may often correct a wrongly 
placed entity boundary, which is a common mis-
take of general-purpose shallow parsers. 
In this paper we show how to use these observa-
tions to supplement a Web RE system with an en-
tity validation and correction component, which is 
able to significantly improve the system?s accu-
racy. We evaluate the methods using SRES 
(Feldman and Rosenfeld 2006) ? a Web RE sys-
tem, designed to extend and improve KnowItAll 
(Etzioni, Cafarella et al 2005). The contributions 
of this paper are as follows: 
? We show how to automatically generate 
the validating patterns for the target relation 
arguments, and how to integrate the results 
produced by the validating patterns into the 
whole relation extraction system. 
? We show how to use corpus statistics and 
term extraction methods to correct the 
boundaries of relation arguments. 
? We experimentally compare the improve-
ment produced by the corpus-based entity 
validation and correction methods with the 
improvements produced by two alternative 
validators ? a CRF-based NER system 
trained on a separate labeled corpus, and a 
small manually-built rule-based NER com-
ponent. 
The rest of the paper is organized as follows:  
Section 2 describes previous work.  Section 3 out-
lines the general design principles of SRES and 
briefly describes its components. Section 4 de-
scribes in detail the different entity validation and 
correction methods, and Section 5 presents their 
601
experimental evaluation. Section 6 contains con-
clusions and directions for future work. 
2 Related Work 
We are not aware of any work that deals specifi-
cally with validation and/or correction of entity 
recognition for the purposes of improving relation 
extraction accuracy. However, the background 
techniques of our methods are relatively simple 
and known. The validation is based on the same 
ideas that underlie semi-supervised entity extrac-
tion (Etzioni, Cafarella et al 2005), and uses a 
simplified SRES code. The boundary correction 
process utilizes well-known term extraction meth-
ods, e.g., (Su, Wu et al 1994). 
We also recently became aware of the work by 
Downey, Broadhead and Etzioni (2007) that deals 
with locating entities of arbitrary types in large 
corpora using corpus statistics. 
The IE systems most similar to SRES are based 
on bootstrap learning: Mutual Bootstrapping 
(Riloff and Jones 1999), the DIPRE system (Brin 
1998), and the Snowball system (Agichtein and 
Gravano 2000). Ravichandran and Hovy 
(Ravichandran and Hovy 2002) also use bootstrap-
ping, and learn simple surface patterns for extract-
ing binary relations from the Web. 
Unlike these systems, SRES surface patterns al-
low gaps that can be matched by any sequences of 
tokens. This makes SRES patterns more general, 
and allows to recognize instances in sentences in-
accessible to the simple surface patterns of systems 
such as (Brin 1998; Riloff and Jones 1999; Ravi-
chandran and Hovy 2002). 
Another direction for unsupervised relation 
learning was taken in (Hasegawa, Sekine et al 
2004; Chen, Ji et al 2005). These systems use a 
NER system to identify frequent pairs of entities 
and then cluster the pairs based on the types of the 
entities and the words appearing between the enti-
ties. The main benefit of this approach is that all 
relations between two entity types can be discov-
ered simultaneously and there is no need for the 
user to supply the relations definitions. 
3 Description of SRES 
The goal of SRES is extracting instances of speci-
fied relations from the Web without human super-
vision. Accordingly, the supervised input to the 
system is limited to the specifications of the target 
relations. A specification for a given relation con-
sists of the relation schema and a small set of seeds 
? known true instances of the relation. In the full-
scale SRES, the seeds are also generated automati-
cally, by using a set of generic patterns instantiated 
with the relation schema. However, the seed gen-
eration is not relevant to this paper. 
A relation schema specifies the name of the rela-
tion, the names and types of its arguments, and the 
arguments ordering. For example, the schema of 
the Acquisition relation 
Acquisition(Buyer=ProperNP, 
                   Acquired=ProperNP)  ordered  
specifies that Acquisition has two slots, named 
Buyer and Acquired, which must be filled with en-
tities of type ProperNP. The order of the slots is 
important (as signified by the word ?ordered?, and 
as opposed to relations like Merger, which are 
?unordered? or, in binary case, ?symmetric?). 
The baseline SRES does not utilize a named en-
tity recognizer, instead using a shallow parser for 
exracting the relation slots. Thus, the only allowed 
entity types are ProperNP, CommonNP, and 
AnyNP, which mean the heads of, respectively, 
proper, common, and arbitrary noun phrases. In the 
experimental section we compare the baseline 
SRES to its extensions containing additional NER 
components. When using those components we 
allow further subtypes of ProperNP, and the rela-
tion schema above becomes 
? (Buyer=Company, Acquired=Company) ? 
The main components of SRES are the Pattern 
Learner, the Instance Extractor, and the Classifier. 
The Pattern Learner uses the seeds to learn likely 
patterns of relation occurrences. Then, the Instance 
Extractor uses the patterns to extract the candidate 
instances from the sentences. Finally, the Classifier 
assigns the confidence score to each extraction. We 
shall now briefly describe these components. 
3.1 Pattern Learner 
The Pattern Learner receives a relation schema 
and a set of seeds. Then it finds the occurences of 
seeds inside a large (unlabeled) text corpus, ana-
lyzes their contexts, and extracts common patterns 
among these contexts. The details of the patterns 
language and the process of pattern learning are 
not significant for this paper, and are described 
fully in (Feldman and Rosenfeld 2006). 
602
3.2 Instance Extractor 
The Instance Extractor applies the patterns gener-
ated by the Pattern Learner to the text corpus. In 
order to be able to match the slots of the patterns, 
the Instance Extractor utilizes an external shallow 
parser from the OpenNLP package 
(http://opennlp.sourceforge.net/), which is able to 
find all proper and common noun phrases in a sen-
tence. These phrases are matched to the slots of the 
patterns. In other respects, the pattern matching 
and extraction process is straightforward. 
3.3 Classifier 
The goal of the final classification stage is to filter 
the list of all extracted instances, keeping the cor-
rect extractions, and removing mistakes that would 
always occur regardless of the quality of the pat-
terns. It is of course impossible to know which ex-
tractions are correct, but there exist properties of 
patterns and pattern matches that increase or de-
crease the confidence in the extractions that they 
produce. 
These properties are turned into a set of binary 
features, which are processed by a linear feature-
rich classifier. The classifier receives a feature vec-
tor for a candidate, and produces a confidence 
score between 0 and 1. 
 The set of features is small and is not specific to 
any particular relation. This allows to train a model 
using a small amount of labeled data for one rela-
tion, and then use the model for scoring the candi-
dates of all other relations. Since the supervised 
training stage needs to be run only once, it is a part 
of the system development, and the complete sys-
tem remains unsupervised, as demonstrated in 
(Feldman and Rosenfeld 2006). 
4 Entity Validation and Correction 
In this paper we describe three different methods 
of validation and correction of relation arguments 
in the extracted instances. Two of them are ?classi-
cal? and are based, respectively, on the knowledge-
engineering, and on the statistical supervised ap-
proaches to the named entity recognition problems. 
The third is our novel approach, based on redun-
dancy and corpus statistics. 
The methods are implemented as components 
for SRES, called Entity Validators, inserted be-
tween the Instance Extractor and the Classifier. 
The result of applying Entity Validator to a candi-
date instance is an (optionally) fixed instance, with 
validity values attached to all slots. There are three 
validity values: valid, invalid, and uncertain. 
The Classifier uses the validity values by con-
verting them into two additional binary features, 
which are then able to influence the confidence of 
extractions. 
We shall now describe the three different valida-
tors in details. 
4.1 Small Rule-based NER validator 
This validator is a small Perl script that checks 
whether a character string conforms to a set of 
simple regular expression patterns, and whether it 
appears inside lists of known named entities. There 
are two sets of regular expression patterns ? for 
Person and for Company entity types, and three 
large lists ? for known personal names, known 
companies, and ?other known named entities?, cur-
rently including locations, universities, and gov-
ernment agencies. 
The manually written regular expression repre-
sent simple regularities in the internal structure of 
the entity types. For example, the patterns for Per-
son include: 
Person = KnownFirstName  [Initial]  LastName 
Person = Honorific [FirstName] [Initial] LastName 
Honorific = (?Mr? | ?Ms? | ?Dr? |?) [?.?] 
Initial = CapitalLetter [?.?] 
KnownFirstName = member of  
                                      KnownPersonalNamesList 
FirstName = CapitalizedWord  
LastName = CapitalizedWord 
LastName = CapitalizedWord [???CapitalizedWord] 
LastName = (?o? | ?de? | ?) ?`?CapitalizedWord 
          ? 
while the patterns for Company include: 
Company = KnownCompanyName 
Company = CompanyName CompanyDesignator 
Company = CompanyName FrequentCompanySfx 
KnownCompanyName = member of 
                                              KnownCompaniesList 
CompanyName = CapitalizedWord + 
CompanyDesignator = ?inc? | ?corp? | ?co? | ? 
FrequentCompanySfx = ?systems? | ?software? | ? 
          ? 
The validator works in the following way: it re-
ceives a sentence with a labeled candidate entity of 
a specified entity type (which can be either Person 
or Company). It then applies all of the regular ex-
pression patterns to the labeled text and to its en-
603
closing context. It also checks for membership in 
the lists of known entities. If a boundary is incor-
rectly placed according to the patterns or to the 
lists, it is fixed. Then, the following result is re-
turned: 
Valid, if some pattern/list of the right entity type 
matched the candidate entity, while there 
were no matches for patterns/lists of other 
entity types. 
Invalid, if no pattern/list of the right entity type 
matched the candidate entity, while there 
were matches for patterns/lists of other entity 
types. 
Uncertain, otherwise, that is either if there were 
no matches at all, or if both correct and in-
correct entity types matched. 
The number of patterns is relatively small, and 
the whole component consists of about 300 lines in 
Perl and costs several person-days of knowledge 
engineering work. Despite its simplicity, we will 
show in the experimental section that it is quite 
effective, and even often outperforms the CRF-
based NER component, described below. 
4.2 CRF-based NER validator 
This validator is built using a feature-rich CRF-
based sequence classifier, trained upon an English 
dataset of the CoNLL 2003 shared task (Rosenfeld, 
Fresko et al 2005). For the gazetteer lists it uses 
the same large lists as the rule-based component 
described above. 
The validator receives a sentence with a labeled 
candidate entity of a specified entity type (which 
can be either Person or Company). It then sends 
the sentence to the CRF-based classifier, which 
labels all named entities it knows ? Dates, Times, 
Percents, Persons, Organizations, and Locations. 
If the CRF classifier places the entity boundaries 
differently, they are fixed. Then, the following re-
sult is returned: 
Valid, if CRF classification of the entity accords 
with the expected argument type. 
Invalid, if CRF classification of the entity is dif-
ferent from the expected argument type. 
Uncertain, otherwise, that is if the CRF classi-
fier didn?t recognize the entity at all. 
4.3 Corpus-based NER validator 
The goal of building the corpus-based NER valida-
tor is to provide the same level of performance as 
the supervised NER components, while requiring 
neither additional human supervision nor addi-
tional labeled corpora or other resources. There are 
several important facts that help achieve this goal. 
First, the relation instances that are used as seeds 
for the pattern learning are known to contain cor-
rect instances of the right entity type. These in-
stances can be used as seeds in their own right, for 
learning the patterns of occurrence of the corre-
sponding entity types. Second, the entities in which 
we are interested usually appear in the corpus with 
a sufficient frequency. The validation is based on 
the first observation, while the boundary fixing on 
the second. 
Corpus-based entity validation 
There is a preparation stage, during which the 
information required for validation is extracted 
from the corpus. This information is the lists of all 
entities of every type that appears in the target rela-
tions. In order to extract these lists we use a simpli-
fied SRES. The entities are considered to be unary 
relations, and the seeds for them are taken from the 
slots of the target binary relations seeds. We don?t 
use the Classifier on the extracted entity instances. 
Instead, for every extracted instance we record the 
number of different sentences the entity was ex-
tracted from. 
During the validation process, the validator?s 
task is to evaluate a given candidate entity in-
stance. The validator compares the number of 
times the instance was extracted (during the prepa-
ration stage) by the patterns for the correct entity 
type, and by the patterns for all other entity types. 
The validator then returns 
Valid, if the number of times the entity was ex-
tracted for the specified entity type is at least 
5, and at least two times bigger than the 
number of times it was extracted for all other 
entity types. 
Invalid, if the number of times the instance was 
extracted for the specified entity type is less 
than 5, and at least 2 times smaller than the 
number of times it was extracted for all other 
entity types. 
604
Uncertain, otherwise, that is if it was never ex-
tracted at all, or extracted with similar fre-
quency for both correct and wrong entity 
types. 
Corpus-based correction of entity boundaries 
Our entity boundaries correction mechanism is 
similar to the known statistical term extraction 
techniques (Su, Wu et al 1994). It is based on the 
assumption that the component words of a term (an 
entity in our case) are more tightly bound to each 
other than to the context. In the statistical sense, 
this fact is expressed by a high mutual information 
between the adjacent words belonging to the same 
term. 
There are two possible boundary fixes: remov-
ing words from the candidate entity, or adding 
words from the context to the entity. There is a 
significant practical difference between the two 
cases. 
Assume that an entity boundary was placed too 
broadly, and included extra words. If this was a 
chance occurrence (and only such cases can be 
found by statistical methods), then the resulting 
sequence of tokens will be very infrequent, while 
its parts will have relatively high frequency. For 
example, consider a sequence ?Formerly Microsoft 
Corp.?, which is produced by mistakenly labeling 
?Formerly? as a proper noun by the PoS tagger. 
While it is easy to know from the frequencies that 
a boundary mistake was made, it is unclear (to the 
system) which part is the correct entity. But since 
the entity (one of the parts of the candidate) has a 
high frequency, there is a chance that the relation 
instance, in which the entity appears, will be re-
peated elsewhere in the corpus and will be ex-
tracted correctly there. Therefore, in such case, the 
simplest recourse is to simply label the entity as 
Invalid, and not to try fixing the boundaries. 
On the other hand, if a word was missed from an 
entity (e.g., ?Beverly O?, instead of ?Beverly O ' 
Neill?), the resulting sequence will be frequent. 
Moreover, it is quite probable that the same 
boundary mistake is made in many places, because 
the same sequence of tokens is being analyzed in 
all those places. Therefore, it makes sense to try to 
fix the bounary in this case, especially since it can 
be done simply and  reliably: a word (or several 
words) is attached to the entity string if both their 
frequencies and their mutual information are above 
a threshold. 
5 Experimental Evaluation 
The experiments described in this paper aim to 
confirm the effectiveness of the proposed corpus-
based relation argument validation and correction 
method, and to compare its performance with the 
classical knowledge-engineering-based and super-
vised-training-based methods. The experiments 
were performed with five relations: 
Acquisition(BuyerCompany, AcquiredCompany), 
Merger(Company1, Company2), 
CEO_Of(Company, Person), 
MayorOf(City, Person), 
InventorOf(Person, Invention). 
The data for the experiments were collected by the 
KnowItAll crawler. The data for the Acquisition 
and Merger consist of about 900,000 sentences for 
each of the two relations. The data for the bound 
relations consist of sentences, such that each con-
tains one of a hundred values of the first (bound) 
attribute. Half of the hundred are frequent entities 
(>100,000 search engine hits), and another half are 
rare (<10,000 hits). 
For evaluating the validators we randomly se-
lected a set of 10000 sentences from the corpora 
for each of the relations, and manually evaluated 
the SRES results generated from these sentences. 
Four sets of results were evaluated: the baseline 
results produced without any NER validator, and 
three sets of results produced using three different 
NER validators. For the InventorOf relation, only 
the corpus-based validator results can be produced, 
since the other two NER components cannot be 
adapted to validate/correct entities of type Inven-
tion. 
The results for the five relations are shown in 
the Figure 1. Several conclusions can be drawn 
from the graphs. First, all of the NER validators 
improve over the baseline SRES, sometimes as 
much as doubling the recall at the same level of 
precision. In most cases the three validators show 
roughly similar levels of performance. A notable 
difference is the CEO_Of relation, where the sim-
ple rule-based component performs much better 
than CRF, which performs yet better than the cor-
pus-based component. The CEO_Of relation is 
tested as bound, which means that only the second 
relation argument, of type Person, is validated. The 
Person entities have much more rigid internal 
structure than the other entities ? Companies and 
Inventions. Consequently, the best performing of 
605
Acquisition
0.50
0.60
0.70
0.80
0.90
1.00
0 50 100 150
Correct Extractions
P
re
c
is
io
n
Baseline RB-NER CRF Corpus
Merger
0.50
0.60
0.70
0.80
0.90
1.00
0 50 100 150
Correct Extractions
P
re
c
is
io
n
Baseline RB-NER CRF Corpus
 
CeoOf
0.50
0.60
0.70
0.80
0.90
1.00
0 20 40 60 80 100 120
Correct Extractions
P
re
c
is
io
n
Baseline RB-NER CRF Corpus
 
InventorOf
0.50
0.60
0.70
0.80
0.90
1.00
0 20 40 60 80 100 120
Correct Extractions
P
re
c
is
io
n
Baseline Corpus
 
 
Figure 1. Comparison between Baseline-SRES and its extensions with three different NER validators:  a 
simple Rule-Based one, a CRF-based statistical one, and a Corpus-based one. 
 
 
the three validators is the rule-based, which di-
rectly tests this internal structure. The CRF-based 
validator is also able to take advantage of the struc-
ture, although in a weaker manner. The Corpus-
based validator, however, works purely on the ba-
sis of context, entirely disregarding the internal 
structure of entities, and thus performs worst of all 
in this case. On the other hand, the Corpus-based 
validator is able to improve the results for the In-
ventor relation, which the other two validators are 
completely unable to do. 
It is also of interest to compare the performance 
of CRF-based and the rule-based NER components 
in other cases. As can be seen, in most cases the 
rule-based component, despite its simplicity, out-
performs the CRF-based one. The possible reason 
for this is that relation extraction setting is signifi-
cantly different from the classical named entity 
recognition setting. A classical NER system is set 
to maximize  the F1 measure of all mentions of all 
entities in the corpus. A relation argument extrac-
tor, on the other hand, should maximize its per-
formance on relation arguments, and apparently 
their statistical properties are often significantly 
different. 
6 Conclusions 
We have presented a novel method for validation 
and correction of relation arguments for the state-
of-the-art unsupervised Web relation extraction 
system SRES. The method is based on corpus sta-
tistics and requires no human supervision and no 
additional corpus resources beyond the corpus that 
is used for relation extraction. 
We showed experimentally the effectiveness of 
our method, which performed comparably to both 
simple rule-based NER and a statistical CRF-based 
NER in the task of validating Companies, and 
somewhat worse in the task of validating Persons, 
606
due to its complete disregard of internal structure 
of entities. The ways to learn and use this structure 
in an unsupervised way are left for future research. 
Our method also successfully validated the 
Invention entities, which are inaccessible to the 
other methods due to the lack of training data. 
In our experiments we made use of a unique fea-
ture of SRES system ? a feature-rich classifier that 
assigns confidence score to the candidate in-
stances, basing its decisions on various features of 
the patterns and of the contexts from which the 
candidates were extracted. This architecture allows 
easy integration of the entity validation compo-
nents as additional feature generators. We believe, 
however, that our results have greater applicability, 
and that the corpus statistics-based components can 
be added to RE systems with other architectures as 
well. 
References 
Agichtein, E. and L. Gravano (2000). Snowball: Ex-
tracting Relations from Large Plain-Text Collections. 
Proceedings of the 5th ACM International Confer-
ence on Digital Libraries (DL). 
Brin, S. (1998). Extracting Patterns and Relations from 
the World Wide Web. WebDB Workshop at 6th In-
ternational Conference on Extending Database Tech-
nology, EDBT?98, Valencia, Spain. 
Chen, J., D. Ji, C. L. Tan and Z. Niu (2005). Unsuper-
vised Feature Selection for Relation Extraction. 
IJCNLP-05, Jeju Island, Korea. 
Downey, D., M. Broadhead and O. Etzioni (2007). Lo-
cating Complex Named Entities in Web Text. IJCAI-
07. 
Etzioni, O., M. Cafarella, D. Downey, A. Popescu, T. 
Shaked, S. Soderland, D. Weld and A. Yates (2005). 
Unsupervised named-entity extraction from the Web: 
An experimental study. Artificial Intelligence 165(1): 
91-134. 
Feldman, R. and B. Rosenfeld (2006). Boosting Unsu-
pervised Relation Extraction by Using NER. 
EMNLP-06, Sydney, Australia. 
Feldman, R. and B. Rosenfeld (2006). Self-Supervised 
Relation Extraction from the Web. ISMIS-2006, Bari, 
Italy. 
Hasegawa, T., S. Sekine and R. Grishman (2004). Dis-
covering Relations among Named Entities from 
Large Corpora. ACL 2004. 
Ravichandran, D. and E. Hovy (2002). Learning Sur-
face Text Patterns for a Question Answering System. 
40th ACL Conference. 
Riloff, E. and R. Jones (1999). Learning Dictionaries 
for Information Extraction by Multi-level Boot-
strapping. AAAI-99. 
Rosenfeld, B., M. Fresko and R. Feldman (2005). A 
Systematic Comparison of Feature-Rich Probabilis-
tic Classifiers for NER Tasks. PKDD. 
Su, K.-Y., M.-W. Wu and J.-S. Chang (1994). A Cor-
pus-based Approach to Automatic Compound Ex-
traction. Meeting of the Association for Computa-
tional Linguistics: 242-247. 
 
 
607
