Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1013?1024,
October 25-29, 2014, Doha, Qatar.
c?2014 Association for Computational Linguistics
Greed is Good if Randomized: New Inference for Dependency Parsing
Yuan Zhang
?
, Tao Lei
?
, Regina Barzilay, and Tommi Jaakkola
Computer Science and Artificial Intelligence Laboratory
Massachusetts Institute of Technology
{yuanzh, taolei, regina, tommi}@csail.mit.edu
Abstract
Dependency parsing with high-order fea-
tures results in a provably hard decoding
problem. A lot of work has gone into
developing powerful optimization meth-
ods for solving these combinatorial prob-
lems. In contrast, we explore, analyze, and
demonstrate that a substantially simpler
randomized greedy inference algorithm al-
ready suffices for near optimal parsing: a)
we analytically quantify the number of lo-
cal optima that the greedy method has to
overcome in the context of first-order pars-
ing; b) we show that, as a decoding algo-
rithm, the greedy method surpasses dual
decomposition in second-order parsing; c)
we empirically demonstrate that our ap-
proach with up to third-order and global
features outperforms the state-of-the-art
dual decomposition and MCMC sampling
methods when evaluated on 14 languages
of non-projective CoNLL datasets.
1
1 Introduction
Dependency parsing is typically guided by param-
eterized scoring functions that involve rich fea-
tures exerting refined control over the choice of
parse trees. As a consequence, finding the high-
est scoring parse tree is a provably hard combina-
torial inference problem (McDonald and Pereira,
2006). Much of the recent work on parsing has
focused on solving these problems using powerful
optimization techniques. In this paper, we follow a
different strategy, arguing that a much simpler in-
ference strategy suffices. In fact, we demonstrate
that a randomized greedy method of inference sur-
passes the state-of-the-art performance in depen-
dency parsing.
?
Both authors contributed equally.
1
Our code is available at https://github.com/
taolei87/RBGParser.
Our choice of a randomized greedy algorithm
for parsing follows from a successful track record
of such methods in other hard combinatorial prob-
lems. These conceptually simple and intuitive
algorithms have delivered competitive approxi-
mations across a broad class of NP-hard prob-
lems ranging from set cover (Hochbaum, 1982) to
MAX-SAT (Resende et al., 1997). Their success
is predicated on the observation that most realiza-
tions of problems are much easier to solve than the
worst-cases. A simpler algorithm will therefore
suffice in typical cases. Evidence is accumulating
that parsing problems may exhibit similar proper-
ties. For instance, methods such as dual decom-
position offer certificates of optimality when the
highest scoring tree is found. Across languages,
dual decomposition has shown to lead to a cer-
tificate of optimality for the vast majority of the
sentences (Koo et al., 2010; Martins et al., 2011).
These remarkable results suggest that, as a com-
binatorial problem, parsing appears simpler than
its broader complexity class would suggest. In-
deed, we show that a simpler inference algorithm
already suffices for superior results.
In this paper, we introduce a randomized greedy
algorithm that can be easily used with any rich
scoring function. Starting with an initial tree
drawn uniformly at random, the algorithm makes
only local myopic changes to the parse tree in an
attempt to climb the objective function. While a
single run of the hill-climbing algorithm may in-
deed get stuck in a locally optimal solution, mul-
tiple random restarts can help to overcome this
problem. The same algorithm is used both for
learning the parameters of the scoring function as
well as for parsing test sentences.
The success of a randomized greedy algorithm
is tied to the number of local maxima in the search
space. When the number is small, only a few
restarts will suffice for the greedy algorithm to
find the highest scoring parse. We provide an al-
1013
gorithm for explicitly counting the number of lo-
cal optima in the context of first-order parsing,
and demonstrate that the number is typically quite
small. Indeed, we find that a first-order parser
trained with exact inference or using our random-
ized greedy algorithm delivers basically the same
performance.
We hypothesize that parsing with high-order
scoring functions exhibits similar properties. The
main rationale is that, even in the presence of high-
order features, the resulting scoring function re-
mains first-order dominant. The performance of
a simple arc-factored first-order parser is only a
few percentage points behind higher-order parsers.
The higher-order features in the scoring function
offer additional refinement but only a few changes
above and beyond the first-order result. As a
consequence, most of the arc choices are already
determined by a much simpler, polynomial time
parser.
We use dual decomposition to show that the
greedy method indeed succeeds as an inference al-
gorithm even with higher-order scoring functions.
In fact, with second-order features, regardless of
which method was used for training, the random-
ized greedy method outperforms dual decomposi-
tion by finding higher scoring trees. For the sen-
tences that dual decomposition is optimal (obtains
a certificate), the greedy method finds the same
solution in over 99% of the cases. Our simple
inference algorithm is therefore likely to scale to
higher-order parsing and we demonstrate empiri-
cally that this is indeed so.
We validate our claim by evaluating the method
on the CoNLL dependency benchmark that com-
prises treebanks from 14 languages. Aver-
aged across all languages, our method out-
performs state-of-the-art parsers, including Tur-
boParser (Martins et al., 2013) and our earlier
sampling-based parser (Zhang et al., 2014). On
seven languages, we report the best published re-
sults. The method is not sensitive to initialization.
In fact, drawing the initial tree uniformly at ran-
dom results in the same performance as when ini-
tialized from a trained first-order distribution. In
contrast, sufficient randomization of the starting
point is critical. Only a small number of restarts
suffices for finding (near) optimal parse trees.
2 Related Work
Finding Optimal Structure in Parsing The use
of rich-scoring functions in dependency parsing
inevitably leads to the challenging combinatorial
problem of finding the maximizing parse. In fact,
McDonald and Pereira (2006) demonstrated that
the task is provably NP-hard for non-projective
second-order parsing. Not surprisingly, approx-
imate inference has been at the center of pars-
ing research. Examples of these approaches in-
clude easy-first parsing (Goldberg and Elhadad,
2010), inexact search (Johansson and Nugues,
2007; Zhang and Clark, 2008; Huang et al., 2012;
Zhang et al., 2013), partial dynamic program-
ming (Huang and Sagae, 2010) and dual decom-
position (Koo et al., 2010; Martins et al., 2011).
Our work is most closely related to the MCMC
sampling-based approaches (Nakagawa, 2007;
Zhang et al., 2014). In our earlier work, we devel-
oped a method that learns to take guided stochas-
tic steps towards a high-scoring parse (Zhang et
al., 2014). In the heart of that technique are so-
phisticated samplers for traversing the space of
trees. In this paper, we demonstrate that a sub-
stantially simpler approach that starts from a tree
drawn from the uniform distribution and uses hill-
climbing for parameter updates achieves similar or
higher performance.
Another related greedy inference method has
been used for non-projective dependency pars-
ing (McDonald and Pereira, 2006). This method
relies on hill-climbing to convert the highest scor-
ing projective tree into its non-projective approxi-
mation. Our experiments demonstrate that when
hill-climbing is employed as a primary learning
mechanism for high-order parsing, it exhibits dif-
ferent properties: the distribution for initialization
does not play a major role in the final outcome,
while the use of restarts contributes significantly
to the quality of the resulting tree.
Greedy Approximations for NP-hard Problems
There is an expansive body of research on greedy
approximations for NP-hard problems. Examples
of NP-hard problems with successful greedy ap-
proximations include the traveling saleman prob-
lem problem (Held and Karp, 1970; Rego et
al., 2011), the MAX-SAT problem (Mitchell et
al., 1992; Resende et al., 1997) and vertex
cover (Hochbaum, 1982). While some greedy
methods have poor worst-case complexity, many
1014
of them work remarkably well in practice. Despite
the apparent simplicity of these algorithms, un-
derstanding their properties is challenging: often
their ?theoretical analyses are negative and incon-
clusive? (Amenta and Ziegler, 1999; Spielman and
Teng, 2001). Identifying conditions under which
approximations are provably optimal is an active
area of research in computer science theory (Du-
mitrescu and T?oth, 2013; Jonsson et al., 2013).
In NLP, randomized and greedy approximations
have been successfully used across multiple ap-
plications, including machine translation and lan-
guage modeling (Brown et al., 1993; Ravi and
Knight, 2010; Daum?e III et al., 2009; Moore and
Quirk, 2008; Deoras et al., 2011). In this paper,
we study the properties of these approximations in
the context of dependency parsing.
3 Method
3.1 Preliminaries
Let x be a sentence and T (x) be the set of possi-
ble dependency trees over the words in x. We use
y ? T (x) to denote a dependency tree for x, and
y(m) to specify the head (parent) of the modifier
word indexed by m in tree y. We also use m to
denote the indexed word when there is no ambi-
guity. In addition, we define T (y,m) as the set
of ?neighboring trees? of y obtained by changing
only the head of the modifier, i.e. y(m).
The dependency trees are scored according to
S(x, y) = ? ? ?(x, y), where ? is a vector of pa-
rameters and ?(x, y) is a sparse feature vector rep-
resentation of tree y for sentence x. In this work,
?(x, y) will include up to third-order features as
well as a range of global features commonly used
in re-ranking methods (Collins, 2000; Charniak
and Johnson, 2005; Huang, 2008).
The parameters ? in the scoring function are
estimated on the basis of a training set D =
{(x?
i
, y?
i
)}
N
i=1
of sentences x?
i
and the correspond-
ing gold (target) trees y?
i
. We adopt a max-margin
framework for this learning problem. Specifically,
we aim to find parameter values that score the gold
target trees higher than others:
?i ? {1, ? ? ? , N}, y ? T (x?
i
),
S(x?
i
, y?
i
) ? S(x?
i
, y) + ?y?
i
? y?
1
? ?
i
where ?
i
? 0 is the slack variable (non-zero values
are penalized against) and ?y?
i
? y?
1
is the ham-
ming distance between the gold tree y?
i
and a can-
didate parse y.
In an online learning setup, parameters are up-
dated successively after each sentence. Each up-
date still requires us to find the ?strongest viola-
tion?, i.e., a candidate tree y? that scores higher
than the gold tree y?
i
:
y? = argmax
y?T (x?
i
)
{S(x?
i
, y) + ?y ? y?
i
?
1
}
The parameters are then revised so as to select
against the offending y?. Instead of a standard
parameter update based on y? as in perceptron,
stochastic gradient descent, or passive-aggressive
updates, our implementation follows Lei et al.
(2014) where the first-order parameters are broken
up into a tensor. Each tensor component is updated
successively in combination with the parameters
corresponding to MST features (McDonald et al.,
2005) and higher-order features (when included).
2
3.2 Algorithm
During training and testing, the key combinatorial
problem we must solve is that of decoding, i.e.,
finding the highest scoring tree y? ? T (x) for each
sentence x (or x?
i
). In our notation,
y? = argmax
y?T (x?
i
)
{? ? ?(x?
i
, y) + ?y ? y?
i
?
1
} (train)
y? = argmax
y?T (x)
{? ? ?(x, y)} (test)
While the decoding problem with feature sets sim-
ilar to ours has been shown to be NP-hard, many
approximation algorithms work remarkably well.
We commence with a motivating example.
Locality and Parsing One possible reason for
why greedy or other approximation algorithms
work well for dependency parsing is that typical
sentences and therefore the learned scoring func-
tions S(x, y) = ? ? ?(x, y) are primarily ?lo-
cal?. By this we mean that head-modifier deci-
sions could be made largely without considering
the surrounding structure (the context). For exam-
ple, in English an adjective and a determiner are
typically attached to the following noun.
We demonstrate the degree of locality in de-
pendency parsing by comparing a first-order tree-
based parser to the parser that predicts each head
word independently of others. Note that the in-
dependent prediction of dependency arcs does not
necessarily give rise to a tree. The parameters of
2
We refer the readers to Lei et al. (2014) for more details
about the tensor scoring function and the online update.
1015
Dataset Indp. Pred Tree Pred
Slovene 83.7 84.2
Arabic 79.0 79.2
Japanese 93.4 93.7
English 91.6 91.9
Average 86.9 87.3
Table 1: Head attachment accuracy of a first-order
local classifier (left) and a first-order structural
prediction model (right). The two types of mod-
els are trained using the same set of features.
Input: parameter ?, sentence x
Output: dependency tree y?
1: Randomly initialize tree y
(0)
;
2: t = 0;
3: repeat
4: list = bottom-up node list of y
(t)
;
5: for each word m in list do
6: y
(t+1)
= argmax
y?T (y
(t)
,m)
S(x, y);
7: t = t+ 1;
8: end for
9: until no change in this iteration
10: return y? = y
(t)
;
Figure 1: A randomized hill-climbing algorithm
for dependency parsing.
the two parsers, the independent prediction and
a tree-based parser, are trained separately with
the corresponding decoding algorithm but with the
same feature set.
Table 1 shows that the accuracy of the inde-
pendent prediction ranges from 79% to 93% on
four CoNLL datasets. The results are on par with
the first-order structured prediction model. This
experiment reinforces the conclusion in Liang et
al. (2008), where a local classifier was shown
to achieve comparable accuracy to a sequential
model (e.g. CRF) in POS tagging and named-
entity recognition.
Hill-Climbing with Random Restarts We
build here on the motivating example and explore
greedy algorithms as generalizations of purely lo-
cal decoding. Greedy algorithms break the decod-
ing problem into a sequence of simple local steps,
each required to improve the solution. In our case,
simple local steps correspond to choosing the head
for each modifier word.
We begin with a tree y
(0)
, which can be a sam-
ple drawn uniformly from T (x) (Wilson, 1996).
Our greedy algorithm then updates y
(t)
to a bet-
ter tree y
(t+1)
by revising the head of one modifier
word while maintaining the constraint that the re-
sulting structure is a tree. The modifiers are con-
sidered in the bottom-up order relative to the cur-
rent tree (the word furthest from the root is consid-
ered first). We provide an analysis to motivate this
bottom-up update strategy in Section 4.1. The al-
gorithm continues until the score can no longer be
improved by changing the head of a single word.
The resulting tree represents a locally optimal pre-
diction relative to a single-arc greedy algorithm.
Figure 1 gives the algorithm in pseudo-code.
There are many possible variations of the sim-
ple randomized greedy hill-climbing algorithm.
First, the Wilson sampling algorithm (Wilson,
1996) can be naturally extended to obtain i.i.d.
samples from any first-order distributions. There-
fore, we could initialize the tree y
(0)
with a tree
from a first-order parser, or draw the initial tree
from a first-order distribution other than uniform.
However, perhaps surprisingly, as we demon-
strate later, little is lost with uniform initializa-
tion. Second, since a single run of randomized
hill-climbing is relatively cheap and runs are in-
dependent to each other, it is easy to execute mul-
tiple runs independently in parallel. The final pre-
dicted tree is then simply the highest scoring tree
across the multiple runs. We demonstrate that only
a small number of parallel runs are necessary for
near optimal prediction.
4 Analysis
4.1 First-Order Parsing
We provide here a firmer basis for why the ran-
domized greedy algorithm can be expected to
work. While the focus of the rest of the paper
is on higher-order parsing, we limit ourselves in
this subsection to first-order parsing. The reasons
for this are threefold. First, a simple greedy algo-
rithm is already not guaranteed a priori to work in
the context of a first-order scoring function. The
conclusions from this analysis are therefore likely
to carry over to higher-order parsing scenarios as
well. Second, a first-order arc-factored scoring
provides us an easy way to ascertain when the ran-
domized greedy algorithm indeed found the high-
est scoring tree. Finally, we are able to count the
1016
Dataset Average Len.
# of local optima at percentile fraction of finding global optima (%)
50% 70% 90% 0 <Len.? 15 Len.> 15
Turkish 12.1 1 1 2 100 100
Slovene 15.9 2 20 3647 100 98.1
English 24.0 21 121 2443 100 99.3
Arabic 36.8 2 35 >10000 100 99.1
Table 2: The left part of the table shows the local optimum statistics of the first-order model. The
sentences are sorted by the number of local optima. Columns 3 to 5 show the number of local optima of
a sentence at different percentile of the sorted list. For example, on English 50% of the sentences have
no more than 21 local optimum trees. The right part shows the fraction of finding global optima using
300 uniform restarts for each sentence.
number of locally optimal solutions for a greedy
algorithm in the context of first-order parsing and
can therefore relate this property to the success
rates of the algorithm.
Reachability We begin by highlighting a basic
property of trees, namely that single arc changes
suffice for transforming any tree to any other tree
in a small number of steps while maintaining that
each intermediate structure is also a tree. In this
sense, a target tree is reachable from any start-
ing point using only single arc changes. More
formally, let y be any starting tree and y
?
the de-
sired target. Let m
1
,m
2
, ? ? ? ,m
n
be the bottom-
up list of words (modifiers) corresponding to tree
y, where m
1
is the word furthest from the root.
We can simply change each head y(m
i
) to that of
y
?
(m
i
) in this order i = 1, . . . , n. The bottom-up
order guarantees that no cycle is introduced with
respect to the remaining (yet unmodified) nodes of
y. The fact that y
?
is a valid tree implies no cycle
will appear with respect to the already modified
nodes.
Note that, according to this property, any tree
is reachable from any starting point using only k
modifications, where k is the number of head dif-
ferences, i.e. k = |{m : y(m) 6= y
?
(m)}|. The
result also suggests that it may be helpful to per-
form the greedy steps in the bottom-up order, a
suggestion that we follow in our implementation.
Broadly speaking, we have established that
the greedy algorithm is not inherently limited by
virtue of its basic steps. Of course, it is a differ-
ent question whether the scoring function supports
such local changes towards the correct target tree.
Locally Optimal Trees While greedy algo-
rithms are notoriously prone to getting stuck in
locally optimal solutions, we establish here that
Function CountOptima(G = ?V,E?)
V = {w
0
, w
1
, ? ? ? , w
n
} where w
0
is the
root
E = {e
ij
? R} are the arc scores
Return: the number of local optima
1: Let y(0) = ? and y(i) = argmax
j
e
ji
;
2: if y is a tree (no cycle) then return 1;
3: Find a cycle C ? V in y;
4: count = 0;
// contract the cycle
5: create a vertex w
?
;
6: ?j /? C : e
?j
= max
k?C
e
kj
;
7: for each vertex w
i
? C do
8: ?j /? C : e
j?
= e
ji
;
9: V
?
= V ? {w
?
} \ C;
10: E
?
= E ? {e
?j
, e
j?
| ?j /? C}
11: count += CountOptima(G
?
= ?V
?
, E
?
?);
12: end for
13: return count;
Figure 2: A recursive algorithm for counting lo-
cal optima for a sentence with words w
1
, ? ? ? , w
n
(first-order parsing). The algorithm resembles the
Chu-Liu-Edmonds algorithm for finding the max-
imum directed spanning tree (Chu and Liu, 1965).
decoding with learned scoring functions involves
only a small number of local optima. In our case,
a local optimum corresponds to a tree y where no
single change of head y(m) results in a higher
scoring tree. Clearly, the highest scoring tree is
also a local optimum in this sense. If there were
many such local optima, finding the one with the
highest score would be challenging for a greedy
algorithm, even with randomization.
We begin with a worst case analysis and estab-
1017
Dataset
Trained with Hill-Climbing (HC) Trained with Dual Decomposition (DD)
%Cert (DD) s
DD
>s
HC
s
DD
=s
HC
s
DD
<s
HC
%Cert (DD) s
DD
>s
HC
s
DD
=s
HC
s
DD
<s
HC
Turkish 98.7 0.0 99.8 0.2 98.7 0.0 100.0 0.0
Slovene 94.5 0.0 98.7 1.3 92.3 0.2 99.0 0.8
English 94.5 0.3 98.7 1.0 94.6 0.5 98.7 0.8
Arabic 78.8 3.4 93.9 2.7 75.3 4.7 88.4 6.9
Table 3: Decoding quality comparison between hill-climbing (HC) and dual decomposition (DD). Mod-
els are trained either with HC (left) or DD (right). s
HC
denotes the score of the tree retrieved by HC
and s
DD
gives the analogous score for DD. The columns show the percentage of all test sentences for
which one method succeeds in finding a higher or the same score. ?Cert? column gives the percentage
of sentences for which DD finds a certificate.
lish a tight upper bound on the number of local
optima for a first-order scoring function.
Theorem 1 For any first-order scoring function
that factorizes into the sum of arc scores S(x, y) =
?
S
arc
(y(m),m): (a) the number of locally op-
timal trees is at most 2
n?1
for n words; (b) this
upper bound is tight.
3
While the number of possible dependency trees
is (n + 1)
n?1
(Cayley?s formula), the number of
local optima is at most 2
n?1
. This is still too many
for longer sentences, suggesting that, in the worst
case, a randomized greedy algorithm is unlikely to
find the highest scoring tree. However, the scor-
ing functions we learn for dependency parsing are
considerably easier.
Average Case Analysis In contrast to the worst-
case analysis above, we will count here the actual
number of local optima per sentence for a first-
order scoring function learned from data with the
randomized greedy algorithm. Figure 2 provides
pseudo-code for our counting algorithm. The al-
gorithm is derived by tailoring the proof of Theo-
rem 1 to each sentence.
Table 2 shows the empirical number of locally
optimal trees estimated by our algorithm across 4
different languages. Decoding with trained scor-
ing functions in the average case is clearly sub-
stantially easier than the worst case. For exam-
ple, on the English test set more than 70% of the
sentences have at most 121 locally optimal trees.
Since the average sentence length is 24, the dis-
crepancy between the typical number (e.g., 121)
and the worst case (2
24?1
) is substantial. As a re-
sult, only a small number of restarts is likely to
suffice for finding optimal trees in practice.
Optimal Decoding We can easily verify
whether the randomized greedy algorithm indeed
3
A proof sketch is given in Appendix.
succeeds in finding the highest scoring trees with
a learned first-order scoring function. We have
established above that there are typically only a
small number of locally optimal trees. We would
therefore expect the algorithm to work. We show
the results in the second part of Table 2. For short
sentences of length up to 15, our method finds the
global optimum for all the test sentences. Success
rates remain high even for longer test sentences.
4.2 Higher-Order Parsing
Exact decoding with high-order features is known
to be provably hard (McDonald et al., 2005). We
begin our analysis here with a second-order (sib-
ling/grandparent) model, and compare our ran-
domized hill-climbing (HC) method to dual de-
composition (DD), re-implementing Koo et al.
(2010). Table 3 compares decoding quality for the
two methods across four languages. Overall, in
97.8% of the sentences, HC obtains the same score
as DD, in 1.3% of the cases HC finds a higher
scoring tree, and in 0.9% of cases DD results in
a better tree. The results follow the same pattern
regardless of which method was used to train the
scoring function. The average rate of certificates
for DD was 92%. In over 99% of these sentences,
HC reaches the same optimum.
We expect that these observations about the suc-
cess of HC carry over to other high-order parsing
models for several reasons. First, a large num-
ber of arcs are pruned in the initial stage, con-
siderably reducing the search space and minimiz-
ing the number of possible locally optimal trees.
Second, many dependencies can be determined
already with independent arc prediction (see our
motivating example above), predictions that are
readily achieved with a greedy algorithm. Finally,
high-order features represent smaller refinements,
i.e., suggest only a few changes above and be-
yond the dominant first-order scores. Greedy al-
1018
gorithms are therefore likely to be able to leverage
at least some of this potential. We demonstrate be-
low that this is indeed so.
Our methods are trained within the max-margin
framework. As a result, we are expected to find
the highest scoring competing tree for each train-
ing sentence (the ?strongest violation?). One may
question therefore whether possible sub-optimal
decoding for some training sentences (finding ?a
violation? rather than the ?strongest violation?)
impacts the learned parser. To this end, Huang et
al. (2012) have established that weaker violations
do suffice for separable training sets.
5 Experimental Setup
Dataset and Evaluation Measures We evalu-
ate our model on CoNLL dependency treebanks
for 14 different languages (Buchholz and Marsi,
2006; Surdeanu et al., 2008), using standard train-
ing and testing splits. We use part-of-speech tags
and the morphological information provided in the
corpus. Following standard practice, we use Unla-
beled Attachment Score (UAS) excluding punctu-
ation (Koo et al., 2010; Martins et al., 2013) as the
evaluation metric in all our experiments.
Baselines We compare our model with the Tur-
boParser (Martins et al., 2013) and our earlier
sampling-based parser (Zhang et al., 2014). For
both parsers, we directly compare with the re-
cent published results on the CoNLL datasets.
We also compare our parser against the best pub-
lished results for the individual languages in our
datasets. This comparison set includes four ad-
ditional parsers: Martins et al. (2011), Koo et al.
(2010), Zhang et al. (2013) and our tensor-based
parser (Lei et al., 2014).
Features We use the same feature templates as
in our prior work (Zhang et al., 2014; Lei et al.,
2014)
4
. Figure 3 shows the first- to third-order
feature templates that we use in our model. For
the global features we use right-branching, coor-
dination, PP attachment, span length, neighbors,
valency and non-projective arcs features.
Implementation Details Following standard
practices, we train our model using the passive-
aggressive online learning algorithm (MIRA)
and parameter averaging (Crammer et al., 2006;
4
We refer the readers to Zhang et al. (2014) and Lei et al.
(2014) for the detailed definition of each feature template.
arc!
head bigram!!h h m m+1h m consecutive sibling!h m s grandparent!g h mgrand-sibling!g h m s
tri-siblings!h m s t grand-grandparent!g h mgg
outer-sibling-grandchild!h m sgc h s gcminner-sibling-grandchild!
Figure 3: First- to third-order features.
Arabic Slovene English Chinese German
?2
?1
0
1
2
3
4
5 Len ? 15Len > 15
Figure 4: Absolute UAS improvement of our full
model over the first-order model. Sentences in the
test set are divided into 2 groups based on their
lengths.
Collins, 2002). By default we use an adaptive
strategy for running the hill-climbing algorithm
? for a given sentence we repeatedly run the al-
gorithm in parallel
5
until the best tree does not
change for K = 300 consecutive restarts. For
each restart, by default we initialize the tree y
(0)
by sampling from the first-order distribution us-
ing the current learned parameter values (and first-
order scores). We train our first-order and third-
order model for 10 epochs and our full model for
20 epochs for all languages, and report the average
performance across three independent runs.
6 Results
Comparison with the Baselines Table 4 sum-
marizes the results of our model, along with the
state-of-the-art baselines. On average across 14
languages, our full model with the tensor com-
ponent outperforms both TurboParser and the
sampling-based parser. The direct comparison
5
We use 8 threads in all the experiments.
1019
Our Model
Exact 1st
Turbo Sampling
Best Published
1st 3rd Full
w/o tensor
Full (MA13) (ZL14)
Arabic 78.98 79.95 79.38 80.24 79.22 79.64 80.12 81.12 (MS11)
Bulgarian 92.15 93.38 93.69 93.72 92.24 93.10 93.30 94.02 (ZH13)
Chinese 91.20 93.00 92.76 93.04 91.17 89.98 92.63 92.68 (LX14)
Czech 87.65 90.11 90.34 90.77 87.82 90.32 91.04 91.04 (ZL14)
Danish 90.50 91.43 91.66 91.86 90.56 91.48 91.80 92.00 (ZH13)
Dutch 84.49 86.43 87.04 87.39 84.79 86.19 86.47 86.47 (ZL14)
English 91.85 93.01 93.20 93.25 91.94 93.22 92.94 93.22 (MA13)
German 90.52 91.91 92.64 92.67 90.54 92.41 92.07 92.41 (MA13)
Japanese 93.78 93.80 93.35 93.56 93.74 93.52 93.42 93.74 (LX14)
Portuguese 91.12 92.07 92.60 92.36 91.16 92.69 92.41 93.03 (KR10)
Slovene 84.29 86.48 87.06 86.72 84.15 86.01 86.82 86.95 (MS11)
Spanish 85.52 87.87 88.17 88.75 85.59 85.59 88.24 88.24 (ZL14)
Swedish 89.89 91.17 91.35 91.08 89.78 91.14 90.71 91.62 (ZH13)
Turkish 76.57 76.80 76.13 76.68 76.40 76.90 77.21 77.55 (KR10)
Average 87.75 89.10 89.24 89.44 87.79 88.72 89.23 89.58
Table 4: Results of our model and several state-of-the-art systems. ?Best Published UAS? includes the
most accurate parsers among Martins et al. (2011), Martins et al. (2013), Koo et al. (2010), Zhang et
al. (2013), Lei et al. (2014) and Zhang et al. (2014). For the third-order model, we use the feature set
of TurboParser (Martins et al., 2013). The full model combines features of our sampling-based parser
(Zhang et al., 2014) and tensor features (Lei et al., 2014).
Dataset
MAP-1st Uniform Rnd-1st
UAS Init. UAS Init. UAS Init.
Slovene 85.2 80.1 86.7 13.7 86.7 34.2
Arabic 78.8 75.1 79.7 12.4 80.2 32.8
English 91.1 82.0 93.3 39.6 93.3 55.6
Chinese 87.2 75.3 93.2 36.8 93.0 54.5
Dutch 84.8 79.5 87.0 26.9 87.4 45.6
Average 85.4 78.4 88.0 25.9 88.1 44.5
Table 5: Comparison between different initializa-
tion strategies: (a) MAP-1st: only the MAP tree
of the first-order score; (b) Uniform: random trees
are sampled from the uniform distribution; and
(c) Rnd-1st: random trees are sampled from the
first-order distribution. For each method, the table
shows the average accuracy of the initial tree and
the final parsing accuracy.
with TurboParser is achieved by restricting our
model to third order features which still outper-
forms TurboParser (89.10% vs 88.72%). To com-
pare against the sampling-based parser, we em-
ploy our model without the tensor component. The
two models achieve a similar average performance
(89.24% and 89.23% respectively). Since relative
parsing performance depends on a target language,
we also include comparison with the best pub-
lished results. The model achieves the best pub-
lished results for seven languages.
Another noteworthy comparison concerns first-
order parsers. As Table 4 shows, the exact and ap-
proximate versions of the first-order parser deliver
almost identical performance.
Impact of High-Order Features Table 4 shows
that the model can effectively utilize high-order
features. Comparing the average performance of
the model variants, we see that the accuracy on
the benchmark languages consistently improves
when higher-order features are added. This char-
acteristic of the randomized greedy parser is in
line with findings about other state-of-the-art high-
order parsers (Martins et al., 2013; Zhang et al.,
2014). Figure 4 breaks down these gains based
on the sentence length. As expected, on most lan-
guages high-order features are particularly helpful
when parsing longer sentences.
Impact of Initialization and Restarts Table 5
shows the impact of initialization on the model
performance for several languages. We consider
three strategies: the MAP estimate of the first-
order score from the model, uniform sampling and
sampling from the first-order distribution. The ac-
curacy of initial trees varies greatly, ranging from
78.4% for the MAP estimate to 25.9% and 44.5%
for the latter randomized strategies. However, the
resulting parsing accuracy is not determined by
the initial accuracy. In fact, the two sampling
strategies result in almost identical parsing perfor-
mance. While the first-order MAP estimate gives
the best initial guess, the overall parsing accuracy
of this method lags behind. This result demon-
strates the importance of restarts ? in contrast to
the randomized strategies, the MAP initialization
performs only a single run of hill-climbing.
1020
Length ? 15 Length > 15
Slovene 100 98.11
English 100 99.12
Table 6: Fractions (%) of the sentences that find
the best solution among 3,000 restarts within the
first 300 restarts.
0 200 400 600 800 1000
0.994
0.996
0.998
1
# Restarts
Scor
e
 
 
len?15len>15
(a) Slovene
0 200 400 600 800 1000
0.994
0.996
0.998
1
# Restarts
Scor
e
 
 
len?15len>15
(b) English
Figure 5: Convergence analysis on Slovene and
English datasets. The graph shows the normalized
score of the output tree as a function of the number
of restarts. The score of each sentence is normal-
ized by the highest score obtained for this sentence
after 3,000 restarts. We only show the curves up to
1,000 restarts because they all reach convergence
after around 500 restarts.
Convergence Properties Figure 5 shows the
score of the trees retrieved by our full model with
respect to the number of restarts, for short and long
sentences in English and Slovene. To facilitate the
comparison, we normalize the score of each sen-
tence by the maximal score obtained for this sen-
tence after 3,000 restarts. Overall, most sentences
converge quickly. This view is also supported by
Table 6 which shows the fraction of the sentences
that converge within the first 300 restarts. We can
see that all the short sentences (length up to 15)
reach convergence within the allocated restarts.
Perhaps surprisingly, more than 98% of the long
sentences also converge within 300 restarts.
Decoding Speed As the number of restarts im-
pacts the parsing accuracy, we can trade perfor-
mance for speed. Figure 6 shows that the model
2 4 6 8 10 12 14x 10?3
82
84
86
88
Sec/Tok
UAS
 
 
3rd?order ModelFull Model
(a) Slovene
2 4 6 8 10x 10?3
88
90
92
94
Sec/Tok
UAS
 
 
3rd?order ModelFull Model
(b) English
Figure 6: Trade-off between performance and
speed on Slovene and English datasets. The graph
shows the accuracy as a function of decoding
speed measured in second per token. Variations in
decoding speed is achieved by changing the num-
ber of restarts.
achieves high performance with acceptable pars-
ing speed. While various system implementation
issues such as programming language and com-
putational platform complicate a direct compari-
son with other parsing systems, our model deliv-
ers parsing time roughly comparable to other state-
of-the-art graph-based systems (for example, Tur-
boParser and MST parser) and the sampling-based
parser.
7 Conclusions
We have shown that a simple, generally appli-
cable randomized greedy algorithm for inference
suffices to deliver state-of-the-art parsing perfor-
mance. We argued that the effectiveness of such
greedy algorithms is contingent on having a small
number of local optima in the scoring function. By
algorithmically counting the number of locally op-
timal solutions in the context of first-order parsing,
we show that this number is indeed quite small.
Moreover, we show that, as a decoding algorithm,
the greedy method surpasses dual decomposition
in second-order parsing. Finally, we empirically
demonstrate that our approach with up to third-
order and global features outperforms the state-of-
the-art parsers when evaluated on 14 languages of
1021
non-projective CoNLL datasets.
Appendix
We provide here a more detailed justification for
the counting algorithm in Figure 2 and, by exten-
sion, a proof sketch of Theorem 1. The bullets
below follow the operation of the algorithm.
? Whenever independent selection of the heads
results in a valid tree, there is only 1 opti-
mum (Lines 1&2 of the algorithm). Other-
wise there must be a cycle C in y (Line 3 of
the algorithm)
? We claim that any locally optimal tree y
?
of
the graph G = (V,E) must contain |C| ? 1
arcs of the cycle C ? V . This can be shown
by contradiction. If y
?
contains less than
|C| ? 1 arcs of C, then (a) we can construct
a tree y
??
that contains |C| ? 1 arcs; (b) the
heads in y
??
are strictly better than those in
y
?
over the unused part of the cycle; (c) by
reachability, there is a path y
?
? y
??
so y
?
cannot be a local optimum.
? Any locally optimal tree in G must select an
arc inC and reassign it. The rest of the |C|?1
arcs will then result in a chain.
? By contracting cycle C we obtain a new
graph G
?
of size |G| ? |C| + 1 (Lines 5-11
of the algorithm). Easy to verify that (not
shown): any local optimum in G
?
is a local
optimum in G and vice versa.
The theorem follows as a corollary of these
steps. To see this, let F (G
m
) be the number of
local optima in the graph of size m:
F (G
m
) ? max
C?V (G)
?
i
F (G
(i)
m?c+1
)
where G
(i)
m?c+1
is the graph (of size m ? c + 1)
created by selecting the i
th
arc in cycleC and con-
tracting G
m
accordingly, and c = |C| is the size
of the cycle. Define
?
F (m) as the upper bound of
F (G
m
) for any graph of size m. By the above
formula, we know that
?
F (m) ? max
2?c<m
?
F (m? c+ 1)? c
By solving for
?
F (m) we get
?
F (m) ? 2
m?2
. Since
m = n+1 for a sentence with n words, the upper-
bound of local optima is 2
n?1
.
To show the tightness, for any n > 0, create
the graph G
n+1
with arc scores e
ij
= e
ji
= i for
any 0 ? i < j ? n. Note that w
n
? w
n?1
?
w
n
forms the circle C of size 2, it can be shown
by induction on n and F (G
n+1
) that F (G
n+1
) =
F (G
n
)? 2 = 2
n?1
.
Acknowledgments
This research is developed in collaboration with
the Arabic Language Technologies (ALT) group
at Qatar Computing Research Institute (QCRI)
within the IYAS project. The authors acknowl-
edge the support of the U.S. Army Research Of-
fice under grant number W911NF-10-1-0533, and
of the DARPA BOLT program. We thank the MIT
NLP group and the ACL reviewers for their com-
ments. Any opinions, findings, conclusions, or
recommendations expressed in this paper are those
of the authors, and do not necessarily reflect the
views of the funding organizations.
References
Nina Amenta and G?unter Ziegler, 1999. Deformed
Products and Maximal Shadows of Polytopes. Con-
temporary Mathematics. American Mathematics So-
ciety.
Peter F. Brown, Vincent J Della Pietra, Stephen A Della
Pietra, and Robert L. Mercer. 1993. The mathemat-
ics of statistical machine translation: Parameter esti-
mation. Computational linguistics, 19(2):263?311.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings of the Tenth Conference on Computa-
tional Natural Language Learning, CoNLL-X ?06.
Association for Computational Linguistics.
Eugene Charniak and Mark Johnson. 2005. Coarse-
to-fine n-best parsing and maxent discriminative
reranking. In Proceedings of the 43rd Annual Meet-
ing on Association for Computational Linguistics,
pages 173?180. Association for Computational Lin-
guistics.
Yoeng-Jin Chu and Tseng-Hong Liu. 1965. On the
shortest arborescence of a directed graph. Scientia
Sinica, 14(10):1396.
Michael Collins. 2000. Discriminative reranking for
natural language parsing. In Proceedings of the
Seventeenth International Conference on Machine
Learning, ICML ?00, pages 175?182.
Michael Collins. 2002. Discriminative training meth-
ods for hidden markov models: Theory and exper-
iments with perceptron algorithms. In Proceedings
of the Conference on Empirical Methods in Natural
1022
Language Processing - Volume 10, EMNLP ?02. As-
sociation for Computational Linguistics.
Koby Crammer, Ofer Dekel, Joseph Keshet, Shai
Shalev-Shwartz, and Yoram Singer. 2006. Online
passive-aggressive algorithms. The Journal of Ma-
chine Learning Research.
Hal Daum?e III, John Langford, and Daniel Marcu.
2009. Search-based structured prediction. Machine
learning, 75(3):297?325.
Anoop Deoras, Tom?a?s Mikolov, and Kenneth Church.
2011. A fast re-scoring strategy to capture long dis-
tance dependencies. In Proceedings of the Confer-
ence on Empirical Methods in Natural Language
Processing (EMNLP), pages 1116?1127. Associa-
tion for Computational Linguistics.
Adrian Dumitrescu and Csaba D T?oth. 2013. The trav-
eling salesman problem for lines, balls and planes.
In SODA, pages 828?843. SIAM.
Yoav Goldberg and Michael Elhadad. 2010. An effi-
cient algorithm for easy-first non-directional depen-
dency parsing. In Human Language Technologies:
The 2010 Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics, pages 742?750. Association for Computa-
tional Linguistics.
Michael Held and Richard M. Karp. 1970. The
traveling-salesman problem and minimum spanning
trees. Operations Research, 18(6):1138?1162.
Dorit S. Hochbaum. 1982. Approximation algo-
rithms for the set covering and vertex cover prob-
lems. SIAM Journal on Computing, 11(3):555?556.
Liang Huang and Kenji Sagae. 2010. Dynamic pro-
gramming for linear-time incremental parsing. In
Proceedings of the 48th Annual Meeting of the Asso-
ciation for Computational Linguistics, pages 1077?
1086. Association for Computational Linguistics.
Liang Huang, Suphan Fayong, and Yang Guo. 2012.
Structured perceptron with inexact search. In Pro-
ceedings of the 2012 Conference of the North Amer-
ican Chapter of the Association for Computational
Linguistics: Human Language Technologies, pages
142?151. Association for Computational Linguis-
tics.
Liang Huang. 2008. Forest reranking: Discriminative
parsing with non-local features. In ACL, pages 586?
594.
Richard Johansson and Pierre Nugues. 2007. Incre-
mental dependency parsing using online learning. In
EMNLP-CoNLL, pages 1134?1138.
Peter Jonsson, Victor Lagerkvist, Gustav Nordh, and
Bruno Zanuttini. 2013. Complexity of sat problems,
clone theory and the exponential time hypothesis. In
SODA, pages 1264?1277. SIAM.
Terry Koo, Alexander M. Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proceedings of the 2010 Conference on
Empirical Methods in Natural Language Process-
ing. Association for Computational Linguistics.
Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proceedings of the
52th Annual Meeting of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics.
Percy Liang, Hal Daum?e III, and Dan Klein. 2008.
Structure compilation: trading structure for features.
In Proceedings of the 25th international conference
on Machine learning, pages 592?599. ACM.
Andr?e F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and M?ario A. T. Figueiredo. 2011. Dual de-
composition with many overlapping components. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing, EMNLP ?11.
Association for Computational Linguistics.
Andr?e F. T. Martins, Miguel B. Almeida, and Noah A.
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proceedings of the
51th Annual Meeting of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics.
Ryan McDonald and Fernando Pereira. 2006. Online
learning of approximate dependency parsing algo-
rithms. In EACL.
Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005. Online large-margin training of de-
pendency parsers. In Proceedings of the 43rd An-
nual Meeting of the Association for Computational
Linguistics (ACL?05).
David Mitchell, Bart Selman, and Hector Levesque.
1992. Hard and easy distributions of sat problems.
In AAAI, volume 92, pages 459?465. Citeseer.
Robert C. Moore and Chris Quirk. 2008. Random
restarts in minimum error rate training for statis-
tical machine translation. In Proceedings of the
22nd International Conference on Computational
Linguistics-Volume 1, pages 585?592. Association
for Computational Linguistics.
Tetsuji Nakagawa. 2007. Multilingual dependency
parsing using global features. In EMNLP-CoNLL,
pages 952?956.
Sujith Ravi and Kevin Knight. 2010. Does giza++
make search errors? Computational Linguistics,
36(3):295?302.
C?esar Rego, Dorabela Gamboa, Fred Glover, and Colin
Osterman. 2011. Traveling salesman problem
heuristics: leading methods, implementations and
latest advances. European Journal of Operational
Research, 211(3):427?441.
1023
Mauricio G. C. Resende, L. S. Pitsoulis, and P. M.
Pardalos. 1997. Approximate solution of weighted
max-sat problems using grasp. Satisfiability prob-
lems, 35:393?405.
Daniel Spielman and Shang-Hua Teng. 2001.
Smoothed analysis of algorithms: Why the simplex
algorithm usually takes polynomial time. In Pro-
ceedings of the thirty-third annual ACM symposium
on Theory of computing, pages 296?305. ACM.
Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu??s M`arquez, and Joakim Nivre. 2008. The
CoNLL-2008 shared task on joint parsing of syn-
tactic and semantic dependencies. In Proceedings
of the Twelfth Conference on Computational Natu-
ral Language Learning, CoNLL ?08. Association for
Computational Linguistics.
David B. Wilson. 1996. Generating random spanning
trees more quickly than the cover time. In Proceed-
ings of the twenty-eighth annual ACM symposium on
Theory of computing, pages 296?303. ACM.
Yue Zhang and Stephen Clark. 2008. A tale of
two parsers: investigating and combining graph-
based and transition-based dependency parsing us-
ing beam-search. In Proceedings of the Conference
on Empirical Methods in Natural Language Pro-
cessing, pages 562?571. Association for Computa-
tional Linguistics.
Hao Zhang, Liang Zhao, Kai Huang, and Ryan Mc-
Donald. 2013. Online learning for inexact hyper-
graph search. In Proceedings of EMNLP.
Yuan Zhang, Tao Lei, Regina Barzilay, Tommi
Jaakkola, and Amir Globerson. 2014. Steps to ex-
cellence: Simple inference with refined scoring of
dependency trees. In Proceedings of the 52th An-
nual Meeting of the Association for Computational
Linguistics. Association for Computational Linguis-
tics.
1024
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 126?135,
Jeju, Republic of Korea, 8-14 July 2012. c?2012 Association for Computational Linguistics
Learning High-Level Planning from Text
S.R.K. Branavan, Nate Kushman, Tao Lei, Regina Barzilay
Computer Science and Artificial Intelligence Laboratory
Massachusetts Institute of Technology
{branavan, nkushman, taolei, regina}@csail.mit.edu
Abstract
Comprehending action preconditions and ef-
fects is an essential step in modeling the dy-
namics of the world. In this paper, we ex-
press the semantics of precondition relations
extracted from text in terms of planning oper-
ations. The challenge of modeling this con-
nection is to ground language at the level of
relations. This type of grounding enables us to
create high-level plans based on language ab-
stractions. Our model jointly learns to predict
precondition relations from text and to per-
form high-level planning guided by those rela-
tions. We implement this idea in the reinforce-
ment learning framework using feedback au-
tomatically obtained from plan execution at-
tempts. When applied to a complex virtual
world and text describing that world, our rela-
tion extraction technique performs on par with
a supervised baseline, yielding an F-measure
of 66% compared to the baseline?s 65%. Ad-
ditionally, we show that a high-level planner
utilizing these extracted relations significantly
outperforms a strong, text unaware baseline
? successfully completing 80% of planning
tasks as compared to 69% for the baseline.1
1 Introduction
Understanding action preconditions and effects is a
basic step in modeling the dynamics of the world.
For example, having seeds is a precondition for
growing wheat. Not surprisingly, preconditions have
been extensively explored in various sub-fields of
AI. However, existing work on action models has
largely focused on tasks and techniques specific to
individual sub-fields with little or no interconnection
between them. In NLP, precondition relations have
been studied in terms of the linguistic mechanisms
1The code, data and experimental setup for this work are
available at http://groups.csail.mit.edu/rbg/code/planning
A pickaxe, which is used to harvest stone, can be
made from wood.
(a)
Low Level Actions for: wood? pickaxe? stone
step 1: move from (0,0) to (2,0)
step 2: chop tree at: (2,0)
step 3: get wood at: (2,0)
step 4: craft plank from wood
step 5: craft stick from plank
step 6: craft pickaxe from plank and stick
? ? ?
step N-1: pickup tool: pickaxe
step N: harvest stone with pickaxe at: (5,5)
(b)
Figure 1: Text description of preconditions and effects
(a), and the low-level actions connecting them (b).
that realize them, while in classical planning, these
relations are viewed as a part of world dynamics.
In this paper, we bring these two parallel views to-
gether, grounding the linguistic realization of these
relations in the semantics of planning operations.
The challenge and opportunity of this fusion
comes from the mismatch between the abstractions
of human language and the granularity of planning
primitives. Consider, for example, text describing a
virtual world such as Minecraft2 and a formal de-
scription of that world using planning primitives.
Due to the mismatch in granularity, even the simple
relations between wood, pickaxe and stone described
in the sentence in Figure 1a results in dozens of low-
level planning actions in the world, as can be seen
in Figure 1b. While the text provides a high-level
description of world dynamics, it does not provide
sufficient details for successful plan execution. On
the other hand, planning with low-level actions does
not suffer from this limitation, but is computation-
ally intractable for even moderately complex tasks.
As a consequence, in many practical domains, plan-
ning algorithms rely on manually-crafted high-level
2http://www.minecraft.net/
126
abstractions to make search tractable (Ghallab et al,
2004; Lekavy? and Na?vrat, 2007).
The central idea of our work is to express the se-
mantics of precondition relations extracted from text
in terms of planning operations. For instance, the
precondition relation between pickaxe and stone de-
scribed in the sentence in Figure 1a indicates that
plans which involve obtaining stone will likely need
to first obtain a pickaxe. The novel challenge of this
view is to model grounding at the level of relations,
in contrast to prior work which focused on object-
level grounding. We build on the intuition that the
validity of precondition relations extracted from text
can be informed by the execution of a low-level
planner.3 This feedback can enable us to learn these
relations without annotations. Moreover, we can use
the learned relations to guide a high level planner
and ultimately improve planning performance.
We implement these ideas in the reinforcement
learning framework, wherein our model jointly
learns to predict precondition relations from text and
to perform high-level planning guided by those rela-
tions. For a given planning task and a set of can-
didate relations, our model repeatedly predicts a se-
quence of subgoals where each subgoal specifies an
attribute of the world that must be made true. It
then asks the low-level planner to find a plan be-
tween each consecutive pair of subgoals in the se-
quence. The observed feedback ? whether the low-
level planner succeeded or failed at each step ? is
utilized to update the policy for both text analysis
and high-level planning.
We evaluate our algorithm in the Minecraft virtual
world, using a large collection of user-generated on-
line documents as our source of textual information.
Our results demonstrate the strength of our relation
extraction technique ? while using planning feed-
back as its only source of supervision, it achieves
a precondition relation extraction accuracy on par
with that of a supervised SVM baseline. Specifi-
cally, it yields an F-score of 66% compared to the
65% of the baseline. In addition, we show that
these extracted relations can be used to improve the
performance of a high-level planner. As baselines
3If a planner can find a plan to successfully obtain stone
after obtaining a pickaxe, then a pickaxe is likely a precondition
for stone. Conversely, if a planner obtains stone without first
obtaining a pickaxe, then it is likely not a precondition.
for this evaluation, we employ the Metric-FF plan-
ner (Hoffmann and Nebel, 2001),4 as well as a text-
unaware variant of our model. Our results show that
our text-driven high-level planner significantly out-
performs all baselines in terms of completed plan-
ning tasks ? it successfully solves 80% as compared
to 41% for the Metric-FF planner and 69% for the
text unaware variant of our model. In fact, the per-
formance of our method approaches that of an ora-
cle planner which uses manually-annotated precon-
ditions.
2 Related Work
Extracting Event Semantics from Text The task
of extracting preconditions and effects has previ-
ously been addressed in the context of lexical se-
mantics (Sil et al, 2010; Sil and Yates, 2011).
These approaches combine large-scale distributional
techniques with supervised learning to identify de-
sired semantic relations in text. Such combined ap-
proaches have also been shown to be effective for
identifying other relationships between events, such
as causality (Girju and Moldovan, 2002; Chang and
Choi, 2006; Blanco et al, 2008; Beamer and Girju,
2009; Do et al, 2011).
Similar to these methods, our algorithm capital-
izes on surface linguistic cues to learn preconditions
from text. However, our only source of supervision
is the feedback provided by the planning task which
utilizes the predictions. Additionally, we not only
identify these relations in text, but also show they
are valuable in performing an external task.
Learning Semantics via Language Grounding
Our work fits into the broad area of grounded lan-
guage acquisition, where the goal is to learn linguis-
tic analysis from a situated context (Oates, 2001;
Siskind, 2001; Yu and Ballard, 2004; Fleischman
and Roy, 2005; Mooney, 2008a; Mooney, 2008b;
Branavan et al, 2009; Liang et al, 2009; Vogel
and Jurafsky, 2010). Within this line of work, we
are most closely related to the reinforcement learn-
ing approaches that learn language by interacting
with an external environment (Branavan et al, 2009;
Branavan et al, 2010; Vogel and Jurafsky, 2010;
Branavan et al, 2011).
4The state-of-the-art baseline used in the 2008 International
Planning Competition. http://ipc.informatik.uni-freiburg.de/
127
Text (input):
A pickaxe, which is used to harvest stone, 
can be made from wood.
Precondition Relations:
pickaxe stonewood pickaxe
Plan Subgoal Sequence:
initial
state
stone
(goal)
wood
(subgoal 1)
pickaxe
(subgoal 2)
Figure 2: A high-level plan showing two subgoals in
a precondition relation. The corresponding sentence is
shown above.
The key distinction of our work is the use of
grounding to learn abstract pragmatic relations, i.e.
to learn linguistic patterns that describe relationships
between objects in the world. This supplements pre-
vious work which grounds words to objects in the
world (Branavan et al, 2009; Vogel and Jurafsky,
2010). Another important difference of our setup
is the way the textual information is utilized in the
situated context. Instead of getting step-by-step in-
structions from the text, our model uses text that de-
scribes general knowledge about the domain struc-
ture. From this text, it extracts relations between
objects in the world which hold independently of
any given task. Task-specific solutions are then con-
structed by a planner that relies on these relations to
perform effective high-level planning.
Hierarchical Planning It is widely accepted that
high-level plans that factorize a planning prob-
lem can greatly reduce the corresponding search
space (Newell et al, 1959; Bacchus and Yang,
1994). Previous work in planning has studied
the theoretical properties of valid abstractions and
proposed a number of techniques for generating
them (Jonsson and Barto, 2005; Wolfe and Barto,
2005; Mehta et al, 2008; Barry et al, 2011). In gen-
eral, these techniques use static analysis of the low-
level domain to induce effective high-level abstrac-
tions. In contrast, our focus is on learning the ab-
straction from natural language. Thus our technique
is complementary to past work, and can benefit from
human knowledge about the domain structure.
3 Problem Formulation
Our task is two-fold. First, given a text document
describing an environment, we wish to extract a set
of precondition/effect relations implied by the text.
Second, we wish to use these induced relations to
determine an action sequence for completing a given
task in the environment.
We formalize our task as illustrated in Figure 2.
As input, we are given a world defined by the tuple
?S,A, T ?, where S is the set of possible world states,
A is the set of possible actions and T is a determin-
istic state transition function. Executing action a in
state s causes a transition to a new state s? according
to T (s? | s, a). States are represented using proposi-
tional logic predicates xi ? X , where each state is
simply a set of such predicates, i.e. s ? X .
The objective of the text analysis part of our task
is to automatically extract a set of valid precondi-
tion/effect relationships from a given document d.
Given our definition of the world state, precondi-
tions and effects are merely single term predicates,
xi, in this world state. We assume that we are given
a seed mapping between a predicate xi, and the
word types in the document that reference it (see
Table 3 for examples). Thus, for each predicate
pair ?xk, xl?, we want to utilize the text to predict
whether xk is a precondition for xl; i.e., xk ? xl.
For example, from the text in Figure 2, we want to
predict that possessing a pickaxe is a precondition
for possessing stone. Note that this relation implies
the reverse as well, i.e. xl can be interpreted as the
effect of an action sequence performed on state xk.
Each planning goal g ? G is defined by a starting
state sg0, and a final goal state s
g
f . This goal state is
represented by a set of predicates which need to be
made true. In the planning part of our task our objec-
tive is to find a sequence of actions ~a that connect sg0
to sgf . Finally, we assume document d does not con-
tain step-by-step instructions for any individual task,
but instead describes general facts about the given
world that are useful for a wide variety of tasks.
4 Model
The key idea behind our model is to leverage textual
descriptions of preconditions and effects to guide the
construction of high level plans. We define a high-
level plan as a sequence of subgoals, where each
128
subgoal is represented by a single-term predicate,
xi, that needs to be set in the corresponding world
state ? e.g. have(wheat)=true. Thus the set of
possible subgoals is defined by the set of all possi-
ble single-term predicates in the domain. In contrast
to low-level plans, the transition between these sub-
goals can involve multiple low-level actions. Our al-
gorithm for textually informed high-level planning
operates in four steps:
1. Use text to predict the preconditions of each
subgoal. These predictions are for the entire
domain and are not goal specific.
2. Given a planning goal and the induced pre-
conditions, predict a subgoal sequence that
achieves the given goal.
3. Execute the predicted sequence by giving each
pair of consecutive subgoals to a low-level
planner. This planner, treated as a black-box,
computes the low-level plan actions necessary
to transition from one subgoal to the next.
4. Update the model parameters, using the low-
level planner?s success or failure as the source
of supervision.
We formally define these steps below.
Modeling Precondition Relations Given a docu-
ment d, and a set of subgoal pairs ?xi, xj?, we want
to predict whether subgoal xi is a precondition for
xj . We assume that precondition relations are gener-
ally described within single sentences. We first use
our seed grounding in a preprocessing step where
we extract all predicate pairs where both predicates
are mentioned in the same sentence. We call this set
the Candidate Relations. Note that this set will con-
tain many invalid relations since co-occurrence in a
sentence does not necessarily imply a valid precon-
dition relation.5 Thus for each sentence, ~wk, asso-
ciated with a given Candidate Relation, xi ? xj ,
our task is to predict whether the sentence indicates
the relation. We model this decision via a log linear
distribution as follows:
p(xi ? xj | ~wk, qk; ?c) ? e
?c??c(xi,xj , ~wk,qk), (1)
where ?c is the vector of model parameters. We
compute the feature function ?c using the seed
5In our dataset only 11% of Candidate Relations are valid.
Input: A document d, Set of planning tasks G,
Set of candidate precondition relations Call,
Reward function r(), Number of iterations T
Initialization:Model parameters ?x = 0 and ?c = 0.
for i = 1 ? ? ?T do
Sample valid preconditions:
C ? ?
foreach ?xi, xj? ? Call do
foreach Sentence ~wk containing xi and xj do
v ? p(xi ? xj | ~wk, qk; ?c)
if v = 1 then C = C ? ?xi, xj?
end
end
Predict subgoal sequences for each task g.
foreach g ? G do
Sample subgoal sequence ~x as follows:
for t = 1 ? ? ?n do
Sample next subgoal:
xt ? p(x | xt?1, s
g
0, s
g
f , C; ?x)
Construct low-level subtask from xt?1 to xt
Execute low-level planner on subtask
end
Update subgoal prediction model using Eqn. 2
end
Update text precondition model using Eqn. 3
end
Algorithm 1: A policy gradient algorithm for pa-
rameter estimation in our model.
grounding, the sentence ~wk, and a given dependency
parse qk of the sentence. Given these per-sentence
decisions, we predict the set of all valid precondi-
tion relations, C, in a deterministic fashion. We do
this by considering a precondition xi ? xj as valid
if it is predicted to be valid by at least one sentence.
Modeling Subgoal Sequences Given a planning
goal g, defined by initial and final goal states sg0 and
sgf , our task is to predict a sequence of subgoals ~x
which will achieve the goal. We condition this de-
cision on our predicted set of valid preconditions C,
by modeling the distribution over sequences ~x as:
p(~x | sg0, s
g
f , C; ?x) =
n?
t=1
p(xt | xt?1, s
g
0, s
g
f , C; ?x),
p(xt | xt?1, s
g
0, s
g
f , C; ?x) ? e
?x??x(xt,xt?1,s
g
0,s
g
f ,C).
Here we assume that subgoal sequences are Marko-
vian in nature and model individual subgoal predic-
tions using a log-linear model. Note that in con-
129
trast to Equation 1 where the predictions are goal-
agnostic, these predictions are goal-specific. As be-
fore, ?x is the vector of model parameters, and ?x is
the feature function. Additionally, we assume a spe-
cial stop symbol, x?, which indicates the end of the
subgoal sequence.
Parameter Update Parameter updates in our model
are done via reinforcement learning. Specifically,
once the model has predicted a subgoal sequence for
a given goal, the sequence is given to the low-level
planner for execution. The success or failure of this
execution is used to compute the reward signal r for
parameter estimation. This predict-execute-update
cycle is repeated until convergence. We assume that
our reward signal r strongly correlates with the cor-
rectness of model predictions. Therefore, during
learning, we need to find the model parameters that
maximize expected future reward (Sutton and Barto,
1998). We perform this maximization via stochastic
gradient ascent, using the standard policy gradient
algorithm (Williams, 1992; Sutton et al, 2000).
We perform two separate policy gradient updates,
one for each model component. The objective of the
text component of our model is purely to predict the
validity of preconditions. Therefore, subgoal pairs
?xk, xl?, where xl is reachable from xk, are given
positive reward. The corresponding parameter up-
date, with learning rate ?c, takes the following form:
??c ? ?c r
[
?c(xi, xj , ~wk, qk) ?
Ep(xi??xj? |?)
[
?c(xi? , xj? , ~wk, qk)
]
]
. (2)
The objective of the planning component of our
model is to predict subgoal sequences that success-
fully achieve the given planning goals. Thus we di-
rectly use plan-success as a binary reward signal,
which is applied to each subgoal decision in a se-
quence. This results in the following update:
??x ? ?x r
?
t
[
?x(xt, xt?1, s
g
0, s
g
f , C) ?
Ep(x?t|?)
[
?x(x
?
t, xt?1, s
g
0, s
g
f , C)
] ]
, (3)
where t indexes into the subgoal sequence and ?x is
the learning rate.
fish
iron
shears bucket
milkstringseeds wool
iron doorbone meal
fishing rod
wood
plank
stick
fence
Figure 3: Example of the precondition dependencies
present in the Minecraft domain.
Domain #Objects #Pred Types #Actions
Parking 49 5 4
Floortile 61 10 7
Barman 40 15 12
Minecraft 108 16 68
Table 1: A comparison of complexity between Minecraft
and some domains used in the IPC-2011 sequential satis-
ficing track. In the Minecraft domain, the number of ob-
jects, predicate types, and actions is significantly larger.
5 Applying the Model
We apply our method to Minecraft, a grid-based vir-
tual world. Each grid location represents a tile of ei-
ther land or water and may also contain resources.
Users can freely move around the world, harvest
resources and craft various tools and objects from
these resources. The dynamics of the world require
certain resources or tools as prerequisites for per-
forming a given action, as can be seen in Figure 3.
For example, a user must first craft a bucket before
they can collect milk.
Defining the Domain In order to execute a tradi-
tional planner on the Minecraft domain, we define
the domain using the Planning Domain Definition
Language (PDDL) (Fox and Long, 2003). This is the
standard task definition language used in the Inter-
national Planning Competitions (IPC).6 We define
as predicates all aspects of the game state ? for ex-
ample, the location of resources in the world, the re-
sources and objects possessed by the player, and the
player?s location. Our subgoals xi and our task goals
sgf map directly to these predicates. This results in
a domain with significantly greater complexity than
those solvable by traditional low-level planners. Ta-
ble 1 compares the complexity of our domain with
some typical planning domains used in the IPC.
6http://ipc.icaps-conference.org/
130
Low-level Planner As our low-level planner we
employ Metric-FF (Hoffmann and Nebel, 2001),
the state-of-the-art baseline used in the 2008 In-
ternational Planning Competition. Metric-FF is a
forward-chaining heuristic state space planner. Its
main heuristic is to simplify the task by ignoring op-
erator delete lists. The number of actions in the so-
lution for this simplified task is then used as the goal
distance estimate for various search strategies.
Features The two components of our model lever-
age different types of information, and as a result,
they each use distinct sets of features. The text com-
ponent features ?c are computed over sentences and
their dependency parses. The Stanford parser (de
Marneffe et al, 2006) was used to generate the de-
pendency parse information for each sentence. Ex-
amples of these features appear in Table 2. The se-
quence prediction component takes as input both the
preconditions induced by the text component as well
as the planning state and the previous subgoal. Thus
?x contains features which check whether two sub-
goals are connected via an induced precondition re-
lation, in addition to features which are simply the
Cartesian product of domain predicates.
6 Experimental Setup
Datasets As the text description of our virtual world,
we use documents from the Minecraft Wiki,7 the
most popular information source about the game.
Our manually constructed seed grounding of pred-
icates contains 74 entries, examples of which can be
seen in Table 3. We use this seed grounding to iden-
tify a set of 242 sentences that reference predicates
in the Minecraft domain. This results in a set of
694 Candidate Relations. We also manually anno-
tated the relations expressed in the text, identifying
94 of the Candidate Relations as valid. Our corpus
contains 979 unique word types and is composed of
sentences with an average length of 20 words.
We test our system on a set of 98 problems that
involve collecting resources and constructing ob-
jects in the Minecraft domain ? for example, fish-
ing, cooking and making furniture. To assess the
complexity of these tasks, we manually constructed
high-level plans for these goals and solved them us-
ing the Metric-FF planner. On average, the execu-
7http://www.minecraftwiki.net/wiki/Minecraft Wiki/
Words
Dependency Types
Dependency Type ? Direction
Word ? Dependency Type
Word ? Dependency Type ? Direction
Table 2: Example text features. A subgoal pair ?xi, xj?
is first mapped to word tokens using a small grounding
table. Words and dependencies are extracted along paths
between mapped target words. These are combined with
path directions to generate the text features.
Domain Predicate Noun Phrases
have(plank) wooden plank, wood plank
have(stone) stone, cobblestone
have(iron) iron ingot
Table 3: Examples in our seed grounding table. Each
predicate is mapped to one or more noun phrases that de-
scribe it in the text.
tion of the sequence of low-level plans takes 35 ac-
tions, with 3 actions for the shortest plan and 123
actions for the longest. The average branching fac-
tor is 9.7, leading to an average search space of more
than 1034 possible action sequences. For evaluation
purposes we manually identify a set of Gold Rela-
tions consisting of all precondition relations that are
valid in this domain, including those not discussed
in the text.
Evaluation Metrics We use our manual annotations
to evaluate the type-level accuracy of relation extrac-
tion. To evaluate our high-level planner, we use the
standard measure adopted by the IPC. This evalu-
ation measure simply assesses whether the planner
completes a task within a predefined time.
Baselines To evaluate the performance of our rela-
tion extraction, we compare against an SVM classi-
fier8 trained on the Gold Relations. We test the SVM
baseline in a leave-one-out fashion.
To evaluate the performance of our text-aware
high-level planner, we compare against five base-
lines. The first two baselines ? FF and No Text ?
do not use any textual information. The FF base-
line directly runs the Metric-FF planner on the given
task, while the No Text baseline is a variant of our
model that learns to plan in the reinforcement learn-
ing framework. It uses the same state-level features
8SVMlight (Joachims, 1999) with default parameters.
131
?Seeds  for growing  wheat  can be obtained by breaking  tall grass (false negative)
Sticks  are the only building material required to craft a  fence  or  ladder.
Figure 4: Examples of precondition relations predicted by our model from text. Check marks (3) indicate correct
predictions, while a cross (8) marks the incorrect one ? in this case, a valid relation that was predicted as invalid by
our model. Note that each pair of highlighted noun phrases in a sentence is a Candidate Relation, and pairs that are
not connected by an arrow were correctly predicted to be invalid by our model.
200100 15050
Figure 5: The performance of our model and a supervised
SVM baseline on the precondition prediction task. Also
shown is the F-Score of the full set of Candidate Rela-
tions which is used unmodified by All Text, and is given as
input to our model. Our model?s F-score, averaged over
200 trials, is shown with respect to learning iterations.
as our model, but does not have access to text.
The All Text baseline has access to the full set of
694 Candidate Relations. During learning, our full
model refines this set of relations, while in contrast
the All Text baseline always uses the full set.
The two remaining baselines constitute the upper
bound on the performance of our model. The first,
Manual Text, is a variant of our model which directly
uses the links derived from manual annotations of
preconditions in text. The second, Gold, has access
to the Gold Relations. Note that the connections
available to Manual Text are a subset of the Gold
links, because the text does not specify all relations.
Experimental Details All experimental results are
averaged over 200 independent runs for both our
model as well as the baselines. Each of these tri-
als is run for 200 learning iterations with a max-
imum subgoal sequence length of 10. To find a
low-level plan between each consecutive pair of sub-
goals, our high-level planner internally uses Metric-
FF. We give Metric-FF a one-minute timeout to find
such a low-level plan. To ensure that the comparison
Method %Plans
FF 40.8
No text 69.4
All text 75.5
Full model 80.2
Manual text 84.7
Gold connection 87.1
Table 4: Percentage of tasks solved successfully by our
model and the baselines. All performance differences be-
tween methods are statistically significant at p ? .01.
between the high-level planners and the FF baseline
is fair, the FF baseline is allowed a runtime of 2,000
minutes. This is an upper bound on the time that our
high-level planner can take over the 200 learning it-
erations, with subgoal sequences of length at most
10 and a one minute timeout. Lastly, during learning
we initialize all parameters to zero, use a fixed learn-
ing rate of 0.0001, and encourage our model to ex-
plore the state space by using the standard -greedy
exploration strategy (Sutton and Barto, 1998).
7 Results
Relation Extraction Figure 5 shows the perfor-
mance of our method on identifying preconditions
in text. We also show the performance of the super-
vised SVM baseline. As can be seen, after 200 learn-
ing iterations, our model achieves an F-Measure of
66%, equal to the supervised baseline. These results
support our hypothesis that planning feedback is a
powerful source of supervision for analyzing a given
text corpus. Figure 4 shows some examples of sen-
tences and the corresponding extracted relations.
Planning Performance As shown in Table 4 our
text-enriched planning model outperforms the text-
free baselines by more than 10%. Moreover, the
performance improvement of our model over the All
Text baseline demonstrates that the accuracy of the
132
0% 20% 40% 60% 80% 100%
No text
All text
Full model
Manual text
Gold
Easy
Hard
71%
64%
59%
48%
31% 88%
89%
91%
94%
95%
Figure 6: Percentage of problems solved by various mod-
els on Easy and Hard problem sets.
extracted text relations does indeed impact planning
performance. A similar conclusion can be reached
by comparing the performance of our model and the
Manual Text baseline.
The difference in performance of 2.35% between
Manual Text and Gold shows the importance of the
precondition information that is missing from the
text. Note that Gold itself does not complete all
tasks ? this is largely because the Markov assump-
tion made by our model does not hold for all tasks.9
Figure 6 breaks down the results based on the dif-
ficulty of the corresponding planning task. We mea-
sure problem complexity in terms of the low-level
steps needed to implement a manually constructed
high-level plan. Based on this measure, we divide
the problems into two sets. As can be seen, all of
the high-level planners solve almost all of the easy
problems. However, performance varies greatly on
the more challenging tasks, directly correlating with
planner sophistication. On these tasks our model
outperforms the No Text baseline by 28% and the
All Text baseline by 11%.
Feature Analysis Figure 7 shows the top five pos-
itive features for our model and the SVM baseline.
Both models picked up on the words that indicate
precondition relations in this domain. For instance,
the word use often occurs in sentences that describe
the resources required to make an object, such as
?bricks are items used to craft brick blocks?. In ad-
dition to lexical features, dependency information is
also given high weight by both learners. An example
9When a given task has two non-trivial preconditions, our
model will choose to satisfy one of the two first, and the Markov
assumption blinds it to the remaining precondition, preventing
it from determining that it must still satisfy the other.
path has word "craft"
path has dependency type "partmod"
path has word "equals"
path has word "use"
path has dependency type "xsubj"
path has word "use"
path has word "fill"
path has dependency type "dobj"
path has dependency type "xsubj"
path has word "craft"
Figure 7: The top five positive features on words and
dependency types learned by our model (above) and by
SVM (below) for precondition prediction.
of this is a feature that checks for the direct object
dependency type. This analysis is consistent with
prior work on event semantics which shows lexico-
syntactic features are effective cues for learning text
relations (Blanco et al, 2008; Beamer and Girju,
2009; Do et al, 2011).
8 Conclusions
In this paper, we presented a novel technique for in-
ducing precondition relations from text by ground-
ing them in the semantics of planning operations.
While using planning feedback as its only source
of supervision, our method for relation extraction
achieves a performance on par with that of a su-
pervised baseline. Furthermore, relation grounding
provides a new view on classical planning problems
which enables us to create high-level plans based on
language abstractions. We show that building high-
level plans in this manner significantly outperforms
traditional techniques in terms of task completion.
Acknowledgments
The authors acknowledge the support of the
NSF (CAREER grant IIS-0448168, grant IIS-
0835652), the DARPA Machine Reading Program
(FA8750-09-C-0172, PO#4910018860), and Batelle
(PO#300662). Thanks to Amir Globerson, Tommi
Jaakkola, Leslie Kaelbling, George Konidaris, Dy-
lan Hadfield-Menell, Stefanie Tellex, the MIT NLP
group, and the ACL reviewers for their suggestions
and comments. Any opinions, findings, conclu-
sions, or recommendations expressed in this paper
are those of the authors, and do not necessarily re-
flect the views of the funding organizations.
133
References
Fahiem Bacchus and Qiang Yang. 1994. Downward
refinement and the efficiency of hierarchical problem
solving. Artificial Intell., 71(1):43?100.
Jennifer L. Barry, Leslie Pack Kaelbling, and Toms
Lozano-Prez. 2011. DetH*: Approximate hierarchi-
cal solution of large markov decision processes. In
IJCAI?11, pages 1928?1935.
Brandon Beamer and Roxana Girju. 2009. Using a bi-
gram event model to predict causal potential. In Pro-
ceedings of CICLing, pages 430?441.
Eduardo Blanco, Nuria Castell, and Dan Moldovan.
2008. Causal relation extraction. In Proceedings of
the LREC?08.
S.R.K Branavan, Harr Chen, Luke Zettlemoyer, and
Regina Barzilay. 2009. Reinforcement learning for
mapping instructions to actions. In Proceedings of
ACL, pages 82?90.
S.R.K Branavan, Luke Zettlemoyer, and Regina Barzilay.
2010. Reading between the lines: Learning to map
high-level instructions to commands. In Proceedings
of ACL, pages 1268?1277.
S. R. K. Branavan, David Silver, and Regina Barzilay.
2011. Learning to win by reading manuals in a monte-
carlo framework. In Proceedings of ACL, pages 268?
277.
Du-Seong Chang and Key-Sun Choi. 2006. Incremen-
tal cue phrase learning and bootstrapping method for
causality extraction using cue phrase and word pair
probabilities. Inf. Process. Manage., 42(3):662?678.
Marie-Catherine de Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed
dependency parses from phrase structure parses. In
LREC 2006.
Q. Do, Y. Chan, and D. Roth. 2011. Minimally super-
vised event causality identification. In EMNLP, 7.
Michael Fleischman and Deb Roy. 2005. Intentional
context in situated natural language learning. In Pro-
ceedings of CoNLL, pages 104?111.
Maria Fox and Derek Long. 2003. Pddl2.1: An ex-
tension to pddl for expressing temporal planning do-
mains. Journal of Artificial Intelligence Research,
20:2003.
Malik Ghallab, Dana S. Nau, and Paolo Traverso. 2004.
Automated Planning: theory and practice. Morgan
Kaufmann.
Roxana Girju and Dan I. Moldovan. 2002. Text mining
for causal relations. In Proceedigns of FLAIRS, pages
360?364.
Jo?rg Hoffmann and Bernhard Nebel. 2001. The FF plan-
ning system: Fast plan generation through heuristic
search. JAIR, 14:253?302.
Thorsten Joachims. 1999. Advances in kernel meth-
ods. chapter Making large-scale support vector ma-
chine learning practical, pages 169?184. MIT Press.
Anders Jonsson and Andrew Barto. 2005. A causal
approach to hierarchical decomposition of factored
mdps. In Advances in Neural Information Processing
Systems, 13:10541060, page 22. Press.
Maria?n Lekavy? and Pavol Na?vrat. 2007. Expressivity
of strips-like and htn-like planning. Lecture Notes in
Artificial Intelligence, 4496:121?130.
Percy Liang, Michael I. Jordan, and Dan Klein. 2009.
Learning semantic correspondences with less supervi-
sion. In Proceedings of ACL, pages 91?99.
Neville Mehta, Soumya Ray, Prasad Tadepalli, and
Thomas Dietterich. 2008. Automatic discovery and
transfer of maxq hierarchies. In Proceedings of the
25th international conference on Machine learning,
ICML ?08, pages 648?655.
Raymond J. Mooney. 2008a. Learning language from its
perceptual context. In Proceedings of ECML/PKDD.
Raymond J. Mooney. 2008b. Learning to connect lan-
guage and perception. In Proceedings of AAAI, pages
1598?1601.
A. Newell, J.C. Shaw, and H.A. Simon. 1959. The pro-
cesses of creative thinking. Paper P-1320. Rand Cor-
poration.
James Timothy Oates. 2001. Grounding knowledge
in sensors: Unsupervised learning for language and
planning. Ph.D. thesis, University of Massachusetts
Amherst.
Avirup Sil and Alexander Yates. 2011. Extract-
ing STRIPS representations of actions and events.
In Recent Advances in Natural Language Learning
(RANLP).
Avirup Sil, Fei Huang, and Alexander Yates. 2010. Ex-
tracting action and event semantics from web text. In
AAAI 2010 Fall Symposium on Commonsense Knowl-
edge (CSK).
Jeffrey Mark Siskind. 2001. Grounding the lexical se-
mantics of verbs in visual perception using force dy-
namics and event logic. Journal of Artificial Intelli-
gence Research, 15:31?90.
Richard S. Sutton and Andrew G. Barto. 1998. Rein-
forcement Learning: An Introduction. The MIT Press.
Richard S. Sutton, David McAllester, Satinder Singh, and
Yishay Mansour. 2000. Policy gradient methods for
reinforcement learning with function approximation.
In Advances in NIPS, pages 1057?1063.
Adam Vogel and Daniel Jurafsky. 2010. Learning to
follow navigational directions. In Proceedings of the
ACL, pages 806?814.
Ronald J Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforcement
learning. Machine Learning, 8.
134
Alicia P. Wolfe and Andrew G. Barto. 2005. Identify-
ing useful subgoals in reinforcement learning by local
graph partitioning. In In Proceedings of the Twenty-
Second International Conference on Machine Learn-
ing, pages 816?823.
Chen Yu and Dana H. Ballard. 2004. On the integration
of grounding language and learning objects. In Pro-
ceedings of AAAI, pages 488?493.
135
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 1294?1303,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
From Natural Language Specifications to Program Input Parsers
Tao Lei, Fan Long, Regina Barzilay, and Martin Rinard
Computer Science and Artificial Intelligence Laboratory
Massachusetts Institute of Technology
{taolei, fanl, regina, rinard}@csail.mit.edu
Abstract
We present a method for automatically
generating input parsers from English
specifications of input file formats. We
use a Bayesian generative model to cap-
ture relevant natural language phenomena
and translate the English specification into
a specification tree, which is then trans-
lated into a C++ input parser. We model
the problem as a joint dependency pars-
ing and semantic role labeling task. Our
method is based on two sources of infor-
mation: (1) the correlation between the
text and the specification tree and (2) noisy
supervision as determined by the success
of the generated C++ parser in reading in-
put examples. Our results show that our
approach achieves 80.0% F-Score accu-
racy compared to an F-Score of 66.7%
produced by a state-of-the-art semantic
parser on a dataset of input format speci-
fications from the ACM International Col-
legiate Programming Contest (which were
written in English for humans with no in-
tention of providing support for automated
processing).1
1 Introduction
The general problem of translating natural lan-
guage specifications into executable code has been
around since the field of computer science was
founded. Early attempts to solve this problem
produced what were essentially verbose, clumsy,
and ultimately unsuccessful versions of standard
formal programming languages. In recent years
1The code, data, and experimental setup for this research
are available at http://groups.csail.mit.edu/rbg/code/nl2p
the input
a single integer T test cases
an integer N the next N lines
N characters
The input contains a single integer T that indicates the number of test cases. Then follow the T cases. Each test case begins with a line contains an integer N, representing the size of wall. The next N lines represent the original wall. Each line contains N characters. The j-th character of the i-th line figures out the color ...
(a) Text Specification:
(b) Specification Tree:
(c) Two Program Input Examples:
110YYWYYWWWWWYWWWYWWWWWYYWYYWWWWW...WWWWWWWWWW
21Y5YWYWW...WWYYY
Figure 1: An example of (a) one natural language
specification describing program input data; (b)
the corresponding specification tree representing
the program input structure; and (c) two input ex-
amples
however, researchers have had success address-
ing specific aspects of this problem. Recent ad-
vances in this area include the successful transla-
tion of natural language commands into database
queries (Wong and Mooney, 2007; Zettlemoyer
and Collins, 2009; Poon and Domingos, 2009;
Liang et al, 2011) and the successful mapping of
natural language instructions into Windows com-
mand sequences (Branavan et al, 2009; Branavan
et al, 2010).
In this paper we explore a different aspect of
this general problem: the translation of natural
language input specifications into executable code
that correctly parses the input data and generates
1294
data structures for holding the data. The need
to automate this task arises because input format
specifications are almost always described in natu-
ral languages, with these specifications then man-
ually translated by a programmer into the code
for reading the program inputs. Our method
highlights potential to automate this translation,
thereby eliminating the manual software develop-
ment overhead.
Consider the text specification in Figure 1a.
If the desired parser is implemented in C++, it
should create a C++ class whose instance objects
hold the different fields of the input. For exam-
ple, one of the fields of this class is an integer, i.e.,
?a single integer T? identified in the text specifi-
cation in Figure 1a. Instead of directly generating
code from the text specification, we first translate
the specification into a specification tree (see Fig-
ure 1b), then map this tree into parser code (see
Figure 2). We focus on the translation from the
text specification to the specification tree.2
We assume that each text specification is ac-
companied by a set of input examples that the de-
sired input parser is required to successfully read.
In standard software development contexts, such
input examples are usually available and are used
to test the correctness of the input parser. Note that
this source of supervision is noisy ? the generated
parser may still be incorrect even when it success-
fully reads all of the input examples. Specifically,
the parser may interpret the input examples differ-
ently from the text specification. For example, the
program input in Figure 1c can be interpreted sim-
ply as a list of strings. The parser may also fail
to parse some correctly formatted input files not in
the set of input examples. Therefore, our goal is to
design a technique that can effectively learn from
this weak supervision.
We model our problem as a joint depen-
dency parsing and role labeling task, assuming
a Bayesian generative process. The distribution
over the space of specification trees is informed
by two sources of information: (1) the correla-
tion between the text and the corresponding spec-
ification tree and (2) the success of the generated
parser in reading input examples. Our method uses
a joint probability distribution to take both of these
sources of information into account, and uses a
sampling framework for the inference of specifi-
2During the second step of the process, the specification
tree is deterministically translated into code.
1 struct TestCaseType {
2 int N;
3 vector<NLinesType*> lstLines;
4 InputType* pParentLink;
5 }
6
7 struct InputType {
8 int T;
9 vector<TestCaseType*> lstTestCase;
10 }
11
12 TestCaseType* ReadTestCase(FILE * pStream,
13 InputType* pParentLink) {
14 TestCaseType* pTestCase
15 = new TestCaseType;
16 pTestCase?pParentLink = pParentLink;
17
18 ...
19
20 return pTestCase;
21 }
22
23 InputType* ReadInput(FILE * pStream) {
24 InputType* pInput = new InputType;
25
26 pInput?T = ReadInteger(pStream);
27 for (int i = 0; i < pInput?T; ++i) {
28 TestCaseType* pTestCase
29 = new TestCaseType;
30 pTestCase = ReadTestCase (pStream,
31 pInput);
32 pInput?lstTestCase.push back (pTestCase);
33 }
34
35 return pInput;
36 }
Figure 2: Input parser code for reading input files
specified in Figure 1.
cation trees given text specifications. A specifica-
tion tree is rejected in the sampling framework if
the corresponding code fails to successfully read
all of the input examples. The sampling frame-
work also rejects the tree if the text/specification
tree pair has low probability.
We evaluate our method on a dataset of in-
put specifications from ACM International Colle-
giate Programming Contests, along with the cor-
responding input examples. These specifications
were written for human programmers with no in-
tention of providing support for automated pro-
cessing. However, when trained using the noisy
supervision, our method achieves substantially
more accurate translations than a state-of-the-art
semantic parser (Clarke et al, 2010) (specifically,
80.0% in F-Score compared to an F-Score of
66.7%). The strength of our model in the face of
such weak supervision is also highlighted by the
fact that it retains an F-Score of 77% even when
only one input example is provided for each input
1295
Your program is supposed to read the input from the standard input and write its output to the standard output.The first line of the input contains one integer N. N lines follow, the i-th of them contains two real numbers Xi, Yi separated by a single space - the coordinates of the i-th house. Each of the following lines contains four real numbers separated by a single space. These numbers are the coordinates of two different points (X1, Y1) and (X2, Y2), lying on the highway. 
(a)
Text Specification: the input
one integer N N lines the following lines
Specification Tree:
(b)
two real numbers Xi, Yi four real numbers
(c)
Input  :=  N           Lines [size = N]           FollowingLines [size = *]N      :=  intLines  :=  Xi YiXi     :=  floatYi     :=  float
Formal Input Grammar Definition:
FollowingLines  :=  F1 F2 F3 F4F1     :=  float
Figure 3: An example of generating input parser code from text: (a) a natural language input specifica-
tion; (b) a specification tree representing the input format structure (we omit the background phrases in
this tree in order to give a clear view of the input format structure); and (c) formal definition of the input
format constructed from the specification tree, represented as a context-free grammar in Backus-Naur
Form with additional size constraints.
specification.
2 Related Work
Learning Meaning Representation from Text
Mapping sentences into structural meaning rep-
resentations is an active and extensively studied
task in NLP. Examples of meaning representations
considered in prior research include logical forms
based on database query (Tang and Mooney, 2000;
Zettlemoyer and Collins, 2005; Kate and Mooney,
2007; Wong and Mooney, 2007; Poon and Domin-
gos, 2009; Liang et al, 2011; Goldwasser et al,
2011), semantic frames (Das et al, 2010; Das
and Smith, 2011) and database records (Chen and
Mooney, 2008; Liang et al, 2009).
Learning Semantics from Feedback Our ap-
proach is related to recent research on learn-
ing from indirect supervision. Examples include
leveraging feedback available via responses from
a virtual world (Branavan et al, 2009) or from ex-
ecuting predicted database queries (Chang et al,
2010; Clarke et al, 2010). While Branavan et
al. (2009) formalize the task as a sequence of de-
cisions and learns from local rewards in a Rein-
forcement Learning framework, our model learns
to predict the whole structure at a time. Another
difference is the way our model incorporates the
noisy feedback. While previous approaches rely
on the feedback to train a discriminative prediction
model, our approach models a generative process
to guide structure predictions when the feedback
is noisy or unavailable.
NLP in Software Engineering Researchers
have recently developed a number of approaches
that apply natural language processing techniques
to software engineering problems. Examples in-
clude analyzing API documents to infer API li-
brary specifications (Zhong et al, 2009; Pandita
et al, 2012) and analyzing code comments to de-
tect concurrency bugs (Tan et al, 2007; Tan et al,
2011). This research analyzes natural language in
documentation or comments to better understand
existing application programs. Our mechanism, in
contrast, automatically generates parser programs
from natural language input format descriptions.
3 Problem Formulation
The task of translating text specifications to input
parsers consists of two steps, as shown in Figure 3.
First, given a text specification describing an input
format, we wish to infer a parse tree (which we
call a specification tree) implied by the text. Sec-
ond, we convert each specification tree into for-
mal grammar of the input format (represented in
Backus-Naur Form) and then generate code that
reads the input into data structures. In this paper,
we focus on the NLP techniques used in the first
step, i.e., learning to infer the specification trees
from text. The second step is achieved using a de-
terministic rule-based tool. 3
As input, we are given a set of text specifica-
tions w = {w1, ? ? ? , wN}, where each wi is a text
specification represented as a sequence of noun
phrases {wik}. We use UIUC shallow parser to
preprocess each text specificaton into a sequence
of the noun phrases.4 In addition, we are given a
set of input examples for each wi. We use these
examples to test the generated input parsers to re-
3Specifically, the specification tree is first translated into
the grammar using a set of rules and seed words that identi-
fies basic data types such as int. Our implementation then
generates a top-down parser since the generated grammar is
simple. In general, standard techniques such as Bison and
Yacc (Johnson, 1979) can generate bottom-up parsers given
such grammar.
4http://cogcomp.cs.illinois.edu/demo/shallowparse/?id=7
1296
ject incorrect predictions made by our probabilis-
tic model.
We formalize the learning problem as a de-
pendency parsing and role labeling problem.
Our model predicts specification trees t =
{t1, ? ? ? , tN} for the text specifications, where
each specification tree ti is a dependency tree over
noun phrases {wik}. In general many program in-
put formats are nested tree structures, in which the
tree root denotes the entire chunk of program in-
put data and each chunk (tree node) can be further
divided into sub-chunks or primitive fields that ap-
pear in the program input (see Figure 3). There-
fore our objective is to predict a dependency tree
that correctly represents the structure of the pro-
gram input.
In addition, the role labeling problem is to as-
sign a tag zik to each noun phrase wik in a specifi-
cation tree, indicating whether the phrase is a key
phrase or a background phrase. Key phrases are
named entities that identify input fields or input
chunks appear in the program input data, such as
?the input? or ?the following lines? in Figure 3b.
In contrast, background phrases do not define in-
put fields or chunks. These phrases are used to or-
ganize the document (e.g., ?your program?) or to
refer to key phrases described before (e.g., ?each
line?).
4 Model
We use two kinds of information to bias our
model: (1) the quality of the generated code as
measured by its ability to read the given input ex-
amples and (2) the features over the observed text
wi and the hidden specification tree ti (this is stan-
dard in traditional parsing problems). We combine
these two kinds of information into a Bayesian
generative model in which the code quality of the
specification tree is captured by the prior probabil-
ity P (t) and the feature observations are encoded
in the likelihood probability P (w|t). The infer-
ence jointly optimizes these two factors:
P (t|w) ? P (t) ? P (w|t).
Modeling the Generative Process. We assume
the generative model operates by first generating
the model parameters from a set of Dirichlet dis-
tributions. The model then generates text spec-
ification trees. Finally, it generates natural lan-
guage feature observations conditioned on the hid-
den specification trees.
The generative process is described formally as
follows:
? Generating Model Parameters: For every
pair of feature type f and phrase tag z, draw
a multinomial distribution parameter ?zf from
a Dirichlet prior P (?zf ). The multinomial pa-
rameters provide the probabilities of observ-
ing different feature values in the text.
? Generating Specification Tree: For each
text specification, draw a specification tree t
from all possible trees over the sequence of
noun phrases in this specification. We denote
the probability of choosing a particular spec-
ification tree t as P (t).
Intuitively, this distribution should assign
high probability to good specification trees
that can produce C++ code that reads all input
examples without errors, we therefore define
P (t) as follows:5
P (t) = 1Z ?
?
???
???
1 the input parser of tree t
reads all input examples
without error
 otherwise
whereZ is a normalization factor and  is em-
pirically set to 10?6. In other words, P (?)
treats all specification trees that pass the input
example test as equally probable candidates
and inhibits the model from generating trees
which fail the test. Note that we do not know
this distribution a priori until the specification
trees are evaluated by testing the correspond-
ing C++ code. Because it is intractable to test
all possible trees and all possible generated
code for a text specification, we never explic-
itly compute the normalization factor 1/Z of
this distribution. We therefore use sampling
methods to tackle this problem during infer-
ence.
? Generating Features: The final step gener-
ates lexical and contextual features for each
tree. For each phrase wk associated with tag
zk, let wp be its parent phrase in the tree and
ws be the non-background sibling phrase to
its left in the tree. The model generates the
corresponding set of features ?(wp, ws, wk)
for each text phrase tuple (wp, ws, wk), with
5When input examples are not available, P (t) is just uni-
form distribution.
1297
probability P (?(wp, ws, wk)). We assume
that each feature fj is generated indepen-
dently:
P (w|t) = P (?(wp, ws, wk))
=
?
fj??(wp,ws,wk)
?zkfj
where ?zkfj is the j-th component in the multi-
nomial distribution ?zkf denoting the proba-bility of observing a feature fj associated
with noun phrase wk labeled with tag zk. We
define a range of features that capture the cor-
respondence between the input format and its
description in natural language. For example,
at the unigram level we aim to capture that
noun phrases containing specific words such
as ?cases? and ?lines? may be key phrases
(correspond to data chunks appear in the in-
put), and that verbs such as ?contain? may
indicate that the next noun phrase is a key
phrase.
The full joint probability of a set w of N spec-
ifications and hidden text specification trees t is
defined as:
P (?, t,w) = P (?)
N?
i=1
P (ti)P (wi|ti, ?)
= P (?)
N?
i=1
P (ti)
?
k
P (?(wip, wis, wik)).
Learning the Model During inference, we want
to estimate the hidden specification trees t given
the observed natural language specifications w, af-
ter integrating the model parameters out, i.e.
t ? P (t|w) =
?
?
P (t, ?|w)d?.
We use Gibbs sampling to sample variables t from
this distribution. In general, the Gibbs sampling
algorithm randomly initializes the variables and
then iteratively solves one subproblem at a time.
The subproblem is to sample only one variable
conditioned on the current values of all other vari-
ables. In our case, we sample one hidden spec-
ification tree ti while holding all other trees t?i
fixed:
ti ? P (ti|w, t?i) (1)
where t?i = (t1, ? ? ? , ti?1, ti+1, ? ? ? , tN ).
However directly solving the subproblem (1)
in our case is still hard, we therefore use a
Metropolis-Hastings sampler that is similarly ap-
plied in traditional sentence parsing problems.
Specifically, the Hastings sampler approximates
(1) by first drawing a new ti? from a tractable pro-
posal distribution Q instead of P (ti|w, t?i). We
choose Q to be:
Q(ti?|??, wi) ? P (wi|ti?, ??). (2)
Then the probability of accepting the new sample
is determined using the typical Metropolis Hast-
ings process. Specifically, ti? will be accepted to
replace the last ti with probability:
R(ti, ti?) = min
{
1, P (t
i?|w, t?i) Q(ti|??, wi)
P (ti|w, t?i) Q(ti?|??, wi)
}
= min
{
1, P (t
i?, t?i,w)P (wi|ti, ??)
P (ti, t?i,w)P (wi|ti?, ??)
}
,
in which the normalization factors 1/Z are can-
celled out. We choose ?? to be the parameter ex-
pectation based on the current observations, i.e.
?? = E
[
?|w, t?i
], so that the proposal distribu-
tion is close to the true distribution. This sampling
algorithm with a changing proposal distribution
has been shown to work well in practice (John-
son and Griffiths, 2007; Cohn et al, 2010; Naseem
and Barzilay, 2011). The algorithm pseudo code is
shown in Algorithm 1.
To sample from the proposal distribution (2) ef-
ficiently, we implement a dynamic programming
algorithm which calculates marginal probabilities
of all subtrees. The algorithm works similarly to
the inside algorithm (Baker, 1979), except that we
do not assume the tree is binary. We therefore per-
form one additional dynamic programming step
that sums over all possible segmentations of each
span. Once the algorithm obtains the marginal
probabilities of all subtrees, a specification tree
can be drawn recursively in a top-down manner.
Calculating P (t,w) in R(t, t?) requires inte-
grating the parameters ? out. This has a closed
form due to the Dirichlet-multinomial conjugacy:
P (t,w) = P (t) ?
?
?
P (w|t, ?)P (?)d?
? P (t) ?
?
Beta (count(f) + ?) .
Here ? are the Dirichlet hyper parameters and
count(f) are the feature counts observed in data
(t,w). The closed form is a product of the Beta
functions of each feature type.
1298
Feature Type Description Feature Value
Word each word in noun phrase wk lines, VAR
Verb verbs in noun phrase wk and the verb phrase before wk contains
Distance sentence distance between wk and its parent phrase wp 1
Coreference wk share duplicate nouns or variable names with wp or ws True
Table 1: Example of feature types and values. To deal with sparsity, we map variable names such as ?N?
and ?X? into a category word ?VAR? in word features.
Input: Set of text specification documents
w = {w1, ? ? ? , wN},
Number of iterations T
Randomly initialize specification trees1
t = {t1, ? ? ? , tN}
for iter = 1 ? ? ?T do2
Sample tree ti for i-th document:3
for i = 1 ? ? ?N do4
Estimate model parameters:5
?? = E
[
??|w, t?i
]
6
Sample a new specification tree from distribution7
Q:
t? ? Q(t?|??, wi)8
Generate and test code, and return feedback:9
f ? = CodeGenerator(wi, t?)10
Calculate accept probability r:11
r = R(ti, t?)12
Accept the new tree with probability r:13
With probability r : ti = t?14
end15
end16
Produce final structures:17
return { ti if ti gets positive feedback }18
Algorithm 1: The sampling framework for learn-
ing the model.
Model Implementation: We define several
types of features to capture the correlation be-
tween the hidden structure and its expression in
natural language. For example, verb features are
introduced because certain preceding verbs such
as ?contains? and ?consists? are good indicators of
key phrases. There are 991 unique features in total
in our experiments. Examples of features appear
in Table 1.
We use a small set of 8 seed words to bias the
search space. Specifically, we require each leaf
key phrase to contain at least one seed word that
identifies the C++ primitive data type (such as ?in-
teger?, ?float?, ?byte? and ?string?).
We also encourage a phrase containing the word
?input? to be the root of the tree (for example, ?the
input file?) and each coreference phrase to be a
Total # of words 7330
Total # of noun phrases 1829
Vocabulary size 781
Avg. # of words per sentence 17.29
Avg. # of noun phrase per document 17.26
Avg. # of possible trees per document 52K
Median # of possible trees per document 79
Min # of possible trees per document 1
Max # of possible trees per document 2M
Table 2: Statistics for 106 ICPC specifications.
background phrase (for example, ?each test case?
after mentioning ?test cases?), by initially adding
pseudo counts to Dirichlet priors.
5 Experimental Setup
Datasets: Our dataset consists of problem de-
scriptions from ACM International Collegiate Pro-
gramming Contests.6 We collected 106 problems
from ACM-ICPC training websites.7 From each
problem description, we extracted the portion that
provides input specifications. Because the test
input examples are not publicly available on the
ACM-ICPC training websites, for each specifica-
tion, we wrote simple programs to generate 100
random input examples.
Table 2 presents statistics for the text specifica-
tion set. The data set consists of 424 sentences,
where an average sentence contains 17.3 words.
The data set contains 781 unique words. The
length of each text specification varies from a sin-
gle sentence to eight sentences. The difference be-
tween the average and median number of trees is
large. This is because half of the specifications are
relatively simple and have a small number of pos-
sible trees, while a few difficult specifications have
over thousands of possible trees (as the number of
trees grows exponentially when the text length in-
creases).
Evaluation Metrics: We evaluate the model
6Official Website: http://cm.baylor.edu/welcome.icpc
7PKU Online Judge: http://poj.org/; UVA Online Judge:
http://uva.onlinejudge.org/
1299
performance in terms of its success in generating a
formal grammar that correctly represents the input
format (see Figure 3c). As a gold annotation, we
construct formal grammars for all text specifica-
tions. Our results are generated by automatically
comparing the machine-generated grammars with
their golden counterparts. If the formal grammar
is correct, then the generated C++ parser will cor-
rectly read the input file into corresponding C++
data structures.
We use Recall and Precision as evaluation mea-
sures:
Recall = # correct structures# text specifications
Precision = # correct structures# produced structures
where the produced structures are the positive
structures returned by our framework whose corre-
sponding code successfully reads all input exam-
ples (see Algorithm 1 line 18). Note the number of
produced structures may be less than the number
of text specifications, because structures that fail
the input test are not returned.
Baselines: To evaluate the performance of our
model, we compare against four baselines.
The No Learning baseline is a variant of our
model that selects a specification tree without
learning feature correspondence. It continues
sampling a specification tree for each text speci-
fication until it finds one which successfully reads
all of the input examples.
The second baseline Aggressive is a state-of-
the-art semantic parsing framework (Clarke et al,
2010).8 The framework repeatedly predicts hidden
structures (specification trees in our case) using a
structure learner, and trains the structure learner
based on the execution feedback of its predictions.
Specifically, at each iteration the structure learner
predicts the most plausible specification tree for
each text document:
ti = argmaxt f(wi, t).
Depending on whether the corresponding code
reads all input examples successfully or not, the
(wi, ti) pairs are added as an positive or negative
sample to populate a training set. After each it-
eration the structure learner is re-trained with the
training samples to improve the prediction accu-
racy. In our experiment, we follow (Clarke et al,
8We take the name Aggressive from this paper.
Model Recall Precision F-Score
No Learning 52.0 57.2 54.5
Aggressive 63.2 70.5 66.7
Full Model 72.5 89.3 80.0
Full Model (Oracle) 72.5 100.0 84.1
Aggressive (Oracle) 80.2 100.0 89.0
Table 3: Average % Recall and % Precision of our
model and all baselines over 20 independent runs.
2010) and choose a structural Support Vector Ma-
chine SVMstruct 9 as the structure learner.
The remaining baselines provide an upper
bound on the performance of our model. The base-
line Full Model (Oracle) is the same as our full
model except that the feedback comes from an or-
acle which tells whether the specification tree is
correct or not. We use this oracle information in
the prior P (t) same as we use the noisy feedback.
Similarly the baseline Aggressive (Oracle) is the
Aggressive baseline with access to the oracle.
Experimental Details: Because no human an-
notation is required for learning, we train our
model and all baselines on all 106 ICPC text spec-
ifications (similar to unsupervised learning). We
report results averaged over 20 independent runs.
For each of these runs, the model and all baselines
run 100 iterations. For baseline Aggressive, in
each iteration the SVM structure learner predicts
one tree with the highest score for each text spec-
ification. If two different specification trees of the
same text specification get positive feedback, we
take the one generated in later iteration for evalu-
ation.
6 Experimental Results
Comparison with Baselines Table 3 presents
the performance of various models in predicting
correct specification trees. As can be seen, our
model achieves an F-Score of 80%. Our model
therefore significantly outperforms the No Learn-
ing baseline (by more than 25%). Note that the
No Learning baseline achieves a low Precision
of 57.2%. This low precision reflects the noisi-
ness of the weak supervision - nearly one half of
the parsers produced by No Learning are actually
incorrect even though they read all of the input
examples without error. This comparison shows
the importance of capturing correlations between
the specification trees and their text descriptions.
9www.cs.cornell.edu/people/tj/svm light/svm struct.html
1300
(a)
The next N lines of the input file contain the Cartesian coordinates of watchtowers, one pair of coordinates per line.(b)
The input contains several testcases.Each is specified by two strings S, T of alphanumeric ASCII characters 
Figure 4: Examples of dependencies and key phrases predicted by our model. Green marks correct key
phrases and dependencies and red marks incorrect ones. The missing key phrases are marked in gray.
%supervision
Figure 5: Precision and Recall of our model by
varying the percentage of weak supervision. The
green lines are the performance of Aggressive
baseline trained with full weak supervision.
Because our model learns correlations via feature
representations, it produces substantially more ac-
curate translations.
While both the Full Model and Aggressive base-
line use the same source of feedback, they capi-
talize on it in a different way. The baseline uses
the noisy feedback to train features capturing the
correlation between trees and text. Our model, in
contrast, combines these two sources of informa-
tion in a complementary fashion. This combina-
tion allows our model to filter false positive feed-
back and produce 13% more correct translations
than the Aggressive baseline.
Clean versus Noisy Supervision To assess the
impact of noise on model accuracy, we compare
the Full Model against the Full Model (Oracle).
The two versions achieve very close performance
(80% v.s 84% in F-Score), even though Full Model
is trained with noisy feedback. This demonstrates
the strength of our model in learning from such
weak supervision. Interestingly, Aggressive (Ora-
cle) outperforms our oracle model by a 5% mar-
gin. This result shows that when the supervision
is reliable, the generative assumption limits our
model?s ability to gain the same performance im-
provement as discriminative models.
#input examples
Figure 6: Precision and Recall of our model by
varying the number of available input examples
per text specification.
Impact of Input Examples Our model can also
be trained in a fully unsupervised or a semi-
supervised fashion. In real cases, it may not be
possible to obtain input examples for all text spec-
ifications. We evaluate such cases by varying the
amount of supervision, i.e. how many text specifi-
cations are paired with input examples. In each
run, we randomly select text specifications and
only these selected specifications have access to
input examples. Figure 5 gives the performance of
our model with 0% supervision (totally unsuper-
vised) to 100% supervision (our full model). With
much less supervision, our model is still able to
achieve performance comparable with the Aggres-
sive baseline.
We also evaluate how the number of provided
input examples influences the performance of the
model. Figure 6 indicates that the performance is
largely insensitive to the number of input exam-
ples ? once the model is given even one input
example, its performance is close to the best per-
formance it obtains with 100 input examples. We
attribute this phenomenon to the fact that if the
generated code is incorrect, it is unlikely to suc-
cessfully parse any input.
Case Study Finally, we consider some text spec-
ifications that our model does not correctly trans-
1301
late. In Figure 4a, the program input is interpreted
as a list of character strings, while the correct in-
terpretation is that the input is a list of string pairs.
Note that both interpretations produce C++ input
parsers that successfully read all of the input ex-
amples. One possible way to resolve this problem
is to add other features such as syntactic depen-
dencies between words to capture more language
phenomena. In Figure 4b, the missing key phrase
is not identified because our model is not able to
ground the meaning of ?pair of coordinates? to two
integers. Possible future extensions to our model
include using lexicon learning methods for map-
ping words to C++ primitive types for example
?coordinates? to ?int, int?.
7 Conclusion
It is standard practice to write English language
specifications for input formats. Programmers
read the specifications, then develop source code
that parses inputs in the format. Known disadvan-
tages of this approach include development cost,
parsers that contain errors, specification misunder-
standings, and specifications that become out of
date as the implementation evolves.
Our results show that taking both the correlation
between the text and the specification tree and the
success of the generated C++ parser in reading in-
put examples into account enables our method to
correctly generate C++ parsers for 72.5% of our
natural language specifications.
8 Acknowledgements
The authors acknowledge the support of Battelle
Memorial Institute (PO #300662) and the NSF
(Grant IIS-0835652). Thanks to Mirella Lapata,
members of the MIT NLP group and the ACL re-
viewers for their suggestions and comments. Any
opinions, findings, conclusions, or recommenda-
tions expressed in this paper are those of the au-
thors, and do not necessarily reflect the views of
the funding organizations.
References
James K. Baker. 1979. Trainable grammars for speech
recognition. In DH Klatt and JJ Wolf, editors,
Speech Communication Papers for the 97th Meet-
ing of the Acoustical Society of America, pages 547?
550.
S. R. K. Branavan, Harr Chen, Luke S. Zettlemoyer,
and Regina Barzilay. 2009. Reinforcement learning
for mapping instructions to actions. In Proceedings
of the Annual Meeting of the Association for Com-
putational Linguistics.
S.R.K Branavan, Luke Zettlemoyer, and Regina Barzi-
lay. 2010. Reading between the lines: Learning to
map high-level instructions to commands. In Pro-
ceedings of ACL, pages 1268?1277.
Mingwei Chang, Vivek Srikumar, Dan Goldwasser,
and Dan Roth. 2010. Structured output learning
with indirect supervision. In Proceedings of the 27th
International Conference on Machine Learning.
David L. Chen and Raymond J. Mooney. 2008. Learn-
ing to sportscast: A test of grounded language acqui-
sition. In Proceedings of 25th International Confer-
ence on Machine Learning (ICML-2008).
James Clarke, Dan Goldwasser, Ming-Wei Chang, and
Dan Roth. 2010. Driving semantic parsing from
the world?s response. In Proceedings of the Four-
teenth Conference on Computational Natural Lan-
guage Learning.
Trevor Cohn, Phil Blunsom, and Sharon Goldwater.
2010. Inducing tree-substitution grammars. Jour-
nal of Machine Learning Research, 11.
Dipanjan Das and Noah A. Smith. 2011. Semi-
supervised frame-semantic parsing for unknown
predicates. In Proceedings of the 49th Annual Meet-
ing of the Association for Computational Linguis-
tics: Human Language Technologies, pages 1435?
1444.
Dipanjan Das, Nathan Schneider, Desai Chen, and
Noah A. Smith. 2010. Probabilistic frame-semantic
parsing. In Human Language Technologies: The
2010 Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics, pages 948?956.
Dan Goldwasser, Roi Reichart, James Clarke, and Dan
Roth. 2011. Confidence driven unsupervised se-
mantic parsing. In Proceedings of the 49th Annual
Meeting of the Association for Computational Lin-
guistics: Human Language Technologies - Volume
1, HLT ?11.
Mark Johnson and Thomas L. Griffiths. 2007.
Bayesian inference for pcfgs via markov chain
monte carlo. In Proceedings of the North American
Conference on Computational Linguistics (NAACL
?07).
Stephen C. Johnson. 1979. Yacc: Yet another
compiler-compiler. Unix Programmer?s Manual,
vol 2b.
Rohit J. Kate and Raymond J. Mooney. 2007. Learn-
ing language semantics from ambiguous supervi-
sion. In Proceedings of the 22nd national confer-
ence on Artificial intelligence - Volume 1, AAAI?07.
1302
P. Liang, M. I. Jordan, and D. Klein. 2009. Learning
semantic correspondences with less supervision. In
Association for Computational Linguistics and In-
ternational Joint Conference on Natural Language
Processing (ACL-IJCNLP).
P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Proceedings of the Annual Meeting of the Associa-
tion for Computational Linguistics.
Tahira Naseem and Regina Barzilay. 2011. Using se-
mantic cues to learn syntax. In Proceedings of the
25th National Conference on Artificial Intelligence
(AAAI).
Rahul Pandita, Xusheng Xiao, Hao Zhong, Tao Xie,
Stephen Oney, and Amit Paradkar. 2012. Inferring
method specifications from natural language api de-
scriptions. In Proceedings of the 2012 International
Conference on Software Engineering, ICSE 2012,
pages 815?825, Piscataway, NJ, USA. IEEE Press.
Hoifung Poon and Pedro Domingos. 2009. Unsuper-
vised semantic parsing. In Proceedings of the 2009
Conference on Empirical Methods in Natural Lan-
guage Processing: Volume 1 - Volume 1, EMNLP
?09.
Lin Tan, Ding Yuan, Gopal Krishna, and Yuanyuan
Zhou. 2007. /* iComment: Bugs or bad comments?
*/. In Proceedings of the 21st ACM Symposium on
Operating Systems Principles (SOSP07), October.
Lin Tan, Yuanyuan Zhou, and Yoann Padioleau. 2011.
aComment: Mining annotations from comments and
code to detect interrupt-related concurrency bugs. In
Proceedings of the 33rd International Conference on
Software Engineering (ICSE11), May.
Lappoon R. Tang and Raymond J. Mooney. 2000. Au-
tomated construction of database interfaces: inte-
grating statistical and relational learning for seman-
tic parsing. In Proceedings of the conference on
Empirical Methods in Natural Language Process-
ing, EMNLP ?00.
Yuk Wah Wong and Raymond J. Mooney. 2007.
Learning synchronous grammars for semantic pars-
ing with lambda calculus. In ACL.
Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In Proceedings of UAI, pages 658?666.
Luke S. Zettlemoyer and Michael Collins. 2009.
Learning context-dependent mappings from sen-
tences to logical form. In Proceedings of the An-
nual Meeting of the Association for Computational
Linguistics.
Hao Zhong, Lu Zhang, Tao Xie, and Hong Mei. 2009.
Inferring resource specifications from natural lan-
guage api documentation. In Proceedings of the
2009 IEEE/ACM International Conference on Auto-
mated Software Engineering, ASE ?09, pages 307?
318, Washington, DC, USA. IEEE Computer Soci-
ety.
1303
Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics, pages 197?207,
Baltimore, Maryland, USA, June 23-25 2014.
c
?2014 Association for Computational Linguistics
Steps to Excellence: Simple Inference with Refined Scoring of
Dependency Trees
Yuan Zhang, Tao Lei, Regina Barzilay, Tommi Jaakkola
Massachusetts Institute of Technology
{yuanzh, taolei, regina, tommi}@csail.mit.edu
Amir Globerson
The Hebrew University
gamir@cs.huji.ac.il
Abstract
Much of the recent work on depen-
dency parsing has been focused on solv-
ing inherent combinatorial problems as-
sociated with rich scoring functions. In
contrast, we demonstrate that highly ex-
pressive scoring functions can be used
with substantially simpler inference pro-
cedures. Specifically, we introduce a
sampling-based parser that can easily han-
dle arbitrary global features. Inspired
by SampleRank, we learn to take guided
stochastic steps towards a high scoring
parse. We introduce two samplers for
traversing the space of trees, Gibbs and
Metropolis-Hastings with Random Walk.
The model outperforms state-of-the-art re-
sults when evaluated on 14 languages
of non-projective CoNLL datasets. Our
sampling-based approach naturally ex-
tends to joint prediction scenarios, such
as joint parsing and POS correction. The
resulting method outperforms the best re-
ported results on the CATiB dataset, ap-
proaching performance of parsing with
gold tags.
1
1 Introduction
Dependency parsing is commonly cast as a max-
imization problem over a parameterized scoring
function. In this view, the use of more expres-
sive scoring functions leads to more challenging
combinatorial problems of finding the maximiz-
ing parse. Much of the recent work on parsing has
been focused on improving methods for solving
the combinatorial maximization inference prob-
lems. Indeed, state-of-the-art results have been ob-
1
The source code for the work is available at
http://groups.csail.mit.edu/rbg/code/
global/acl2014.
tained by adapting powerful tools from optimiza-
tion (Martins et al, 2013; Martins et al, 2011;
Rush and Petrov, 2012). We depart from this view
and instead focus on using highly expressive scor-
ing functions with substantially simpler inference
procedures. The key ingredient in our approach is
how learning is coupled with inference. Our com-
bination outperforms the state-of-the-art parsers
and remains comparable even if we adopt their
scoring functions.
Rich scoring functions have been used for some
time. They first appeared in the context of rerank-
ing (Collins, 2000), where a simple parser is used
to generate a candidate list which is then reranked
according to the scoring function. Because the
number of alternatives is small, the scoring func-
tion could in principle involve arbitrary (global)
features of parse trees. The power of this method-
ology is nevertheless limited by the initial set of
alternatives from the simpler parser. Indeed, the
set may already omit the gold parse. We dispense
with the notion of a candidate set and seek to ex-
ploit the scoring function more directly.
In this paper, we introduce a sampling-based
parser that places few or no constraints on the
scoring function. Starting with an initial candi-
date tree, our inference procedure climbs the scor-
ing function in small (cheap) stochastic steps to-
wards a high scoring parse. The proposal distri-
bution over the moves is derived from the scoring
function itself. Because the steps are small, the
complexity of the scoring function has limited im-
pact on the computational cost of the procedure.
We explore two alternative proposal distributions.
Our first strategy is akin to Gibbs sampling and
samples a new head for each word in the sentence,
modifying one arc at a time. The second strat-
egy relies on a provably correct sampler for first-
order scores (Wilson, 1996), and uses it within a
Metropolis-Hastings algorithm for general scoring
functions. It turns out that the latter optimizes the
197
score more efficiently than the former.
Because the inference procedure is so simple,
it is important that the parameters of the scoring
function are chosen in a manner that facilitates
how we climb the scoring function in small steps.
One way to achieve this is to make sure that im-
provements in the scoring functions are correlated
with improvements in the quality of the parse.
This approach was suggested in the SampleRank
framework (Wick et al, 2011) for training struc-
tured prediction models. This method was origi-
nally developed for a sequence labeling task with
local features, and was shown to be more effec-
tive than state-of-the-art alternatives. Here we ap-
ply SampleRank to parsing, applying several mod-
ifications such as the proposal distributions men-
tioned earlier.
The benefits of sampling-based learning go be-
yond stand-alone parsing. For instance, we can
use the framework to correct preprocessing mis-
takes in features such as part-of-speech (POS)
tags. In this case, we combine the scoring func-
tion for trees with a stand-alone tagging model.
When proposing a small move, i.e., sampling a
head of the word, we can also jointly sample its
POS tag from a set of alternatives provided by
the tagger. As a result, the selected tag is influ-
enced by a broad syntactic context above and be-
yond the initial tagging model and is directly opti-
mized to improve parsing performance. Our joint
parsing-tagging model provides an alternative to
the widely-adopted pipeline setup.
We evaluate our method on benchmark multi-
lingual dependency corpora. Our method outper-
forms the Turbo parser across 14 languages on av-
erage by 0.5%. On four languages, we top the best
published results. Our method provides a more
effective mechanism for handling global features
than reranking, outperforming it by 1.3%. In terms
of joint parsing and tagging on the CATiB dataset,
we nearly bridge (88.38%) the gap between in-
dependently predicted (86.95%) and gold tags
(88.45%). This is better than the best published
results in the 2013 SPMRL shared task (Seddah et
al., 2013), including parser ensembles.
2 Related Work
Earlier works on dependency parsing focused on
inference with tractable scoring functions. For in-
stance, a scoring function that operates over each
single dependency can be optimized using the
maximum spanning tree algorithm (McDonald et
al., 2005). It was soon realized that using higher
order features could be beneficial, even at the cost
of using approximate inference and sacrificing op-
timality. The first successful approach in this arena
was reranking (Collins, 2000; Charniak and John-
son, 2005) on constituency parsing. Reranking
can be combined with an arbitrary scoring func-
tion, and thus can easily incorporate global fea-
tures over the entire parse tree. Its main disadvan-
tage is that the output parse can only be one of the
few parses passed to the reranker.
Recent work has focused on more powerful in-
ference mechanisms that consider the full search
space (Zhang and McDonald, 2012; Rush and
Petrov, 2012; Koo et al, 2010; Huang, 2008). For
instance, Nakagawa (2007) deals with tractabil-
ity issues by using sampling to approximate
marginals. Another example is the dual decompo-
sition (DD) framework (Koo et al, 2010; Martins
et al, 2011). The idea in DD is to decompose the
hard maximization problem into smaller parts that
can be efficiently maximized and enforce agree-
ment among these via Lagrange multipliers. The
method is essentially equivalent to linear program-
ming relaxation approaches (Martins et al, 2009;
Sontag et al, 2011), and also similar in spirit to
ILP approaches (Punyakanok et al, 2004).
A natural approach to approximate global in-
ference is via search. For instance, a transition-
based parsing system (Zhang and Nivre, 2011)
incrementally constructs a parsing structure us-
ing greedy beam-search. Other approaches op-
erate over full trees and generate a sequence
of candidates that successively increase the
score (Daum?e III et al, 2009; Li et al, 2013;
Wick et al, 2011). Our work builds on one such
approach ? SampleRank (Wick et al, 2011), a
sampling-based learning algorithm. In SampleR-
ank, the parameters are adjusted so as to guide the
sequence of candidates closer to the target struc-
ture along the search path. The method has been
successfully used in sequence labeling and ma-
chine translation (Haddow et al, 2011). In this
paper, we demonstrate how to adapt the method
for parsing with rich scoring functions.
3 Sampling-Based Dependency Parsing
with Global Features
In this section, we introduce our novel sampling-
based dependency parser which can incorporate
198
arbitrary global features. We begin with the no-
tation before addressing the decoding and learning
algorithms. Finally, we extend our model to a joint
parsing and POS correction task.
3.1 Notations
We denote sentences by x and the corresponding
dependency trees by y ? Y(x). Here Y(x) is the
set of valid (projective or non-projective) depen-
dency trees for sentence x. We use x
j
to refer
to the jth word of sentence x, and h
j
to the head
word of x
j
. A training set of size N is given as a
set of pairs D = {(x
(i)
, y
(i)
)}
N
i=1
where y
(i)
is the
ground truth parse for sentence x
(i)
.
We parameterize the scoring function s(x, y) as
s(x, y) = ? ? f(x, y) (1)
where f(x, y) is the feature vector associated with
tree y for sentence x. We do not make any assump-
tions about how the feature function decomposes.
In contrast, most state-of-the-art parsers operate
under the assumption that the feature function de-
composes into a sum of simpler terms. For exam-
ple, in the second-order MST parser (McDonald
and Pereira, 2006), all the feature terms involve
arcs or consecutive siblings. Similarly, parsers
based on dual decomposition (Martins et al, 2011;
Koo et al, 2010) assume that s(x, y) decomposes
into a sum of terms where each term can be maxi-
mized over y efficiently.
3.2 Decoding
The decoding problem consists of finding a valid
dependency tree y ? Y(x) that maximizes the
score s(x, y) = ? ? f(x, y) with parameters ?.
For scoring functions that extend beyond first-
order arc preferences, finding the maximizing non-
projective tree is known to be NP-hard (McDonald
and Pereira, 2006). We find a high scoring tree
through sampling, and (later) learn the parameters
? so as to further guide this process.
Our sampler generates a sequence of depen-
dency structures so as to approximate independent
samples from
p(y|x, T, ?) ? exp (s(x, y)/T ) (2)
The temperature parameter T controls how con-
centrated the samples are around the maximum
of s(x, y) (e.g., see Geman and Geman (1984)).
Sampling from target distribution p is typically as
hard as (or harder than) that maximizing s(x, y).
Inputs: ?, x, T
0
(initial temperature), c (temperature
update rate), proposal distribution q.
Outputs: y
?
T ? T
0
Set y
0
to some random tree
y
?
? y
0
repeat
y
?
? q(?|x, y
t
, T, ?)
if s(x, y
?
) > s(x, y
?
) then
y
?
? y
?
? = min
[
1,
p(y
?
)q(y
t
|y
?
)
p(y
t
)q(y
?
|y
t
)
]
Sample Bernouli variable Z with P [Z = 1] = ?.
if Z = 0 then
y
t+1
? y
t
else
y
t+1
? y
?
t? t+ 1
T ? c ? T
until convergence
return y
?
Figure 1: Sampling-based algorithm for decoding
(i.e., approximately maximizing s(x, y)).
We follow here a Metropolis-Hastings sampling
algorithm (e.g., see Andrieu et al (2003)) and
explore different alternative proposal distributions
q(y
?
|x, y, ?, T ). The distribution q governs the
small steps that are taken in generating a sequence
of structures. The target distribution p folds into
the procedure by defining the probability that we
will accept the proposed move. The general struc-
ture of our sampling algorithm is given in Figure 1.
3.2.1 Gibbs Sampling
Perhaps the most natural choice of the proposal
distribution q is a conditional distribution from p.
This is feasible if we restrict the proposed moves
to only small changes in the current tree. In our
case, we choose a word j randomly, and then sam-
ple its head h
j
according to p with the constraint
that we obtain a valid tree (when projective trees
are sought, this constraint is also incorporated).
For this choice of q, the probability of accepting
the new tree (? in Figure 1) is identically one.
Thus new moves are always accepted.
3.2.2 Exact First-Order Sampling
One shortcoming of the Gibbs sampler is that it
only changes one variable (arc) at a time. This
usually leads to slow mixing, requiring more sam-
ples to get close to the parse with maximum
score. Ideally, we would change multiple heads
in the parse tree simultaneously, and sample those
choices from the corresponding conditional distri-
bution of p. While in general this is increasingly
difficult with more heads, it is indeed tractable if
199
Inputs: x, y
t
, ?, K (number of heads to change).
Outputs: y
?
for i = 1 to |x| do
inTree[i]? false
ChangeNode[i]? false
Set ChangeNode to true for K random nodes.
head[0]? ?1
for i = 1 to |x| do
u? i
while not inTree[u] do
if ChangeNode[u] then
head[u]? randomHead(u, ?)
else
head[u]? y
t
(u)
u? head[u]
if LoopExist(head) then
EraseLoop(head)
u? i
while not inTree[u] do
inTree[u]? true
u? head[u]
return Construct tree y
?
from the head array.
Figure 2: A proposal distribution q(y
?
|y
t
) based
on the random walk sampler of Wilson (1996).
The function randomHead samples a new head for
node u according to the first-order weights given
by ?.
the model corresponds to a first-order parser. One
such sampling algorithm is the random walk sam-
pler of Wilson (1996). It can be used to obtain
i.i.d. samples from distributions of the form:
p(y) ?
?
i?j?y
w
ij
, (3)
where y corresponds to a tree with a spcified root
and w
ij
is the exponential of the first-order score.
y is always a valid parse tree if we allow multiple
children of the root and do not impose projective
constraint. The algorithm in Wilson (1996) iter-
ates over all the nodes, and for each node performs
a random walk according to the weights w
ij
until
the walk creates a loop or hits a tree. In the first
case the algorithm erases the loop and continues
the walk. If the walk hits the current tree, the walk
path is added to form a new tree with more nodes.
This is repeated until all the nodes are included in
the tree. It can be shown that this procedure gen-
erates i.i.d. trees from p(y).
Since our features do not by design correspond
to a first-order parser, we cannot use the Wilson
algorithm as it is. Instead we use it as the proposal
function and sample a subset of the dependen-
cies from the first-order distribution of our model,
while fixing the others. In each step we uniformly
sample K nodes to update and sample their new
1!
2!
not?Monday? not ssssssssssss" ?""" wasloop erased!Black?Monday?was
ROOT! It! was! not! Black! Monday!
2!
1!
3!
ROOT! It! was! not! Black! Monday!
(b) walk path:!
(c) walk path:!
(a) original tree!
ROOT! It! was! not! Black! Monday!
Figure 3: An illustration of random walk sam-
pler. The index on each edge indicates its order on
each walk path. The heads of the red words are
sampled while others are fixed. The blue edges
represent the current walk path and the black ones
are already in the tree. Note that the walk direc-
tion is opposite to the dependency direction. (a)
shows the original tree before sampling; (b) and
(c) show the walk path and how the tree is gener-
ated in two steps. The loop not? Monday? not
in (b) is erased.
heads using the Wilson algorithm (in the experi-
ments we use K = 4). Note that blocked Gibbs
sampling would be exponential in K, and is thus
very slow already at K = 4. The procedure is de-
scribed in Figure 2 with a graphic illustration in
Figure 3.
3.3 Training
In this section, we describe how to learn the
adjustable parameters ? in the scoring function.
The parameters are learned in an on-line fash-
ion by successively imposing soft constraints be-
tween pairs of dependency structures. We intro-
duce both margin constraints and constraints per-
taining to successive samples generated along the
search path. We demonstrate later that both types
of constraints are essential.
We begin with the standard margin constraints.
An ideal scoring function would always rank the
gold parse higher than any alternative. Moreover,
alternatives that are far from the gold parse should
score even lower. As a result, we require that
s(x
(i)
, y
(i)
)? s(x
(i)
, y) ? ?(y
(i)
, y) ?y (4)
where ?(y
(i)
, y) is the number of head mistakes
in y relative to the gold parse y
(i)
. We adopt here
a shorthand Err(y) = ?(y
(i)
, y), where the de-
200
pendence on y
(i)
is implied from context. Note
that Equation 4 contains exponentially many con-
straints and cannot be enforced jointly for general
scoring functions. However, our sampling proce-
dure generates a small number of structures along
the search path. We enforce only constraints cor-
responding to those samples.
The second type of constraints are enforced be-
tween successive samples along the search path.
To illustrate the idea, consider a parse y that dif-
fers from y
(i)
in only one arc, and a parse y
?
that
differs from y
(i)
in ten arcs. We cannot necessarily
assume that s(x, y) is greater than s(x, y
?
) without
additional encouragement. Thus, we can comple-
ment the constraints in Equation 4 with additional
pairwise constraints (Wick et al, 2011):
s(x
(i)
, y)? s(x
(i)
, y
?
) ? Err(y
?
)? Err(y) (5)
where similarly to Equation 4, the difference in
scores scales with the differences in errors with re-
spect to the target y
(i)
. We only enforce the above
constraints for y, y
?
that are consecutive samples
in the course of the sampling process. These con-
straints serve to guide the sampling process de-
rived from the scoring function towards the gold
parse.
We learn the parameters ? in an on-line fashion
to satisfy the above constraints. This is done via
the MIRA algorithm (Crammer and Singer, 2003).
Specifically, if the current parameters are ?
t
, and
we enforce constraint Equation 5 for a particular
pair y, y
?
, then we will find ?
t+1
that minimizes
min ||? ? ?
t
||
2
+ C?
s.t. ? ? (f(x, y)? f(x, y
?
)) ? Err(y
?
)? Err(y)? ?
(6)
The updates can be calculated in closed form. Fig-
ure 4 summarizes the learning algorithm. We re-
peatedly generate parses based on the current pa-
rameters ?
t
for each sentence x
(i)
, and use succes-
sive samples to enforce constraints in Equation 4
and Equation 5 one at a time.
3.4 Joint Parsing and POS Correction
It is easy to extend our sampling-based parsing
framework to joint prediction of parsing and other
labels. Specifically, when sampling the new heads,
we can also sample the values of other variables at
the same time. For instance, we can sample the
POS tag, the dependency relation or morphology
information. In this work, we investigate a joint
Inputs: D = {(x
(i)
, y
(i)
)}
N
i=1
.
Outputs: Learned parameters ?.
?
0
? 0
for e = 1 to #epochs do
for i = 1 toN do
y
?
? q(?|x
(i)
, y
t
i
i
, ?
t
)
y
+
= arg min
y?
{
y
t
i
i
,y
?
}
Err(y)
y
?
= arg max
y?
{
y
t
i
i
,y
?
}
Err(y)
y
t
i
+1
i
? acceptOrReject(y
?
, y
t
i
i
, ?
t
)
t
i
? t
i
+ 1
?f = f(x
(i)
, y
+
)? f(x
(i)
, y
?
)
?Err = Err(y
+
)? Err(y
?
)
if ?Err 6= 0 and ?
t
? ?f < ?Err then
?
t+1
? updateMIRA(?f,?Err, ?
t
)
t? t+ 1
?f
g
= f(x
(i)
, y
(i)
)? f(x
(i)
, y
t
i
i
)
if ?
t
? ?f
g
< Err(y
t
i
i
) then
?
t+1
? updateMIRA(?f
g
, Err(y
t
i
i
), ?
t
)
t? t+ 1
return Average of ?
0
, . . . , ?
t
parameters.
Figure 4: SampleRank algorithm for learning. The
rejection strategy is as in Figure 1. y
t
i
i
is the t
i
th
tree sample of x
(i)
. The first MIRA update (see
Equation 6) enforces a ranking constraint between
two sampled parses. The second MIRA update en-
forces constraints between a sampled parse and the
gold parse. In practice several samples are drawn
for each sentence in each epoch.
POS correction scenario in which only the pre-
dicted POS tags are provided in the testing phase,
while both gold and predicted tags are available
for the training set.
We extend our model such that it jointly learns
how to predict a parse tree and also correct the pre-
dicted POS tags for a better parsing performance.
We generate the POS candidate list for each word
based on the confusion matrix on the training set.
Let c(t
g
, t
p
) be the count when the gold tag is t
g
and the predicted one is t
p
. For each word w, we
first prune out its POS candidates by using the vo-
cabulary from the training set. We don?t prune
anything if w is unseen. Assuming that the pre-
dicted tag forw is t
p
, we further remove those tags
t if their counts are smaller than some threshold
c(t, t
p
) < ? ? c(t
p
, t
p
)
2
.
After generating the candidate lists for each
word, the rest of the extension is rather straight-
forward. For each sampling, let H be the set of
candidate heads and T be the set of candidate POS
tags. The Gibbs sampler will generate a new sam-
ple from the space H ? T . The other parts of the
algorithm remain the same.
2
In our work we choose ? = 0.003, which gives a 98.9%
oracle POS tagging accuracy on the CATiB development set.
201
arc!
head bigram!!h h m m+1arbitrary sibling!?!h m sh m consecutive sibling!h m s grandparent!g h m
grand-sibling!g h m s tri-siblings!h m s t grand-grandparent!g h mgg
outer-sibling-grandchild!h m sgc h s gcminner-sibling-grandchild!
Figure 5: First- to third-order features.
4 Features
First- to Third-Order Features The feature
templates of first- to third-order features are
mainly drawn from previous work on graph-
based parsing (McDonald and Pereira, 2006),
transition-based parsing (Nivre et al, 2006) and
dual decomposition-based parsing (Martins et al,
2011). As shown in Figure 5, the arc is the basic
structure for first-order features. We also define
features based on consecutive sibling, grandpar-
ent, arbitrary sibling, head bigram, grand-sibling
and tri-siblings, which are also used in the Turbo
parser (Martins et al, 2013). In addition to these
first- to third-order structures, we also consider
grand-grandparent and sibling-grandchild struc-
tures. There are two types of sibling-grandchild
structures: (1) inner-sibling when the sibling is
between the head and the modifier and (2) outer-
sibling for the other cases.
Global Features We used feature shown promis-
ing in prior reranking work Charniak and Johnson
(2005), Collins (2000) and Huang (2008).
? Right Branch This feature enables the model
to prefer right or left-branching trees. It counts
the number of words on the path from the root
node to the right-most non-punctuation word,
normalized by the length of the sentence.
? Coordination In a coordinate structure, the two
adjacent conjuncts usually agree with each other
on POS tags and their span lengths. For in-
stance, in cats and dogs, the conjuncts are both
short noun phrases. Therefore, we add differ-
ent features to capture POS tag and span length
consistency in a coordinate structure.
? PP Attachment We add features of lexical tu-
eat! with! knife! and! fork!
Figure 6: An example of PP attachment with coor-
dination. The arguments should be knife and fork,
not and.
ples involving the head, the argument and the
preposition of prepositional phrases. Generally,
this feature can be defined based on an instance
of grandparent structure. However, we also han-
dle the case of coordination. In this case, the ar-
guments should be the conjuncts rather than the
coordinator. Figure 6 shows an example.
? Span Length This feature captures the distribu-
tion of the binned span length of each POS tag.
It also includes flags of whether the span reaches
the end of the sentence and whether the span is
followed by the punctuation.
? Neighbors The POS tags of the neighboring
words to the left and right of each span, together
with the binned span length and the POS tag at
the span root.
? Valency We consider valency features for each
POS tag. Specifically, we add two types of va-
lency information: (1) the binned number of
non-punctuation modifiers and (2) the concate-
nated POS string of all those modifiers.
? Non-projective Arcs A flag indicating if a de-
pendency is projective or not (i.e. if it spans a
word that does not descend from its head) (Mar-
tins et al, 2011). This flag is also combined with
the POS tags or the lexical words of the head and
the modifier.
POS Tag Features In the joint POS correction
scenario, we also add additional features specifi-
cally for POS prediction. The feature templates
are inspired by previous feature-rich POS tagging
work (Toutanova et al, 2003). However, we are
free to add higher order features because we do
not rely on dynamic programming decoding. In
our work we use feature templates up to 5-gram.
Table 1 summarizes all POS tag feature templates.
5 Experimental Setup
Datasets We evaluate our model on standard
benchmark corpora ? CoNLL 2006 and CoNLL
2008 (Buchholz and Marsi, 2006; Surdeanu et al,
2008) ? which include dependency treebanks for
14 different languages. Most of these data sets
202
1-gram
?t
i
?, ?t
i
, w
i?2
?, ?t
i
, w
i?1
?, ?t
i
, w
i
?, ?t
i
, w
i+1
?,
?t
i
, w
i+2
?
2-gram
?t
i?1
, t
i
?, ?t
i?2
, t
i
?, ?t
i?1
, t
i
, w
i?1
?,
?t
i?1
, t
i
, w
i
?
3-gram
?t
i?1
, t
i
, t
i+1
?, ?t
i?2
, t
i
, t
i+1
, ?, ?t
i?1
, t
i
, t
i+2
?,
?t
i?2
, t
i
, t
i+2
?
4-gram
?t
i?2
, t
i?1
, t
i
, t
i+1
?, ?t
i?2
, t
i?1
, t
i
, t
i+2
?,
?t
i?2
, t
i
, t
i+1
, t
i+2
?
5-gram ?t
i?2
, t
i?1
, t
i
, t
i+1
, t
i+2
?
Table 1: POS tag feature templates. t
i
and w
i
de-
notes the POS tag and the word at the current posi-
tion. t
i?x
and t
i+x
denote the left and right context
tags, and similarly for words.
contain non-projective dependency trees. We use
all sentences in CoNLL datasets during training
and testing. We also use the Columbia Arabic
Treebank (CATiB) (Marton et al, 2013). CATiB
mostly includes projective trees. The trees are an-
notated with both gold and predicted versions of
POS tags and morphology information. Follow-
ing Marton et al (2013), for this dataset we use
12 core POS tags, word lemmas, determiner fea-
tures, rationality features and functional genders
and numbers.
Some CATiB sentences exceed 200 tokens. For
efficiency, we limit the sentence length to 70 to-
kens in training and development sets. However,
we do not impose this constraint during testing.
We handle long sentences during testing by apply-
ing a simple split-merge strategy. We split the sen-
tence based on the ending punctuation, predict the
parse tree for each segment and group the roots of
resulting trees into a single node.
Evaluation Measures Following standard prac-
tice, we use Unlabeled Attachment Score (UAS)
as the evaluation metric in all our experiments.
We report UAS excluding punctuation on CoNLL
datasets, following Martins et al (2013). For the
CATiB dataset, we report UAS including punctu-
ation in order to be consistent with the published
results in the 2013 SPMRL shared task (Seddah et
al., 2013).
Baselines We compare our model with the Turbo
parser and the MST parser. For the Turbo parser,
we directly compare with the recent published re-
sults in (Martins et al, 2013). For the MST parser,
we train a second-order non-projective model us-
ing the most recent version of the code
3
.
We also compare our model against a discrim-
inative reranker. The reranker operates over the
3
http://sourceforge.net/projects/mstparser/
top-50 list obtained from the MST parser
4
. We
use a 10-fold cross-validation to generate candi-
date lists for training. We then train the reranker
by running 10 epochs of cost-augmented MIRA.
The reranker uses the same features as our model,
along with the tree scores obtained from the MST
parser (which is a standard practice in reranking).
Experimental Details Following Koo and Collins
(2010), we always first train a first-order pruner.
For each word x
i
, we prune away the incoming
dependencies ?h
i
, x
i
? with probability less than
0.005 times the probability of the most likely head,
and limit the number of candidate heads up to 30.
This gives a 99% pruning recall on the CATiB
development set. The first-order model is also
trained using the algorithm in Figure 4. Af-
ter pruning, we tune the regularization parameter
C = {0.1, 0.01, 0.001} on development sets for
different languages. Because the CoNLL datasets
do not have a standard development set, we ran-
domly select a held out of 200 sentences from the
training set. We also pick the training epochs from
{50, 100, 150} which gives the best performance
on the development set for each language. After
tuning, the model is trained on the full training set
with the selected parameters.
We apply the Random Walk-based sampling
method (see Section 3.2.2) for the standard de-
pendency parsing task. However, for the joint
parsing and POS correction on the CATiB dataset
we do not use the Random Walk method because
the first-order features in normal parsing are no
longer first-order when POS tags are also vari-
ables. Therefore, the first-order distribution is not
well-defined and we only employ Gibbs sampling
for simplicity. On the CATiB dataset, we restrict
the sample trees to always be projective as de-
scribed in Section 3.2.1. However, we do not im-
pose this constraint for the CoNLL datasets.
6 Results
Comparison with State-of-the-art Parsers Ta-
ble 2 summarizes the performance of our model
and of the baselines. We first compare our model
to the Turbo parser using the Turbo parser fea-
ture set. This is meant to test how our learning
and inference methods compare to a dual decom-
position approach. The first column in Table 2
4
The MST parser is trained in projective mode for rerank-
ing because generating top-k list from second-order non-
projective model is intractable.
203
Our Model (UAS)
Turbo (UAS)
MST 2nd-Ord.
(UAS)
Best Published UAS
Top-50
Reranker
Top-500
RerankerTurbo Feat. Full Feat.
Arabic 79.86 80.21 79.64 78.75 81.12 (Ma11) 79.03 78.91
Bulgarian 92.97 93.30 93.10 91.56 94.02 (Zh13) 92.81 -
Chinese 92.06 92.63 89.98 91.77 91.89 (Ma10) 92.25 -
Czech 90.62 91.04 90.32 87.30 90.32 (Ma13) 88.14 -
Danish 91.45 91.80 91.48 90.50 92.00 (Zh13) 90.88 90.91
Dutch 85.83 86.47 86.19 84.11 86.19 (Ma13) 81.01 -
English 92.79 92.94 93.22 91.54 93.22 (Ma13) 92.41 -
German 91.79 92.07 92.41 90.14 92.41 (Ma13) 91.19 -
Japanese 93.23 93.42 93.52 92.92 93.72 (Ma11) 93.40 -
Portuguese 91.82 92.41 92.69 91.08 93.03 (Ko10) 91.47 -
Slovene 86.19 86.82 86.01 83.25 86.95 (Ma11) 84.81 85.37
Spanish 88.24 88.21 85.59 84.33 87.96 (Zh13) 86.85 87.21
Swedish 90.48 90.71 91.14 89.05 91.62 (Zh13) 90.53 -
Turkish 76.82 77.21 76.90 74.39 77.55 (Ko10) 76.35 76.23
Average 88.87 89.23 88.72 86.86 89.33 87.92 -
Table 2: Results of our model, the Turbo parser, and the MST parser. ?Best Published UAS? includes the
most accurate parsers among Nivre et al (2006), McDonald et al (2006), Martins et al (2010), Martins
et al (2011), Martins et al (2013), Koo et al (2010), Rush and Petrov (2012), Zhang and McDonald
(2012) and Zhang et al (2013). Martins et al (2013) is the current Turbo parser. The last two columns
shows UAS of the discriminative reranker.
shows the result for our model with an average of
88.87%, and the third column shows the results
for the Turbo parser with an average of 88.72%.
This suggests that our learning and inference pro-
cedures are as effective as the dual decomposition
method in the Turbo parser.
Next, we add global features that are not used by
the Turbo parser. The performance of our model
is shown in the second column with an average of
89.23%. It outperforms the Turbo parser by 0.5%
and achieves the best reported performance on
four languages. Moreover, our model also outper-
forms the 88.80% average UAS reported in Mar-
tins et al (2011), which is the top performing sin-
gle parsing system (to the best of our knowledge).
Comparison with Reranking As column 6 of Ta-
ble 2 shows, our model outperforms the reranker
by 1.3%
5
. One possible explanation of this perfor-
mance gap between the reranker and our model is
the small number of candidates considered by the
reranker. To test this hypothesis, we performed
experiments with top-500 list for a subset of lan-
guages.
6
As column 7 shows, this increase in the
list size does not change the relative performance
of the reranker and our model.
Joint Parsing and POS Correction Table 3
shows the results of joint parsing and POS cor-
rection on the CATiB dataset, for our model and
5
Note that the comparison is conservative because we
can also add MST scores as features in our model as in
reranker. With these features our model achieves an average
UAS 89.28%.
6
We ran this experiment on 5 languages with small
datasets due to the scalability issues associated with rerank-
ing top-500 list.
state-of-the-art systems. As the upper part of the
table shows, the parser with corrected tags reaches
88.38% compared to the accuracy of 88.46% on
the gold tags. This is a substantial increase from
the parser that uses predicted tags (86.95%).
To put these numbers into perspective, the bot-
tom part of Table 3 shows the accuracy of the best
systems from the 2013 SPMRL shared task on
Arabic parsing using predicted information (Sed-
dah et al, 2013). Our system not only out-
performs the best single system (Bj?orkelund et
al., 2013) by 1.4%, but it also tops the ensem-
ble system that combines three powerful parsers:
the Mate parser (Bohnet, 2010), the Easy-First
parser (Goldberg and Elhadad, 2010) and the
Turbo parser (Martins et al, 2013)
Impact of Sampling Methods We compare two
sampling methods introduced in Section 3.2 with
respect to their decoding efficiency. Specifically,
we measure the score of the retrieved trees in test-
ing as a function of the decoding speed, measured
by the number of tokens per second. We change
the temperature update rate c in order to decode
with different speed. In Figure 7 we show the cor-
responding curves for two languages: Arabic and
Chinese. We select these two languages as they
correspond to two extremes in sentence length:
Arabic has the longest sentences on average, while
Chinese has the shortest ones. For both languages,
the tree score improves over time. Given sufficient
time, both sampling methods achieve the same
score. However, the Random Walk-based sam-
pler performs better when the quality is traded for
speed. This result is to be expected given that each
204
Dev. Set (? 70) Testing Set
POS Acc. UAS POS Acc. UAS
Gold - 90.27 - 88.46
Predicted 96.87 88.81 96.82 86.95
POS Correction 97.72 90.08 97.49 88.38
CADIM 96.87 87.4- 96.82 85.78
IMS-Single - - - 86.96
IMS-Ensemble - - - 88.32
Table 3: Results for parsing and corrective tagging
on the CATiB dataset. The upper part shows UAS
of our model with gold/predicted information or
POS correction. Bottom part shows UAS of the
best systems in the SPMRL shared task. IMS-
Single (Bj?orkelund et al, 2013) is the best single
parsing system, while IMS-Ensemble (Bj?orkelund
et al, 2013) is the best ensemble parsing system.
We also show results for CADIM (Marton et al,
2013), the second best system, because we use
their predicted features.
0 20 40 60 80 1002.648
2.65
2.652
2.654
2.656
2.658 x 104
Toks/sec
Score
 
 
GibbsRandom Walk
(a) Arabic
0 100 200 300 400 500 600 700 8001.897
1.898
1.899
1.9 x 10
4
Toks/sec
Score
 
 
GibbsRandom Walk
(b) Chinese
Figure 7: Total score of the predicted test trees as
a function of the decoding speed, measured in the
number of tokens per second.
iteration of this sampler makes multiple changes
to the tree, in contrast to a single-edge change of
Gibbs sampler.
The Effect of Constraints in Learning Our train-
ing method updates parameters to satisfy the pair-
wise constraints between (1) subsequent samples
on the sampling path and (2) selected samples and
the ground truth. Figure 8 shows that applying
both types of constraints is consistently better than
using either of them alone. Moreover, these re-
sults demonstrate that comparison between subse-
quent samples is more important than comparison
against the gold tree.
Decoding Speed Our sampling-based parser is an
Danish Japanese Portuguese Swedish89
90
91
92
93
94
UAS
(%)
 
 BothNeighborGold
Figure 8: UAS on four languages when train-
ing with different constraints. ?Neighbor? corre-
sponds to pairwise constraints between subsequent
samples, ?Gold? represents constraints between a
single sample and the ground truth, ?Both? means
applying both types of constraints.
anytime algorithm, and therefore its running time
can be traded for performance. Figure 7 illustrates
this trade-off. In the experiments reported above,
we chose a conservative cooling rate and contin-
ued to sample until the score no longer changed.
The parser still managed to process all the datasets
in a reasonable time. For example, the time that it
took to decode all the test sentences in Chinese and
Arabic were 3min and 15min, respectively. Our
current implementation is in Java and can be fur-
ther optimized for speed.
7 Conclusions
This paper demonstrates the power of combining a
simple inference procedure with a highly expres-
sive scoring function. Our model achieves the best
results on the standard dependency parsing bench-
mark, outperforming parsing methods with elabo-
rate inference procedures. In addition, this frame-
work provides simple and effective means for joint
parsing and corrective tagging.
Acknowledgments
This research is developed in collaboration with
the Arabic Language Technologies (ALT) group
at Qatar Computing Research Institute (QCRI)
within the IYAS project. The authors acknowledge
the support of the MURI program (W911NF-10-
1-0533, the DARPA BOLT program and the US-
Israel Binational Science Foundation (BSF, Grant
No 2012330). We thank the MIT NLP group and
the ACL reviewers for their comments.
205
References
Christophe Andrieu, Nando De Freitas, Arnaud
Doucet, and Michael I Jordan. 2003. An introduc-
tion to mcmc for machine learning. Machine learn-
ing, 50(1-2):5?43.
Anders Bj?orkelund, Ozlem Cetinoglu, Rich?ard Farkas,
Thomas Mueller, and Wolfgang Seeker. 2013.
(re)ranking meets morphosyntax: State-of-the-art
results from the SPMRL 2013 shared task. In Pro-
ceedings of the Fourth Workshop on Statistical Pars-
ing of Morphologically-Rich Languages, pages 135?
145, Seattle, Washington, USA, October. Associa-
tion for Computational Linguistics.
Bernd Bohnet. 2010. Top accuracy and fast depen-
dency parsing is not a contradiction. In COLING,
pages 89?97.
Sabine Buchholz and Erwin Marsi. 2006. Conll-x
shared task on multilingual dependency parsing. In
Proceedings of the Tenth Conference on Computa-
tional Natural Language Learning, pages 149?164.
Association for Computational Linguistics.
Eugene Charniak and Mark Johnson. 2005. Coarse-
to-fine n-best parsing and maxent discriminative
reranking. In Proceedings of the 43rd Annual Meet-
ing on Association for Computational Linguistics,
pages 173?180. Association for Computational Lin-
guistics.
Michael Collins. 2000. Discriminative reranking for
natural language parsing. In Proceedings of the
Seventeenth International Conference on Machine
Learning, ICML ?00, pages 175?182.
Koby Crammer and Yoram Singer. 2003. Ultracon-
servative online algorithms for multiclass problems.
The Journal of Machine Learning Research, 3:951?
991.
Hal Daum?e III, John Langford, and Daniel Marcu.
2009. Search-based structured prediction. Machine
learning, 75(3):297?325.
Stuart Geman and Donald Geman. 1984. Stochas-
tic relaxation, gibbs distributions, and the bayesian
restoration of images. Pattern Analysis andMachine
Intelligence, IEEE Transactions on, (6):721?741.
Yoav Goldberg and Michael Elhadad. 2010. An effi-
cient algorithm for easy-first non-directional depen-
dency parsing. In Human Language Technologies:
The 2010 Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics, pages 742?750. Association for Computa-
tional Linguistics.
Barry Haddow, Abhishek Arun, and Philipp Koehn.
2011. Samplerank training for phrase-based ma-
chine translation. In Proceedings of the Sixth Work-
shop on Statistical Machine Translation, pages 261?
271. Association for Computational Linguistics.
Liang Huang. 2008. Forest reranking: Discriminative
parsing with non-local features. In ACL, pages 586?
594.
Terry Koo and Michael Collins. 2010. Efficient third-
order dependency parsers. In Proceedings of the
48th Annual Meeting of the Association for Com-
putational Linguistics, pages 1?11. Association for
Computational Linguistics.
Terry Koo, Alexander M Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proceedings of the 2010 Conference
on Empirical Methods in Natural Language Pro-
cessing, pages 1288?1298. Association for Compu-
tational Linguistics.
Quannan Li, Jingdong Wang, Zhuowen Tu, and
David P Wipf. 2013. Fixed-point model for struc-
tured labeling. In Proceedings of the 30th Interna-
tional Conference on Machine Learning (ICML-13),
pages 214?221.
Andr?e FT Martins, Noah A Smith, and Eric P Xing.
2009. Concise integer linear programming formula-
tions for dependency parsing. In Proceedings of the
Joint Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference on
Natural Language Processing of the AFNLP: Vol-
ume 1-Volume 1, pages 342?350. Association for
Computational Linguistics.
Andr?e FT Martins, Noah A Smith, Eric P Xing, Pe-
dro MQ Aguiar, and M?ario AT Figueiredo. 2010.
Turbo parsers: Dependency parsing by approxi-
mate variational inference. In Proceedings of the
2010 Conference on Empirical Methods in Natural
Language Processing, pages 34?44. Association for
Computational Linguistics.
Andr?e FT Martins, Noah A Smith, Pedro MQ Aguiar,
and M?ario AT Figueiredo. 2011. Dual decompo-
sition with many overlapping components. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing, pages 238?249. As-
sociation for Computational Linguistics.
Andr?e FT Martins, Miguel B Almeida, and Noah A
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proceedings of the
51th Annual Meeting of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics.
Yuval Marton, Nizar Habash, Owen Rambow, and
Sarah Alkhulani. 2013. Spmrl13 shared task sys-
tem: The cadim arabic dependency parser. In Pro-
ceedings of the Fourth Workshop on Statistical Pars-
ing of Morphologically-Rich Languages, pages 76?
80.
Ryan T McDonald and Fernando CN Pereira. 2006.
Online learning of approximate dependency parsing
algorithms. In EACL.
206
R. McDonald, F. Pereira, K. Ribarov, and J. Hajic.
2005. Non-projective dependency parsing using
spanning tree algorithms. In Proceedings of the con-
ference on Human Language Technology and Em-
pirical Methods in Natural Language Processing,
pages 523?530.
Ryan McDonald, Kevin Lerman, and Fernando Pereira.
2006. Multilingual dependency analysis with a two-
stage discriminative parser. In Proceedings of the
Tenth Conference on Computational Natural Lan-
guage Learning, pages 216?220. Association for
Computational Linguistics.
Tetsuji Nakagawa. 2007. Multilingual dependency
parsing using global features. In EMNLP-CoNLL,
pages 952?956.
Joakim Nivre, Johan Hall, Jens Nilsson, G?uls?en Eryiit,
and Svetoslav Marinov. 2006. Labeled pseudo-
projective dependency parsing with support vector
machines. In Proceedings of the Tenth Confer-
ence on Computational Natural Language Learning,
pages 221?225. Association for Computational Lin-
guistics.
Vasin Punyakanok, Dan Roth, Wen-tau Yih, and Dav
Zimak. 2004. Semantic role labeling via integer
linear programming inference. In Proceedings of
the 20th international conference on Computational
Linguistics, page 1346. Association for Computa-
tional Linguistics.
Alexander M Rush and Slav Petrov. 2012. Vine prun-
ing for efficient multi-pass dependency parsing. In
Proceedings of the 2012 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 498?507. Association for Computational Lin-
guistics.
Djam?e Seddah, Reut Tsarfaty, Sandra K?ubler, Marie
Candito, Jinho D Choi, Rich?ard Farkas, Jennifer
Foster, Iakes Goenaga, Koldo Gojenola Gallete-
beitia, Yoav Goldberg, et al 2013. Overview of the
spmrl 2013 shared task: A cross-framework evalua-
tion of parsing morphologically rich languages. In
Proceedings of the Fourth Workshop on Statistical
Parsing of Morphologically-Rich Languages, pages
146?182.
D. Sontag, A. Globerson, and T. Jaakkola. 2011. In-
troduction to dual decomposition for inference. In
Optimization for Machine Learning, pages 219?254.
MIT Press.
Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu??s M`arquez, and Joakim Nivre. 2008. The
conll-2008 shared task on joint parsing of syntac-
tic and semantic dependencies. In Proceedings of
the Twelfth Conference on Computational Natural
Language Learning, pages 159?177. Association for
Computational Linguistics.
Kristina Toutanova, Dan Klein, Christopher D Man-
ning, and Yoram Singer. 2003. Feature-rich part-of-
speech tagging with a cyclic dependency network.
In Proceedings of the 2003 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics on Human Language Technology-
Volume 1, pages 173?180. Association for Compu-
tational Linguistics.
Michael L. Wick, Khashayar Rohanimanesh, Kedar
Bellare, Aron Culotta, and Andrew McCallum.
2011. Samplerank: Training factor graphs with
atomic gradients. In Lise Getoor and Tobias Schef-
fer, editors, Proceedings of the 28th International
Conference on Machine Learning, ICML 2011,
pages 777?784.
David Bruce Wilson. 1996. Generating random span-
ning trees more quickly than the cover time. In
Proceedings of the twenty-eighth annual ACM sym-
posium on Theory of computing, pages 296?303.
ACM.
Hao Zhang and Ryan McDonald. 2012. Generalized
higher-order dependency parsing with cube prun-
ing. In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learning,
pages 320?331. Association for Computational Lin-
guistics.
Yue Zhang and Joakim Nivre. 2011. Transition-based
dependency parsing with rich non-local features. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies: short papers-Volume 2, pages
188?193. Association for Computational Linguis-
tics.
Hao Zhang, Liang Huang Kai Zhao, and Ryan McDon-
ald. 2013. Online learning for inexact hypergraph
search. In Proceedings of EMNLP.
207
Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics, pages 1381?1391,
Baltimore, Maryland, USA, June 23-25 2014.
c
?2014 Association for Computational Linguistics
Low-Rank Tensors for Scoring Dependency Structures
Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and Tommi Jaakkola
Computer Science and Artificial Intelligence Laboratory
Massachusetts Institute of Technology
{taolei, yuxin, yuanzh, regina, tommi}@csail.mit.edu
Abstract
Accurate scoring of syntactic structures
such as head-modifier arcs in dependency
parsing typically requires rich, high-
dimensional feature representations. A
small subset of such features is often se-
lected manually. This is problematic when
features lack clear linguistic meaning as
in embeddings or when the information is
blended across features. In this paper, we
use tensors to map high-dimensional fea-
ture vectors into low dimensional repre-
sentations. We explicitly maintain the pa-
rameters as a low-rank tensor to obtain low
dimensional representations of words in
their syntactic roles, and to leverage mod-
ularity in the tensor for easy training with
online algorithms. Our parser consistently
outperforms the Turbo and MST parsers
across 14 different languages. We also ob-
tain the best published UAS results on 5
languages.
1
1 Introduction
Finding an expressive representation of input sen-
tences is crucial for accurate parsing. Syntac-
tic relations manifest themselves in a broad range
of surface indicators, ranging from morphological
to lexical, including positional and part-of-speech
(POS) tagging features. Traditionally, parsing re-
search has focused on modeling the direct connec-
tion between the features and the predicted syntac-
tic relations such as head-modifier (arc) relations
in dependency parsing. Even in the case of first-
order parsers, this results in a high-dimensional
vector representation of each arc. Discrete fea-
tures, and their cross products, can be further com-
plemented with auxiliary information about words
1
Our code is available at https://github.com/
taolei87/RBGParser.
participating in an arc, such as continuous vector
representations of words. The exploding dimen-
sionality of rich feature vectors must then be bal-
anced with the difficulty of effectively learning the
associated parameters from limited training data.
A predominant way to counter the high dimen-
sionality of features is to manually design or select
a meaningful set of feature templates, which are
used to generate different types of features (Mc-
Donald et al, 2005a; Koo and Collins, 2010; Mar-
tins et al, 2013). Direct manual selection may be
problematic for two reasons. First, features may
lack clear linguistic interpretation as in distribu-
tional features or continuous vector embeddings of
words. Second, designing a small subset of tem-
plates (and features) is challenging when the rel-
evant linguistic information is distributed across
the features. For instance, morphological proper-
ties are closely tied to part-of-speech tags, which
in turn relate to positional features. These features
are not redundant. Therefore, we may suffer a per-
formance loss if we select only a small subset of
the features. On the other hand, by including all
the rich features, we face over-fitting problems.
We depart from this view and leverage high-
dimensional feature vectors by mapping them into
low dimensional representations. We begin by
representing high-dimensional feature vectors as
multi-way cross-products of smaller feature vec-
tors that represent words and their syntactic rela-
tions (arcs). The associated parameters are viewed
as a tensor (multi-way array) of low rank, and opti-
mized for parsing performance. By explicitly rep-
resenting the tensor in a low-rank form, we have
direct control over the effective dimensionality of
the set of parameters. We obtain role-dependent
low-dimensional representations for words (head,
modifier) that are specifically tailored for parsing
accuracy, and use standard online algorithms for
optimizing the low-rank tensor components.
The overall approach has clear linguistic and
1381
computational advantages:
? Our low dimensional embeddings are tailored
to the syntactic context of words (head, modi-
fier). This low dimensional syntactic abstrac-
tion can be thought of as a proxy to manually
constructed POS tags.
? By automatically selecting a small number of
dimensions useful for parsing, we can lever-
age a wide array of (correlated) features. Un-
like parsers such as MST, we can easily bene-
fit from auxiliary information (e.g., word vec-
tors) appended as features.
We implement the low-rank factorization model
in the context of first- and third-order depen-
dency parsing. The model was evaluated on 14
languages, using dependency data from CoNLL
2008 and CoNLL 2006. We compare our results
against the MST (McDonald et al, 2005a) and
Turbo (Martins et al, 2013) parsers. The low-rank
parser achieves average performance of 89.08%
across 14 languages, compared to 88.73% for the
Turbo parser, and 87.19% for MST. The power of
the low-rank model becomes evident in the ab-
sence of any part-of-speech tags. For instance,
on the English dataset, the low-rank model trained
without POS tags achieves 90.49% on first-order
parsing, while the baseline gets 86.70% if trained
under the same conditions, and 90.58% if trained
with 12 core POS tags. Finally, we demonstrate
that the model can successfully leverage word vec-
tor representations, in contrast to the baselines.
2 Related Work
Selecting Features for Dependency Parsing A
great deal of parsing research has been dedicated
to feature engineering (Lazaridou et al, 2013;
Marton et al, 2010; Marton et al, 2011). While
in most state-of-the-art parsers, features are se-
lected manually (McDonald et al, 2005a; McDon-
ald et al, 2005b; Koo and Collins, 2010; Mar-
tins et al, 2013; Zhang and McDonald, 2012a;
Rush and Petrov, 2012a), automatic feature selec-
tion methods are gaining popularity (Martins et al,
2011b; Ballesteros and Nivre, 2012; Nilsson and
Nugues, 2010; Ballesteros, 2013). Following stan-
dard machine learning practices, these algorithms
iteratively select a subset of features by optimizing
parsing performance on a development set. These
feature selection methods are particularly promis-
ing in parsing scenarios where the optimal feature
set is likely to be a small subset of the original set
of candidate features. Our technique, in contrast,
is suitable for cases where the relevant information
is distributed across a larger set of related features.
Embedding for Dependency Parsing A lot of
recent work has been done on mapping words into
vector spaces (Collobert and Weston, 2008; Turian
et al, 2010; Dhillon et al, 2011; Mikolov et al,
2013). Traditionally, these vector representations
have been derived primarily from co-occurrences
of words within sentences, ignoring syntactic roles
of the co-occurring words. Nevertheless, any such
word-level representation can be used to offset in-
herent sparsity problems associated with full lexi-
calization (Cirik and S?ensoy, 2013). In this sense
they perform a role similar to POS tags.
Word-level vector space embeddings have so
far had limited impact on parsing performance.
From a computational perspective, adding non-
sparse vectors directly as features, including their
combinations, can significantly increase the num-
ber of active features for scoring syntactic struc-
tures (e.g., dependency arc). Because of this is-
sue, Cirik and S?ensoy (2013) used word vectors
only as unigram features (without combinations)
as part of a shift reduce parser (Nivre et al, 2007).
The improvement on the overall parsing perfor-
mance was marginal. Another application of word
vectors is compositional vector grammar (Socher
et al, 2013). While this method learns to map
word combinations into vectors, it builds on ex-
isting word-level vector representations. In con-
trast, we represent words as vectors in a manner
that is directly optimized for parsing. This frame-
work enables us to learn new syntactically guided
embeddings while also leveraging separately esti-
mated word vectors as starting features, leading to
improved parsing performance.
Dimensionality Reduction Many machine
learning problems can be cast as matrix problems
where the matrix represents a set of co-varying
parameters. Such problems include, for example,
multi-task learning and collaborative filtering.
Rather than assuming that each parameter can be
set independently of others, it is helpful to assume
that the parameters vary in a low dimensional
subspace that has to be estimated together with the
parameters. In terms of the parameter matrix, this
corresponds to a low-rank assumption. Low-rank
constraints are commonly used for improving
1382
generalization (Lee and Seung, 1999; Srebro
et al, 2003; Srebro et al, 2004; Evgeniou and
Pontil, 2007)
A strict low-rank assumption can be restrictive.
Indeed, recent approaches to matrix problems de-
compose the parameter matrix as a sum of low-
rank and sparse matrices (Tao and Yuan, 2011;
Zhou and Tao, 2011). The sparse matrix is used to
highlight a small number of parameters that should
vary independently even if most of them lie on
a low-dimensional subspace (Waters et al, 2011;
Chandrasekaran et al, 2011). We follow this de-
composition while extending the parameter matrix
into a tensor.
Tensors are multi-way generalizations of ma-
trices and possess an analogous notion of rank.
Tensors are increasingly used as tools in spec-
tral estimation (Hsu and Kakade, 2013), includ-
ing in parsing (Cohen et al, 2012) and other NLP
problems (de Cruys et al, 2013), where the goal
is to avoid local optima in maximum likelihood
estimation. In contrast, we expand features for
parsing into a multi-way tensor, and operate with
an explicit low-rank representation of the associ-
ated parameter tensor. The explicit representa-
tion sidesteps inherent complexity problems asso-
ciated with the tensor rank (Hillar and Lim, 2009).
Our parameters are divided into a sparse set corre-
sponding to manually chosen MST or Turbo parser
features and a larger set governed by a low-rank
tensor.
3 Problem Formulation
We will commence here by casting first-order de-
pendency parsing as a tensor estimation problem.
We will start by introducing the notation used in
the paper, followed by a more formal description
of our dependency parsing task.
3.1 Basic Notations
Let A ? R
n?n?d
be a 3-dimensional tensor (a 3-
way array). We denote each element of the tensor
as A
i,j,k
where i ? [n], j ? [n], k ? [d] and [n]
is a shorthand for the set of integers {1, 2, ? ? ? , n}.
Similarly, we use M
i,j
and u
i
to represent the ele-
ments of matrix M and vector u, respectively.
We define the inner product of two tensors (or
matrices) as ?A,B? = vec(A)
T
vec(B), where
vec(?) concatenates the tensor (or matrix) ele-
ments into a column vector. The squared norm
of a tensor/matrix is denoted by ?A?
2
= ?A,A?.
The Kronecker product of three vectors is de-
noted by u?v?w and forms a rank-1 tensor such
that
(u? v ? w)
i,j,k
= u
i
v
j
w
k
.
Note that the vectors u, v, and w may be column
or row vectors. Their orientation is defined based
on usage. For example, u ? v is a rank-1 matrix
uv
T
when u and v are column vectors (u
T
v if they
are row vectors).
We say that tensor A is in Kruskal form if
A =
r
?
i=1
U(i, :)? V (i, :)?W (i, :) (1)
where U, V ? R
r?n
, W ? R
r?d
and U(i, :) is the
i
th
row of matrix U . We will directly learn a low-
rank tensor A (because r is small) in this form as
one of our model parameters.
3.2 Dependency Parsing
Let x be a sentence and Y(x) the set of possible
dependency trees over the words in x. We assume
that the score S(x, y) of each candidate depen-
dency tree y ? Y(x) decomposes into a sum of
?local? scores for arcs. Specifically:
S(x, y) =
?
h?m ? y
s(h? m) ?y ? Y(x)
where h ? m is the head-modifier dependency
arc in the tree y. Each y is understood as a col-
lection of arcs h ? m where h and m index
words in x.
2
For example, x(h) is the word cor-
responding to h. We suppress the dependence on
x whenever it is clear from context. For exam-
ple, s(h ? m) can depend on x in complicated
ways as discussed below. The predicted parse is
obtained as y? = arg max
y?Y(x)
S(x, y).
A key problem is how we parameterize the
arc scores s(h ? m). Following the MST
parser (McDonald et al, 2005a) we can define
rich features characterizing each head-modifier
arc, compiled into a sparse binary vector ?
h?m
?
R
L
that depends on the sentence x as well as the
chosen arc h? m (again, we suppress the depen-
dence on x). Based on this feature representation,
we define the score of each arc as s
?
(h ? m) =
2
Note that in the case of high-order parsing, the sum
S(x, y) may also include local scores for other syntactic
structures, such as grandhead-head-modifier score s(g ?
h ? m). See (Martins et al, 2013) for a complete list of
these structures.
1383
Unigram features:
form form-p form-n
lemma lemma-p lemma-n
pos pos-p pos-n
morph bias
Bigram features:
pos-p, pos
pos, pos-n
pos, lemma
morph, lemma
Trigram features:
pos-p, pos, pos-n
Table 1: Word feature templates used by our
model. pos, form, lemma and morph stand for
the fine POS tag, word form, word lemma and the
morphology feature (provided in CoNLL format
file) of the current word. There is a bias term that
is always active for any word. The suffixes -p and
-n refer to the left and right of the current word re-
spectively. For example, pos-p means the POS tag
to the left of the current word in the sentence.
??, ?
h?m
? where ? ? R
L
represent adjustable pa-
rameters to be learned, and L is the number of pa-
rameters (and possible features in ?
h?m
).
We can alternatively specify arc features in
terms of rank-1 tensors by taking the Kronecker
product of simpler feature vectors associated with
the head (vector ?
h
? R
n
), and modifier (vector
?
m
? R
n
), as well as the arc itself (vector ?
h,m
?
R
d
). Here ?
h,m
is much lower dimensional than
the MST arc feature vector ?
h?m
discussed ear-
lier. For example, ?
h,m
may be composed of only
indicators for binned arc lengths
3
. ?
h
and ?
m
, on
the other hand, are built from features shown in
Table 1. By taking the cross-product of all these
component feature vectors, we obtain the full fea-
ture representation for arc h? m as a rank-1 ten-
sor
?
h
? ?
m
? ?
h,m
? R
n?n?d
Note that elements of this rank-1 tensor include
feature combinations that are not part of the fea-
ture crossings in ?
h?m
. In this sense, the rank-1
tensor represents a substantial feature expansion.
The arc score s
tensor
(h? m) associated with the
3
In our current version, ?
h,m
only contains the binned
arc length. Other possible features include, for example, the
label of the arc h ? m, the POS tags between the head and
the modifier, boolean flags which indicate the occurence of
in-between punctutations or conjunctions, etc.
tensor representation is defined analogously as
s
tensor
(h? m) = ?A, ?
h
? ?
m
? ?
h,m
?
where the adjustable parametersA also form a ten-
sor. Given the typical dimensions of the compo-
nent feature vectors, ?
h
, ?
m
, ?
h,m
, it is not even
possible to store all the parameters in A. Indeed,
in the full English training set of CoNLL-2008, the
tensor involves around 8 ? 10
11
entries while the
MST feature vector has approximately 1.5 ? 10
7
features. To counter this feature explosion, we re-
strict the parameters A to have low rank.
Low-Rank Dependency Scoring We can repre-
sent a rank-r tensor A explicitly in terms of pa-
rameter matrices U , V , and W as shown in Eq. 1.
As a result, the arc score for the tensor reduces to
evaluating U?
h
, V ?
m
, and W?
h,m
which are all
r dimensional vectors and can be computed effi-
ciently based on any sparse vectors ?
h
, ?
m
, and
?
h,m
. The resulting arc score s
tensor
(h ? m) is
then
r
?
i=1
[U?
h
]
i
[V ?
m
]
i
[W?
h,m
]
i
(2)
By learning parameters U , V , andW that function
well in dependency parsing, we also learn context-
dependent embeddings for words and arcs. Specif-
ically,U?
h
(for a given sentence, suppressed) is an
r dimensional vector representation of the word
corresponding to h as a head word. Similarly,
V ?
m
provides an analogous representation for a
modifier m. Finally, W?
h,m
is a vector embed-
ding of the supplemental arc-dependent informa-
tion. The resulting embedding is therefore tied
to the syntactic roles of the words (and arcs), and
learned in order to perform well in parsing.
We expect a dependency parsing model to ben-
efit from several aspects of the low-rank tensor
scoring. For example, we can easily incorpo-
rate additional useful features in the feature vec-
tors ?
h
, ?
m
and ?
h,m
, since the low-rank assump-
tion (for small enough r) effectively counters the
otherwise uncontrolled feature expansion. More-
over, by controlling the amount of information
we can extract from each of the component fea-
ture vectors (via rank r), the statistical estimation
problem does not scale dramatically with the di-
mensions of ?
h
, ?
m
and ?
h,m
. In particular, the
low-rank constraint can help generalize to unseen
arcs. Consider a feature ?(x(h) = a) ? ?(x(m) =
1384
b) ? ?(dis(x, h,m) = c) which is non-zero only
for an arc a ? b with distance c in sentence x.
If the arc has not been seen in the available train-
ing data, it does not contribute to the traditional
arc score s
?
(?). In contrast, with the low-rank con-
straint, the arc score in Eq. 2 would typically be
non-zero.
Combined Scoring Our parsing model aims to
combine the strengths of both traditional features
from the MST/Turbo parser as well as the new
low-rank tensor features. In this way, our model
is able to capture a wide range of information in-
cluding the auxiliary features without having un-
controlled feature explosion, while still having the
full accessibility to the manually engineered fea-
tures that are proven useful. Specifically, we de-
fine the arc score s
?
(h? m) as the combination
(1? ?)s
tensor
(h? m) + ?s
?
(h? m)
= (1? ?)
r
?
i=1
[U?
h
]
i
[V ?
m
]
i
[W?
h,m
]
i
+ ? ??, ?
h?m
? (3)
where ? ? R
L
, U ? R
r?n
, V ? R
r?n
, and W ?
R
r?d
are the model parameters to be learned. The
rank r and ? ? [0, 1] (balancing the two scores)
represent hyper-parameters in our model.
4 Learning
The training set D = {(x?
i
, y?
i
)}
N
i=1
consists of N
pairs, where each pair consists of a sentence x
i
and the corresponding gold (target) parse y
i
. The
goal is to learn values for the parameters ?, U , V
and W that optimize the combined scoring func-
tion S
?
(x, y) =
?
h?m?y
s
?
(h ? m), defined
in Eq. 3, for parsing performance. We adopt a
maximum soft-margin framework for this learning
problem. Specifically, we find parameters ?, U , V ,
W , and {?
i
} that minimize
C
?
i
?
i
+ ???
2
+ ?U?
2
+ ?V ?
2
+ ?W?
2
s.t. S
?
(x?
i
, y?
i
) ? S
?
(x?
i
, y
i
) + ?y?
i
? y
i
?
1
? ?
i
?y
i
? Y(x?
i
), ?i. (4)
where ?y?
i
?y
i
?
1
is the number of mismatched arcs
between the two trees, and ?
i
is a non-negative
slack variable. The constraints serve to separate
the gold tree from other alternatives in Y(x?
i
) with
a margin that increases with distance.
The objective as stated is not jointly convex
with respect to U , V and W due to our explicit
representation of the low-rank tensor. However, if
we fix any two sets of parameters, for example, if
we fix V andW , then the combined score S
?
(x, y)
will be a linear function of both ? and U . As a re-
sult, the objective will be jointly convex with re-
spect to ? and U and could be optimized using
standard tools. However, to accelerate learning,
we adopt an online learning setup. Specifically,
we use the passive-aggressive learning algorithm
(Crammer et al, 2006) tailored to our setting, up-
dating pairs of parameter sets, (?, U), (?, V ) and
(?,W ) in an alternating manner. This method is
described below.
Online Learning In an online learning setup,
we update parameters successively based on each
sentence. In order to apply the passive-aggressive
algorithm, we fix two of U , V and W (say, for ex-
ample, V and W ) in an alternating manner, and
apply a closed-form update to the remaining pa-
rameters (here U and ?). This is possible since
the objective function with respect to (?, U) has a
similar form as in the original passive-aggressive
algorithm. To illustrate this, consider a training
sentence x
i
. The update involves finding first the
best competing tree,
y?
i
= arg max
y
i
?Y(x?
i
)
S
?
(x?
i
, y
i
) + ?y?
i
? y
i
?
1
(5)
which is the tree that violates the constraint in
Eq. 4 most (i.e. maximizes the loss ?
i
). We then
obtain parameter increments ?? and ?U by solv-
ing
min
??, ?U, ??0
1
2
????
2
+
1
2
??U?
2
+ C?
s.t. S
?
(x?
i
, y?
i
) ? S
?
(x?
i
, y?
i
) + ?y?
i
? y?
i
?
1
? ?
In this way, the optimization problem attempts to
keep the parameter change as small as possible,
while forcing it to achieve mostly zero loss on this
single instance. This problem has a closed form
solution
?? = min
{
C,
loss
?
2
?d??
2
+ (1? ?)
2
?du?
2
}
?d?
?U = min
{
C,
loss
?
2
?d??
2
+ (1? ?)
2
?du?
2
}
(1? ?)du
1385
where
loss = S
?
(x?
i
, y?
i
) + ?y?
i
? y?
i
?
1
? S
?
(x?
i
, y?
i
)
d? =
?
h?m ? y?
i
?
h?m
?
?
h?m ? y?
i
?
h?m
du =
?
h?m ? y?
i
[(V ?
m
) (W?
h,m
)]? ?
h
?
?
h?m ? y?
i
[(V ?
m
) (W?
h,m
)]? ?
h
where (u v)
i
= u
i
v
i
is the Hadamard (element-
wise) product. The magnitude of change of ? and
U is controlled by the parameterC. By varyingC,
we can determine an appropriate step size for the
online updates. The updates also illustrate how ?
balances the effect of the MST component of the
score relative to the low-rank tensor score. When
? = 0, the arc scores are entirely based on the low-
rank tensor and ?? = 0. Note that ?
h
, ?
m
, ?
h,m
,
and ?
h?m
are typically very sparse for each word
or arc. Therefore du and d? are also sparse and
can be computed efficiently.
Initialization The alternating online algorithm
relies on how we initializeU , V , andW since each
update is carried out in the context of the other
two. A random initialization of these parameters is
unlikely to work well, both due to the dimensions
involved, and the nature of the alternating updates.
We consider here instead a reasonable determinis-
tic ?guess? as the initialization method.
We begin by training our model without any
low-rank parameters, and obtain parameters ?.
The majority of features in this MST component
can be expressed as elements of the feature ten-
sor, i.e., as [?
h
? ?
m
? ?
h,m
]
i,j,k
. We can there-
fore create a tensor representation of ? such that
B
i,j,k
equals the corresponding parameter value
in ?. We use a low-rank version of B as the ini-
tialization. Specifically, we unfold the tensor B
into a matrix B
(h)
of dimensions n and nd, where
n = dim(?
h
) = dim(?
m
) and d = dim(?
h,m
).
For instance, a rank-1 tensor can be unfolded as
u ? v ? w = u ? vec(v ? w). We compute the
top-r SVD of the resulting unfolded matrix such
that B
(h)
= P
T
SQ. U is initialized as P . Each
right singular vector S
i
Q(i, :) is also a matrix in
R
n?d
. The leading left and right singular vectors
of this matrix are assigned to V (i, :) and W (i, :)
respectively. In our implementation, we run one
epoch of our model without low-rank parameters
and initialize the tensor A.
Parameter Averaging The passive-aggressive
algorithm regularizes the increments (e.g. ?? and
?U ) during each update but does not include any
overall regularization. In other words, keeping up-
dating the model may lead to large parameter val-
ues and over-fitting. To counter this effect, we use
parameter averaging as used in the MST and Turbo
parsers. The final parameters are those averaged
across all the iterations (cf. (Collins, 2002)). For
simplicity, in our algorithm we average U , V , W
and ? separately, which works well empirically.
5 Experimental Setup
Datasets We test our dependency model on 14
languages, including the English dataset from
CoNLL 2008 shared tasks and all 13 datasets from
CoNLL 2006 shared tasks (Buchholz and Marsi,
2006; Surdeanu et al, 2008). These datasets in-
clude manually annotated dependency trees, POS
tags and morphological information. Following
standard practices, we encode this information as
features.
Methods We compare our model to MST and
Turbo parsers on non-projective dependency pars-
ing. For our parser, we train both a first-order
parsing model (as described in Section 3 and 4)
as well as a third-order model. The third order
parser simply adds high-order features, those typ-
ically used in MST and Turbo parsers, into our
s
?
(x, y) = ??, ?(x, y)? scoring component. The
decoding algorithm for the third-order parsing is
based on (Zhang et al, 2014). For the Turbo
parser, we directly compare with the recent pub-
lished results in (Martins et al, 2013). For the
MST parser, we train and test using the most re-
cent version of the code.
4
In addition, we im-
plemented two additional baselines, NT-1st (first
order) and NT-3rd (third order), corresponding to
our model without the tensor component.
Features For the arc feature vector ?
h?m
, we
use the same set of feature templates as MST
v0.5.1. For head/modifier vector ?
h
and ?
m
, we
show the complete set of feature templates used
by our model in Table 1. Finally, we use a similar
set of feature templates as Turbo v2.1 for 3rd order
parsing.
To add auxiliary word vector representations,
we use the publicly available word vectors (Cirik
4
http://sourceforge.net/projects/mstparser/
1386
First-order only High-order
Ours NT-1st MST Turbo Ours-3rd NT-3rd MST-2nd Turbo-3rd Best Published
Arabic 79.60 78.71 78.3 77.23 79.95 79.53 78.75 79.64 81.12 (Ma11)
Bulgarian 92.30 91.14 90.98 91.76 93.50 92.79 91.56 93.1 94.02 (Zh13)
Chinese 91.43 90.85 90.40 88.49 92.68 92.39 91.77 89.98 91.89 (Ma10)
Czech 87.90 86.62 86.18 87.66 90.50 89.43 87.3 90.32 90.32 (Ma13)
Danish 90.64 89.80 89.84 89.42 91.39 90.82 90.5 91.48 92.00 (Zh13)
Dutch 84.81 83.77 82.89 83.61 86.41 86.08 84.11 86.19 86.19 (Ma13)
English 91.84 91.40 90.59 91.21 93.02 92.82 91.54 93.22 93.22 (Ma13)
German 90.24 89.70 89.54 90.52 91.97 92.26 90.14 92.41 92.41 (Ma13)
Japanese 93.74 93.36 93.38 92.78 93.71 93.23 92.92 93.52 93.72 (Ma11)
Portuguese 90.94 90.67 89.92 91.14 91.92 91.63 91.08 92.69 93.03 (Ko10)
Slovene 84.25 83.15 82.09 82.81 86.24 86.07 83.25 86.01 86.95 (Ma11)
Spanish 85.27 84.95 83.79 83.61 88.00 87.47 84.33 85.59 87.96 (Zh13)
Swedish 89.86 89.66 88.27 89.36 91.00 90.83 89.05 91.14 91.62 (Zh13)
Turkish 75.84 74.89 74.81 75.98 76.84 75.83 74.39 76.9 77.55 (Ko10)
Average 87.76 87.05 86.5 86.83 89.08 88.66 87.19 88.73 89.43
Table 2: First-order parsing (left) and high-order parsing (right) results on CoNLL-2006 datasets and the
English dataset of CoNLL-2008. For our model, the experiments are ran with rank r = 50 and hyper-
parameter ? = 0.3. To remove the tensor in our model, we ran experiments with ? = 1, corresponding
to columns NT-1st and NT-3rd. The last column shows results of most accurate parsers among Nivre et
al. (2006), McDonald et al (2006), Martins et al (2010), Martins et al (2011a), Martins et al (2013),
Koo et al (2010), Rush and Petrov (2012b), Zhang and McDonald (2012b) and Zhang et al (2013).
and S?ensoy, 2013), learned from raw data (Glober-
son et al, 2007; Maron et al, 2010). Three
languages in our dataset ? English, German and
Swedish ? have corresponding word vectors in this
collection.
5
The dimensionality of this representa-
tion varies by language: English has 50 dimen-
sional word vectors, while German and Swedish
have 25 dimensional word vectors. Each entry of
the word vector is added as a feature value into
feature vectors ?
h
and ?
m
. For each word in the
sentence, we add its own word vector as well as
the vectors of its left and right words.
We should note that since our model parameter
A is represented and learned in the low-rank form,
we only have to store and maintain the low-rank
projections U?
h
, V ?
m
andW?
h,m
rather than ex-
plicitly calculate the feature tensor ?
h
??
m
??
h,m
.
Therefore updating parameters and decoding a
sentence is still efficient, i.e., linear in the num-
ber of values of the feature vector. In contrast,
assume we take the cross-product of the auxiliary
word vector values, POS tags and lexical items of
a word and its context, and add the crossed val-
ues into a normal model (in ?
h?m
). The number
of features for each arc would be at least quadratic,
growing into thousands, and would be a significant
impediment to parsing efficiency.
Evaluation Following standard practices, we
train our full model and the baselines for 10
5
https://github.com/wolet/sprml13-word-embeddings
epochs. As the evaluation measure, we use un-
labeled attachment scores (UAS) excluding punc-
tuation. In all the reported experiments, the hyper-
parameters are set as follows: r = 50 (rank of the
tensor), C = 1 for first-order model and C = 0.01
for third-order model.
6 Results
Overall Performance Table 2 shows the per-
formance of our model and the baselines on 14
CoNLL datasets. Our model outperforms Turbo
parser, MST parser, as well as its own variants
without the tensor component. The improvements
of our low-rank model are consistent across lan-
guages: results for the first order parser are better
on 11 out of 14 languages. By comparing NT-1st
and NT-3rd (models without low-rank) with our
full model (with low-rank), we obtain 0.7% abso-
lute improvement on first-order parsing, and 0.3%
improvement on third-order parsing. Our model
also achieves the best UAS on 5 languages.
We next focus on the first-order model and
gauge the impact of the tensor component. First,
we test our model by varying the hyper-parameter
? which balances the tensor score and the tradi-
tional MST/Turbo score components. Figure 1
shows the average UAS on CoNLL test datasets
after each training epoch. We can see that the im-
provement of adding the low-rank tensor is con-
sistent across various choices of hyper parame-
1387
2 4 6 8 1084.0%
84.5%
85.0%
85.5%
86.0%
86.5%
87.0%
87.5%
88.0%
# Epochs 
 
?=0.0?=0.2?=0.3?=0.4NT?1st
Figure 1: Average UAS on CoNLL testsets af-
ter different epochs. Our full model consistently
performs better than NT-1st (its variation without
tensor component) under different choices of the
hyper-parameter ?.
no word vector with word vector
English 91.84 92.07
German 90.24 90.48
Swedish 89.86 90.38
Table 3: Results of adding unsupervised word vec-
tors to the tensor. Adding this information yields
consistent improvement for all languages.
ter ?. When training with the tensor component
alone (? = 0), the model converges more slowly.
Learning of the tensor is harder because the scor-
ing function is not linear (nor convex) with respect
to parameters U , V and W . However, the tensor
scoring component achieves better generalization
on the test data, resulting in better UAS than NT-
1st after 8 training epochs.
To assess the ability of our model to incorpo-
rate a range of features, we add unsupervised word
vectors to our model. As described in previous
section, we do so by appending the values of dif-
ferent coordinates in the word vector into ?
h
and
?
m
. As Table 3 shows, adding this information in-
creases the parsing performance for all the three
languages. For instance, we obtain more than
0.5% absolute improvement on Swedish.
Syntactic Abstraction without POS Since our
model learns a compressed representation of fea-
ture vectors, we are interested to measure its per-
formance when part-of-speech tags are not pro-
vided (See Table 4). The rationale is that given all
other features, the model would induce representa-
tions that play a similar role to POS tags. Note that
Our model NT-1st
-POS +wv. -POS +POS
English 88.89 90.49 86.70 90.58
German 82.63 85.80 78.71 88.50
Swedish 81.84 85.90 79.65 88.75
Table 4: The first three columns show parsing re-
sults when models are trained without POS tags.
The last column gives the upper-bound, i.e. the
performance of a parser trained with 12 Core POS
tags. The low-rank model outperforms NT-1st by
a large margin. Adding word vector features fur-
ther improves performance.
the performance of traditional parsers drops when
tags are not provided. For example, the perfor-
mance gap is 10% on German. Our experiments
show that low-rank parser operates effectively in
the absence of tags. In fact, it nearly reaches the
performance of the original parser that used the
tags on English.
Examples of Derived Projections We manu-
ally analyze low-dimensional projections to assess
whether they capture syntactic abstraction. For
this purpose, we train a model with only a ten-
sor component (such that it has to learn an accu-
rate tensor) on the English dataset and obtain low
dimensional embeddings U?
w
and V ?
w
for each
word. The two r-dimension vectors are concate-
nated as an ?averaged? vector. We use this vector
to calculate the cosine similarity between words.
Table 5 shows examples of five closest neighbors
of queried words. While these lists include some
noise, we can clearly see that the neighbors ex-
hibit similar syntactic behavior. For example, ?on?
is close to other prepositions. More interestingly,
we can consider the impact of syntactic context
on the derived projections. The bottom part of
Table 5 shows that the neighbors change substan-
tially depending on the syntactic role of the word.
For example, the closest words to the word ?in-
crease? are verbs in the context phrase ?will in-
crease again?, while the closest words become
nouns given a different phrase ?an increase of?.
Running Time Table 6 illustrates the impact of
estimating low-rank tensor parameters on the run-
ning time of the algorithm. For comparison, we
also show the NT-1st times across three typical
languages. The Arabic dataset has the longest av-
erage sentence length, while the Chinese dataset
1388
greatly profit says on when
actively earnings adds with where
openly franchisees predicts into what
significantly shares noted at why
outright revenue wrote during which
substantially members contends over who
increase will increase again an increase of
rise arguing gain
advance be prices
contest charging payment
halt gone members
Exchequer making subsidiary
hit attacks hit the hardest hit is
shed distributes monopolies
rallied stayed pills
triggered sang sophistication
appeared removed ventures
understate eased factors
Table 5: Five closest neighbors of the queried
words (shown in bold). The upper part shows our
learned embeddings group words with similar syn-
tactic behavior. The two bottom parts of the table
demonstrate that how the projections change de-
pending on the syntactic context of the word.
#Tok. Len.
Train. Time (hour)
NT-1st Ours
Arabic 42K 32 0.13 0.22
Chinese 337K 6 0.37 0.65
English 958K 24 1.88 2.83
Table 6: Comparison of training times across three
typical datasets. The second column is the number
of tokens in each data set. The third column shows
the average sentence length. Both first-order mod-
els are implemented in Java and run as a single
process.
has the shortest sentence length in CoNLL 2006.
Based on these results, estimating a rank-50 tensor
together with MST parameters only increases the
running time by a factor of 1.7.
7 Conclusions
Accurate scoring of syntactic structures such as
head-modifier arcs in dependency parsing typi-
cally requires rich, high-dimensional feature rep-
resentations. We introduce a low-rank factoriza-
tion method that enables to map high dimensional
feature vectors into low dimensional representa-
tions. Our method maintains the parameters as a
low-rank tensor to obtain low dimensional repre-
sentations of words in their syntactic roles, and to
leverage modularity in the tensor for easy train-
ing with online algorithms. We implement the
approach on first-order to third-order dependency
parsing. Our parser outperforms the Turbo and
MST parsers across 14 languages.
Future work involves extending the tensor com-
ponent to capture higher-order structures. In par-
ticular, we would consider second-order structures
such as grandparent-head-modifier by increasing
the dimensionality of the tensor. This tensor will
accordingly be a four or five-way array. The online
update algorithm remains applicable since each di-
mension is optimized in an alternating fashion.
8 Acknowledgements
The authors acknowledge the support of the MURI
program (W911NF-10-1-0533) and the DARPA
BOLT program. This research is developed in col-
laboration with the Arabic Language Technoligies
(ALT) group at Qatar Computing Research Insti-
tute (QCRI) within the LYAS project. We thank
Volkan Cirik for sharing the unsupervised word
vector data. Thanks to Amir Globerson, Andreea
Gane, the members of the MIT NLP group and
the ACL reviewers for their suggestions and com-
ments. Any opinions, findings, conclusions, or
recommendations expressed in this paper are those
of the authors, and do not necessarily reflect the
views of the funding organizations.
References
Miguel Ballesteros and Joakim Nivre. 2012. Mal-
tOptimizer: An optimization tool for MaltParser. In
EACL. The Association for Computer Linguistics.
Miguel Ballesteros. 2013. Effective morpholog-
ical feature selection with MaltOptimizer at the
SPMRL 2013 shared task. In Proceedings of
the Fourth Workshop on Statistical Parsing of
Morphologically-Rich Languages. Association for
Computational Linguistics.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings of the Tenth Conference on Computa-
tional Natural Language Learning, CoNLL-X ?06.
Association for Computational Linguistics.
Venkat Chandrasekaran, Sujay Sanghavi, Pablo A Par-
rilo, and Alan S Willsky. 2011. Rank-sparsity in-
coherence for matrix decomposition. SIAM Journal
on Optimization.
Volkan Cirik and H?usn?u S?ensoy. 2013. The AI-KU
system at the SPMRL 2013 shared task : Unsuper-
vised features for dependency parsing. In Proceed-
ings of the Fourth Workshop on Statistical Parsing of
Morphologically-Rich Languages. Association for
Computational Linguistics.
1389
Shay B Cohen, Karl Stratos, Michael Collins, Dean P
Foster, and Lyle Ungar. 2012. Spectral learning of
latent-variable PCFGs. In Proceedings of the 50th
Annual Meeting of the Association for Computa-
tional Linguistics: Long Papers-Volume 1. Associ-
ation for Computational Linguistics.
Michael Collins. 2002. Discriminative training meth-
ods for hidden markov models: Theory and exper-
iments with perceptron algorithms. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing - Volume 10, EMNLP ?02. As-
sociation for Computational Linguistics.
R. Collobert and J. Weston. 2008. A unified architec-
ture for natural language processing: Deep neural
networks with multitask learning. In International
Conference on Machine Learning, ICML.
Koby Crammer, Ofer Dekel, Joseph Keshet, Shai
Shalev-Shwartz, and Yoram Singer. 2006. Online
passive-aggressive algorithms. The Journal of Ma-
chine Learning Research.
Tim Van de Cruys, Thierry Poibeau, and Anna Korho-
nen. 2013. A tensor-based factorization model of
semantic compositionality. In HLT-NAACL. The As-
sociation for Computational Linguistics.
Paramveer S. Dhillon, Dean Foster, and Lyle Ungar.
2011. Multiview learning of word embeddings via
CCA. In Advances in Neural Information Process-
ing Systems.
A Evgeniou and Massimiliano Pontil. 2007. Multi-
task feature learning. In Advances in neural infor-
mation processing systems: Proceedings of the 2006
conference. The MIT Press.
Amir Globerson, Gal Chechik, Fernando Pereira, and
Naftali Tishby. 2007. Euclidean embedding of co-
occurrence data. Journal of Machine Learning Re-
search.
Christopher Hillar and Lek-Heng Lim. 2009. Most
tensor problems are NP-hard. arXiv preprint
arXiv:0911.1393.
Daniel Hsu and Sham M Kakade. 2013. Learning mix-
tures of spherical gaussians: moment methods and
spectral decompositions. In Proceedings of the 4th
Conference on Innovations in Theoretical Computer
Science. ACM.
Terry Koo and Michael Collins. 2010. Efficient third-
order dependency parsers. In Proceedings of the
48th Annual Meeting of the Association for Compu-
tational Linguistics, ACL ?10. Association for Com-
putational Linguistics.
Terry Koo, Alexander M Rush, Michael Collins,
Tommi Jaakkola, and David Sontag. 2010. Dual
decomposition for parsing with non-projective head
automata. In Proceedings of the 2010 Conference on
Empirical Methods in Natural Language Process-
ing. Association for Computational Linguistics.
Angeliki Lazaridou, Eva Maria Vecchi, and Marco
Baroni. 2013. Fish transporters and miracle
homes: How compositional distributional semantics
can help NP parsing. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics.
Daniel D Lee and H Sebastian Seung. 1999. Learning
the parts of objects by non-negative matrix factor-
ization. Nature.
Yariv Maron, Michael Lamar, and Elie Bienenstock.
2010. Sphere embedding: An application to part-
of-speech induction. In Advances in Neural Infor-
mation Processing Systems.
Andr?e FT Martins, Noah A Smith, Eric P Xing, Pe-
dro MQ Aguiar, and M?ario AT Figueiredo. 2010.
Turbo parsers: Dependency parsing by approximate
variational inference. In Proceedings of the 2010
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics.
Andr?e F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and M?ario A. T. Figueiredo. 2011a. Dual
decomposition with many overlapping components.
In Proceedings of the Conference on Empirical
Methods in Natural Language Processing, EMNLP
?11. Association for Computational Linguistics.
Andr?e FT Martins, Noah A Smith, Pedro MQ Aguiar,
and M?ario AT Figueiredo. 2011b. Structured spar-
sity in structured prediction. In Proceedings of the
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics.
Andr?e FT Martins, Miguel B Almeida, and Noah A
Smith. 2013. Turning on the turbo: Fast third-order
non-projective turbo parsers. In Proceedings of the
51th Annual Meeting of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics.
Yuval Marton, Nizar Habash, and Owen Rambow.
2010. Improving arabic dependency parsing with
lexical and inflectional morphological features. In
Proceedings of the NAACL HLT 2010 First Work-
shop on Statistical Parsing of Morphologically-Rich
Languages, SPMRL ?10. Association for Computa-
tional Linguistics.
Yuval Marton, Nizar Habash, and Owen Rambow.
2011. Improving arabic dependency parsing with
form-based and functional morphological features.
In Proceedings of the 49th Annual Meeting of the
Association for Computational Linguistics: Human
Language Technologies. Association for Computa-
tional Linguistics.
Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005a. Online large-margin training of de-
pendency parsers. In Proceedings of the 43rd An-
nual Meeting of the Association for Computational
Linguistics (ACL?05).
1390
Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Haji?c. 2005b. Non-projective dependency pars-
ing using spanning tree algorithms. In Proceedings
of the conference on Human Language Technology
and Empirical Methods in Natural Language Pro-
cessing. Association for Computational Linguistics.
Ryan McDonald, Kevin Lerman, and Fernando Pereira.
2006. Multilingual dependency analysis with a
two-stage discriminative parser. In Proceedings
of the Tenth Conference on Computational Natural
Language Learning. Association for Computational
Linguistics.
Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. 2013. Efficient estimation of word represen-
tations in vector space. CoRR.
Peter Nilsson and Pierre Nugues. 2010. Automatic
discovery of feature sets for dependency parsing. In
Proceedings of the 23rd International Conference
on Computational Linguistics (Coling 2010). Coling
2010 Organizing Committee.
Joakim Nivre, Johan Hall, Jens Nilsson, G?uls?en Eryiit,
and Svetoslav Marinov. 2006. Labeled pseudo-
projective dependency parsing with support vector
machines. In Proceedings of the Tenth Conference
on Computational Natural Language Learning. As-
sociation for Computational Linguistics.
Joakim Nivre, Johan Hall, Jens Nilsson, Atanas
Chanev, G?ulsen Eryigit, Sandra K?ubler, Svetoslav
Marinov, and Erwin Marsi. 2007. MaltParser: A
language-independent system for data-driven depen-
dency parsing. Natural Language Engineering.
Alexander Rush and Slav Petrov. 2012a. Vine pruning
for efficient multi-pass dependency parsing. In The
2012 Conference of the North American Chapter of
the Association for Computational Linguistics: Hu-
man Language Technologies (NAACL ?12).
Alexander M Rush and Slav Petrov. 2012b. Vine prun-
ing for efficient multi-pass dependency parsing. In
Proceedings of the 2012 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies.
Association for Computational Linguistics.
Richard Socher, John Bauer, Christopher D. Manning,
and Andrew Y. Ng. 2013. Parsing with compo-
sitional vector grammars. In Proceedings of the
51th Annual Meeting of the Association for Compu-
tational Linguistics.
Nathan Srebro, Tommi Jaakkola, et al 2003. Weighted
low-rank approximations. In ICML.
Nathan Srebro, Jason Rennie, and Tommi S Jaakkola.
2004. Maximum-margin matrix factorization. In
Advances in neural information processing systems.
Mihai Surdeanu, Richard Johansson, Adam Meyers,
Llu??s M`arquez, and Joakim Nivre. 2008. The
CoNLL-2008 shared task on joint parsing of syn-
tactic and semantic dependencies. In Proceedings
of the Twelfth Conference on Computational Natu-
ral Language Learning, CoNLL ?08. Association for
Computational Linguistics.
Min Tao and Xiaoming Yuan. 2011. Recovering low-
rank and sparse components of matrices from in-
complete and noisy observations. SIAM Journal on
Optimization.
Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010.
Word representations: A simple and general method
for semi-supervised learning. In Proceedings of the
48th Annual Meeting of the Association for Compu-
tational Linguistics, ACL ?10. Association for Com-
putational Linguistics.
Andrew E Waters, Aswin C Sankaranarayanan, and
Richard Baraniuk. 2011. SpaRCS: Recovering low-
rank and sparse matrices from compressive mea-
surements. In Advances in Neural Information Pro-
cessing Systems.
Hao Zhang and Ryan McDonald. 2012a. Generalized
higher-order dependency parsing with cube prun-
ing. In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learn-
ing, EMNLP-CoNLL ?12. Association for Compu-
tational Linguistics.
Hao Zhang and Ryan McDonald. 2012b. Generalized
higher-order dependency parsing with cube prun-
ing. In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learning.
Association for Computational Linguistics.
Hao Zhang, Liang Huang Kai Zhao, and Ryan McDon-
ald. 2013. Online learning for inexact hypergraph
search. In Proceedings of EMNLP.
Yuan Zhang, Tao Lei, Regina Barzilay, Tommi
Jaakkola, and Amir Globerson. 2014. Steps to ex-
cellence: Simple inference with refined scoring of
dependency trees. In Proceedings of the 52th An-
nual Meeting of the Association for Computational
Linguistics. Association for Computational Linguis-
tics.
Tianyi Zhou and Dacheng Tao. 2011. Godec: Ran-
domized low-rank & sparse matrix decomposition in
noisy case. In Proceedings of the 28th International
Conference on Machine Learning (ICML-11).
1391
