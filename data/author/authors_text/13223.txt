Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 91?100,
Singapore, 6-7 August 2009. c?2009 ACL and AFNLP
Efficient kernels for sentence pair classification
Fabio Massimo Zanzotto
DISP
University of Rome ?Tor Vergata?
Via del Politecnico 1
00133 Roma, Italy
zanzotto@info.uniroma2.it
Lorenzo Dell?Arciprete
University of Rome ?Tor Vergata?
Via del Politecnico 1
00133 Roma, Italy
lorenzo.dellarciprete@gmail.com
Abstract
In this paper, we propose a novel class
of graphs, the tripartite directed acyclic
graphs (tDAGs), to model first-order rule
feature spaces for sentence pair classifi-
cation. We introduce a novel algorithm
for computing the similarity in first-order
rewrite rule feature spaces. Our algorithm
is extremely efficient and, as it computes
the similarity of instances that can be rep-
resented in explicit feature spaces, it is a
valid kernel function.
1 Introduction
Natural language processing models are generally
positive combinations between linguistic models
and automatically learnt classifiers. As trees are
extremely important in many linguistic theories, a
large amount of works exploiting machine learn-
ing algorithms for NLP tasks has been developed
for this class of data structures (Collins and Duffy,
2002; Moschitti, 2004). These works propose ef-
ficient algorithms for determining the similarity
among two trees in tree fragment feature spaces.
Yet, some NLP tasks such as textual entail-
ment recognition (Dagan and Glickman, 2004;
Dagan et al, 2006) and some linguistic theories
such as HPSG (Pollard and Sag, 1994) require
more general graphs and, then, more general al-
gorithms for computing similarity among graphs.
Unfortunately, algorithms for computing similar-
ity among two general graphs in term of com-
mon subgraphs are still exponential (Ramon and
Ga?rtner, 2003). In these cases, approximated al-
gorithms have been proposed. For example, the
one proposed in (Ga?rtner, 2003) counts the num-
ber of subpaths in common. The same happens for
the one proposed in (Suzuki et al, 2003) that is
applicable to a particular class of graphs, i.e. the
hierarchical directed acyclic graphs. These algo-
rithms do not compute the number of subgraphs
in common between two graphs. Then, these al-
gorithms approximate the feature spaces we need
in these NLP tasks. For computing similarities in
these feature spaces, we have to investigate if we
can define a particular class of graphs for the class
of tasks we want to solve. Once we focused the
class of graph, we can explore efficient similarity
algorithms.
A very important class of graphs can be de-
fined for tasks involving sentence pairs. In these
cases, an important class of feature spaces is the
one that represents first-order rewrite rules. For
example, in textual entailment recognition (Da-
gan et al, 2006), we need to determine whether
a text T implies a hypothesis H , e.g., whether or
not ?Farmers feed cows animal extracts? entails
?Cows eat animal extracts? (T
1
,H
1
). If we want
to learn textual entailment classifiers, we need
to exploit first-order rules hidden in training in-
stances. To positively exploit the training instance
?Pediatricians suggest women to feed newborns
breast milk? entails ?Pediatricians suggest that
newborns eat breast milk? (T
2
,H
2
) for classify-
ing the above example, learning algorithms should
learn that the two instances hide the first-order rule
? = feed
Y Z
?
Y
eat
Z . The first-order
rule feature space, introduced by (Zanzotto and
Moschitti, 2006), gives high performances in term
of accuracy for textual entailment recognition with
respect to other features spaces.
In this paper, we propose a novel class of
graphs, the tripartite directed acyclic graphs
(tDAGs), that model first-order rule feature spaces
and, using this class of graphs, we introduce a
novel algorithm for computing the similarity in
first-order rewrite rule feature spaces. The possi-
bility of explicitly representing the first-order fea-
ture space as subgraphs of tDAGs makes the de-
rived similarity function a valid kernel. With re-
spect to the algorithm proposed in (Moschitti and
Zanzotto, 2007), our algorithm is more efficient
91
and it is a valid kernel function.
The paper is organized as follows. In Sec. 2,
we firstly describe tripartite directed acyclic
graphs (tDAGs) to model first-order feature (FOR)
spaces. In Sec. 3, we then present the related
work. In Sec. 4, we introduce the similarity func-
tion for these FOR spaces. This can be used as ker-
nel function in kernel-based machines (e.g., sup-
port vector machines (Cortes and Vapnik, 1995)).
We then introduce our efficient algorithm for com-
puting the similarity among tDAGs. In Sec. 5,
we analyze the computational efficiency of our
algorithm showing that it is extremely more ef-
ficient than the algorithm proposed in (Moschitti
and Zanzotto, 2007). Finally, in Sec. 6, we draw
conclusions and plan the future work.
2 Representing first-order rules and
sentence pairs as tripartite directed
acyclic graphs
As first step, we want to define the tripartite di-
rected acyclic graphs (tDAGs). This is an ex-
tremely important class of graphs for the first-
order rule feature spaces we want to model. We
want here to intuitively show that, if we model
first-order rules and sentence pairs as tDAGs, de-
termining whether or not a sentence pair can be
unified with a first-order rewrite rule is a graph
matching problem. This intuitive idea helps in
determining our efficient algorithm for exploiting
first-order rules in learning examples.
To illustrate the above idea we will use an ex-
ample based on the above rule ?= feedY Z ?
Y
eat
Z and the above sentence pair (T
1
,H
1
).
The rule ? encodes the entailment relation of the
verb to feed and the verb to eat. If represented
over a syntactic interpretation, the rule has the fol-
lowing aspect:
?
1
=
VP
VB
feed
NP Y NP Z ?
S
NP Y VP
VB
eat
NP Z
As in the case of feature structures (Carpenter,
1992), we can observe this rule as a graph. As
we are not interested in the variable names but we
need to know the relation between the right hand
side and the left hand side of the rule, we can
substitute each variable with an unlabelled node.
We then connect tree nodes having variables with
VP
VB
feed
NP NP ?
?
S
NP VP
VB
eat
NP
Figure 1: A simple rewrite rule seen as a graph
S
NP
DT
The
NN
farmer
VP
VB
feed
NP
NNS
cows
NP
NN
animal
NNS
extracts
?
?
?
S
NP
NNS
Cows
VP
VB
eat
NP
NN
animal
NNS
extracts
Figure 2: A sample pair seen as a graph
the corresponding unlabelled node. The result is a
graph as the one in Fig. 1. The variables Y and Z
are represented by the unlabelled nodes between
the trees.
In the same way we can represent the sentence
pair (T
1
,H
1
) using graph with explicit links be-
tween related words and nodes (see Fig. 2). We
can link words using anchoring methods as in
(Raina et al, 2005). These links can then be prop-
agated in the syntactic tree using semantic heads
of the constituents (Pollard and Sag, 1994). The
rule ?
1
matches over the pair (T
1
,H
1
) if the graph
?
1
is among the subgraphs of the graph in Fig. 2.
Both rules and sentence pairs are graphs of the
same type. These graphs are basically two trees
connected through an intermediate set of nodes
representing variables in the rules and relations be-
tween nodes in the sentence pairs. We will here-
after call these graphs tripartite directed acyclic
graphs (tDAGs). The formal definition follows.
Definition tDAG: A tripartite directed acyclic
graph is a graph G = (N,E) where
? the set of nodes N is partitioned in three sets
N
t
, N
g
, and A
? the set of edges is partitioned in four sets E
t
,
E
g
, E
A
t
, and E
A
g
such that t = (N
t
, E
t
) and g = (N
g
, E
g
) are two
trees and E
A
t
= {(x, y)|x ? N
t
and y ? A} and
E
A
g
= {(x, y)|x ? N
g
and y ? A} are the edges
connecting the two trees.
A tDAG is a partially labeled graph. The label-
ing function L only applies to the subsets of nodes
related to the two trees, i.e., L : N
t
? N
g
? L.
Nodes in the set A are not labeled.
92
The explicit representation of the tDAG in Fig. 2
has been useful to show that the unification of a
rule and a sentence pair is a graph matching prob-
lem. Yet, it is complex to follow. We will then de-
scribe a tDAG with an alternative and more con-
venient representation. A tDAG G = (N,E)
can be seen as pair G = (?, ?) of extended trees
? and ? where ? = (N
t
? A,E
t
? E
A
t
) and
? = (N
g
? A,E
g
? E
A
g
). These are extended
trees as each tree contains the relations with the
other tree.
As for the feature structures, we will graphically
represent a (x, y) ? E
A
t
and a (z, y) ? E
A
g
as
boxes y respectively on the node x and on the
node z. These nodes will then appear as L(x) y
and L(z) y , e.g., NP 1 . The name y is not a label
but a placeholder representing an unlabelled node.
This representation is used for rules and for sen-
tence pairs. The sentence pair in Fig. 2 is then
represented as reported in Fig. 3.
3 Related work
Automatically learning classifiers for sentence
pairs is extremely important for applications like
textual entailment recognition, question answer-
ing, and machine translation.
In textual entailment recognition, it is not hard
to see graphs similar to tripartite directed acyclic
graphs as ways of extracting features from exam-
ples to feed automatic classifiers. Yet, these graphs
are generally not tripartite in the sense described
in the previous section and they are not used to ex-
tract features representing first-order rewrite rules.
In (Raina et al, 2005; Haghighi et al, 2005; Hickl
et al, 2006), two connected graphs representing
the two sentences s
1
and s
2
are used to compute
distance features, i.e., features representing the
distance between s
1
and s
2
. The underlying idea
is that lexical, syntactic, and semantic similarities
between sentences in a pair are relevant features
to classify sentence pairs in classes such as entail
and not-entail.
In (de Marneffe et al, 2006), first-order rewrite
rule feature spaces have been explored. Yet, these
spaces are extremely small. Only some features
representing first-order rules have been explored.
Pairs of graphs are used here to determine if a fea-
ture is active or not, i.e., the rule fires or not. A
larger feature space of rewrite rules has been im-
plicitly explored in (Wang and Neumann, 2007)
but this work considers only ground rewrite rules.
In (Zanzotto and Moschitti, 2006), tripartite di-
rected acyclic graphs are implicitly introduced and
exploited to build first-order rule feature spaces.
Yet, both in (Zanzotto and Moschitti, 2006) and
in (Moschitti and Zanzotto, 2007), the model pro-
posed has two major limitations: it can represent
rules with less than 7 variables and the proposed
kernel is not a completely valid kernel as it uses
the max function.
In machine translation, some methods such as
(Eisner, 2003) learn graph based rewrite rules for
generative purposes. Yet, the method presented in
(Eisner, 2003) can model first-order rewrite rules
only with a very small amount of variables, i.e.,
two or three variables.
4 An efficient algorithm for computing
the first-order rule space kernel
In this section, we present our idea for an effi-
cient algorithm for exploiting first-order rule fea-
ture spaces. In Sec. 4.1, we firstly define the simi-
larity function, i.e., the kernel K(G
1
, G
2
), that we
need to determine for correctly using first-order
rules feature spaces. This kernel is strongly based
on the isomorphism between graphs. A relevant
idea of this paper is the observation that we can
define an efficient way to detect the isomorphism
between the tDAGs (Sec. 4.2). This algorithm ex-
ploits the efficient algorithms of tree isomorphism
as the one implicitly used in (Collins and Duffy,
2002). After describing the isomorphism between
tDAGs, We can present the idea of our efficient al-
gorithm for computing K(G
1
, G
2
) (Sec. 4.3). We
introduce the algorithms to make it a viable solu-
tion (Sec. 4.4). Finally, in Sec. 4.5, we report the
kernel computation we compare against presented
by (Zanzotto and Moschitti, 2006; Moschitti and
Zanzotto, 2007).
4.1 Kernel functions over first-order rule
feature spaces
The first-order rule feature space we want to model
is huge. If we use kernel-based machine learning
models such as SVM (Cortes and Vapnik, 1995),
we can implicitly define the space by defining its
similarity functions, i.e., its kernel functions. We
firstly introduce the first-order rule feature space
and we then define the prototypical kernel function
over this space.
The first-order rule feature space (FOR) is in
general the space of all the possible first-order
93
P1
= ?
S
NP
NNS
Farmers
VP
VB
feed
NP 1
NNS 1
cows
NP 3
NN 2
animal
NNS 3
extracts
,
S
NP 1
NNS 1
Cows
VP
VB
eat
NP 3
NN 2
animal
NNS 3
extracts
?
P
2
= ?
S 2
NP 1
NNS 1
Pediatricians
VP 2
VB 2
suggest
S
NP
NNS
women
VP
TO
to
VP
VB
feed
NP 3
NNS 3
newborns
NP 4
NN 5
breast
NN 4
milk
,
S 2
NP 1
NNS 1
Pediatricians
VP 2
VB 2
suggest
SBAR
IN
that
S
NP 3
NNS 3
newborns
VP
VB
eat
NP 4
NN 5
breast
NN 4
milk
?
Figure 3: Two tripartite DAGs
rules defined as tDAGs. Within this space it is pos-
sible to define the function S(G) that determines
all the possible active features of the tDAG G in
FOR. The function S(G) determines all the pos-
sible and meaningful subgraphs of G. We want
that these subgraphs represent first-order rules that
can be matched with the pair G. Then, meaningful
subgraphs of G = (?, ?) are graphs as (t, g) where
t and g are subtrees of ? and ?. For example, the
subgraphs of P
1
and P
2
in Fig. 3 are hereafter par-
tially represented:
S(P
1
) = { ?
S
NP VP
,
S
NP 1 VP
? , ?
NP 1
NNS 1
,
NP 1
NNS 1
? ,
?
S
NP VP
VB
feed
NP 1 NP 3
,
S
NP 1 VP
VB
eat
NP 3
? ,
?
VP
VB
feed
NP 1 NP 3 ,
S
NP 1 VP
VB
eat
NP 3
? , ... }
and
S(P
2
) = { ?
S 2
NP 1 VP 2
,
S 2
NP 1 VP 2
? , ?
NP 1
NNS 1
,
NP 1
NNS 1
? ,
?
VP
VB
feed
NP 3 NP 4 ,
S
NP 3 VP
VB
eat
NP 4
? , ... }
In the FOR space, the kernel function K should
then compute the number of subgraphs in com-
mon. The trivial way to describe the former kernel
function is using the intersection operator, i.e., the
kernel K(G
1
, G
2
) is the following:
K(G
1
, G
2
) = |S(G
1
) ? S(G
2
)| (1)
This is very simple to write and it is in principle
correct. A graph g in the intersection S(G
1
) ?
S(G
2
) is a graph that belongs to both S(G
1
) and
S(G
2
). Yet, this hides a very important fact: de-
termining whether two graphs, g
1
and g
2
, are the
same graph g
1
= g
2
is not trivial. For example,
it is not sufficient to superficially compare graphs
to determine that ?
1
belongs both to S
1
and S
2
.
We need to use the correct property for g
1
= g
2
,
i.e., the isomorphism between two graphs. We can
call the operator Iso(g
1
, g
2
). When two graphs
verify the property Iso(g
1
, g
2
), both g
1
and g
2
can be taken as the graph g representing the two
graphs. Detecting Iso(g
1
, g
2
) has an exponential
complexity (Ko?bler et al, 1993).
This complexity of the intersection operator be-
tween sets of graphs deserves a different way to
represent the operation. We will use the same sym-
bol but we will use the prefix notation. The opera-
tor is hereafter re-defined:
? (S(G
1
),S(G
2
)) =
= {g
1
|g
1
? S(G
1
),?g
2
? S(G
2
), Iso(g
1
, g
2
)}
4.2 Isomorphism between tDAGs
As isomorphism between graphs is an essential ac-
tivity for learning from structured data, we here
review its definition and we adapt it to tDAGs.
94
We then observe that isomorphism between two
tDAGs can be divided in two sub-problems:
? finding the isomorphism between two pairs
of extended trees
? checking whether the partial isomorphism
found between the two pairs of extended trees
are compatible.
In general, two tDAGs, G
1
= (N
1
, E
1
) and
G
2
= (N
2
, E
2
) are isomorphic (or match) if
|N
1
| = |N
2
|, |E
1
| = |E
2
|, and a bijective func-
tion f : N
1
? N
2
exists such that these properties
hold:
? for each node n ? N
1
, L(f(n)) = L(n)
? for each edge (n
1
, n
2
) ? E
1
an edge
(f(n
1
), f(n
2
)) is in E
2
The bijective function f is a member of the combi-
natorial setF of all the possible bijective functions
between the two sets N
1
and N
2
.
The trivial algorithm for detecting if two graphs
are isomorphic is exponential (Ko?bler et al,
1993). It explores all the set F . It is still unde-
termined if the general graph isomorphism prob-
lem is NP-complete. Yet, we can use the fact that
tDAGs are two extended trees for building a bet-
ter algorithm. There is an efficient algorithm for
computing isomorphism between trees (as the one
implicitly used in (Collins and Duffy, 2002)).
Given two tDAGs G
1
= (?
1
, ?
1
) and G
2
=
(?
2
, ?
2
) the isomorphism problem can be divided
in detecting two properties:
1. Partial isomorphism. Two tDAGs G
1
and G
2
are partially isomorphic, if ?
1
and ?
2
are iso-
morphic and if ?
1
and ?
2
are isomorphic. The
partial isomorphism produces two bijective
functions f
?
and f
?
.
2. Constraint compatibility. Two bijective func-
tions f
?
and f
?
are compatible on the sets of
nodes A
1
and A
2
, if for each n ? A
1
, it hap-
pens that f
?
(n) = f
?
(n).
We can rephrase the second property, i.e., the
constraint compatibility, as follows. We de-
fine two constraints c(?
1
, ?
2
) and c(?
1
, ?
2
) rep-
resenting the functions f
?
and f
?
on the sets
A
1
and A
2
. The two constraints are defined as
c(?
1
, ?
2
) = {(n, f
?
(n))|n ? A
1
} and c(?
1
, ?
2
) =
{(n, f
?
(n))|n ? A
1
}. Two partially isomorphic
tDAGs are isomorphic if the constraints match,
i.e., c(?
1
, ?
2
) = c(?
1
, ?
2
).
P
a
= (?
a
, ?
a
) = ?
A 1
B 1
B 1 B 2
C 1
C 1 C 2
,
I 1
M 1
M 2 M 1
N 1
N 2 N 1
?
P
b
= (?
b
, ?
b
) = ?
A 1
B 1
B 1 B 2
C 1
C 1 C 3
,
I 1
M 1
M 3 M 1
N 1
N 2 N 1
?
Figure 5: Simple non-linguistic tDAGs
For example, the third pair of S(P
1
) and the
second pair of S(P
2
) are isomorphic as: (1) these
are partially isomorphic, i.e., the right hand sides
? and the left hand sides ? are isomorphic; (2)
both pairs of extended trees generate the constraint
c
1
= {(
1
,
3
), (
3
,
4
)}. In the same way, the
fourth pair of S(P
1
) and the third pair of S(P
2
)
generate c
2
= {(
1
,
1
)}
4.3 General idea for an efficient kernel
function
As above discussed, two tDAGs are isomorphic if
the two properties, the partial isomorphism and
the constraint compatibility, hold. To compute the
kernel function K(G
1
, G
2
) defined in Sec. 4.1, we
can exploit these properties in the reverse order.
Given a constraint c, we can select all the graphs
that meet the constraint c (constraint compatibil-
ity). Having the two set of all the tDAGs meeting
the constraint, we can detect the partial isomor-
phism. We split each pair of tDAGs in the four
extended trees and we determine if these extended
trees are compatible.
We introduce this innovative method to com-
pute the kernel K(G
1
, G
2
) in the FOR space in
two steps. Firstly, we give an intuitive explanation
and, secondly, we formally define the kernel.
4.3.1 Intuitive explanation
To give an intuition of the kernel computation,
without loss of generality and for sake of simplic-
ity, we use two non-linguistic tDAGs, P
a
and P
b
(see Fig. 5), and the subgraph function ?S(?). This
latter is an approximated version of S(?) that gen-
erates tDAGs with subtrees rooted in the root of
the initial trees of ?.
To exploit the constraint compatibility
property, we define C as the set of all the
relevant alternative constraints, i.e., the con-
straints c that are likely to be generated
when detecting the partial isomorphism.
For P
a
and P
b
, this set is C = {c
1
, c
2
} =
95
?(
?
S(P
a
),
?
S(P
b
))|
c
1
= { ?
A 1
B 1 C 1
,
I 1
M 1 N 1
? , ?
A 1
B 1
B 1 B 2
C 1 ,
I 1
M 1 N 1
? , ?
A 1
B 1
B 1 B 2
C 1 ,
I 1
M 1 N 1
N 2 N 1
? ,
?
A 1
B 1 C 1
,
I 1
M 1 N 1
N 2 N 1
? } = {
A 1
B 1 C 1
,
A 1
B 1
B 1 B 2
C 1 } ? {
I 1
M 1 N 1
,
I 1
M 1 N 1
N 2 N 1
} =
= ?(
?
S(?
a
),
?
S(?
b
))|
c
1
??(
?
S(?
a
),
?
S(?
b
))|
c
1
?(
?
S(P
a
),
?
S(P
b
))|
c
2
= { ?
A 1
B 1 C 1
,
I 1
M 1 N 1
? , ?
A 1
B 1 C 1
C 1 C 2
,
I 1
M 1 N 1
? , ?
A 1
B 1 C 1
C 1 C 2
,
I 1
M 1
M 2 M 1
N 1 ? ,
?
A 1
B 1 C 1
,
I 1
M 1
M 2 M 1
N 1 ? } = {
A 1
B 1 C 1
,
A 1
B 1 C 1
C 1 C 2
} ? {
I 1
M 1 N 1
,
I 1
M 1
M 2 M 1
N 1 }=
= ?(
?
S(?
a
),
?
S(?
b
))|
c
2
??(
?
S(?
a
),
?
S(?
b
))|
c
2
Figure 4: Intuitive idea for the kernel computation
{
{(
1
,
1
), (
2
,
2
)}, {(
1
,
1
), (
2
,
3
)}
}
. We can
then determine the kernel K(P
a
, P
b
) as:
K(P
a
,P
b
)= |?(
?
S(P
a
),
?
S(P
b
))|=
=
|
?(
?
S(P
a
),
?
S(P
b
))|
c
1
?
?(
?
S(P
a
),
?
S(P
b
))|
c
2
|
where ?( ?S(P
a
),
?
S(P
b
))|
c
are the common sub-
graphs that meet the constraint c. A tDAG g? =
(?
?
, ?
?
) in ?S(P
a
) is in ?( ?S(P
a
),
?
S(P
b
))|
c
if g?? =
(?
??
, ?
??
) in ?S(P
b
) exists, g? is partially isomorphic
to g??, and c? = c(? ?, ? ??) = c(??, ???) is covered by
and compatible with the constraint c, i.e., c? ? c.
For example in Fig. 4, the first tDAG of the set
?(
?
S(P
a
),
?
S(P
b
))|
c
1
belongs to the set as its con-
straint c? = {( 1 , 1 )} is a subset of c
1
.
Observing the kernel computation in this way
is important. Elements in ?( ?S(P
a
),
?
S(P
b
))|
c
already satisfy the property of constraint com-
patibility. We only need to determine if the
partially isomorphic properties hold for elements
in ?( ?S(P
a
),
?
S(P
b
))|
c
. Then, we can write the
following equivalence:
?(
?
S(P
a
),
?
S(P
b
))|
c
=
=?(
?
S(?
a
),
?
S(?
b
))|
c
??(
?
S(?
a
),
?
S(?
b
))|
c
(2)
Figure 4 reports this equivalence for the two
sets derived using the constraints c
1
and c
2
.
Note that this equivalence is not valid if a con-
straint is not applied, i.e., ?( ?S(P
a
),
?
S(P
b
))
6= ?(
?
S(?
a
),
?
S(?
b
)) ? ?(
?
S(?
a
),
?
S(?
b
)).
The pair P
a
itself does not belong to
?(
?
S(P
a
),
?
S(P
b
)) but it does belong to
?(
?
S(?
a
),
?
S(?
b
))? ?(
?
S(?
a
),
?
S(?
b
)).
The equivalence (2) allows to compute the car-
dinality of ?( ?S(P
a
),
?
S(P
b
))|
c
using the cardinal-
ities of ?( ?S(?
a
),
?
S(?
b
))|
c
and ?( ?S(?
a
),
?
S(?
b
))|
c
.
These latter sets contain only extended trees where
the equivalences between unlabelled nodes are
given by c. We can then compute the cardinali-
ties of these two sets using methods developed for
trees (e.g., the kernel function K
S
(?
1
, ?
2
) intro-
duced in (Collins and Duffy, 2002)).
4.3.2 Formal definition
Given the idea of the previous section, it is easy
to demonstrate that the kernel K(G
1
, G
2
) can be
written as follows:
K(G
1
,G
2
)=
|
?
c?C
?(S(?
1
),S(?
2
))|
c
??(S(?
1
),S(?
2
))|
c
|
where C is set of alternative constraints and
?(S(?
1
),S(?
2
))|
c
are all the common extended
trees compatible with the constraint c.
We can compute the above kernel using the
inclusion-exclusion property, i.e.,
|A
1
? ? ? ? ?A
n
| =
?
J?2
{1,...,n}
(?1)
|J |?1
|A
J
| (3)
where 2{1,...,n} is the set of all the subsets of
{1, . . . , n} and A
J
=
?
i?J
A
i
.
To describe the application of the inclusion-
exclusion model in our case, let firstly define:
K
S
(?
1
, ?
2
, c) = |?(S(?
1
),S(?
2
))|
c
| (4)
96
where ?
1
can be both ?
1
and ?
1
and ?
2
can be both
?
2
and ?
2
. Trivially, we can demonstrate that:
K(G
1
, G
2
) =
=
?
J?2
{1,...,|C|}
(?1)
|J|?1
K
S
(?
1
,?
2
,c(J))K
S
(?
1
,?
2
,c(J))
(5)
where c(J) =
?
i?J
c
i
.
Given the nature of the constraint set C , we
can compute efficiently the previous equation as
it often happens that two different J
1
and J
2
in
2
{1,...,|C|} generate the same c, i.e.
c =
?
i?J
1
c
i
=
?
i?J
2
c
i
(6)
Then, we can define C? as the set of all intersec-
tions of constraints in C , i.e. C? = {c(J)|J ?
2
{1,...,|C|}
}. We can rewrite the equation as:
K(G
1
, G
2
) =
=
?
c?C
?
K
S
(?
1
, ?
2
, c)K
S
(?
1
, ?
2
, c)N(c) (7)
where
N(c) =
?
J?2
{1,...,|C|}
c=c(J)
(?1)
|J |?1 (8)
The complexity of the above kernel strongly de-
pends on the cardinality of C and the related cardi-
nality of C?. The worst-case computational com-
plexity is still exponential with respect to the size
of A
1
and A
2
. Yet, the average case complexity
(Wang, 1997) is promising.
The set C is generally very small with re-
spect to the worst case. If F
(A
1
,A
2
)
are all the
possible correspondences between the nodes
A
1
and A
2
, it happens that |C| << |F
(A
1
,A
2
)
|
where |F
(A
1
,A
2
)
| is the worst case. For example,
in the case of P
1
and P
2
, the cardinality of
C =
{
{(
1
,
1
)}, {(
1
,
3
), (
3
,
4
), (
2
,
5
)}
}
is extremely smaller than the one of
F
(A
1
,A
2
)
= {{( 1 , 1 ),( 2 , 2 ),( 3 , 3 )},
{( 1 , 2 ),( 2 , 1 ),( 3 , 3 )}, {( 1 , 2 ),( 2 , 3 ),( 3 , 1 )},
..., {( 1 , 3 ),( 2 , 4 ),( 3 , 5 )}}. In Sec. 4.5 we argue
that the algorithm presented in (Moschitti and
Zanzotto, 2007) has the worst-case complexity.
Moreover, the set C? is extremely smaller than
2
{1,...,|C|} due to the above property (6).
We will analyze the average-case complex-
ity with respect to the worst-case complexity in
Sec. 5.
4.4 Enabling the efficient kernel function
The above idea for computing the kernel function
is extremely interesting. Yet, we need to make it
viable by describing the way we can determine ef-
ficiently the three main parts of the equation (7):
1) the set of alternative constraints C (Sec. 4.4.1);
2) the set C? of all the possible intersections of
constraints in C (Sec. 4.4.2); and, finally, 3) the
numbers N(c) (Sec. 4.4.3).
4.4.1 Determining the set of alternative
constraints
The first step of equation (7) is to determine the
alternative constraints C . We can here strongly
use the possibility of dividing tDAGs in two trees.
We build C as C
?
? C
?
where: 1) C
?
are the
constraints obtained from pairs of isomorphic ex-
tended trees t
1
? S(?
1
) and t
2
? S(?
2
); 2) C
?
are
the constraints obtained from pairs of isomorphic
extended trees t
1
? S(?
1
) and t
2
? S(?
2
).
The idea for an efficient algorithm is that we
can compute the C without explicitly looking
at all the subgraphs involved. We instead use
and combine the constraints derived comparing
the productions of the extended trees. We can
compute then C
?
with the productions of ?
1
and
?
2
and C
?
with the productions of ?
1
and ?
2
.
For example (see Fig. 3), focusing on the ? , the
rule
NP
3
?
NN
2
NNS
3 of G
1
and
NP
4
?
NN
5
NNS
4 of G
2
generates the
constraint c = {( 3 , 4 ), (2 , 5 )}.
Using the above intuition it is possible to define
an algorithm that builds an alternative constraint
set C with the following two properties:
1. for each common subtree according to a set
of constraints c, ?c? ? C such that c ? c?;
2. @c?, c?? ? C such that c? ? c?? and c? 6= ?.
4.4.2 Determining the set C?
The set C? is defined as the set of all possible in-
tersections of alternative constraints in C . Figure
6 presents the algorithm determining C?. Due to
the property (6) discussed in Sec. 4.3, we can em-
pirically demonstrate that the average complexity
of the algorithm is not bigger than O(|C|2). Yet,
again, the worst case complexity is exponential.
4.4.3 Determining the values of N(c)
The multiplier N(c) (Eq. 8) represents the num-
ber of times the constraint c is considered in the
sum of equation 5, keeping into account the sign of
97
Algorithm Build the set C? from the set C
C
+
? C ; C
1
? C ; C
2
? ?
WHILE |C
1
| > 1
FORALL c? ? C
1
FORALL c?? ? C
1
such that c? 6= c??
c? c
?
? c
??
IF c /? C+ add c to C
2
C
+
? C
+
? C
2
; C
1
? C
2
; C
2
? ?
C
?
? C ? C
+
? {?}
Figure 6: Algorithm for computing C?
the corresponding addend. It is possible to demon-
strate that:
N(c) = 1?
?
c
?
?C
?
c
?
?c
N
c
? (9)
This recursive formulation of the equation allows
us to easily determine the value of N(c) for every
c belonging to C?. It is possible to prove this prop-
erty using set properties and the binomial theorem.
The proof is omitted for lack of space.
4.5 Reviewing the strictly related work
To understand if ours is an efficient algorithm, we
compare it with the algorithm presented by (Mos-
chitti and Zanzotto, 2007). We will hereafter call
this algorithm K
max
. The K
max
algorithm and
kernel is an approximation of what is a kernel
needed for a FOR space as it is not difficult to
demonstrate that K
max
(G
1
, G
2
) ? K(G
1
, G
2
).
The K
max
approximation is based on maximiza-
tion over the set of possible correspondences of
the placeholders. Following our formulation, this
kernel appears as:
K
max
(G
1
, G
2
) =
= max
c?F
(A
1
,A
2
)
K
S
(?
1
, ?
2
, c)K
S
(?
1
, ?
2
, c) (10)
where F
(A
1
,A
2
)
are all the possible correspon-
dences between the nodes A
1
and A
2
of the two
tDAGs as the one presented in Sec. 4.3. This for-
mulation of the kernel has the worst case complex-
ity of our formulation, i.e., Eq. 7.
For computing the basic kernel for the extended
trees, i.e. K
S
(?
1
, ?
2
, c) we use the model algo-
rithm presented by (Zanzotto and Moschitti, 2006)
and refined by (Moschitti and Zanzotto, 2007)
based on the algorithm for tree fragment feature
0
10
20
30
40
50
0 10 20 30 40 50
ms
n?m placeholders
K(G
1
, G
2
)
K
max
(G
1
, G
2
)
Figure 7: Mean execution time in milliseconds
(ms) of the two algorithms wrt. n ? m where n
and m are the number of placeholders of the two
tDAGs
spaces (Collins and Duffy, 2002). As we are using
the same basic kernel, we can empirically compare
the two methods.
5 Experimental evaluation
In this section we want to empirically estimate the
benefits on the computational cost of our novel al-
gorithm with respect to the algorithm proposed by
(Moschitti and Zanzotto, 2007). Our algorithm is
in principle exponential with respect to the set of
alternative constraints C . Yet, due to what pre-
sented in Sec. 4.4 and as the set C? is usually
very small, the average complexity is extremely
low. Following the theory on the average-cost
computational complexity (Wang, 1997), we es-
timated the behavior of the algorithms on a large
distribution of cases. We then compared the com-
puting times of the two algorithms. Finally, as
K and K
max
compute slightly different kernels,
we compare the accuracy of the two methods.
We implemented both algorithms K(G
1
, G
2
) and
K
max
(G
1
, G
2
) in support vector machine classi-
fier (Joachims, 1999) and we experimented with
both implementations on the same machine. We
hereafter analyze the results in term of execution
time (Sec. 5.1) and in term of accuracy (Sec. 5.2).
5.1 Average computing time analysis
For this first set of experiments, the source of ex-
amples is the one of the recognizing textual en-
tailment challenge, i.e., RTE2 (Bar-Haim et al,
98
0200
400
600
800
1000
1200
1400
1600
0 2 4 6 8 10 12 14
s
#ofplaceholders
K(G
1
, G
2
)
K
max
(G
1
, G
2
)
Figure 8: Total execution time in seconds (s) of
the training phase on RTE2 wrt. different numbers
of allowed placeholders
2006). The dataset of the challenge has 1,600 sen-
tence pairs.
The computational cost of both K(G
1
, G
2
) and
K
max
(G
1
, G
2
) depends on the number of place-
holders n = |A
1
| of G
1
and on m = |A
2
| the
number of placeholders of G
2
. Then, in the first
experiment we want to determine the relation be-
tween the computational time and the factor n?m.
Results are reported in Fig. 7 where the computa-
tion times are plotted with respect to n?m. Each
point in the curve represents the average execu-
tion time for the pairs of instances having n ?m
placeholders. As expected, the computation of the
function K is more efficient than the computation
K
max
. The difference between the two execution
times increases with n?m.
We then performed a second experiment that
wants to determine the relation of the total exe-
cution with the maximum number of placeholders
in the examples. This is useful to estimate the be-
havior of the algorithm with respect to its applica-
tion in learning models. Using the RTE2 data, we
artificially build different versions with increasing
number of placeholders. We then have RTE2 with
1 placeholder at most in each pair, RTE2 with 2
placeholders, etc. The number of pairs in each set
is the same. What changes is the maximal num-
ber of placeholders. Results are reported in Fig. 8
where the execution time of the training phase in
seconds (s) is plotted for each different set. We
see that the computation of K
max
is exponential
with respect to the number of placeholders and
Kernel Accuracy Used training Support
examples Vectors
K
max
59.32 4223 4206
K 60.04 4567 4544
Table 1: Comparative performances of K
max
and K
it becomes intractable after 7 placeholders. The
computation of K is instead more flat. This can
be explained as the computation of K is related
to the real alternative constraints that appears in
the dataset. The computation of the kernel K then
outperforms the computation of the kernel K
max
.
5.2 Accuracy analysis
As K
max
that has been demonstrated very effec-
tive in term of accuracy for RTE and K compute
a slightly different similarity function, we want to
show that the performance of our more computa-
tionally efficient K is comparable, and even better,
to the performances of K
max
. We then performed
an experiment taking as training all the data de-
rived from RTE1, RTE2, and RTE3, (i.e., 4567
training examples) and taking as testing RTE-4
(i.e., 1000 testing examples). The results are re-
ported in Tab. 1. As the table shows, the accuracy
of K is higher than the accuracy of K
max
. There
are two main reasons. The first is that K
max
is
an approximation of K . The second is that we
can now consider sentence pairs with more than
7 placeholders. Then, we can use the complete
training set as the third column of the table shows.
6 Conclusions and future work
We presented an interpretation of first order rule
feature spaces as tripartite directed acyclic graphs
(tDAGs). This view on the problem gave us the
possibility of defining a novel and efficient algo-
rithm for computing the kernel function for first
order rule feature spaces. Moreover, the resulting
algorithm is a valid kernel as it can be written as
dot product in the explicit space of the tDAG frag-
ments. We demonstrated that our algorithm out-
performs in term of average complexity the previ-
ous algorithm and it yields to better accuracies for
the final task. We are investigating if this is a valid
algorithm for two general directed acyclic graphs.
99
References
Roy Bar-Haim, Ido Dagan, Bill Dolan, Lisa
Ferro, Danilo Giampiccolo, and Idan Magnini,
Bernardo Szpektor. 2006. The second pascal recog-
nising textual entailment challenge. In Proceedings
of the Second PASCAL Challenges Workshop on
Recognising Textual Entailment. Venice, Italy.
Bob Carpenter. 1992. The Logic of Typed Fea-
ture Structures. Cambridge University Press, Cam-
bridge, England.
Michael Collins and Nigel Duffy. 2002. New rank-
ing algorithms for parsing and tagging: Kernels over
discrete structures, and the voted perceptron. In Pro-
ceedings of ACL02.
C. Cortes and V. Vapnik. 1995. Support vector net-
works. Machine Learning, 20:1?25.
Ido Dagan and Oren Glickman. 2004. Probabilistic
textual entailment: Generic applied modeling of lan-
guage variability. In Proceedings of the Workshop
on Learning Methods for Text Understanding and
Mining, Grenoble, France.
Ido Dagan, Oren Glickman, and Bernardo Magnini.
2006. The pascal recognising textual entailment
challenge. In Quionero-Candela et al, editor, LNAI
3944: MLCW 2005, pages 177?190, Milan, Italy.
Springer-Verlag.
Marie-Catherine de Marneffe, Bill MacCartney, Trond
Grenager, Daniel Cer, Anna Rafferty, and Christo-
pher D. Manning. 2006. Learning to distinguish
valid textual entailments. In Proceedings of the Sec-
ond PASCAL Challenges Workshop on Recognising
Textual Entailment, Venice, Italy.
Jason Eisner. 2003. Learning non-isomorphic tree
mappings for machine translation. In Proceedings
of the 41st Annual Meeting of the Association for
Computational Linguistics (ACL), Companion Vol-
ume, pages 205?208, Sapporo, July.
Thomas Ga?rtner. 2003. A survey of kernels for struc-
tured data. SIGKDD Explorations.
Aria D. Haghighi, Andrew Y. Ng, and Christopher D.
Manning. 2005. Robust textual inference via graph
matching. In HLT ?05: Proceedings of the con-
ference on Human Language Technology and Em-
pirical Methods in Natural Language Processing,
pages 387?394, Morristown, NJ, USA. Association
for Computational Linguistics.
Andrew Hickl, John Williams, Jeremy Bensley, Kirk
Roberts, Bryan Rink, and Ying Shi. 2006. Rec-
ognizing textual entailment with LCCs GROUND-
HOG system. In Bernardo Magnini and Ido Dagan,
editors, Proceedings of the Second PASCAL Recog-
nizing Textual Entailment Challenge, Venice, Italy.
Springer-Verlag.
Thorsten Joachims. 1999. Making large-scale svm
learning practical. In B. Schlkopf, C. Burges, and
A. Smola, editors, Advances in Kernel Methods-
Support Vector Learning. MIT Press.
Johannes Ko?bler, Uwe Scho?ning, and Jacobo Tora?n.
1993. The graph isomorphism problem: its struc-
tural complexity. Birkhauser Verlag, Basel, Switzer-
land, Switzerland.
Alessandro Moschitti and Fabio Massimo Zanzotto.
2007. Fast and effective kernels for relational learn-
ing from texts. In Proceedings of the International
Conference of Machine Learning (ICML). Corvallis,
Oregon.
Alessandro Moschitti. 2004. A study on convolution
kernels for shallow semantic parsing. In proceed-
ings of the ACL, Barcelona, Spain.
C. Pollard and I.A. Sag. 1994. Head-driven Phrase
Structured Grammar. Chicago CSLI, Stanford.
Rajat Raina, Aria Haghighi, Christopher Cox, Jenny
Finkel, Jeff Michels, Kristina Toutanova, Bill Mac-
Cartney, Marie-Catherine de Marneffe, Manning
Christopher, and Andrew Y. Ng. 2005. Robust tex-
tual inference using diverse knowledge sources. In
Proceedings of the 1st Pascal Challenge Workshop,
Southampton, UK.
Jan Ramon and Thomas Ga?rtner. 2003. Expressivity
versus efficiency of graph kernels. In First Interna-
tional Workshop on Mining Graphs, Trees and Se-
quences.
Jun Suzuki, Tsutomu Hirao, Yutaka Sasaki, and Eisaku
Maeda. 2003. Hierarchical directed acyclic graph
kernel: Methods for structured natural language
data. In In Proceedings of the 41st Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 32?39.
Rui Wang and Gu?nter Neumann. 2007. Recog-
nizing textual entailment using a subsequence ker-
nel method. In Proceedings of the Twenty-Second
AAAI Conference on Artificial Intelligence (AAAI-
07), July 22-26, Vancouver, Canada.
Jie Wang. 1997. Average-case computational com-
plexity theory. pages 295?328.
Fabio Massimo Zanzotto and Alessandro Moschitti.
2006. Automatic learning of textual entailments
with cross-pair similarities. In Proceedings of the
21st Coling and 44th ACL, pages 401?408. Sydney,
Australia, July.
100
Proceedings of the Workshop on Distributional Semantics and Compositionality (DiSCo?2011), pages 10?15,
Portland, Oregon, 24 June 2011. c?2011 Association for Computational Linguistics
Distributed Structures and Distributional Meaning
Fabio Massimo Zanzotto
DISP University of Rome ?Tor Vergata?
Via del Politecnico 1
00133 Roma, Italy
zanzotto@info.uniroma2.it
Lorenzo Dell?Arciprete
University of Rome ?Tor Vergata?
Via del Politecnico 1
00133 Roma, Italy
lorenzo.dellarciprete@gmail.com
Abstract
Stemming from distributed representation the-
ories, we investigate the interaction between
distributed structure and distributional mean-
ing. We propose a pure distributed tree (DT)
and distributional distributed tree (DDT). DTs
and DDTs are exploited for defining dis-
tributed tree kernels (DTKs) and distributional
distributed tree kernels (DDTKs). We com-
pare DTKs and DDTKs in two tasks: approx-
imating tree kernels TK (Collins and Duffy,
2002); performing textual entailment recog-
nition (RTE). Results show that DTKs corre-
late with TKs and perform in RTE better than
DDTKs. Then, including distributional vec-
tors in distributed structures is a very difficult
task.
1 Introduction
Demonstrating that distributional semantics is a se-
mantic model of natural language is a real research
challenge in natural language processing. Frege?s
principle of compositionality (Frege, 1884), nat-
urally taken into account in logic-based semantic
models of natural language (Montague, 1974), is
hardly effectively included in distributional seman-
tics models. These models should composition-
ally derive distributional vectors for sentences and
phrases from the distributional vectors of the com-
posing words.
Besides vector averaging (Landauer and Dumais,
1997; Foltz et al, 1998), that can model distribu-
tional meaning of sentences, recent distributional
compositional models focus on finding distribu-
tional vectors of word pairs (Mitchell and Lapata,
2010; Guevara, 2010; Baroni and Zamparelli, 2010;
Zanzotto et al, 2010). Scaling up these 2-word se-
quence models to the sentence level is not trivial as
syntactic structure of sentences plays a very impor-
tant role. Understanding the relation between the
structure and the meaning is needed for building dis-
tributional compositional models for sentences.
Research in Distributed Representations (DR)
(Hinton et al, 1986) proposed models and methods
for encoding data structures in vectors, matrices, or
high-order tensors. Distributed Representations are
oriented to preserve the structural information in the
final representation. For this purpose, DR models
generally use random and possibly orthogonal vec-
tors for words and structural elements (Plate, 1994).
As distributional semantics vectors are unlikely to
be orthogonal, syntactic structure of sentences may
be easily lost in the final vector combination.
In this paper, we investigate the interaction be-
tween distributed structure and distributional mean-
ing by proposing a model to encode syntactic trees
in distributed structures and by exploiting this model
in kernel machines (Vapnik, 1995) to determine the
similarity between syntactic trees. We propose a
pure distributed tree (DT) and a distributional dis-
tributed tree (DDT). In line with the distributed rep-
resentation theory, DTs use random vectors for rep-
resenting words whereas DDTs use distributional
vectors for words. Our interest is in understand-
ing if the introduction of distributional semantic in-
formation in an inherently syntactic based model,
such as distributed representations, leads to better
performances in semantic aware tasks. DTs and
DDTs are exploited for defining distributed tree ker-
10
nels (DTKs) and distributional distributed tree ker-
nels (DDTKs). We study the interaction between
structure and meaning in two ways: 1) by compar-
ing DTKs and DDTKs with the classical tree sim-
ilarity functions, i.e., the tree kernels TK (Collins
and Duffy, 2002); 2) by comparing the accuracy of
DTKs and DDTKs in a semantic task such as recog-
nizing textual entailment (RTE). Results show that
DTKs correlate with TKs and perform in RTE better
than DDTKs. This indicates that including distri-
butional vectors in distributed structures should be
performed in a more complex fashion.
2 Related Work
Distributed Representations (DR) (Hinton et al,
1986) are models and methods for encoding data
structures as trees in vectors, matrices, or high-
order tensors. DR are studied in opposition to sym-
bolic representations to describe how knowledge is
treated in connectionist models (Rumelhart and Mc-
clelland, 1986). Basic symbolic elements, e.g., John
or car, as well as eventually nested structures, e.g.,
buy(John,car,in(1978)), are represented as vectors,
matrices, or higher order tensors. Vectors of ba-
sic elements (words, or concepts) can be randomly
generated (e.g. (Anderson, 1973; Murdock, 1983))
or, instead, they may represent their attributes and
can be manually built (e.g. (McRae et al, 1997; An-
drews et al, 2009)). Vectors, matrices, or tensors for
structures are compositionally derived using vectors
for basic elements.
Good compositionally obtained vectors for struc-
tures are explicit and immediately accessible: infor-
mation stored in a distributed representation should
be easily accessible with simple operations (Plate,
1994). Circular convolution in Holographic Re-
duced Representations (HRRs) (Plate, 1994) is de-
signed to satisfy the immediate accessibility prop-
erty. It supports two operations for producing and
accessing the compact representations: the circular
convolution and the correlation. Given that com-
ponent vectors are obtained randomly (as in (An-
derson, 1973; Murdock, 1983)), correlation is the
inverse of composition. Yet, distributed represen-
tations offer an informative way of encoding struc-
tures if basic vectors are nearly orthogonal.
3 Distributed Trees and Distributional
Distributed Trees
Stemming from distributed representations, we pro-
pose a way to encode syntactic trees in distributed
vectors. These vectors can be pure distributed tree
vectors (DT) or distributional distributed tree vectors
(DDT). Once defined, these vectors can be used as
a tree similarity function in kernel machines (Vap-
nik, 1995). We can build pure distributed tree ker-
nels (DTK) or distributional distributed tree kernels
(DDTK) to be used in recognizing textual entailment
(RTE).
The rest of the section is organized as follows.
We firstly present the distributed trees and the dis-
tributed tree kernels (Sec. 3.1). We then describe
how to obtain DTs and DDTs (Sec. 3.2). Finally, we
describe how the related kernels can be used for the
recognizing textual entailment task (Sec. 3.2.1).
3.1 Distributed Trees and Distributed Tree
Kernels
We define a distributed vector in order to finally pro-
duce a similarity function between trees (i.e., a ker-
nel function) as the classical tree kernel (Collins and
Duffy, 2002). A distributed vector ~?T is a vector rep-
resenting the subtrees of a tree T . The final function
is:
~?T =
?
n?N(T )
s(n) (1)
where N(T ) is the set of nodes of the tree T , n is
a node, and s(n) is the sum of the distributed vec-
tors of the subtrees of T rooted in the node n. The
function s(n) is recursively defined as follows:
? s(n) = ~n?~w if n is a pre-terminal node n? w
where ~n is the vector representing n and ~w is
the one representing the word w.
? s(n) = ~n? (~c1 + s(c1))? . . .? (~cn + s(cn))
where n is not a pre-terminal node, n ?
c1 . . . cn is the first production of the tree rooted
in n, ~n is the vector of the node n, and ~ci are
the vectors of the nodes ci.
The distributed vectors of the nodes only depend on
tags of the nodes.
11
The function ? is defined as the reverse element-
wise product ~v = ~a?~b as:
vi = ?aibn?i+1 (2)
where vi, ai, and bi are the elements of, respectively,
the vectors ~v, ~a, and ~b; n is the dimension of the
space; and ? is a value to ensure that the operation?
approximate the property of vector module preserva-
tion. This function is not commutative and this guar-
antees that different trees t have different vectors ~t.
It is possible to demonstrate that:
~?T =
?
t?S(T )
~t (3)
where S(T ) is the set of the subtrees of T , t is one
of its subtrees, and ~t is its distributed representation.
The distributed kernel T?K function over trees
then easily follows as:
T?K(T1, T2) =
~?
T1 ?
~?
T2 =
?
t1?S(T1)
?
t2?S(T2)
~t1 ?~t2 (4)
If the different trees are orthogonal, T?K(T1, T2)
counts approximately the number of subtrees in
common between the two trees T1 and T2.
3.2 Pure Distributed vs. Distributional
Distributed Trees
For producing the distributed trees, we use basic ran-
dom vectors representing tree nodes ~n. These are
generated by independently drawing their elements
from a normal distribution N(0,1) with mean 0 and
variance 1. The vectors are then normalized so that
they have unitary Euclidean length. This generation
process guarantees that, for a high enough number
of dimensions, the vectors are statistically expected
to be nearly orthogonal, i.e. the dot product among
pairs of different vectors is expected to be 0.
We can obtain the pure distributed trees (DT) and
the distributional distributed trees (DDT) along with
their kernel functions, DTK and DDTK, by using
different word vectors ~w. In the DTs, these vectors
are random vectors as the other nodes. In DDTs,
these vectors are distributional vectors obtained on
a corpus with an LSA reduction (Deerwester et al,
1990).
3.2.1 Entailment-specific Kernels
Recognizing textual entailment (RTE) is a
complex semantic task often interpreted as a classi-
fication task. Given the text T and the hypothesis
H determine whether or not T entails H . For
applying the previous kernels to this classification
task, we need to define a specific class of kernels.
As in (Zanzotto and Moschitti, 2006; Wang and
Neumann, 2007; Zanzotto et al, 2009), we encode
the text T and the hypothesis H in two separate
syntactic feature spaces. Then, given two pairs of
text-hypothesis P1 = (T1, H1) and P2 = (T2, H2),
the prototypical kernel PK is written as follows:
PK(P1, P2) = K(T1, T2) +K(H1, H2) (5)
where K(?, ?) is a generic kernel. We will then ex-
periment with different PK kernels obtained using:
the original tree kernel function (TK) (Collins and
Duffy, 2002), DTK, and DDTK.
Along with the previous task specific kernels, we
use a simpler feature (Lex) that is extremely effec-
tive in determining the entailment between T andH .
This simple feature is the lexical similarity between
T andH computed using WordNet-based metrics as
in (Corley and Mihalcea, 2005). This feature, here-
after called Lex, encodes the similarity between T
andH , i.e., sim(T,H). This feature is used alone or
in combination with the previous kernels and it gives
an important boost to their performances. In the
task experiment, we will then also have: Lex+TK,
Lex+DTK, and Lex+DDTK.
4 Experimental Evaluation
In this section, we experiment with the distributed
tree kernels (DTK) and the distributional distributed
tree kernels (DDTK) in order to understand whether
or not the syntactic structure and the distributional
meaning can be easily encoded in the distributed
trees. We will experiment in two ways: (1) direct
comparison of the distances produced by the origi-
nal tree kernel (TK) (Collins and Duffy, 2002) and
the novel kernels DTK and DDTK; (2) task driven
evaluation of DTK and DDTK using the RTE task.
The rest of the section is organized as follows. We
firstly introduce the experiment set up that is used
for the two settings (Sec. 4.1). Secondly, we report
on the experimental results (Sec. 4.2).
12
4.1 Experimental Set-up
We have the double aim of producing a direct com-
parison of how the distributed tree kernel (DTK) is
approximating the original tree kernel (TK) and a
task based comparison for assessing if the approx-
imation is enough effective to similarly solve the
task that is textual entailment recognition. For both
experimental settings, we take the recognizing tex-
tual entailment sets ranging from the first challenge
(RTE-1) to the fifth (RTE-5) (Dagan et al, 2006;
Bar-Haim et al, 2006; Giampiccolo et al, 2007;
Bentivogli et al, 2009).
The distributional vectors used for DDTK have
been obtained by an LSA reduction of the word-by-
word cooccurrence matrix generated on the UKWaC
corpus (Ferraresi et al, 2008), using a context win-
dow of size 3. An appropriate size for the LSA re-
duction was deemed to be 250. Thus, in the exper-
iments we used 250 dimensions both for distribu-
tional and random vectors, to allow a correct com-
parison between DTK and DDTK models.
For the direct comparison, we used tree pairs de-
rived from the RTE sets. Each pair is derived from a
T-H pair where T and H are syntactically analyzed
and each RTE set produces the corresponding set of
tree pairs, e.g., the development set of RTE1 pro-
duces a set of 567 tree pairs. To determine whether
or not a distributed kernel, DTK or DDTK, is be-
having similarly to the original TK kernel, given a
set of tree pairs, we produce two ranked lists of tree
pairs: the first is ranked according to the original TK
applied to the tree pairs and the second according to
the target distributed kernel. We evaluate the corre-
lation of the two ranked lists according to the spear-
man?s correlation. Higher correlation corresponds to
a better approximation of TK.
For the task driven comparison, we experimented
with the datasets in the classical learning setting: the
development set is used as training set and the final
classifier is tested on the testing set. We used a sup-
port vector machine (Joachims, 1999) with an im-
plementation of the original tree kernel (Moschitti,
2006). The classifiers are evaluated according to the
accuracy of the classification decision on the testing
set, i.e., the ratio of the correct decisions over all the
decisions to take.
Average Spearman?s Correlation
DTK 0.8335
DDTK 0.7641
Table 1: Average Spearman?s correlations of the tree ker-
nel (TK) with the distributed tree kernel (DTK) and the
distributed distributional tree kernel (DDTK) in a vector
space with 250 dimensions
avg RTE1 RTE2 RTE3 RTE5
TK 55.02% 55.50% 53.38% 55.88% 55.33%
DTK 55.63% 57.25% 54.88% 54.38% 56.00%
DDTK 55.11% 54.00% 53.88% 55.38% 57.17%
Lex+TK 62.11% 59.75% 61.25% 66.62% 60.83%
Lex+DTK 63.25% 61.12% 62.12% 66.25% 63.50%
Lex+DDTK 62.90% 60.62% 61.25% 66.38% 63.33%
Table 2: Accuracies of the different methods on the tex-
tual entailment recognition task
4.2 Experimental results
In the first experiment of this set, we want to in-
vestigate which one between DTK and DDTK cor-
relates better with original TK. Table 1 reports the
spearman?s correlations of tree kernels with DTK
and DDTK in a vector space with 250 dimensions.
These correlations are obtained averaging the corre-
lations over the 9 RTE sets. According to these re-
sults, DTK better correlates with TK with respect to
DDTK. Distributional vectors used for words are not
orthogonal as these are used to induce the similarity
between words. Yet, this important feature of these
vectors determines a worse encoding of the syntactic
structure.
In the task driven experiment, we wanted to in-
vestigate whether the difference in correlation has
some effect on the performance of the different sys-
tems. Accuracy results on the RTE task are reported
in Table 2. The columns RTE1, RTE2, RTE3, and
RTE5 represent the accuracies of the different ker-
nels using the traditional split of training and test-
ing. The column avg reports the average accuracy
of the different methods in the 4 sets. Rows rep-
resent the different kernels used in this comparative
experiment. These kernels are used with the task
specific kernel PK by changing the generic kernel
K. The first 3 rows represent the pure kernels while
the last 3 rows represent the kernels boosted with
the lexical similarity (Lex), a simple feature com-
puted using WordNet-based metrics, as in (Corley
13
and Mihalcea, 2005). Looking at the first 3 rows,
we derive that there is not a significant difference be-
tween TK, DTK, and DDTK. DTK and DDTK can
then be used instead of the TK. This is an important
result, since the computation of DTK (or DDTK) is
much faster than that of TK, due to TK?s complex-
ity being quadratic with respect to the size of the
trees, and DTK requiring a simple dot product over
vectors that can be obtained with linear complex-
ity with respect to the tree size. The second fact is
that there is no difference between DTK and DDTK:
more semantically informed word vectors have the
same performance of random vectors.
5 Conclusions
Distributed structures and distributional meaning are
largely correlated. In this paper, we analyzed this
correlation with respect to the research challenge of
producing compositional models for distributional
semantics. In the studies of distributed represen-
tation, compositionality is a big issue that has pro-
duced many models and approaches. Compositional
distributional semantics poses the same issue. We
empirically showed that a methodology for includ-
ing distributional meaning in distributed represen-
tation is possible, but it must be furtherly devel-
oped to be an added value. Distributional semantics
has been positively added in traditional tree kernels
(Mehdad et al, 2010). Yet, the specific requirement
of distributed tree kernels (i.e., the orthogonality of
the vectors) reduces this positive effect.
References
James A. Anderson. 1973. A theory for the recognition
of items from short memorized lists. Psychological
Review, 80(6):417 ? 438.
Mark Andrews, Gabriella Vigliocco, and David Vinson.
2009. Integrating experiential and distributional data
to learn semantic representations. Psychological Re-
view, 116(3):463 ? 498.
Roy Bar-Haim, Ido Dagan, Bill Dolan, Lisa Ferro, Danilo
Giampiccolo, Bernardo Magnini, and Idan Szpektor.
2006. The second pascal recognising textual entail-
ment challenge. In Proceedings of the Second PAS-
CAL Challenges Workshop on Recognising Textual
Entailment. Venice, Italy.
Marco Baroni and Roberto Zamparelli. 2010. Nouns
are vectors, adjectives are matrices: Representing
adjective-noun constructions in semantic space. In
Proceedings of the 2010 Conference on Empiri-
cal Methods in Natural Language Processing, pages
1183?1193, Cambridge, MA, October. Association for
Computational Linguistics.
Luisa Bentivogli, Ido Dagan, Hoa T. Dang, Danilo Gi-
ampiccolo, and Bernardo Magnini. 2009. The Fifth
PASCAL Recognizing Textual Entailment Challenge.
In Proceedings of TAC?2009.
Michael Collins and Nigel Duffy. 2002. New ranking
algorithms for parsing and tagging: Kernels over dis-
crete structures, and the voted perceptron. In Proceed-
ings of ACL02.
Courtney Corley and Rada Mihalcea. 2005. Measur-
ing the semantic similarity of texts. In Proc. of the
ACL Workshop on Empirical Modeling of Semantic
Equivalence and Entailment, pages 13?18. Associa-
tion for Computational Linguistics, Ann Arbor, Michi-
gan, June.
Ido Dagan, Oren Glickman, and Bernardo Magnini.
2006. The pascal recognising textual entailment chal-
lenge. In Quionero-Candela et al, editor, LNAI 3944:
MLCW 2005, pages 177?190. Springer-Verlag, Milan,
Italy.
Scott C. Deerwester, Susan T. Dumais, Thomas K. Lan-
dauer, George W. Furnas, and Richard A. Harshman.
1990. Indexing by latent semantic analysis. Jour-
nal of the American Society of Information Science,
41(6):391?407.
Adriano Ferraresi, Eros Zanchetta, Marco Baroni, and
Silvia Bernardini. 2008. Introducing and evaluating
ukwac, a very large web-derived corpus of english. In
In Proceed-ings of the WAC4Workshop at LREC 2008,
Marrakesh, Morocco.
P. Foltz, W. Kintsch, and T. Landauer. 1998. The mea-
surement of textual coherence with latent semantic
analysis. Discourse Processes, 25(2&3):285?307.
Gottlob Frege. 1884. Die Grundlagen der Arith-
metik (The Foundations of Arithmetic): eine logisch-
mathematische Untersuchung ber den Begriff der
Zahl. Breslau.
Danilo Giampiccolo, Bernardo Magnini, Ido Dagan, and
Bill Dolan. 2007. The third pascal recognizing tex-
tual entailment challenge. In Proceedings of the ACL-
PASCAL Workshop on Textual Entailment and Para-
phrasing, pages 1?9. Association for Computational
Linguistics, Prague, June.
Emiliano Guevara. 2010. A regression model of
adjective-noun compositionality in distributional se-
mantics. In Proceedings of the 2010 Workshop on
GEometrical Models of Natural Language Semantics,
pages 33?37, Uppsala, Sweden, July. Association for
Computational Linguistics.
14
G. E. Hinton, J. L. McClelland, and D. E. Rumelhart.
1986. Distributed representations. In D. E. Rumel-
hart and J. L. McClelland, editors, Parallel Distributed
Processing: Explorations in the Microstructure of
Cognition. Volume 1: Foundations. MIT Press, Cam-
bridge, MA.
Thorsten Joachims. 1999. Making large-scale svm
learning practical. In B. Schlkopf, C. Burges, and
A. Smola, editors, Advances in Kernel Methods-
Support Vector Learning. MIT Press.
Thomas K. Landauer and Susan T. Dumais. 1997. A so-
lution to plato?s problem: The latent semantic analysis
theory of acquisition, induction, and representation of
knowledge. Psychological Review, 104(2):211?240,
April.
K. McRae, V. R. de Sa, and M. S. Seidenberg. 1997.
On the nature and scope of featural representations of
word meaning. J Exp Psychol Gen, 126(2):99?130,
June.
Yashar Mehdad, Alessandro Moschitti, and Fabio Mas-
simo Zanzotto. 2010. Syntactic/semantic structures
for textual entailment recognition. In Human Lan-
guage Technologies: The 2010 Annual Conference
of the North American Chapter of the Association
for Computational Linguistics, HLT ?10, pages 1020?
1028, Stroudsburg, PA, USA. Association for Compu-
tational Linguistics.
Jeff Mitchell and Mirella Lapata. 2010. Composition in
distributional models of semantics. Cognitive Science.
Richard Montague. 1974. English as a formal language.
In Richmond Thomason, editor, Formal Philosophy:
Selected Papers of Richard Montague, pages 188?221.
Yale University Press, New Haven.
Alessandro Moschitti. 2006. Making tree kernels prac-
tical for natural language learning. In Proceedings of
EACL?06, Trento, Italy.
Bennet B. Murdock. 1983. A distributed memory model
for serial-order information. Psychological Review,
90(4):316 ? 338.
T. A. Plate. 1994. Distributed Representations and
Nested Compositional Structure. Ph.D. thesis.
David E. Rumelhart and James L. Mcclelland. 1986.
Parallel Distributed Processing: Explorations in the
Microstructure of Cognition : Foundations (Parallel
Distributed Processing). MIT Press, August.
Vladimir Vapnik. 1995. The Nature of Statistical Learn-
ing Theory. Springer.
Rui Wang and Gu?nter Neumann. 2007. Recognizing tex-
tual entailment using sentence similarity based on de-
pendency tree skeletons. In Proceedings of the ACL-
PASCAL Workshop on Textual Entailment and Para-
phrasing, pages 36?41, Prague, June. Association for
Computational Linguistics.
Fabio Massimo Zanzotto and Alessandro Moschitti.
2006. Automatic learning of textual entailments with
cross-pair similarities. In Proceedings of the 21st Col-
ing and 44th ACL, pages 401?408, Sydney, Australia,
July.
Fabio Massimo Zanzotto, Marco Pennacchiotti, and
Alessandro Moschitti. 2009. A machine learning ap-
proach to textual entailment recognition. NATURAL
LANGUAGE ENGINEERING, 15-04:551?582.
Fabio Massimo Zanzotto, Ioannis Korkontzelos,
Francesca Fallucchi, and Suresh Manandhar. 2010.
Estimating linear models for compositional dis-
tributional semantics. In Proceedings of the 23rd
International Conference on Computational Linguis-
tics (COLING), August,.
15
Proceedings of the Workshop on Continuous Vector Space Models and their Compositionality, pages 40?49,
Sofia, Bulgaria, August 9 2013. c?2013 Association for Computational Linguistics
Transducing Sentences to Syntactic Feature Vectors:
an Alternative Way to ?Parse??
Fabio Massimo Zanzotto
University of Rome ?Tor Vergata?
Via del Politecnico 1
00133 Roma, Italy
fabio.massimo.zanzotto@uniroma2.it
Lorenzo Dell?Arciprete
University of Rome ?Tor Vergata?
Via del Politecnico 1
00133 Roma, Italy
lorenzo.dellarciprete@gmail.com
Abstract
Classification and learning algorithms use
syntactic structures as proxies between
source sentences and feature vectors. In
this paper, we explore an alternative path
to use syntax in feature spaces: the Dis-
tributed Representation ?Parsers? (DRP).
The core of the idea is straightforward:
DRPs directly obtain syntactic feature vec-
tors from sentences without explicitly pro-
ducing symbolic syntactic interpretations.
Results show that DRPs produce feature
spaces significantly better than those ob-
tained by existing methods in the same
conditions and competitive with those ob-
tained by existing methods with lexical in-
formation.
1 Introduction
Syntactic processing is widely considered an im-
portant activity in natural language understand-
ing (Chomsky, 1957). Research in natural lan-
guage processing (NLP) exploits this hypothesis
in models and systems. Syntactic features improve
performance in high level tasks such as question
answering (Zhang and Lee, 2003), semantic role
labeling (Gildea and Jurafsky, 2002; Pradhan et
al., 2005; Moschitti et al, 2008; Collobert et al,
2011), paraphrase detection (Socher et al, 2011),
and textual entailment recognition (MacCartney et
al., 2006; Wang and Neumann, 2007; Zanzotto et
al., 2009).
Classification and learning algorithms are key
components in the above models and in current
NLP systems, but these algorithms cannot directly
use syntactic structures. The relevant parts of
phrase structure trees or dependency graphs are
explicitly or implicitly stored in feature vectors.
To fully exploit syntax in learning classi-
fiers, kernel machines (Cristianini and Shawe-
Taylor, 2000) use graph similarity algorithms
(e.g., (Collins and Duffy, 2002) for trees) as struc-
tural kernels (Ga?rtner, 2003). These structural ker-
nels allow to exploit high-dimensional spaces of
syntactic tree fragments by concealing their com-
plexity. These feature spaces, although hidden,
still exist. Then, even in kernel machines, sym-
bolic syntactic structures act only as proxies be-
tween the source sentences and the syntactic fea-
ture vectors.
In this paper, we explore an alternative way
to use syntax in feature spaces: the Distributed
Representation Parsers (DRP). The core of the
idea is straightforward: DRPs directly bridge
the gap between sentences and syntactic feature
spaces. DRPs act as syntactic parsers and fea-
ture extractors at the same time. We leverage on
the distributed trees recently introduced by Zan-
zotto&Dell?Arciprete (2012) and on multiple lin-
ear regression models. Distributed trees are small
vectors that encode the large vectors of the syn-
tactic tree fragments underlying the tree kernels
(Collins and Duffy, 2002). These vectors effec-
tively represent the original vectors and lead to
performances in NLP tasks similar to tree kernels.
Multiple linear regression allows to learn linear
DRPs from training data. We experiment with the
Penn Treebank data set (Marcus et al, 1993). Re-
sults show that DRPs produce distributed trees sig-
nificantly better than those obtained by existing
methods, in the same non-lexicalized conditions,
and competitive with those obtained by existing
methods with lexical information. Finally, DRPs
are extremely faster than existing methods.
The rest of the paper is organized as fol-
lows. First, we present the background of our
40
idea (Sec. 2). Second, we fully describe our
model (Sec. 3). Then, we report on the experi-
ments (Sec. 4). Finally, we draw some conclusions
and outline future work (Sec. 5)
2 Background
Classification and learning algorithms for NLP
tasks treat syntactic structures t as vectors in fea-
ture spaces ~t ? Rm. Each feature generally rep-
resents a substructure ?i. In simple weighting
schemes, feature values are 1 if ?i is a substruc-
ture of t and 0 otherwise. Different weighting
schemes are used and possible. Then, learning al-
gorithms exploit these feature vectors in different
ways. Decision tree learners (Quinlan, 1993) elect
the most representative feature at each iteration,
whereas kernel machines (Cristianini and Shawe-
Taylor, 2000) exploit similarity between pairs of
instances, s(t1, t2). This similarity is generally
measured as the dot product between the two vec-
tors, i.e. s(t1, t2) = ~t1 ? ~t2.
The use of syntactic features changed when tree
kernels (Collins and Duffy, 2002) appeared. Tree
kernels gave the possibility to fully exploit feature
spaces of tree fragments. Until then, learning al-
gorithms could not treat these huge spaces. It is
infeasible to explicitly represent that kind of fea-
ture vectors and to directly compute similarities
through dot products. Tree kernels (Collins and
Duffy, 2002), by computing similarities between
two trees with tree comparison algorithms, exactly
determine dot products of vectors in these target
spaces. After their introduction, different tree ker-
nels have been proposed (e.g., (Vishwanathan and
Smola, 2002; Culotta and Sorensen, 2004; Mos-
chitti, 2006)). Their use spread in many NLP
tasks (e.g., (Zhou et al, 2007; Wang and Neu-
mann, 2007; Moschitti et al, 2008; Zanzotto et
al., 2009; Zhang and Li, 2009)) and in other areas
like biology (Vert, 2002; Hashimoto et al, 2008)
and computer security (Du?ssel et al, 2008; Rieck
and Laskov, 2007; Bockermann et al, 2009).
Tree kernels have played a very important role
in promoting the use of syntactic information in
learning classifiers, but this method obfuscated the
fact that syntactic trees are ultimately used as vec-
tors in learning algorithms. To work with the
idea of directly obtaining rich syntactic feature
vectors from sentences, we need some techniques
to make these high-dimensional vectors again ex-
plicit, through smaller but expressive vectors.
A solution to the above problem stems from
the recently revitalized research in Distributed
Representations (DR) (Hinton et al, 1986; Ben-
gio, 2009; Collobert et al, 2011; Socher et al,
2011; Zanzotto and Dell?Arciprete, 2012). Dis-
tributed Representations, studied in opposition to
symbolic representations (Rumelhart and Mcclel-
land, 1986), are methods for encoding data struc-
tures such as trees into vectors, matrices, or high-
order tensors. The targets of these representa-
tions are generally propositions, i.e., flat tree struc-
tures. The Holographic Reduced Representations
(HRR), proposed by Plate (1994), produce nearly
orthogonal vectors for different structures by com-
bining circular convolution and randomly gener-
ated vectors for basic components (as in (Ander-
son, 1973; Murdock, 1983)).
Building on HRRs, Distributed Trees (DT) have
been proposed to encode deeper trees in low di-
mensional vectors (Zanzotto and Dell?Arciprete,
2012). DTs approximate the feature space of tree
fragments defined for the tree kernels (Collins and
Duffy, 2002) and guarantee similar performances
of classifiers in NLP tasks such as question classi-
fication and textual entailment recognition. Thus,
Distributed Trees are good representations of syn-
tactic trees, that we can use in our definition of
distributed representation parsers (DRPs).
3 Distributed Representation Parsers
In this section, first, we sketch the idea of Dis-
tributed Representation ?Parsers? (DRPs). Then,
we review the distributed trees as a way to repre-
sent trees in low dimensional vectors. Finally, we
describe how to build DRPs by mixing a function
that encodes sentences in vectors and a linear re-
gressor that can be induced from training data.
3.1 The Idea
The approach to using syntax in learning algo-
rithms generally follows two steps: first, parse
sentences s with a symbolic parser (e.g., (Collins,
2003; Charniak, 2000; Nivre et al, 2007)) and
produce symbolic trees t; second, use an en-
coder to build syntactic feature vectors. Fig-
ure 1 sketches this idea when the final vectors
are the distributed trees
;
t ? Rd (Zanzotto and
Dell?Arciprete, 2012)1. In this case, the last step
1To represent a distributed tree for a tree t, we use the
notation
;
t to stress that this small vector is an approximation
of the original high-dimensional vector ~t in the space of tree
41
s
?We booked the flight? ?
Symbolic
Parser
(SP)
?
t
SPPP
NP
PRP
We
VPaa!!
V
booked
NP
Q
DT
the
NN
flight
?
Distributed
Tree
Encoder
(DT)
?
;
t ? Rd
?
?
?
?
?
?
0.0002435
0.00232
.
.
.
?0.007325
?
?
?
?
?
?
Distributed Representation Parser (DRP)
;s ? Rd
D ?
?
?
?
?
?
?
?0.0017245
0.0743869
.
.
.
0.0538474
?
?
?
?
?
?
? P
Figure 1: ?Parsing? with distributed structures in perspective
is the Distributed Tree Encoder (DT).
Our proposal is to build a Distributed Represen-
tation ?Parser? (DRP) that directly maps sentences
s into the final vectors. We choose the distributed
trees
;
t as these reduced vectors fully represent the
syntactic trees. A DRP acts as follows (see Fig-
ure 1): first, a function D encodes sentence s into
a distributed vector ;s ? Rd; second, a function
P transforms the input vector ;s into a distributed
tree
;
t . This second step is a vector to vector trans-
formation and, in a wide sense, ?parses? the input
sentence.
Given an input sentence s, a DRP is then a
function defined as follows:
;
t = DRP (s) = P (D(s)) (1)
In this paper, we design some functions D and we
propose a linear function P , designed to be a re-
gressor that can be induced from training data. In
this study, we use a space with d dimensions for
both sentences ;s and distributed trees
;
t , but, in
general, these spaces can be of different size.
3.2 Syntactic Trees as Distributed Vectors
We here report on the distributed trees2 (Zan-
zotto and Dell?Arciprete, 2012) to describe how
these vectors represent syntactic trees and how the
dot product between two distributed trees approxi-
mates the tree kernel defined by Collins and Duffy
(2002).
fragments.
2For the experiments, we used the implemen-
tation of the distributed tree encoder available at
http://code.google.com/p/distributed-tree-kernels/
Given a tree t, the corresponding distributed tree
;
t is defined as follows:
DT (t) =
?
?i?S(t)
?i
;? i (2)
where S(t) is the set of the subtrees ?i of t,
;? i
is the small vector corresponding to tree fragment
?i and ?i is the weight of subtree ?i in the final
feature space. As in (Collins and Duffy, 2002), the
set S(t) contains tree fragments ? such that the
root of ? is any non-terminal node in t and, if ?
contains node n, it must contain all the siblings of
n in t (see, for example, Slex(t) in Figure 2). The
weight ?i is defined as:
?i =
?
?
?
?
?|?i|?1 if |?i| > 1 and ? 6= 0
1 if |?i| = 1
0 if ? = 0
(3)
where |?i| is the number of non-terminal nodes of
tree fragment ?i and ? is the traditional parame-
ter used to penalize large subtrees. For ? = 0,
?i has a value 1 for productions and 0 other-
wise. If different tree fragments are associated
to nearly orthonormal vectors, the dot product
;
t1 ?
;
t2 approximates the tree kernel (Zanzotto and
Dell?Arciprete, 2012).
A key feature of the distributed tree fragments
;? is that these vectors are built compositionally
from a set N of nearly orthonormal random vec-
tors
;n , associated to node labels n. Given a sub-
tree ? , the related vector is obtained as:
;? = ;n1 ?
;n2 ? . . .?
;nk
42
Sno lex(t) = {
S
Q
NP VP
,
VP
Z