Proceedings of the 12th Conference of the European Chapter of the ACL, pages 692?700,
Athens, Greece, 30 March ? 3 April 2009. c?2009 Association for Computational Linguistics
 
 
Tagging Urdu Text with Parts of Speech: A Tagger Comparison 
 
Hassan Sajjad 
Universit?t Stuttgart 
Stuttgart. Germany 
sajjad@ims.uni-stuttgart.de 
Helmut Schmid 
Universit?t Stuttgart 
Stuttgart, Germany 
schmid@ims.uni-stuttgart.de 
  
 
  
Abstract 
In this paper, four state-of-art probabilistic 
taggers i.e. TnT tagger, TreeTagger, RF tagger 
and SVM tool, are applied to the Urdu lan-
guage. For the purpose of the experiment, a 
syntactic tagset is proposed. A training corpus 
of 100,000 tokens is used to train the models. 
Using the lexicon extracted from the training 
corpus, SVM tool shows the best accuracy of 
94.15%. After providing a separate lexicon of 
70,568 types, SVM tool again shows the best 
accuracy of 95.66%. 
1 Urdu Language 
Urdu belongs to the Indo-Aryan language family. 
It is the national language of Pakistan and is one 
of the official languages of India. The majority 
of the speakers of Urdu spread over the area of 
South Asia, South Africa and the United King-
dom1. 
Urdu is a free order language with general 
word order SOV. It shares its phonological, mor-
phological and syntactic structures with Hindi. 
Some linguists considered them as two different 
dialects of one language (Bhatia and Koul, 
2000). However, Urdu is written in Perso-arabic 
script and inherits most of the vocabulary from 
Arabic and Persian. On the other hand, Hindi is 
written in Devanagari script and inherits vocabu-
lary from Sanskrit. 
Urdu is a morphologically rich language. 
Forms of the verb, as well as case, gender, and 
number are expressed by the morphology. Urdu 
represents case with a separate character after the 
head noun of the noun phrase. Due to their sepa-
rate occurrence and their place of occurrence, 
they are sometimes considered as postpositions. 
Considering them as case markers, Urdu has no-
                                                 
1 http://www.ethnologue.com/14/show_language.asp? 
code=URD 
minative, ergative, accusative, dative, instrumen-
tal, genitive and locative cases (Butt, 1995: pg 
10). The Urdu verb phrase contains a main verb, 
a light verb describing the aspect, and a tense 
verb describing the tense of the phrase (Hardie, 
2003; Hardie, 2003a). 
2 Urdu Tagset 
There are various questions that need to be ans-
wered during the design of a tagset. The granu-
larity of the tagset is the first problem in this re-
gard. A tagset may consist either of general parts 
of speech only or it may consist of additional 
morpho-syntactic categories such as number, 
gender and case. In order to facilitate the tagger 
training and to reduce the lexical and syntactic 
ambiguity, we decided to concentrate on the syn-
tactic categories of the language. Purely syntactic 
categories lead to a smaller number of tags which 
also improves the accuracy of manual tagging2 
(Marcus et al, 1993). 
Urdu is influenced from Arabic, and can 
be considered as having three main parts of 
speech, namely noun, verb and particle (Platts, 
1909; Javed, 1981; Haq, 1987). However, some 
grammarians proposed ten main parts of speech 
for Urdu (Schmidt, 1999). The work of Urdu 
grammar writers provides a full overview of all 
the features of the language. However, in the 
perspective of the tagset, their analysis is lacking 
the computational grounds. The semantic, mor-
phological and syntactic categories are mixed in 
their distribution of parts of speech. For example, 
Haq (1987) divides the common nouns into sit-
uational (smile, sadness, darkness), locative 
(park, office, morning, evening), instrumental 
(knife, sword) and collective nouns (army, data). 
In 2003, Hardie proposed the first com-
putational part of speech tagset for Urdu (Hardie, 
                                                 
2 A part of speech tagger for Indian languages, available at 
http://shiva.iiit.ac.in/SPSAL2007 /iiit_tagset_guidelines.pdf 
692
  
2003a). It is a morpho-syntactic tagset based on 
the EAGLES guidelines. The tagset contains 350 
different tags with information about number, 
gender, case, etc. (van Halteren, 2005). The 
EAGLES guidelines are based on three levels, 
major word classes, recommended attributes and 
optional attributes. Major word classes include 
thirteen tags: noun, verb, adjective, pro-
noun/determiner, article, adverb, adposition, con-
junction, numeral, interjection, unassigned, resi-
dual and punctuation. The recommended 
attributes include number, gender, case, finite-
ness, voice, etc.3 In this paper, we will focus on 
purely syntactic distributions thus will not go 
into the details of the recommended attributes of 
the EAGLES guidelines. Considering the 
EAGLES guidelines and the tagset of Hardie in 
comparison with the general parts of speech of 
Urdu, there are no articles in Urdu. Due to the 
phrase level and semantic differences, pronoun 
and demonstrative are separate parts of speech in 
Urdu. In the Hardie tagset, the possessive pro-
nouns like  /mera/ (my), 	
 /tumhara/ 
(your), 	 /humara/ (our) are assigned to the 
category of possessive adjective. Most of the Ur-
du grammarians consider them as pronouns 
(Platts, 1909; Javed, 1981; Haq, 1987). However, 
all these possessive pronouns require a noun in 
their noun phrase, thus show a similar behavior 
as demonstratives. The locative and temporal 
adverbs ( /yahan/ (here),  /wahan/ (there), 
 /ab/ (now), etc.) and, the locative and tempor-
al nouns ( /subah/ (morning),    /sham/ 
(evening),    /gher/ (home)) appear in a very 
similar syntactic context. In order to keep the 
structure of pronoun and noun consistent, loca-
tive and temporal adverbs are treated as pro-
nouns. The tense and aspect of a verb in Urdu is 
represented by a sequence of auxiliaries. Consid-
er the example4: 
 
       
      Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1465?1468,
October 25-29, 2014, Doha, Qatar.
c?2014 Association for Computational Linguistics
Verifiably Effective Arabic Dialect Identification
Kareem Darwish, Hassan Sajjad, Hamdy Mubarak
Qatar Computing Research Institute
Qatar Foundation
{kdarwish,hsajjad,hmubarak}@qf.org.qa
Abstract
Several recent papers on Arabic dialect identi-
fication have hinted that using a word unigram
model is sufficient and effective for the task.
However, most previous work was done on a
standard fairly homogeneous dataset of dialec-
tal user comments. In this paper, we show
that training on the standard dataset does not
generalize, because a unigram model may be
tuned to topics in the comments and does not
capture the distinguishing features of dialects.
We show that effective dialect identification
requires that we account for the distinguishing
lexical, morphological, and phonological phe-
nomena of dialects. We show that accounting
for such can improve dialect detection accu-
racy by nearly 10% absolute.
1 Introduction
Modern Standard Arabic (MSA) is the lingua franca
of the so-called Arab world, which includes north-
ern Africa, the Arabian Peninsula, and Mesopotamia.
However, Arabic speakers generally use dramatically
different languages (or dialects) in daily interactions
and in social media. These dialects may differ in vocab-
ulary, morphology, and spelling from MSA and most
do not have standard spellings. There is often large
lexical overlap between dialects and MSA. Performing
proper Arabic dialect identification may positively im-
pact many Natural Language Processing (NLP) appli-
cation. For example, transcribing dialectal speech or
automatically translating into a particular dialect would
be aided by the use of targeted language models that are
trained on texts in that dialect.
This has led to recent interest in automatic identifi-
cation of different Arabic dialects (Elfardy et al., 2013;
Cotterell et al., 2014; Zaidan et al., 2014). Though pre-
vious work (Cotterell et al., 2014) have reported high
accuracies for dialect identification using word uni-
gram model, which implies that this is a solved prob-
lem, we argue that the problem is far from being solved.
The reason for this assertion stems from the fact that the
available dialectal data is drawn from singular sources,
namely online news sites, for each dialect. This is prob-
lematic because comments on singular news site are
likely to have some homogeneity in topics and jargon.
Such homogeneity has caused fairly simple classifica-
tion techniques that use word unigrams and character n-
grams to yield very high identification accuracies. Per-
haps, this can be attributed to topical similarity and not
just differences between dialects. To showcase this, we
trained a classifier using the best reported methods, and
we tested the classifier on a new test set of 700 tweets,
with dialectal Egyptian (ARZ) and MSA tweets, which
led to a low accuracy of 83.3%. We also sorted words
in the ARZ part from our training dataset by how much
they discriminate between ARZ and MSA (using mu-
tual information) and indeed many of the top words
were in fact MSA words.
There seems to be a necessity to identify lexical and
linguistic features that discriminate between MSA and
different dialects. In this paper, we highlight some
such features that help in separating between MSA
and ARZ. We identify common ARZ words that do
not overlap with MSA and identify specific linguistic
phenomena that exist in ARZ, and not MSA, such as
morphological patterns, word concatenations, and verb
negation constructs (Section 3). We also devise meth-
ods for capturing the linguistic phenomena, and we use
the appearance of such phenomena as features (Sec-
tion 4). Further, we show the positive impact of using
the new features in identifying ARZ (Section 5).
2 Previous Work
Previous work on Arabic dialect identification uses n-
gram based features at both word-level and character-
level to identify dialectal sentences (Elfardy et al.,
2013; Cotterell et al., 2014; Zaidan et al., 2011; Zaidan
et al., 2014). Zaidan et al. (2011) created a dataset of
dialectal Arabic. They performed cross-validation ex-
periments for dialect identification using word n-gram
based features. Elfardy et al. (2013) built a system to
distinguish between ARZ and MSA. They used word
n-gram features combined with core (token-based and
perplexity-based features) and meta features for train-
ing. Their system showed a 5% improvement over
the system of Zaidan et al. (2011). Later, Zaidan et
al. (2014) used several word n-gram based and char-
acter n-gram based features for dialect identification.
The system trained on word unigram-based feature per-
formed the best with character five-gram-based feature
being second best. A similar result is shown by Cot-
terell et al. (2014) where word unigram model performs
1465
the best.
All of the previous work except Cotterell et al.
(2014)
1
evaluate their systems using cross-validation.
These models heavily rely on the coverage of training
data to achieve better identification. This limits the ro-
bustness of identification to genres inline with the train-
ing data.
Language identification is a related area to dialect
identification. It has raised some of the issues which we
discussed in this paper in the context of dialect identi-
fication. Lui et al. (2011) showed that in-domain lan-
guage identification performs better than cross domain
language identification. Tiedemann et al. (2012) argued
that the linguistic understanding of the differences be-
tween languages can lead to a better language identi-
fication system. kilgarriff (2001) discussed the differ-
ences between datasets as a poor representation of dif-
ferences between dialects of English.
In this paper, we exploit the linguistic phenomena
that are specific to Arabic dialects to show that they
produce significant improvements in accuracy. We
show that this also helps in achieving high quality
cross-domain dialect identification system.
3 Dialectal Egyptian Phenomena
There are several phenomena in ARZ that set it apart
from MSA. Some of them are as follows:
Dialectal words: ARZ uses unique words that do
not overlap with MSA and may not overlap with other
dialects. Some of the common ARZ words are: ?zy?
(like), ?kdh? (like this), and ?Azyk? (how are you)
2
.
These dialectal terms stem from the following:
? Using proper Arabic words that are rarely used in
MSA such as ?$nTp? (bag) and ?n$wf? (we see).
? Fusing multiple words together by concatenating and
dropping letters such as the word ?mEl$? (no worry),
which is a fusion of ?mA Elyh $y? ?.
? Using non-standard spelling of words such as
?SAbE? (finger) instead of ?<sbE? in MSA. Conse-
quently, broken plurals may also be non-standard.
? using non-Arabic words such as ?<y$Arb? (scarf),
which is transliterated from the French ?echarpe.
? altering the forms of some pronouns such as the fem-
inine second person pronoun from ?k? to ?ky?, the sec-
ond person plural pronoun ?tm? to ?tw?, and the object
pronoun ?km? to ?kw?.
Morphological differences: ARZ makes use of par-
ticular morphological patterns that do not exist in MSA
and often alters some morphological constructs. Some
examples include:
? Adding the letter ?b? in front of verb in present tense.
Ex. MSA: ?ylEb? (he plays)? EG: ?bylEb?.
? Using the letters ?H? or ?h?, instead of ?s?, to indi-
cate future tense. Ex. MSA: ?sylEb? (he will play)?
EG: ?hylEb? or ?HylEb?.
1
Zaidan et al. (2014) applied their classifier to a different
genre but did not evaluate it?s performance.
2
Buckwalter encoding is used throughout the paper.
? Adding the letters ?At? to passive past tense verbs.
Ex. MSA: ?luEiba? (was played)? ?AtlaEab?.
? Adding the letters ?m? or ?mA? before the verb and
?$? or ?$y? after the verb to express negation. Ex.
MSA: ?lm ylEb? (he did not play)? ?mlEb$?.
? the merging of verbs and prepositional phrases of the
form (to-pronoun) that follow it. Ex. MSA: ?ylEb lh?
(he plays for/to him)? ?bylEblh?.
? Replacing a short vowel with a long vowel in im-
perative verbs that are derived from hollow roots. Ex.
MSA: ?qul? (say)? ?qwl?.
Letter substitution: in ARZ the following letter
substitutions are common:
? ?v?? ?t?. Ex. MSA: ?kvyr? (a lot)? EG: ?ktyr?.
? ?}?? ?y?. Ex. MSA: ?b}r? (well)? ?byr?.
? Trailing ?y?? ?Y?. Ex. MSA: ?Hqy? (my right)?
?HqY?.
? ?*?? ?d?. Ex. MSA: ?xu*? (take)? ?xud?.
? middle or trailing ?>? ? ?A?. Ex. MSA: ?f>r?
(mouse)? ?fAr?.
? ?D?? ?Z?. Ex. MSA: ?DAbT? (officer)? ?ZAbT?.
? ?Z?? ?D?. Ex. MSA: ?Zhr? (back)? ?Dhr?.
? Middle ?|? ? ?yA?. Ex. MSA: ?ml|n? (full) ?
?mlyAn?.
? Removal of trailing ? ? ?. Ex. MSA: ?AlsmA? ? (the
sky)? ?AlsmA?.
Syntactic differences: some of the following phe-
nomena are generally observed:
? Common use of masculine plural or singular noun
forms instead dual and feminine plural. Ex. MSA ?jny-
hyn? (two pounds)? EG: ?Atnyn jnyh?.
? Dropping some articles and preposition in some syn-
tactic constructs. For example, the preposition ?<lY?
(to) in ?>nA rAyH <lY Al$gl? (I am going to work)
is typically dropped. Also, the particle ?>n? (to) is
dropped in the sentence ?>nA mHtAj >n >nAm? (I
need to sleep).
? Using only one form of noun and verb suffixes such
as ?yn? instead of ?wn? and ?wA? instead of ?wn? re-
spectively. Also, so-called ?five nouns?, are used in
only one form (ex. ?>bw? (father of) instead of ?>bA?
or ?>by?).
4 Detecting Dialectal Peculiarities
ARZ is different from MSA lexically, morphologically,
phonetically, and syntactically. Here, we present meth-
ods to handle such peculiarities. We chose not to han-
dle syntactic differences, because they may be captured
using word n-gram models.
To capture lexical variations, we extracted and sorted
by frequency all the unigrams from the Egyptian side of
the LDC2012T09 corpus (Zbib et al., 2012), which has
? 38k Egyptian-English parallel sentences. A linguist
was tasked with manually reviewing the words from the
top until 1,300 dialectal words were found. Some of the
words on the list included dialectal words, commonly
used foreign words, words that exhibit morphological
variations, and others with letter substitution.
1466
For morphological phenomenon, we employed three
methods, namely:
? Unsupervised Morphology Induction: We em-
ployed the unsupervised morpheme segmentation tool,
Morfessor (Virpioja et al., 2013). It is a data driven
tool that automatically learns morphemes from data in
an unsupervised fashion. We used the trained model to
segment the training and test sets.
? Morphological Rules: In contrast to Morfessor, we
developed only 15 morphological rules (based on the
analysis proposed in Section 3) to segment ARZ text.
These rules would separate prefixes and suffixes like a
light stemmer. Example rules would segment a leading
?b? and segment a combination of a leading ?m? and
trailing ?$?.
?Morphological Generator: For morphological gen-
eration, we enumerated a list of ? 200 morphological
patterns that derive dialectal verbs from Arabic roots.
One such pattern is ytCCC that would generate the di-
alectal verb-form ytktb (to be written) from the root
?ktb?. We used the root list that is distributed with Se-
bawai (Darwish, 2002). We also expanded the list by
attaching negation affixes and pronouns. We retained
generated word forms that: a) exist in a large corpus of
63 million Arabic tweets from 2012 with more than 1
billion tokens; and b) don?t appear in a large MSA cor-
pus of 10 years worth of Aljazeera articles containing
114 million tokens
3
. The resulting list included 94k
verb surface forms such as ?mbyEmlhA$? (he does not
do it).
For phonological differences, we used a morpholog-
ical generator that makes use of the aforementioned
root list and an inventory of ? 605 morphological pat-
terns (with diacritization) to generate possible Arabic
stems. The generated stems with their diacritics were
checked against a large diacritized Arabic corpus con-
taining more than 200 million diacritized words
4
. If
generated words contained the letters ?v?, ?}?, ?*?, and
?D?, we used the aforementioned letter substitutions.
We retained words that exist in the large tweet corpus
but not in the Aljazeera corpus. The list contained 8k
surface forms.
5 Evaluation Setup
Dataset: We performed dialect identification exper-
iment for ARZ and MSA. For ARZ, we used the
Egyptian side of the LDC2012T09 corpus (Zbib et
al., 2012)
5
. For MSA, we used the Arabic side
of the English/Arabic parallel corpus from the Inter-
national Workshop on Arabic Language Translation
6
which consists of ? 150k sentences. For testing, we
constructed an evaluation set that is markedly different
3
http://aljazeera.net
4
http://www.sh.rewayat2.com
5
We did not use the Arabic Online Commentary data
(Zaidan et al., 2011) as annotations were often not reliable.
6
https://wit3.fbk.eu/mt.php?release=
2013-01
from the training set. We crawled Arabic tweets from
Twitter during March 2014 and selected those where
user location was set to Egypt or a geographic location
within Egypt, leading to 880k tweets. We randomly
selected 2k tweets, and we manually annotated them
as ARZ, MSA, or neither until we obtained 350 ARZ
and 350 MSA tweets. We used these tweets for testing.
We plan to release the tweet ID?s and our annotations.
We preprocessed the training and test sets using the
method described by Darwish et al. (2012), which in-
cludes performing letter and word normalizations, and
segmented all data using an open-source MSA word
segmentor (Darwish et al., 2012). We also removed
punctuations, hashtags, and name mentions from the
test set. We used a Random Forest (RF) ensemble clas-
sifier that generates many decision trees, each of which
is trained on a subset of the features.
7
We used the RF
implementation in Weka (Breiman, 2001).
5.1 Classification Runs
Baseline BL: In our baseline experiments, we used
word unigram, bigram, and trigram models and charac-
ter unigram to 5-gram models as features. We first per-
formed a cross-validation experiment using ARZ and
MSA training sets. The classifier achieved fairly high
results (+95%) which are much higher than the results
mentioned in the literature. This could be due in part
to the fact that we were doing ARZ-MSA classification
instead of multi-dialect classification and MSA data is
fairly different in genre from ARZ data. We did not fur-
ther discuss these results. This experiment was a sanity
check to see how does in-domain dialect identification
perform.
Later, we trained the RF classifier on the complete
training set using word n-gram features (WRD), char-
acter n-gram features (CHAR), or both (BOTH) and
tested it on the tweets test set. We referred to this sys-
tem as BL later on.
Dialectal Egyptian Lexicon S
lex
: As mentioned ear-
lier, we constructed three word lists containing 1,300
manually reviewed ARZ words (MAN), 94k dialectal
verbs (VERB), and 8k words with letter substitutions
(SUBT). Using the lists, we counted the number of
words in a tweet that exist in the word lists and used it
as a standalone feature for classifications. LEX refers
to concatenation of all three lists.
Morphological Features: For S
mrph
, we trained Mor-
fessor separately on the MSA and Egyptian training
data and applied to the same training data for segmen-
tation. For S
rule
, we segmented Egyptian part of the
training data using the morphological rules mentioned
in Section 4. For both, word and character n-gram fea-
tures were calculated from the segmented data and the
7
We tried also the multi-class Bayesian classifier and
SVM classifier. SVM classifier had comparable results with
Random Forest classifier. However, it was very slow. So, we
decided to go with Random Forest classifier for the rest of the
experiments.
1467
SYS WRD CHR BOTH BEST+LEX
BL 53.0 74.0 83.3 84.7
S
mrph
72.0 88.0 62.1 89.3
S
rule
53.9 85.9 85.9 90.1
Table 1: Dialect identification accuracy using
various classification settings: only word-based
(WRD), character-based (CHAR), and both features.
BEST+LEX is built on the best feature of that system
plus a feature built on the concatenation of all lists
SYS MAN +VERB +SUBT
S
lex
93.6 94.6 94.4
Table 2: Accuracy of the dialect identification system
with the addition of various types of lexicon
classifier was trained on them and tested on the tweet
test set.
5.2 Results
Table 1 summarizes the results. Unlike results in the lit-
erature, character-based n-gram features outperformed
word-based n-gram features, as they seemed to better
generalize to the new test set, where lexical overlap be-
tween the training and test sets was low. Except for
S
mrph
, adding both character and word n-gram fea-
tures led to improved results. We observed that Mor-
fessor over-segmented the text, which in turns created
small character segments and enabled the character-
based language model to learn the phenomenon inherit
in a word. The baseline system achieved an accuracy
of 84.7% when combined with the S
lex
feature. Com-
bining S
mrph
and S
rule
features with the S
lex
feature
led to further improvement. However, as shown in Ta-
ble 2, using the S
lex
feature alone with the MAN and
VERB lists led to the best results (94.6%), outperform-
ing using all other features either alone or in combina-
tion. This suggests that having a clean list of dialectal
words that cover common dialectal phenomena is more
effective than using word and character n-grams. It also
highlights the shortcomings of using a homogeneous
training set where word unigrams could be capturing
topical cues along with dialectal ones.
6 Conclusion
In this paper, we identified lexical, morphological,
phonological, and syntactic features that help distin-
guish between dialectal Egyptian and MSA. Given the
substantial lexical overlap between dialectal Egyptian
and MSA, targeting words that exhibit distinguishing
traits is essential to proper dialect identification. We
used some of these features for dialect detection lead-
ing to nearly 10% (absolute) improvement in classifi-
cation accuracy. We plan to extend our work to other
dialects.
References
Leo Breiman. 2001. Random Forests. Machine Learn-
ing. 45(1):5-32.
Ryan Cotterell, Chris Callison-Burch. 2014. A Multi-
Dialect, Multi-Genre Corpus of Informal Written
Arabic. LREC-2014, pages 241?245.
Kareem Darwish. 2002. Building a shallow morpho-
logical analyzer in one day. In Proceedings of the
ACL-2002 Workshop on Computational Approaches
to Semitic Languages.
Kareem Darwish, Walid Magdy, Ahmed Mourad.
2012. Language Processing for Arabic Microblog
Retrieval. CIKM-2012, pages 2427?2430.
Kareem Darwish, Ahmed Abdelali, Hamdy Mubarak.
2014. Using Stem-Templates to improve Arabic POS
and Gender/Number Tagging. LREC-2014.
Heba Elfardy, Mona Diab. 2013. Sentence Level Di-
alect Identification in Arabic. ACL-2013, pages
456?461.
Sami Virpioja, Peter Smit, Stig-Arne Grnroos, and
Mikko Kurimo. 2013. Morfessor 2.0: Python Im-
plementation and Extensions for Morfessor Base-
line. Aalto University publication series SCI-
ENCE + TECHNOLOGY, 25/2013. Aalto Univer-
sity, Helsinki, 2013.
Omar F. Zaidan, Chris Callison-Burch. 2011. The Ara-
bic Online Commentary Dataset: An Annotated
Dataset of Informal Arabic with High Dialectal Con-
tent. ACL-11, pages 37?41.
Omar F. Zaidan, Chris Callison-Burch. 2014. Arabic
Dialect Identification. CL-11, 52(1).
Rabih Zbib, Erika Malchiodi, Jacob Devlin, David
Stallard, Spyros Matsoukas, Richard Schwartz,
John Makhoul, Omar F. Zaidan, Chris Callison-
Burch. 2012. Machine translation of Arabic dialects.
NAACL-2012, pages 49?59.
Marco Lui and Timothy Baldwin. 2011. Cross-
domain feature selection for language identification.
IJCNLP-2011, page 553?561.
J?org Tiedemann and Nikola Ljubesic. 2012. Efficient
discrimination between closely related languages.
COLING-2012, 2619?2634.
Adam Kilgarriff. 2001. Comparing corpora. CL-01,
6(1).
1468
Proceedings of the 14th Conference of the European Chapter of the Association for Computational Linguistics, pages 148?153,
Gothenburg, Sweden, April 26-30 2014.
c?2014 Association for Computational Linguistics
Integrating an Unsupervised Transliteration Model into
Statistical Machine Translation
Nadir Durrani
University of Edinburgh
dnadir@inf.ed.ac.uk
Hieu Hoang Philipp Koehn
University of Edinburgh
hieu.hoang,pkoehn@inf.ed.ac.uk
Hassan Sajjad
Qatar Computing Research Institute
hsajjad@@qf.org.qa
Abstract
We investigate three methods for integrat-
ing an unsupervised transliteration model
into an end-to-end SMT system. We in-
duce a transliteration model from parallel
data and use it to translate OOV words.
Our approach is fully unsupervised and
language independent. In the methods
to integrate transliterations, we observed
improvements from 0.23-0.75 (? 0.41)
BLEU points across 7 language pairs. We
also show that our mined transliteration
corpora provide better rule coverage and
translation quality compared to the gold
standard transliteration corpora.
1 Introduction
All machine translation (MT) systems suffer from
the existence of out-of-vocabulary (OOV) words,
irrespective of the amount of data available for
training. OOV words are mostly named entities,
technical terms or foreign words that can be trans-
lated to the target language using transliteration.
Much work (Al-Onaizan and Knight, 2002;
Zhao et al., 2007; Kashani et al., 2007; Habash,
2009) has been done on transliterating named enti-
ties and OOVs, and transliteration has been shown
to improve MT quality. Transliteration has also
shown to be useful for translating closely related
language pairs (Durrani et al., 2010; Nakov and
Tiedemann, 2012), and for disambiguation (Her-
mjakob et al., 2008; Azab et al., 2013). How-
ever, despite its utility, a transliteration module
does not exist in the commonly used MT toolk-
its, such as Moses (Koehn et al., 2007). One of the
main reasons is that the training data, a corpus of
transliteration pairs, required to build a translitera-
tion system, is not readily available for many lan-
guage pairs. Even if such a training data is avail-
able, mechanisms to integrate transliterated words
into MT pipelines are unavailable in these toolkits.
Generally, a supervised transliteration system is
trained separately outside of an MT pipeline, and
a na??ve approach, to replace OOV words with their
1-best transliterations in the post/pre-processing
step of decoding is commonly used.
In this work i) we use an unsupervised model
based on Expectation Maximization (EM) to in-
duce transliteration corpus from word aligned par-
allel data, which is then used to train a translitera-
tion model, ii) we investigate three different meth-
ods for integrating transliteration during decoding,
that we implemented within the Moses toolkit. To
the best of our knowledge, our work is the fore-
most attempt to integrate unsupervised translitera-
tion model into SMT.
This paper is organized as follows. Section 2
describes the unsupervised transliteration mining
system, which automatically mines transliteration
pairs from the same word-aligned parallel corpus
as used for training the MT system. Section 3 de-
scribes the transliteration model that is trained us-
ing the automatically extracted pairs. Section 4
presents three methods for incorporating translit-
eration into the MT pipeline, namely: i) replac-
ing OOVs with the 1-best transliteration in a post-
decoding step, ii) selecting the best translitera-
tion from the list of n-best transliterations using
transliteration and language model features in a
post-decoding step, iii) providing a transliteration
phrase-table to the decoder on the fly where it
can consider all features to select the best translit-
eration of OOV words. Section 5 presents re-
sults. Our integrations achieved an average im-
provement of 0.41 BLEU points over a competi-
tive baseline across 7 language pairs (Arabic, Ben-
gali, Farsi, Hindi, Russian, Telugu and Urdu-into-
English). An additional experiment showed that
our system provides better rule coverage as op-
posed to another built from gold standard translit-
eration corpus and produces better translations.
148
2 Transliteration Mining
The main bottleneck in building a transliteration
system is the lack of availability of translitera-
tion training pairs. It is, however, fair to assume
that any parallel data would contain a reasonable
number of transliterated word pairs. Transliter-
ation mining can be used to extract such word
pairs from the parallel corpus. Most previous
techniques on transliteration mining generally use
supervised and semi-supervised methods (Sherif
and Kondrak, 2007; Jiampojamarn et al., 2010;
Darwish, 2010; Kahki et al., 2012). This con-
strains the mining solution to language pairs for
which training data (seed data) is available. A few
researchers proposed unsupervised approaches to
mine transliterations (Lee and Choi, 1998; Sajjad
et al., 2011; Lin et al., 2011). We adapted the work
of Sajjad et al. (2012) as summarized below.
Model: The transliteration mining model is a
mixture of two sub-models, namely: a translit-
eration and a non-transliteration sub-model. The
idea is that the transliteration model would as-
sign higher probabilities to transliteration pairs
compared to the probabilities assigned by a non-
transliteration model to the same pairs. Consider a
word pair (e, f), the transliteration model prob-
ability for the word pair is defined as follows:
p
tr
(e, f) =
?
a?Align(e,f)
|a|
?
j=1
p(q
j
)
where Align(e, f) is the set of all possible se-
quences of character alignments, a is one align-
ment sequence and q
j
is a character alignment.
The non-transliteration model deals with the
word pairs that have no character relationship be-
tween them. It is modeled by multiplying source
and target character unigram models:
p
ntr
(e, f) =
|e|
?
i=1
p
E
(e
i
)
|f |
?
i=1
p
F
(f
i
)
The transliteration mining model is defined
as an interpolation of the transliteration sub-model
and the non-transliteration sub-model:
p(e, f) = (1? ?)p
tr
(e, f) + ?p
ntr
(e, f)
? is the prior probability of non-transliteration.
The non-transliteration model does not change
during training. We compute it in a pre-processing
step. The transliteration model learns character
alignment using expectation maximization (EM).
See Sajjad et al. (2012) for more details.
3 Transliteration Model
Now that we have transliteration word pairs, we
can learn a transliteration model. We segment the
training corpus into characters and learn a phrase-
based system over character pairs. The translitera-
tion model assumes that source and target charac-
ters are generated monotonically.
1
Therefore we
do not use any reordering models. We use 4 basic
phrase-translation features (direct, inverse phrase-
translation, and lexical weighting features), lan-
guage model feature (built from the target-side of
mined transliteration corpus), and word and phrase
penalties. The feature weights are tuned
2
on a dev-
set of 1000 transliteration pairs.
4 Integration to Machine Translation
We experimented with three methods for integrat-
ing transliterations, described below:
Method 1: involves replacing OOVs in the out-
put with the 1-best transliteration. The success of
Method 1 is solely contingent on the accuracy of
the transliteration model. Also, it ignores con-
text which may lead to incorrect transliteration.
For example, the Arabic word transliterates
to ?Bill? when followed by ?Clinton? and ?Bell?
if preceded by ?Alexander Graham?.
Method 2: provides n-best transliterations to
a monotonic decoder that uses a monolingual
language model and a transliteration phrase-
translation table to rescore transliterations. We
carry forward the 4 translation model features used
in the transliteration system to build a transliter-
ation phrase-table. We additionally use an LM-
OOV feature which counts the number of words
in a hypothesis that are unknown to the lan-
guage model. Smoothing methods such as Kneser-
Ney assign significant probability mass to unseen
events, which may cause the decoder to make in-
correct transliteration selection. The LM-OOV
feature acts as a prior to penalize such hypotheses.
Method 3: Method 2 can not benefit from all in-
decoding features and phenomenon like reorder-
ing. It transliterates Urdu compound
(Arabian Sea) to ?Sea Arabian?, if is an un-
known word. In method 3, we feed the translitera-
tion phrase-table directly into the first-pass decod-
ing which allows reordering of UNK words. We
1
Mining algorithm also makes this assumption.
2
Tuning data is subtracted from the training corpus while
tuning to avoid over-fitting. After the weights are tuned, we
add it back, retrain GIZA, and estimate new models.
149
use the decoding-graph-backoff option in Moses,
that allows multiple translation phrase tables and
back-off models. As in method 2, we also use the
LM-OOV feature in method 3.
3
5 Evaluation
Data: We experimented with 7 language pairs,
namely: Arabic, Bengali, Farsi, Hindi, Russian,
Telugu and Urdu-into-English. For Arabic
4
and
Farsi, we used the TED talks data (Cettolo et al.,
2012) made available for IWSLT-13, and we used
the dev2010 set for tuning and the test2011 and
test2012 sets for evaluation. For Indian languages
we used the Indic multi-parallel corpus (Post et
al., 2012), and we used the dev and test sets pro-
vided with the parallel corpus. For Russian, we
used WMT-13 data (Bojar et al., 2013), and we
used half of the news-test2012 for tuning and other
half for testing. We also evaluated on the news-
test2013 set. For all, we trained the language
model using the monolingual WMT-13 data. See
Table 1 for data statistics.
Lang Train
tm
Train
tr
Dev Test
1
Test
2
AR 152K 6795 887 1434 1704
BN 24K 1916 775 1000
FA 79K 4039 852 1185 1116
HI 39K 4719 1000 1000
RU 2M 302K 1501 1502 3000
TE 45K 4924 1000 1000
UR 87K 9131 980 883
Table 1: No. of sentences in Training Data and
Mined Transliteration Corpus (Types) (Train
tr
)
Baseline Settings: We trained a Moses system
replicating the settings used in competition-grade
systems (Durrani et al., 2013b; Birch et al., 2013):
a maximum sentence length of 80, GDFA sym-
metrization of GIZA++ alignments (Och and Ney,
2003), an interpolated Kneser-Ney smoothed 5-
gram language model with KenLM (Heafield,
2011) used at runtime, a 5-gram OSM (Dur-
rani et al., 2013a), msd-bidirectional-fe lexical-
3
Method 3 is desirable in cases where the decoder can
translate or transliterate a word. For example Hindi word
can be translated to ?Border? and also transliterated
to name ?Seema?. Identifying such candidates that can be
translated or transliterated is a challenge. Machine learning
techniques (Goldwasser and Roth, 2008; Kirschenbaum and
Wintner, 2009) and named entity recognizers (Klementiev
and Roth, 2006; Hermjakob et al., 2008) have been used for
this purpose. Though, we only focus on OOV words, method
3 can be used if such a classifier/NE tagger is available.
4
Arabic and Urdu are segmented using MADA (Habash
and Sadat, 2006) and UWS (Durrani and Hussain, 2010).
ized reordering, sparse lexical and domain fea-
tures (Hasler et al., 2012), a distortion limit of
6, 100-best translation options, MBR decoding
(Kumar and Byrne, 2004), Cube Pruning (Huang
and Chiang, 2007), and the no-reordering-over-
punctuation heuristic. We tuned with the k-best
batch MIRA (Cherry and Foster, 2012).
5
Transliteration Miner: The miner extracts
transliterations from a word-aligned parallel cor-
pus. We only used word pairs with 1-to-1 align-
ments.
6
Before feeding the list into the miner, we
cleaned it by removing digits, symbols, word pairs
where source or target is composed from less than
3 characters, and words containing foreign char-
acters that do not belong to this scripts. We ran
the miner with 10 iterations of EM. The number
of transliteration pairs (types) extracted for each
language pair is shown in Table 1 (Train
tr
).
Transliteration System: Before evaluating our
integrations into the SMT system, we performed
an intrinsic evaluation of the transliteration system
that we built from the mined pairs. We formed
test data for Arabic?English (1799 pairs), Hindi?
English (2394 pairs) and Russian?English (1859
pairs) by concatenating the seed data and gold
standard transliteration pairs both provided for the
Shared Task on Transliteration mining (Kumaran
et al., 2010). Table 2 shows precision and recall of
the mined transliteration system (MTS).
AR HI RU
Precision (1-best Accuracy) 20.0% 25.3% 46.1%
Recall (100-best Accuracy) 80.2% 79.3% 87.5%
Table 2: Precision and Recall of MTS
The precision (1-best accuracy) of the translit-
eration model is quite low. This is because the
transliteration corpus is noisy and contains imper-
fect transliteration pairs. For example, the miner
extracted the pair ( , Australasia), while
the correct transliteration is ?Australia?. We can
improve the precision by tightening the mining
threshold probability. However, our end goal is to
improve end-to-end MT and not the transliteration
system. We observed that recall is more important
than precision for overall MT quality. We provide
an empirical justification for this when discussing
the final experiments.
5
Retuning the transliteration features was not helpful, de-
fault weights are used.
6
M-N/1-N alignments are less likely to be transliterations.
150
MT Experiments: Table 3 gives a comprehen-
sive evaluation of the three methods of integra-
tion discussed in Section 4 along with the num-
ber
7
of OOV words (types) in different tests. We
report BLEU gains (Papineni et al., 2002) obtained
by each method. Method 1 (M
1
), that replaces
OOV words with 1-best transliteration gave an av-
erage improvement of +0.13. This result can be at-
tributed to the low precision of the transliteration
system (Table 2). Method 2 (M
2
), that translit-
erates OOVs in second pass monotonic decoding,
gave an average improvement of +0.39. Slightly
higher gains were obtained using Method 3 (M
3
),
that integrates transliteration phrase-table inside
decoder on the fly. However, the efficacy of M
3
in
comparison to M
2
is not as apparent, as M
2
pro-
duced better results than M
3
in half of the cases.
Lang Test B
0
M
1
M
2
M
3
OOV
AR iwslt
11
26.75 +0.12 +0.36 +0.25 587
iwslt
12
29.03 +0.10 +0.30 +0.27 682
BN jhu
12
16.29 +0.12 +0.42 +0.46 1239
FA iwslt
11
20.85 +0.10 +0.40 +0.31 559
iwslt
12
16.26 +0.04 +0.20 +0.26 400
HI jhu
12
15.64 +0.21 +0.35 +0.47 1629
RU wmt
12
33.95 +0.24 +0.55 +0.49 434
wmt
13
25.98 +0.25 +0.40 +0.23 799
TE jhu
12
11.04 -0.09 +0.40 +0.75 2343
UR jhu
12
23.25 +0.24 +0.54 +0.60 827
Avg 21.9 +0.13 +0.39 +0.41 950
Table 3: End-to-End MT Evaluation ? B
0
=
Baseline, M
1
= Method
1
, M
2
= Method
2
, M
3
=
Method
3
, BLEU gains shown for each method
In an effort to test whether improving translit-
eration precision would improve end-to-end SMT
results, we carried out another experiment. Instead
of building a transliteration system from mined
corpus, we built it using the gold standard corpus
(for Arabic, Hindi and Russian), that we also used
previously to do an intrinsic evaluation. We then
replaced our mined transliteration systems with
the gold standard transliteration systems, in the
best performing SMT systems for these languages.
Table 4 shows a comparison of performances. Al-
though the differences are small, systems using
mined transliteration system (MTS) outperformed
its counterpart that uses gold standard translitera-
tion system (GTS), except in Hindi?English where
7
Note that not all OOVs can be transliterated. This num-
ber is therefore an upper bound what can be transliterated.
both systems were equal.
AR HI RU
iwslt
11
iwslt
12
jhu
12
wmt
12
iwslt
13
MTS 27.11 29.33 16.11 34.50 26.38
GST 26.99 29.20 16.11 34.33 26.22
Table 4: Comparing Gold Standard Transliteration
(GST) and Mined Transliteration Systems
In the error analysis we found that the GST
system suffered from sparsity and did not pro-
vide enough coverage of rules to produce right
transliterations. For example, Arabic drops the
determiner (al), but such additions were not
observed in gold transliteration pairs. Arabic
word (Gigapixel) is therefore translit-
erated to ?algegabksl?. Similarly the GST system
learned no transliteration pairs to account for the
rule ?b ? p? and therefore erroneously translit-
erated (Spurlock) to ?Sbrlok?. Similar
observations were true for the case of Russian?
English. The rules ?a? u? and ?y? ? were not
observed in the gold set, and hence
(hurricane) was transliterated to ?herricane? and
(Talbot) to ?Talboty?. This shows that
better recall obtained from the mined pairs led to
overall improvement.
6 Conclusion
We incorporated unsupervised transliteration min-
ing model into standard MT pipeline to automati-
cally transliterate OOV words without needing ad-
ditional resources. We evaluated three methods
for integrating transliterations on 7 language pairs
and showed improvements ranging from 0.23-0.75
(? 0.41) BLEU points. We also showed that our
mined transliteration corpus provide better recall
and overall translation quality compared to the
gold standard transliteration corpus. The unsu-
pervised transliteration miner and its integration
to SMT has been made available to the research
community via the Moses toolkit.
Acknowledgments
We wish to thank the anonymous reviewers and
Kareem Darwish for their valuable feedback on
an earlier draft of this paper. The research lead-
ing to these results has received funding from
the European Union Seventh Framework Pro-
gramme (FP7/2007-2013) under grant agreement
n
?
287658. This publication only reflects the au-
thors? views.
151
References
Yaser Al-Onaizan and Kevin Knight. 2002. Translat-
ing Named Entities Using Monolingual and Bilin-
gual Resources. In Proceedings of the 40th Annual
Meeting of the Association for Computational Lin-
guistics.
Mahmoud Azab, Houda Bouamor, Behrang Mohit, and
Kemal Oflazer. 2013. Dudley North visits North
London: Learning When to Transliterate to Arabic.
In Proceedings of the 2013 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 439?444, Atlanta, Georgia, June. Association
for Computational Linguistics.
Alexandra Birch, Nadir Durrani, and Philipp Koehn.
2013. Edinburgh SLT and MT System Description
for the IWSLT 2013 Evaluation. In Proceedings
of the 10th International Workshop on Spoken Lan-
guage Translation, pages 40?48, Heidelberg, Ger-
many, December.
Ondrej Bojar, Christian Buck, Chris Callison-Burch,
Christian Federmann, Barry Haddow, Philipp
Koehn, Christof Monz, Matt Post, Radu Soricut,
and Lucia Specia. 2013. Findings of the 2013
Workshop on Statistical Machine Translation. In
Eighth Workshop on Statistical Machine Transla-
tion, WMT-2013, pages 1?44, Sofia, Bulgaria.
Mauro Cettolo, Christian Girardi, and Marcello Fed-
erico. 2012. WIT
3
: Web Inventory of Transcribed
and Translated Talks. In Proceedings of the 16
th
Conference of the European Association for Ma-
chine Translation (EAMT), pages 261?268, Trento,
Italy, May.
Colin Cherry and George Foster. 2012. Batch Tun-
ing Strategies for Statistical Machine Translation. In
Proceedings of the 2012 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 427?436, Montr?eal, Canada, June. Associa-
tion for Computational Linguistics.
Kareem Darwish. 2010. Transliteration Mining with
Phonetic Conflation and Iterative Training. In Pro-
ceedings of the 2010 Named Entities Workshop, Up-
psala, Sweden.
Nadir Durrani and Sarmad Hussain. 2010. Urdu Word
Segmentation. In Human Language Technologies:
The 2010 Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics, pages 528?536, Los Angeles, California,
June. Association for Computational Linguistics.
Nadir Durrani, Hassan Sajjad, Alexander Fraser, and
Helmut Schmid. 2010. Hindi-to-Urdu Machine
Translation through Transliteration. In Proceedings
of the 48th Annual Conference of the Association for
Computational Linguistics, Uppsala, Sweden.
Nadir Durrani, Alexander Fraser, Helmut Schmid,
Hieu Hoang, and Philipp Koehn. 2013a. Can
Markov Models Over Minimal Translation Units
Help Phrase-Based SMT? In Proceedings of the
51st Annual Meeting of the Association for Compu-
tational Linguistics, Sofia, Bulgaria, August. Asso-
ciation for Computational Linguistics.
Nadir Durrani, Barry Haddow, Kenneth Heafield, and
Philipp Koehn. 2013b. Edinburgh?s Machine Trans-
lation Systems for European Language Pairs. In
Proceedings of the Eighth Workshop on Statistical
Machine Translation, Sofia, Bulgaria, August. As-
sociation for Computational Linguistics.
Dan Goldwasser and Dan Roth. 2008. Active Sam-
ple Selection for Named Entity Transliteration. In
Proceedings of ACL-08: HLT, Short Papers, pages
53?56, Columbus, Ohio, June. Association for Com-
putational Linguistics.
Nizar Habash and Fatiha Sadat. 2006. Arabic Pre-
processing Schemes for Statistical Machine Transla-
tion. In Proceedings of the Human Language Tech-
nology Conference of the NAACL, Companion Vol-
ume: Short Papers, pages 49?52, New York City,
USA, June. Association for Computational Linguis-
tics.
Nizar Habash. 2009. REMOOV: A Tool for Online
Handling of Out-of-Vocabulary Words in Machine
Translation. In Proceedings of the Second Interna-
tional Conference on Arabic Language Resources
and Tools, Cairo, Egypt, April. The MEDAR Con-
sortium.
Eva Hasler, Barry Haddow, and Philipp Koehn. 2012.
Sparse Lexicalised Features and Topic Adaptation
for SMT. In Proceedings of the seventh Interna-
tional Workshop on Spoken Language Translation
(IWSLT), pages 268?275.
Kenneth Heafield. 2011. KenLM: Faster and Smaller
Language Model Queries. In Proceedings of the
Sixth Workshop on Statistical Machine Translation,
pages 187?197, Edinburgh, Scotland, United King-
dom, 7.
Ulf Hermjakob, Kevin Knight, and Hal Daum?e III.
2008. Name Translation in Statistical Machine
Translation - Learning When to Transliterate. In
Proceedings of the 46th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, Columbus, Ohio.
Liang Huang and David Chiang. 2007. Forest Rescor-
ing: Faster Decoding with Integrated Language
Models. In Proceedings of the 45th Annual Meet-
ing of the Association of Computational Linguistics,
pages 144?151, Prague, Czech Republic, June. As-
sociation for Computational Linguistics.
Sittichai Jiampojamarn, Kenneth Dwyer, Shane
Bergsma, Aditya Bhargava, Qing Dou, Mi-Young
Kim, and Grzegorz Kondrak. 2010. Transliteration
152
Generation and Mining with Limited Training Re-
sources. In Proceedings of the 2010 Named Entities
Workshop, Uppsala, Sweden.
Ali El Kahki, Kareem Darwish, Ahmed Saad El Din,
and Mohamed Abd El-Wahab. 2012. Transliter-
ation Mining Using Large Training and Test Sets.
In Proceedings of the 2012 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
NAACL HLT ?12.
Mehdi M. Kashani, Eric Joanis, Roland Kuhn, George
Foster, and Fred Popowich. 2007. Integration of
an Arabic Transliteration Module into a Statistical
Machine Translation System. In Proceedings of the
Second Workshop on Statistical Machine Transla-
tion, Prague, Czech Republic.
Amit Kirschenbaum and Shuly Wintner. 2009. Lightly
Supervised Transliteration for Machine Translation.
In Proceedings of the 12th Conference of the Euro-
pean Chapter of the ACL (EACL 2009), pages 433?
441, Athens, Greece, March. Association for Com-
putational Linguistics.
Alexandre Klementiev and Dan Roth. 2006. Named
entity transliteration and discovery from multilin-
gual comparable corpora. In Proceedings of the
Human Language Technology Conference of the
NAACL, Main Conference, pages 82?88, New York
City, USA, June. Association for Computational
Linguistics.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
Source Toolkit for Statistical Machine Translation.
In Proceedings of the 45th Annual Meeting of the
Association for Computational Linguistics, Demon-
stration Program, Prague, Czech Republic.
Shankar Kumar and William J. Byrne. 2004. Mini-
mum Bayes-Risk Decoding for Statistical Machine
Translation. In HLT-NAACL, pages 169?176.
A Kumaran, Mitesh M. Khapra, and Haizhou Li. 2010.
Whitepaper of news 2010 shared task on transliter-
ation mining. In Proceedings of the 2010 Named
Entities Workshop, pages 29?38, Uppsala, Sweden,
July. Association for Computational Linguistics.
Jae-Sung Lee and Key-Sun Choi. 1998. English
to Korean Statistical Transliteration for Information
Retrieval. Computer Processing of Oriental Lan-
guages, 12(1):17?37.
Wen-Pin Lin, Matthew Snover, and Heng Ji. 2011.
Unsupervised Language-Independent Name Trans-
lation Mining from Wikipedia Infoboxes. In Pro-
ceedings of the First workshop on Unsupervised
Learning in NLP, pages 43?52, Edinburgh, Scot-
land, July. Association for Computational Linguis-
tics.
Preslav Nakov and J?org Tiedemann. 2012. Com-
bining Word-Level and Character-Level Models for
Machine Translation Between Closely-Related Lan-
guages. In Proceedings of the 50th Annual Meet-
ing of the Association for Computational Linguis-
tics (Volume 2: Short Papers), pages 301?305, Jeju
Island, Korea, July. Association for Computational
Linguistics.
Franz J. Och and Hermann Ney. 2003. A Systematic
Comparison of Various Statistical Alignment Mod-
els. Computational Linguistics, 29(1).
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. BLEU: a method for automatic
evaluation of machine translation. In Proceedings of
the 40th Annual Meeting on Association for Compu-
tational Linguistics, ACL ?02, pages 311?318, Mor-
ristown, NJ, USA.
Matt Post, Chris Callison-Burch, and Miles Osborne.
2012. Constructing Parallel Corpora for Six Indian
Languages via Crowdsourcing. In Proceedings of
the Seventh Workshop on Statistical Machine Trans-
lation, pages 401?409, Montr?eal, Canada, June. As-
sociation for Computational Linguistics.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2011. An Algorithm for Unsupervised Translitera-
tion Mining with an Application to Word Alignment.
In Proceedings of the 49th Annual Conference of
the Association for Computational Linguistics, Port-
land, USA.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2012. A Statistical Model for Unsupervised and
Semi-supervised Transliteration Mining. In Pro-
ceedings of the 50th Annual Conference of the Asso-
ciation for Computational Linguistics, Jeju, Korea.
Tarek Sherif and Grzegorz Kondrak. 2007. Bootstrap-
ping a Stochastic Transducer for Arabic-English
Transliteration Extraction. In Proceedings of the
45th Annual Meeting of the Association for Compu-
tational Linguistics, Prague, Czech Republic.
Bing Zhao, Nguyen Bach, Ian Lane, and Stephan Vo-
gel. 2007. A Log-Linear Block Transliteration
Model based on Bi-Stream HMMs. In Human
Language Technologies 2007: The Conference of
the North American Chapter of the Association for
Computational Linguistics, Rochester, New York.
153
Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 465?474,
Uppsala, Sweden, 11-16 July 2010. c?2010 Association for Computational Linguistics
Hindi-to-Urdu Machine Translation Through Transliteration
Nadir Durrani Hassan Sajjad Alexander Fraser Helmut Schmid
Institute for Natural Language Processing
University of Stuttgart
{durrani,sajjad,fraser,schmid}@ims.uni-stuttgart.de
Abstract
We present a novel approach to integrate
transliteration into Hindi-to-Urdu statisti-
cal machine translation. We propose two
probabilistic models, based on conditional
and joint probability formulations, that are
novel solutions to the problem. Our mod-
els consider both transliteration and trans-
lation when translating a particular Hindi
word given the context whereas in pre-
vious work transliteration is only used
for translating OOV (out-of-vocabulary)
words. We use transliteration as a tool
for disambiguation of Hindi homonyms
which can be both translated or translit-
erated or transliterated differently based
on different contexts. We obtain final
BLEU scores of 19.35 (conditional prob-
ability model) and 19.00 (joint probability
model) as compared to 14.30 for a base-
line phrase-based system and 16.25 for a
system which transliterates OOV words in
the baseline system. This indicates that
transliteration is useful for more than only
translating OOV words for language pairs
like Hindi-Urdu.
1 Introduction
Hindi is an official language of India and is writ-
ten in Devanagari script. Urdu is the national lan-
guage of Pakistan, and also one of the state lan-
guages in India, and is written in Perso-Arabic
script. Hindi inherits its vocabulary from Sanskrit
while Urdu descends from several languages in-
cluding Arabic, Farsi (Persian), Turkish and San-
skrit. Hindi and Urdu share grammatical structure
and a large proportion of vocabulary that they both
inherited from Sanskrit. Most of the verbs and
closed-class words (pronouns, auxiliaries, case-
markers, etc) are the same. Because both lan-
guages have lived together for centuries, some
Urdu words which originally came from Arabic
and Farsi have also mixed into Hindi and are now
part of the Hindi vocabulary. The spoken form of
the two languages is very similar.
The extent of overlap between Hindi and Urdu
vocabulary depends upon the domain of the text.
Text coming from the literary domain like novels
or history tend to have more Sanskrit (for Hindi)
and Persian/Arabic (for Urdu) vocabulary. How-
ever, news wire that contains text related to me-
dia, sports and politics, etc., is more likely to have
common vocabulary.
In an initial study on a small news corpus of
5000 words, randomly selected from BBC1 News,
we found that approximately 62% of the Hindi
types are also part of Urdu vocabulary and thus
can be transliterated while only 38% have to be
translated. This provides a strong motivation to
implement an end-to-end translation system which
strongly relies on high quality transliteration from
Hindi to Urdu.
Hindi and Urdu have similar sound systems but
transliteration from Hindi to Urdu is still very hard
because some phonemes in Hindi have several or-
thographic equivalents in Urdu. For example the
?z? sound2 can only be written as whenever it
occurs in a Hindi word but can be written as ,
, and in an Urdu word. Transliteration
becomes non-trivial in cases where the multiple
orthographic equivalents for a Hindi word are all
valid Urdu words. Context is required to resolve
ambiguity in such cases. Our transliterator (de-
scribed in sections 3.1.2 and 4.1.3) gives an accu-
racy of 81.6% and a 25-best accuracy of 92.3%.
Transliteration has been previously used only as
a back-off measure to translate NEs (Name Enti-
ties) and OOV words in a pre- or post-processing
step. The problem we are solving is more difficult
than techniques aimed at handling OOV words,
1http://www.bbc.co.uk/hindi/index.shtml
2All sounds are represented using SAMPA notation.
465
Hindi Urdu SAMPA Gloss
/ Am Mango/Ordinary
/ d ZAli Fake/Net
/ Ser Lion/Verse
Table 1: Hindi Words That Can Be Transliterated
Differently in Different Contexts
Hindi Urdu SAMPA Gloss
/ simA Border/Seema
/ Amb@r Sky/Ambar
/ vId Ze Victory/Vijay
Table 2: Hindi Words That Can Be Translated or
Transliterated in Different Contexts
which focus primarily on name transliteration, be-
cause we need different transliterations in differ-
ent contexts; in their case context is irrelevant. For
example: consider the problem of transliterating
the English word ?read? to a phoneme represen-
tation in the context ?I will read? versus the con-
text ?I have read?. An example of this for Hindi
to Urdu transliteration: the two Urdu words
(face/condition) and (chapter of the Koran)
are both written as (sur@t d) in Hindi. The
two are pronounced identically in Urdu but writ-
ten differently. In such cases we hope to choose
the correct transliteration by using context. Some
other examples are shown in Table 1.
Sometimes there is also an ambiguity of
whether to translate or transliterate a particular
word. The Hindi word , for example, will
be translated to (peace, s@kun) when it is a
common noun but transliterated to (Shanti,
SAnt di) when it is a proper name. We try to
model whether to translate or transliterate in a
given situation. Some other examples are shown
in Table 2.
The remainder of this paper is organized as fol-
lows. Section 2 provides a review of previous
work. Section 3 introduces two probabilistic mod-
els for integrating translations and transliterations
into a translation model which are based on condi-
tional and joint probability distributions. Section 4
discusses the training data, parameter optimization
and the initial set of experiments that compare our
two models with a baseline Hindi-Urdu phrase-
based system and with two transliteration-aided
phrase-based systems in terms of BLEU scores
(Papineni et al, 2001). Section 5 performs an er-
ror analysis showing interesting weaknesses in the
initial formulations. We remedy the problems by
adding some heuristics and modifications to our
models which show improvements in the results as
discussed in section 6. Section 7 gives two exam-
ples illustrating how our model decides whether
to translate or transliterate and how it is able to
choose among different valid transliterations given
the context. Section 8 concludes the paper.
2 Previous Work
There has been a significant amount of work on
transliteration. We can break down previous work
into three groups. The first group is generic
transliteration work, which is evaluated outside of
the context of translation. This work uses either
grapheme or phoneme based models to translit-
erate words lists (Knight and Graehl, 1998; Li
et al, 2004; Ekbal et al, 2006; Malik et al,
2008). The work by Malik et al addresses Hindi to
Urdu transliteration using hand-crafted rules and
a phonemic representation; it ignores translation
context.
A second group deals with out-of-vocabulary
words for SMT systems built on large parallel cor-
pora, and therefore focuses on name translitera-
tion, which is largely independent of context. Al-
Onaizan and Knight (2002) transliterate Arabic
NEs into English and score them against their re-
spective translations using a modified IBM Model
1. The options are further re-ranked based on dif-
ferent measures such as web counts and using co-
reference to resolve ambiguity. These re-ranking
methodologies can not be performed in SMT at
the decoding time. An efficient way to compute
and re-rank the transliterations of NEs and inte-
grate them on the fly might be possible. However,
this is not practical in our case as our model con-
siders transliterations of all input words and not
just NEs. A log-linear block transliteration model
is applied to OOV NEs in Arabic to English SMT
by Zhao et al (2007). This work is also translit-
erating only NEs and not doing any disambigua-
tion. The best method proposed by Kashani et
al. (2007) integrates translations provided by ex-
ternal sources such as transliteration or rule-base
translation of numbers and dates, for an arbitrary
number of entries within the input text. Our work
is different from Kashani et al (2007) in that our
model compares transliterations with translations
466
on the fly whereas transliterations in Kashani et al
do not compete with internal phrase tables. They
only compete amongst themselves during a sec-
ond pass of decoding. Hermjakob et al (2008) use
a tagger to identify good candidates for translit-
eration (which are mostly NEs) in input text and
add transliterations to the SMT phrase table dy-
namically such that they can directly compete with
translations during decoding. This is closer to
our approach except that we use transliteration as
an alternative to translation for all Hindi words.
Our focus is disambiguation of Hindi homonyms
whereas they are concentrating only on translit-
erating NE?s. Moreover, they are working with
a large bitext so they can rely on their transla-
tion model and only need to transliterate NEs and
OOVs. Our translation model is based on data
which is both sparse and noisy. Therefore we pit
transliterations against translations for every input
word. Sinha (2009) presents a rule-based MT sys-
tem that uses Hindi as a pivot to translate from En-
glish to Urdu. This work also uses transliteration
only for the translation of unknown words. Their
work can not be used for direct translation from
Hindi to Urdu (independently of English) ?due to
various ambiguous mappings that have to be re-
solved?.
The third group uses transliteration models in-
side of a cross-lingual IR system (AbdulJaleel and
Larkey, 2003; Virga and Khudanpur, 2003; Pirkola
et al, 2003). Picking a single best transliteration
or translation in context is not important in an IR
system. Instead, all the options are used by giv-
ing them weights and context is typically not taken
into account.
3 Our Approach
Both of our models combine a character-based
transliteration model with a word-based transla-
tion model. Our models look for the most probable
Urdu token sequence un1 for a given Hindi token
sequence hn1 . We assume that each Hindi token is
mapped to exactly one Urdu token and that there is
no reordering. The assumption of no reordering is
reasonable given the fact that Hindi and Urdu have
identical grammar structure and the same word or-
der. An Urdu token might consist of more than one
Urdu word3. The following sections give a math-
3This occurs frequently in case markers with nouns,
derivational affixes and compounds etc. These are written
as single words in Hindi as opposed to Urdu where they are
ematical formulation of our two models, Model-1
and Model-2.
3.1 Model-1 : Conditional Probability Model
Applying a noisy channel model to compute the
most probable translation u?n1 , we get:
argmax
un1
p(un1 |h
n
1 ) = argmax
un1
p(un1 )p(h
n
1 |u
n
1 )
(1)
3.1.1 Language Model
The language model (LM) p(un1 ) is implemented
as an n-gram model using the SRILM-Toolkit
(Stolcke, 2002) with Kneser-Ney smoothing. The
parameters of the language model are learned from
a monolingual Urdu corpus. The language model
is defined as:
p(un1 ) =
n?
i=1
pLM (ui|u
i?1
i?k) (2)
where k is a parameter indicating the amount of
context used (e.g., k = 4 means 5-gram model).
ui can be a single or a multi-word token. A
multi-word token consists of two or more Urdu
words. For a multi-word ui we do multiple lan-
guage model look-ups, one for each uix in ui =
ui1 , . . . , uim and take their product to obtain the
value pLM (ui|u
i?1
i?k).
Language Model for Unknown Words: Our
model generates transliterations that can be known
or unknown to the language model and the trans-
lation model. We refer to the words known to
the language model and to the translation model
as LM-known and TM-known words respectively
and to words that are unknown as LM-unknown
and TM-unknown respectively.
We assign a special value ? to the LM-unknown
words. If one or more uix in a multi-word ui are
LM-unknown we assign a language model score
pLM (ui|u
i?1
i?k) = ? for the entire ui, meaning
that we consider partially known transliterations
to be as bad as fully unknown transliterations. The
parameter ? controls the trade-off between LM-
known and LM-unknown transliterations. It does
not influence translation options because they are
always LM-known in our case. This is because our
monolingual corpus also contains the Urdu part of
translation corpus. The optimization of ? is de-
scribed in section 4.2.1.
written as two words. For example (beautiful ; xub-
sur@t d) and (your?s ; ApkA) are written as
and respectively in Urdu.
467
3.1.2 Translation Model
The translation model (TM) p(hn1 |u
n
1 ) is approx-
imated with a context-independent model:
p(hn1 |u
n
1 ) =
n?
i=1
p(hi|ui) (3)
where hi and ui are Hindi and Urdu tokens re-
spectively. Our model estimates the conditional
probability p(hi|ui) by interpolating a word-
based model and a character-based (translitera-
tion) model.
p(hi|ui) = ?pw(hi|ui) + (1? ?)pc(hi|ui) (4)
The parameters of the word-based translation
model pw(h|u) are estimated from the word align-
ments of a small parallel corpus. We only retain
1-1/1-N (1 Hindi word, 1 or more Urdu words)
alignments and throw away N-1 and M-N align-
ments for our models. This is further discussed in
section 4.1.1.
The character-based transliteration model
pc(h|u) is computed in terms of pc(h, u), a joint
character model, which is also used for Chinese-
English back-transliteration (Li et al, 2004) and
Bengali-English name transliteration (Ekbal et al,
2006). The character-based transliteration proba-
bility is defined as follows:
pc(h, u) =
?
an1?align(h,u)
p(an1 )
=
?
an1?align(h,u)
n?
i=1
p(ai|a
i?1
i?k) (5)
where ai is a pair consisting of the i-th Hindi char-
acter hi and the sequence of 0 or more Urdu char-
acters that it is aligned with. A sample alignment
is shown in Table 3(b) in section 4.1.3. Our best
results are obtained with a 5-gram model. The
parameters p(ai|a
i?1
i?k) are estimated from a small
transliteration corpus which we automatically ex-
tracted from the translation corpus. The extrac-
tion details are also discussed in section 4.1.3. Be-
cause our overall model is a conditional probabil-
ity model, joint-probabilities are marginalized us-
ing character-based prior probabilities:
pc(h|u) =
pc(h, u)
pc(u)
(6)
The prior probability pc(u) of the character se-
quence u = cm1 is defined with a character-based
language model:
pc(u) =
m?
i=1
p(ci|c
i?1
i?k) (7)
The parameters p(ci|c
i?1
i?k) are estimated from
the Urdu part of the character-aligned translitera-
tion corpus. Replacing (6) in (4) we get:
p(hi|ui) = ?pw(hi|ui) + (1? ?)
pc(hi, ui)
pc(ui)
(8)
Having all the components of our model defined
we insert (8) and (2) in (1) to obtain the final equa-
tion:
u?n1 = argmax
un1
n?
i=1
pLM (ui|u
i?1
i?k)[?pw(hi|ui)
+ (1? ?)
pc(hi, ui)
pc(ui)
] (9)
The optimization of the interpolating factor ? is
discussed in section 4.2.1.
3.2 Model-2 : Joint Probability Model
This section briefly defines a variant of our model
where we interpolate joint probabilities instead of
conditional probabilities. Again, the translation
model p(hn1 |u
n
1 ) is approximated with a context-
independent model:
p(hn1 |u
n
1 ) =
n?
i=1
p(hi|ui) =
n?
i=1
p(hi, ui)
p(ui)
(10)
The joint probability p(hi, ui) of a Hindi and an
Urdu word is estimated by interpolating a word-
based model and a character-based model.
p(hi, ui) = ?pw(hi, ui)+(1??)pc(hi, ui) (11)
and the prior probability p(ui) is estimated as:
p(ui) = ?pw(ui) + (1? ?)pc(ui) (12)
The parameters of the translation model pw(hi, ui)
and the word-based prior probabilities pw(ui) are
estimated from the 1-1/1-N word-aligned corpus
(the one that we also used to estimate translation
probabilities pw(hi|ui) previously).
The character-based transliteration probability
pc(hi, ui) and the character-based prior probabil-
ity pc(ui) are defined by (5) and (7) respectively in
468
the previous section. Putting (11) and (12) in (10)
we get
p(hn1 |u
n
1 ) =
n?
i=1
?pw(hi, ui) + (1? ?)pc(hi, ui)
?pw(ui) + (1? ?)pc(ui)
(13)
The idea is to interpolate joint probabilities and di-
vide them by the interpolated marginals. The final
equation for Model-2 is given as:
u?n1 = argmax
un1
n?
i=1
pLM (ui|u
i?1
i?k)?
?pw(hi, ui) + (1? ?)pc(hi, ui)
?pw(ui) + (1? ?)pc(ui)
(14)
3.3 Search
The decoder performs a stack-based search using
a beam-search algorithm similar to the one used
in Pharoah (Koehn, 2004a). It searches for an
Urdu string that maximizes the product of trans-
lation probability and the language model proba-
bility (equation 1) by translating one Hindi word
at a time. It is implemented as a two-level pro-
cess. At the lower level, it computes n-best
transliterations for each Hindi word hi accord-
ing to pc(h, u). The joint probabilities given by
pc(h, u) are marginalized for each Urdu transliter-
ation to give pc(h|u). At the higher level, translit-
eration probabilities are interpolated with pw(h|u)
and then multiplied with language model probabil-
ities to give the probability of a hypothesis. We use
20-best translations and 25-best transliterations for
pw(h|u) and pc(h|u) respectively and a 5-gram
language model.
To keep the search space manageable and time
complexity polynomial we apply pruning and re-
combination. Since our model uses monotonic de-
coding we only need to recombine hypotheses that
have the same context (last n-1 words). Next we
do histogram-based pruning, maintaining the 100-
best hypotheses for each stack.
4 Evaluation
4.1 Training
This section discusses the training of the different
model components.
4.1.1 Translation Corpus
We used the freely available EMILLE Corpus
as our bilingual resource which contains roughly
13,000 Urdu and 12,300 Hindi sentences. From
these we were able to sentence-align 7000 sen-
tence pairs using the sentence alignment algorithm
given by Moore (2002).
The word alignments for this task were ex-
tracted by using GIZA++ (Och and Ney, 2003) in
both directions. We extracted a total of 107323
alignment pairs (5743 N-1 alignments, 8404 M-
N alignments and 93176 1-1/1-N alignments). Of
these alignments M-N and N-1 alignment pairs
were ignored. We manually inspected a sample of
1000 instances of M-N/N-1 alignments and found
that more than 70% of these were (totally or par-
tially) wrong. Of the 30% correct alignments,
roughly one-third constitute N-1 alignments. Most
of these are cases where the Urdu part of the align-
ment actually consists of two (or three) words
but was written without space because of lack of
standard writing convention in Urdu. For exam-
ple (can go ; d ZA s@kt de) is alterna-
tively written as (can go ; d ZAs@kt de)
i.e. without space. We learned that these N-1
translations could be safely dropped because we
can generate a separate Urdu word for each Hindi
word. For valid M-N alignments we observed that
these could be broken into 1-1/1-N alignments in
most of the cases. We also observed that we usu-
ally have coverage of the resulting 1-1 and 1-N
alignments in our translation corpus. Looking at
the noise in the incorrect alignments we decided
to drop N-1 and M-N cases. We do not model
deletions and insertions so we ignored null align-
ments. Also 1-N alignments with gaps were ig-
nored. Only the alignments with contiguous words
were kept.
4.1.2 Monolingual Corpus
Our monolingual Urdu corpus consists of roughly
114K sentences. This comprises 108K sentences
from the data made available by the University of
Leipzig4 + 5600 sentences from the training data
of each fold during cross validation.
4.1.3 Transliteration Corpus
The training corpus for transliteration is extracted
from the 1-1/1-N word-alignments of the EMILLE
corpus discussed in section 4.1.1. We use an edit
distance algorithm to align this training corpus at
the character level and we eliminate translation
pairs with high edit distance which are unlikely to
be transliterations.
4http://corpora.informatik.uni-leipzig.de/
469
We used our knowledge of the Hindi and Urdu
scripts to define the initial character mapping. The
mapping was further extended by looking into
available Hindi-Urdu transliteration systems[5,6]
and other resources (Gupta, 2004; Malik et al,
2008; Jawaid and Ahmed, 2009). Each pair in the
character map is assigned a cost. A Hindi charac-
ter that always map to only one Urdu character is
assigned a cost of 0 whereas the Hindi characters
that map to different Urdu characters are assigned
a cost of 0.2. The edit distance metric allows
insert, delete and replace operations. The hand-
crafted pairs define the cost of replace operations.
We set a cost of 0.6 for deletions and insertions.
These costs were optimized on held out data. The
details of optimization are not mentioned due to
limited space. Using this metric we filter out the
word pairs with high edit-distance to extract our
transliteration corpus. We were able to extract
roughly 2100 unique pairs along with their align-
ments. The resulting alignments are modified by
merging unaligned ? ? 1 (no character on source
side, 1 character on target side) or ? ? N align-
ments with the preceding alignment pair. If there
is no preceding alignment pair then it is merged
with the following pair. Table 3 gives an example
showing initial alignment (a) and the final align-
ment (b) after applying the merge operation. Our
model retains 1 ? ? and N ? ? alignments as
deletion operations.
a) Hindi ? b c ? e f
Urdu A XY C D ? F
b) Hindi b c e f
Urdu AXY CD ? F
Table 3: Alignment (a) Before (b) After Merge
The parameters pc(h, u) and pc(u) are trained
on the aligned corpus using the SRILM toolkit.
We use Add-1 smoothing for unigrams and
Kneser-Ney smoothing for higher n-grams.
4.1.4 Diacritic Removal and Normalization
In Urdu, short vowels are represented with diacrit-
ics but these are rarely written in practice. In or-
der to keep the data consistent, all diacritics are
removed. This loss of information is not harm-
ful when transliterating/translating from Hindi to
Urdu because undiacritized text is equally read-
5CRULP: http://www.crulp.org/software/langproc.htm
6Malerkotla.org: http://translate.malerkotla.co.in
able to native speakers as its diacritized counter
part. However leaving occasional diacritics in the
corpus can worsen the problem of data sparsity by
creating spurious ambiguity7.
There are a few Urdu characters that have mul-
tiple equivalent Unicodes. All such forms are nor-
malized to have only one representation8.
4.2 Experimental Setup
We perform a 5-fold cross validation taking 4/5 of
the data as training and 1/5 as test data. Each fold
comprises roughly 1400 test sentences and 5600
training sentences.
4.2.1 Parameter Optimization
Our model contains two parameters ? (the inter-
polating factor between translation and transliter-
ation modules) and ? (the factor that controls the
trade-off between LM-known and LM-unknown
transliterations). The interpolating factor ? is ini-
tialized, inspired by Written-Bell smoothing, with
a value of NN+B
9. We chose a very low value
1e?40 for the factor ? initially, favoring LM-
known transliterations very strongly. Both of these
parameters are optimized as described below.
Because our training data is very sparse we do
not use held-out data for parameter optimization.
Instead we optimize these parameters by perform-
ing a 2-fold optimization for each of the 5 folds.
Each fold is divided into two halves. The param-
eters ? and ? are optimized on the first half and
the other half is used for testing, then optimiza-
tion is done on the second half and the first half is
used for testing. The optimal value for parameter
? occurs between 0.7-0.84 and for the parameter
? between 1e?5 and 1e?10.
4.2.2 Results
Baseline Pb0: We ran Moses (Koehn et al, 2007)
using Koehn?s training scripts10, doing a 5-fold
cross validation with no reordering11. For the
other parameters we use the default values i.e.
5-gram language model and maximum phrase-
length= 6. Again, the language model is imple-
7It should be noted though that diacritics play a very im-
portant role when transliterating in the reverse direction be-
cause these are virtually always written in Hindi as dependent
vowels.
8www.crulp.org/software/langproc/urdunormalization.htm
9N is the number of aligned word pairs (tokens) and B is
the number of different aligned word pairs (types).
10http://statmt.org/wmt08/baseline.html
11Results are worse with reordering enabled.
470
M Pb0 Pb1 Pb2 M1 M2
BLEU 14.3 16.25 16.13 18.6 17.05
Table 4: Comparing Model-1 and Model-2 with
Phrase-based Systems
mented as an n-gram model using the SRILM-
Toolkit with Kneser-Ney smoothing. Each fold
comprises roughly 1400 test sentences, 5000 in
training and 600 in dev12. We also used two meth-
ods to incorporate transliterations in the phrase-
based system:
Post-process Pb1: All the OOV words in the
phrase-based output are replaced with their top-
candidate transliteration as given by our translit-
eration system.
Pre-process Pb2: Instead of adding translit-
erations as a post process we do a second pass
by adding the unknown words with their top-
candidate transliteration to the training corpus and
rerun Koehn?s training script with the new training
corpus. Table 4 shows results (taking arithmetic
average over 5 folds) from Model-1 and Model-
2 in comparison with three baselines discussed
above.
Both our systems (Model-1 and Model-2) beat
the baseline phrase-based system with a BLEU
point difference of 4.30 and 2.75 respectively. The
transliteration aided phrase-based systems Pb1
and Pb2 are closer to our Model-2 results but are
way below Model-1 results. The difference of
2.35 BLEU points between M1 and Pb1 indicates
that transliteration is useful for more than only
translating OOV words for language pairs like
Hindi-Urdu. Our models choose between trans-
lations and transliterations based on context un-
like the phrase-based systems Pb1 and Pb2 which
use transliteration only as a tool to translate OOV
words.
5 Error Analysis
Based on preliminary experiments we found three
major flaws in our initial formulations. This sec-
tion discusses each one of them and provides some
heuristics and modifications that we employ to try
to correct deficiencies we found in the two models
described in section 3.1 and 3.2.
12After having the MERT parameters, we add the 600 dev
sentences back into the training corpus, retrain GIZA, and
then estimate a new phrase table on all 5600 sentences. We
then use the MERT parameters obtained before together with
the newer (larger) phrase-table set.
5.1 Heuristic-1
A lot of errors occur because our translation model
is built on very sparse and noisy data. The moti-
vation for this heuristic is to counter wrong align-
ments at least in the case of verbs and functional
words (which are often transliterations). This
heuristic favors translations that also appear in the
n-best transliteration list over only-translation and
only-transliteration options. We modify the trans-
lation model for both the conditional and the joint
model by adding another factor which strongly
weighs translation+transliteration options by tak-
ing the square-root of the product of the translation
and transliteration probabilities. Thus modifying
equations (8) and (11) in Model-1 and Model-2
we obtain equations (15) and (16) respectively:
p(hi|ui) = ?1pw(hi|ui) + ?2
pc(hi, ui)
pc(ui)
+ ?3
?
pw(hi|ui)
pc(hi, ui)
pc(ui)
(15)
p(hi, ui) = ?1pw(hi, ui) + ?2pc(hi, ui)
+ ?3
?
pw(hi, ui)pc(hi, ui) (16)
For the optimization of lambda parameters we
hold the value of the translation coefficient ?113
and the transliteration coefficient ?2 constant (us-
ing the optimized values as discussed in section
4.2.1) and optimize ?3 again using 2-fold opti-
mization on all the folds as described above14.
5.2 Heuristic-2
When an unknown Hindi word occurs for which
all transliteration options are LM-unknown then
the best transliteration should be selected. The
problem in our original models is that a fixed LM
probability ? is used for LM-unknown transliter-
ations. Hence our model selects the translitera-
tion that has the best pc(hi,ui)pc(ui) score i.e. we max-
imize pc(hi|ui) instead of pc(ui|hi) (or equiva-
lently pc(hi, ui)). The reason is an inconsistency
in our models. The language model probabil-
ity of unknown words is uniform (and equal to
?) whereas the translation model uses the non-
uniform prior probability pc(ui) for these words.
There is another reason why we can not use the
13The translation coefficient ?1 is same as ? used in previ-
ous models and the transliteration coefficient ?2 = 1? ?
14After optimization we normalize the lambdas to make
their sum equal to 1.
471
value ? in this case. Our transliterator model also
produces space inserted words. The value of ? is
very small because of which transliterations that
are actually LM-unknown, but are mistakenly bro-
ken into constituents that are LM-known, will al-
ways be preferred over their counter parts. An ex-
ample of this is (America) for which two
possible transliterations as given by our model are
(AmerIkA, without space) and (AmerI
kA, with space). The latter version is LM-known
as its constituents are LM-known. Our models al-
ways favor the latter version. Space insertion is an
important feature of our transliteration model. We
want our transliterator to tackle compound words,
derivational affixes, case-markers with nouns that
are written as one word in Hindi but as two or more
words in Urdu. Examples were already shown in
section 3?s footnote.
We eliminate the inconsistency by using pc(ui)
as the 0-gram back-off probability distribution in
the language model. For an LM-unknown translit-
erations we now get in Model-1:
p(ui|u
i?1
i?k)[?pw(hi|ui) + (1? ?)
pc(hi, ui)
pc(ui)
]
= p(ui|u
i?1
i?k)[(1? ?)
pc(hi, ui)
pc(ui)
]
=
k?
j=0
?(ui?1i?j )pc(ui)[(1? ?)
pc(hi, ui)
pc(ui)
]
=
k?
j=0
?(ui?1i?j )[(1? ?)pc(hi, ui)]
where
?k
j=0 ?(u
i?1
i?j ) is just the constant that
SRILM returns for unknown words. The last
line of the calculation shows that we simply drop
pc(ui) if ui is LM-unknown and use the constant?k
j=0 ?(u
i?1
i?j ) instead of ?. A similar calculation
for Model-2 gives
?k
j=0 ?(u
i?1
i?j )pc(hi, ui).
5.3 Heuristic-3
This heuristic discusses a flaw in Model-2. For
transliteration options that are TM-unknown, the
pw(h, u) and pw(u) factors becomes zero and the
translation model probability as given by equation
(13) becomes:
(1? ?)pc(hi, ui)
(1? ?)pc(ui)
=
pc(hi, ui)
pc(ui)
In such cases the ? factor cancels out and no
weighting of word translation vs. transliteration
H1 H2 H12
M1 18.86 18.97 19.35
M2 17.56 17.85 18.34
Table 5: Applying Heuristics 1 and 2 and their
Combinations to Model-1 and Model-2
H3 H13 H23 H123
M2 18.52 18.93 18.55 19.00
Table 6: Applying Heuristic 3 and its Combina-
tions with other Heuristics to Model-2
occurs anymore. As a result of this, translitera-
tions are sometimes incorrectly favored over their
translation alternatives.
In order to remedy this problem we assign a
minimal probability ? to the word-based prior
pw(ui) in case of TM-unknown transliterations,
which prevents it from ever being zero. Because
of this addition the translation model probability
for LM-unknown words becomes:
(1? ?)pc(hi, ui)
?? + (1? ?)pc(ui)
where ? =
1
Urdu Types in TM
6 Final Results
This section shows the improvement in BLEU
score by applying heuristics and combinations of
heuristics in both the models. Tables 5 and 6 show
the improvements achieved by using the differ-
ent heuristics and modifications discussed in sec-
tion 5. We refer to the results as MxHy where x
denotes the model number, 1 for the conditional
probability model and 2 for the joint probability
model and y denotes a heuristic or a combination
of heuristics applied to that model15.
Both heuristics (H1 and H2) show improve-
ments over their base models M1 and M2.
Heuristic-1 shows notable improvement for both
models in parts of test data which has high num-
ber of common vocabulary words. Using heuris-
tic 2 we were able to properly score LM-unknown
transliterations against each other. Using these
heuristics together we obtain a gain of 0.75 over
M-1 and a gain of 1.29 over M-2.
Heuristic-3 remedies the flaw in M2 by assign-
ing a special value to the word-based prior pw(ui)
for TM-unknown words which prevents the can-
celation of interpolating parameter ?. M2 com-
bined with heuristic 3 (M2H3) results in a 1.47
15For example M1H1 refers to the results when heuristic-
1 is applied to model-1 whereas M2H12 refers to the results
when heuristics 1 and 2 are together applied to model 2.
472
BLEU point improvement and combined with all
the heuristics (M2H123) gives an overall gain of
1.95 BLEU points and is close to our best results
(M1H12). We also performed significance test
by concatenating all the fold results. Both our best
systems M1H12 and M2H123 are statistically sig-
nificant (p < 0.05)16 over all the baselines dis-
cussed in section 4.2.2.
One important issue that has not been investi-
gated yet is that BLEU has not yet been shown
to have good performance in morphologically rich
target languages like Urdu, but there is no metric
known to work better. We observed that some-
times on data where the translators preferred to
translate rather than doing transliteration our sys-
tem is penalized by BLEU even though our out-
put string is a valid translation. For other parts of
the data where the translators have heavily used
transliteration, the system may receive a higher
BLEU score. We feel that this is an interesting
area of research for automatic metric developers,
and that a large scale task of translation to Urdu
which would involve a human evaluation cam-
paign would be very interesting.
7 Sample Output
This section gives two examples showing how our
model (M1H2) performs disambiguation. Given
below are some test sentences that have Hindi
homonyms (underlined in the examples) along
with Urdu output given by our system. In the first
example (given in Figure 1) Hindi word can be
transliterated to ( Lion) or (Verse) depend-
ing upon the context. Our model correctly identi-
fies which transliteration to choose given the con-
text.
In the second example (shown in Figure 2)
Hindi word can be translated to (peace,
s@kun) when it is a common noun but transliter-
ated to (Shanti, SAnt di) when it is a proper
name. Our model successfully decides whether to
translate or transliterate given the context.
8 Conclusion
We have presented a novel way to integrate
transliterations into machine translation. In
closely related language pairs such as Hindi-Urdu
with a significant amount of vocabulary overlap,
16We used Kevin Gimpel?s tester
(http://www.ark.cs.cmu.edu/MT/) which uses bootstrap
resampling (Koehn, 2004b), with 1000 samples.
Ser d Z@ngl kA rAd ZA he
?Lion is the king of jungle?
AIqbAl kA Aek xub sur@t d Ser he
?There is a beautiful verse from Iqbal?
Figure 1: Different Transliterations in Different
Contexts
p hIr b hi vh s@kun se n@her?h s@kt dA
?Even then he can?t live peacefully?
Aom SAnt di Aom frhA xAn ki d dusri fIl@m he
?Om Shanti Om is Farah Khan?s second film?
Figure 2: Translation or Transliteration
transliteration can be very effective in machine
translation for more than just translating OOV
words. We have addressed two problems. First,
transliteration helps overcome the problem of data
sparsity and noisy alignments. We are able to gen-
erate word translations that are unseen in the trans-
lation corpus but known to the language model.
Additionally, we can generate novel translitera-
tions (that are LM-Unknown). Second, generat-
ing multiple transliterations for homograph Hindi
words and using language model context helps us
solve the problem of disambiguation. We found
that the joint probability model performs almost as
well as the conditional probability model but that
it was more complex to make it work well.
Acknowledgments
The first two authors were funded by the Higher
Education Commission (HEC) of Pakistan. The
third author was funded by Deutsche Forschungs-
gemeinschaft grants SFB 732 and MorphoSynt.
The fourth author was funded by Deutsche
Forschungsgemeinschaft grant SFB 732.
473
References
Nasreen AbdulJaleel and Leah S. Larkey. 2003. Sta-
tistical transliteration for English-Arabic cross lan-
guage information retrieval. In CIKM 03: Proceed-
ings of the twelfth international conference on In-
formation and knowledge management, pages 139?
146.
Yaser Al-Onaizan and Kevin Knight. 2002. Translat-
ing named entities using monolingual and bilingual
resources. In Proceedings of the 40th Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 400?408.
Asif Ekbal, Sudip Kumar Naskar, and Sivaji Bandy-
opadhyay. 2006. A modified joint source-channel
model for transliteration. In Proceedings of the
COLING/ACL poster sessions, pages 191?198, Syd-
ney, Australia. Association for Computational Lin-
guistics.
Swati Gupta. 2004. Aligning Hindi and Urdu bilin-
gual corpora for robust projection. Masters project
dissertation, Department of Computer Science, Uni-
versity of Sheffield.
Ulf Hermjakob, Kevin Knight, and Hal Daume? III.
2008. Name translation in statistical machine trans-
lation - learning when to transliterate. In Proceed-
ings of ACL-08: HLT, pages 389?397, Columbus,
Ohio. Association for Computational Linguistics.
Bushra Jawaid and Tafseer Ahmed. 2009. Hindi to
Urdu conversion: beyond simple transliteration. In
Conference on Language and Technology 2009, La-
hore, Pakistan.
Mehdi M. Kashani, Eric Joanis, Roland Kuhn, George
Foster, and Fred Popowich. 2007. Integration of an
Arabic transliteration module into a statistical ma-
chine translation system. In Proceedings of the Sec-
ond Workshop on Statistical Machine Translation,
pages 17?24, Prague, Czech Republic. Association
for Computational Linguistics.
Kevin Knight and Jonathan Graehl. 1998. Ma-
chine transliteration. Computational Linguistics,
24(4):599?612.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proceedings of the 45th Annual Meeting of the Asso-
ciation for Computational Linguistics, Demonstra-
tion Program, Prague, Czech Republic.
Philipp Koehn. 2004a. Pharaoh: A beam search de-
coder for phrase-based statistical machine transla-
tion models. In AMTA, pages 115?124.
Philipp Koehn. 2004b. Statistical significance tests for
machine translation evaluation. In Dekang Lin and
Dekai Wu, editors, Proceedings of EMNLP 2004,
pages 388?395, Barcelona, Spain, July. Association
for Computational Linguistics.
Haizhou Li, Zhang Min, and Su Jian. 2004. A joint
source-channel model for machine transliteration.
In ACL ?04: Proceedings of the 42nd Annual Meet-
ing on Association for Computational Linguistics,
pages 159?166, Barcelona, Spain. Association for
Computational Linguistics.
M G Abbas Malik, Christian Boitet, and Pushpak Bhat-
tacharyya. 2008. Hindi Urdu machine translitera-
tion using finite-state transducers. In Proceedings
of the 22nd International Conference on Computa-
tional Linguistics, Manchester, UK.
Robert C. Moore. 2002. Fast and accurate sentence
alignment of bilingual corpora. In Conference of the
Association for Machine Translation in the Ameri-
cas (AMTA).
Franz J. Och and Hermann Ney. 2003. A systematic
comparison of various statistical alignment models.
Computational Linguistics, 29(1):19?51.
Kishore A. Papineni, Salim Roukos, Todd Ward, and
Wei-Jing Zhu. 2001. BLEU: a method for auto-
matic evaluation of machine translation. Technical
Report RC22176 (W0109-022), IBM Research Di-
vision, Thomas J. Watson Research Center, York-
town Heights, NY.
Ari Pirkola, Jarmo Toivonen, Heikki Keskustalo, Kari
Visala, and Kalervo Ja?rvelin. 2003. Fuzzy trans-
lation of cross-lingual spelling variants. In SIGIR
?03: Proceedings of the 26th annual international
ACM SIGIR conference on Research and develop-
ment in informaion retrieval, pages 345?352, New
York, NY, USA. ACM.
R. Mahesh K. Sinha. 2009. Developing English-Urdu
machine translation via Hindi. In Third Workshop
on Computational Approaches to Arabic Script-
based Languages (CAASL3), MT Summit XII, Ot-
tawa, Canada.
Andreas Stolcke. 2002. SRILM - an extensible lan-
guage modeling toolkit. In Intl. Conf. Spoken Lan-
guage Processing, Denver, Colorado.
Paola Virga and Sanjeev Khudanpur. 2003. Translit-
eration of proper names in cross-lingual information
retrieval. In Proceedings of the ACL 2003 workshop
on Multilingual and mixed-language named entity
recognition, pages 57?64, Morristown, NJ, USA.
Association for Computational Linguistics.
Bing Zhao, Nguyen Bach, Ian Lane, and Stephan Vo-
gel. 2007. A log-linear block transliteration model
based on bi-stream HMMs. In Human Language
Technologies 2007: The Conference of the North
American Chapter of the Association for Computa-
tional Linguistics; Proceedings of the Main Confer-
ence, pages 364?371, Rochester, New York. Associ-
ation for Computational Linguistics.
474
Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics, pages 430?439,
Portland, Oregon, June 19-24, 2011. c?2011 Association for Computational Linguistics
An Algorithm for Unsupervised Transliteration Mining with an Application
to Word Alignment
Hassan Sajjad Alexander Fraser Helmut Schmid
Institute for Natural Language Processing
University of Stuttgart
{sajjad,fraser,schmid}@ims.uni-stuttgart.de
Abstract
We propose a language-independent method
for the automatic extraction of transliteration
pairs from parallel corpora. In contrast to
previous work, our method uses no form of
supervision, and does not require linguisti-
cally informed preprocessing. We conduct
experiments on data sets from the NEWS
2010 shared task on transliteration mining and
achieve an F-measure of up to 92%, out-
performing most of the semi-supervised sys-
tems that were submitted. We also apply our
method to English/Hindi and English/Arabic
parallel corpora and compare the results with
manually built gold standards which mark
transliterated word pairs. Finally, we integrate
the transliteration module into the GIZA++
word aligner and evaluate it on two word
alignment tasks achieving improvements in
both precision and recall measured against
gold standard word alignments.
1 Introduction
Most previous methods for building transliteration
systems were supervised, requiring either hand-
crafted rules or a clean list of transliteration pairs,
both of which are expensive to create. Such re-
sources are also not applicable to other language
pairs.
In this paper, we show that it is possible to ex-
tract transliteration pairs from a parallel corpus us-
ing an unsupervised method. We first align a bilin-
gual corpus at the word level using GIZA++ and
create a list of word pairs containing a mix of non-
transliterations and transliterations. We train a sta-
tistical transliterator on the list of word pairs. We
then filter out a few word pairs (those which have
the lowest transliteration probabilities according to
the trained transliteration system) which are likely
to be non-transliterations. We retrain the translitera-
tor on the filtered data set. This process is iterated,
filtering out more and more non-transliteration pairs
until a nearly clean list of transliteration word pairs
is left. The optimal number of iterations is automat-
ically determined by a novel stopping criterion.
We compare our unsupervised transliteration min-
ing method with the semi-supervised systems pre-
sented at the NEWS 2010 shared task on translit-
eration mining (Kumaran et al, 2010) using four
language pairs. We refer to this task as NEWS10.
These systems used a manually labelled set of data
for initial supervised training, which means that
they are semi-supervised systems. In contrast, our
system is fully unsupervised. We achieve an F-
measure of up to 92% outperforming most of the
semi-supervised systems.
The NEWS10 data sets are extracted Wikipedia
InterLanguage Links (WIL) which consist of par-
allel phrases, whereas a parallel corpus consists of
parallel sentences. Transliteration mining on the
WIL data sets is easier due to a higher percentage
of transliterations than in parallel corpora. We also
do experiments on parallel corpora for two language
pairs. To this end, we created gold standards in
which sampled word pairs are annotated as either
transliterations or non-transliterations. These gold
standards have been submitted with the paper as sup-
plementary material as they are available to the re-
search community.
430
Finally we integrate a transliteration module into
the GIZA++ word aligner and show that it improves
word alignment quality. The transliteration mod-
ule is trained on the transliteration pairs which our
mining method extracts from the parallel corpora.
We evaluate our word alignment system on two lan-
guage pairs using gold standard word alignments
and achieve improvements of 10% and 13.5% in pre-
cision and 3.5% and 13.5% in recall.
The rest of the paper is organized as follows. In
section 2, we describe the filtering model and the
transliteration model. In section 3, we present our
iterative transliteration mining algorithm and an al-
gorithm which computes a stopping criterion for the
mining algorithm. Section 4 describes the evaluation
of our mining method through both gold standard
evaluation and through using it to improve word
alignment quality. In section 5, we present previous
work and we conclude in section 6.
2 Models
Our algorithms use two different models. The first
model is a joint character sequence model which
we apply to transliteration mining. We use the
grapheme-to-phoneme converter g2p to implement
this model. The other model is a standard phrase-
based MT model which we apply to transliteration
(as opposed to transliteration mining). We build it
using the Moses toolkit.
2.1 Joint Sequence Model Using g2p
Here, we briefly describe g2p using notation from
Bisani and Ney (2008). The details of the model,
its parameters and the utilized smoothing techniques
can be found in Bisani and Ney (2008).
The training data is a list of word pairs (a source
word and its presumed transliteration) extracted
from a word-aligned parallel corpus. g2p builds a
joint sequence model on the character sequences of
the word pairs and infers m-to-n alignments between
source and target characters with Expectation Maxi-
mization (EM) training. The m-to-n character align-
ment units are referred to as ?multigrams?.
The model built on multigrams consisting of
source and target character sequences greater than
one learns too much noise (non-transliteration infor-
mation) from the training data and performs poorly.
In our experiments, we use multigrams with a maxi-
mum of one character on the source and one charac-
ter on the target side (i.e., 0,1-to-0,1 character align-
ment units).
The N-gram approximation of the joint probabil-
ity can be defined in terms of multigrams qi as:
p(qk1 ) ?
k+1?
j=1
p(qj |q
j?1
j?N+1) (1)
where q0, qk+1 are set to a special boundary symbol.
N-gram models of order > 1 did not work well
because these models tended to learn noise (infor-
mation from non-transliteration pairs) in the training
data. For our experiments, we only trained g2p with
the unigram model.
In test mode, we look for the best sequence of
multigrams given a fixed source and target string and
return the probability of this sequence.
For the mining process, we trained g2p on
lists containing both transliteration pairs and non-
transliteration pairs.
2.2 Statistical Machine Transliteration System
We build a phrase-based MT system for translitera-
tion using the Moses toolkit (Koehn et al, 2003). We
also tried using g2p for implementing the translit-
eration decoder but found Moses to perform bet-
ter. Moses has the advantage of using Minimum Er-
ror Rate Training (MERT) which optimizes translit-
eration accuracy rather than the likelihood of the
training data as g2p does. The training data con-
tains more non-transliteration pairs than transliter-
ation pairs. We don?t want to maximize the like-
lihood of the non-transliteration pairs. Instead we
want to optimize the transliteration performance for
test data. Secondly, it is easy to use a large language
model (LM) with Moses. We build the LM on the
target word types in the data to be filtered.
For training Moses as a transliteration system, we
treat each word pair as if it were a parallel sentence,
by putting spaces between the characters of each
word. The model is built with the default settings
of the Moses toolkit. The distortion limit ?d? is set
to zero (no reordering). The LM is implemented as
a five-gram model using the SRILM-Toolkit (Stol-
cke, 2002), with Add-1 smoothing for unigrams and
Kneser-Ney smoothing for higher n-grams.
431
3 Extraction of Transliteration Pairs
Training of a supervised transliteration system re-
quires a list of transliteration pairs which is expen-
sive to create. Such lists are usually either built man-
ually or extracted using a classifier trained on man-
ually labelled data and using other language depen-
dent information. In this section, we present an it-
erative method for the extraction of transliteration
pairs from parallel corpora which is fully unsuper-
vised and language pair independent.
Initially, we extract a list of word pairs from a
word-aligned parallel corpus using GIZA++. The
extracted word pairs are either transliterations, other
kinds of translations, or misalignments. In each it-
eration, we first train g2p on the list of word pairs.
Then we delete those 5% of the (remaining) train-
ing data which are least likely to be transliterations
according to g2p.1 We determine the best iteration
according to our stopping criterion and return the fil-
tered data set from this iteration. The stopping crite-
rion uses unlabelled held-out data to predict the opti-
mal stopping point. The following sections describe
the transliteration mining method in detail.
3.1 Methodology
We will first describe the iterative filtering algorithm
(Algorithm 1) and then the algorithm for the stop-
ping criterion (Algorithm 2). In practice, we first
run Algorithm 2 for 100 iterations to determine the
best number of iterations. Then, we run Algorithm 1
for that many iterations.
Initially, the parallel corpus is word-aligned using
GIZA++ (Och and Ney, 2003), and the alignments
are refined using the grow-diag-final-and heuristic
(Koehn et al, 2003). We extract all word pairs which
occur as 1-to-1 alignments in the word-aligned cor-
pus. We ignore non-1-to-1 alignments because they
are less likely to be transliterations for most lan-
guage pairs. The extracted set of word pairs will be
called ?list of word pairs? later on. We use the list
of word pairs as the training data for Algorithm 1.
Algorithm 1 builds a joint sequence model using
g2p on the training data and computes the joint prob-
ability of all word pairs according to g2p. We nor-
malize the probabilities by taking the nth square root
1Since we delete 5% from the filtered data, the number of
deleted data items decreases in each iteration.
Algorithm 1 Mining of transliteration pairs
1: training data?list of word pairs
2: I? 0
3: repeat
4: Build a joint source channel model on the training
data using g2p and compute the joint probability
of every word pair.
5: Remove the 5% word pairs with the lowest length-
normalized probability from the training data.
{and repeat the process with the filtered training
data}
6: I? I+1
7: until I = Stopping iteration from Algorithm 2
where n is the average length of the source and the
target string. The training data contains mostly non-
transliteration pairs and a few transliteration pairs.
Therefore the training data is initially very noisy and
the joint sequence model is not very accurate. How-
ever it can successfully be used to eliminate a few
word pairs which are very unlikely to be translitera-
tions.
On the filtered training data, we can train a model
which is slightly better than the previous model. Us-
ing this improved model, we can eliminate further
non-transliterations.
Our results show that at the iteration determined
by our stopping criterion, the filtered set mostly
contains transliterations and only a small number
of transliterations have been mistakenly eliminated
(see section 4.2).
Algorithm 2 automatically determines the best
stopping point of the iterative transliteration min-
ing process. It is an extension of Algorithm 1. It
runs the iterative process of Algorithm 1 on half of
the list of word pairs (training data) for 100 itera-
tions. For every iteration, it builds a transliteration
system on the filtered data. The transliteration sys-
tem is tested on the source side of the other half of
the list of word pairs (held-out). The output of the
transliteration system is matched against the target
side of the held-out data. (These target words are ei-
ther transliterations, translations or misalignments.)
We match the target side of the held-out data under
the assumption that all matches are transliterations.
The iteration where the output of the transliteration
system best matches the held-out data is chosen as
the stopping iteration of Algorithm 1.
432
Algorithm 2 Selection of the stopping iteration for
the transliteration mining algorithm
1: Create clusters of word pairs from the list of word
pairs which have a common prefix of length 2 both
on the source and target language side.
2: Randomly add each cluster either to the training data
or to the held-out data.
3: I? 0
4: while I < 100 do
5: Build a joint sequence model on the training
data using g2p and compute the length-normalized
joint probability of every word pair in the training
data.
6: Remove the 5% word pairs with the lowest prob-
ability from the training data. {The training data
will be reduced by 5% of the rest in each iteration}
7: Build a transliteration system on the filtered train-
ing data and test it using the source side of the
held-out and match the output against the target
side of the held-out.
8: I? I+1
9: end while
10: Collect statistics of the matching results and take the
median from 9 consecutive iterations (median9).
11: Choose the iteration with the best median9 score for
the transliteration mining process.
We will now describe Algorithm 2 in detail. Al-
gorithm 2 initially splits the word pairs into training
and held-out data. This could be done randomly, but
it turns out that this does not work well for some
tasks. The reason is that the parallel corpus con-
tains inflectional variants of the same word. If two
variants are distributed over training and held-out
data, then the one in the training data may cause the
transliteration system to produce a correct transla-
tion (but not transliteration) of its variant in the held-
out data. This problem is further discussed in section
4.2.2. Instead of randomly splitting the data, we first
create clusters of word pairs which have a common
prefix of length 2 both on the source and target lan-
guage side. We randomly add each cluster either to
the training data or to the held-out data.
We repeat the mining process (described in Algo-
rithm 1) to eliminate non-transliteration pairs from
the training data. For each iteration of Algorithm 2,
i.e., steps 4 to 9, we build a transliteration system on
the filtered training data and test it on the source side
of the held-out. We collect statistics on how well the
output of the system matches the target side of the
held-out. The matching scores on the held-out data
often make large jumps from iteration to iteration.
We take the median of the results from 9 consecutive
iterations (the 4 iterations before, the current and the
4 iterations after the current iteration) to smooth the
scores. We call this median9. We choose the iter-
ation with the best smoothed score as the stopping
point for the filtering process. In our tests, the me-
dian9 heuristic indicated an iteration close to the op-
timal iteration.
Sometimes several nearby iterations have the
same maximal smoothed score. In that case, we
choose the one with the highest unsmoothed score.
Section 4.2 explains the median9 heuristic in more
detail and presents experimental results showing that
it works well.
4 Experiments
We evaluate our transliteration mining algorithm on
three tasks: transliteration mining from Wikipedia
InterLanguage Links, transliteration mining from
parallel corpora, and word alignment using a word
aligner with a transliteration component. On the
WIL data sets, we compare our fully unsupervised
system with the semi-supervised systems presented
at the NEWS10 (Kumaran et al, 2010). In the eval-
uation on parallel corpora, we compare our min-
ing results with a manually built gold standard in
which each word pair is either marked as a translit-
eration or as a non-transliteration. In the word align-
ment experiment, we integrate a transliteration mod-
ule which is trained on the transliterations pairs ex-
tracted by our method into a word aligner and show
a significant improvement. The following sections
describe the experiments in detail.
4.1 Experiments Using Parallel Phrases of
Wikipedia InterLanguage Links
We conduct transliteration mining experiments on
the English/Arabic, English/Hindi, English/Tamil
and English/Russian Wikipedia InterLanguage
Links (WIL) used in the NEWS10.2 All data sets
2We do not evaluate on the English/Chinese data because
the Chinese data requires word segmentation which is beyond
the scope of our work. Another problem is that our extraction
method was developed for alphabetic languages and probably
needs to be adapted before it is applicable to logographic lan-
guages such as Chinese.
433
Our S-Best S-Worst Systems Rank
EA 87.4 91.5 70.2 16 3
ET 90.1 91.4 57.5 14 3
EH 92.2 94.4 71.4 14 3
Table 1: Summary of results on NEWS10 data sets where
?EA? is English/Arabic, ?ET? is English/Tamil and ?EH?
is English/Hindi. ?Our? shows the F-measure of our fil-
tered data against the gold standard using the supplied
evaluation tool, ?Systems? is the total number of partic-
ipants in the subtask, and ?Rank? is the rank we would
have obtained if our system had participated.
contain training data, seed data and reference data.
We make no use of the seed data since our system is
fully unsupervised. We calculate the F-measure of
our filtered transliteration pairs against the supplied
gold standard using the supplied evaluation tool.
For English/Arabic, English/Hindi and En-
glish/Tamil, our system is better than most of the
semi-supervised systems presented at the NEWS
2010 shared task for transliteration mining. Table 1
summarizes the F-scores on these data sets.
On the English/Russian data set, our system
achieves 76% F-measure which is not good com-
pared with the systems that participated in the shared
task. The English/Russian corpus contains many
cognates which ? according to the NEWS10 defi-
nition ? are not transliterations of each other. Our
system learns the cognates in the training data and
extracts them as transliterations (see Table 2).
The two best teams on the English/Russian task
presented various extraction methods (Jiampoja-
marn et al, 2010; Darwish, 2010). Their sys-
tems behave differently on English/Russian than on
other language pairs. Their best systems for En-
glish/Russian are only trained on the seed data and
the use of unlabelled data does not help the perfor-
mance. Since our system is fully unsupervised, and
the unlabelled data is not useful, we perform badly.
4.2 Experiments Using Parallel Corpora
The Wikipedia InterLanguage Links shared task
data contains a much larger proportion of translitera-
tions than a parallel corpus. In order to examine how
well our method performs on parallel corpora, we
apply it to parallel corpora of English/Hindi and En-
glish/Arabic, and compare the transliteration mining
results with a gold standard.
Table 2: Cognates from English/Russian corpus extracted
by our system as transliteration pairs. None of them are
correct transliteration pairs according to the gold stan-
dard.
We use the English/Hindi corpus from the shared
task on word alignment, organized as part of the
ACL 2005 Workshop on Building and Using Par-
allel Texts (WA05) (Martin et al, 2005). For En-
glish/Arabic, we use a freely available parallel cor-
pus from the United Nations (UN) (Eisele and Chen,
2010). We randomly take 200,000 parallel sentences
from the UN corpus of the year 2000. We cre-
ate gold standards for both language pairs by ran-
domly selecting a few thousand word pairs from the
lists of word pairs extracted from the two corpora.
We manually tag them as either transliterations or
non-transliterations. The English/Hindi gold stan-
dard contains 180 transliteration pairs and 2084
non-transliteration pairs and the English/Arabic gold
standard contains 288 transliteration pairs and 6639
non-transliteration pairs. We have submitted these
gold standards with the paper. They are available to
the research community.
In the following sections, we describe the me-
dian9 heuristic and the splitting method of Algo-
rithm 2. The splitting method is used to avoid early
peaks in the held-out statistics, and the median9
heuristic smooths the held-out statistics in order to
obtain a single peak.3
4.2.1 Motivation for Median9 Heuristic
Algorithm 2 collects statistics from the held-out data
(step 10) and selects the stopping iteration. Due to
the noise in the held-out data, the transliteration ac-
curacy on the held-out data often jumps from itera-
tion to iteration. The dotted line in figure 1 (right)
shows the held-out prediction accuracy for the En-
3We do not use the seed data in our system. However,
to check the correctness of the stopping point, we tested
the transliteration system on the seed data (available with
NEWS10) for every iteration of Algorithm 2. We verified that
the median9 held-out statistics and accuracy on the seed data
have their peaks at the same iteration.
434
glish/Hindi parallel corpus. The curve is very noisy
and has two peaks. It is difficult to see the effect of
the filtering. We take the median of the results from
9 consecutive iterations to smooth the scores. The
solid line in figure 1 (right) shows a smoothed curve
built using the median9 held-out scores. A compari-
son with the gold standard (section 4.2.3) shows that
the stopping point (peak) reached using the median9
heuristic is better than the stopping point obtained
with unsmoothed scores.
4.2.2 Motivation for Splitting Method
Algorithm 2 initially splits the list of word pairs into
training and held-out data. A random split worked
well for the WIL data, but failed on the parallel cor-
pora. The reason is that parallel corpora contain in-
flectional variants of the same word. If these vari-
ants are randomly distributed over training and held-
out data, then a non-transliteration word pair such as
the English-Hindi pair ?change ? badlao? may end
up in the training data and the related pair ?changes
? badlao? in the held-out data. The Moses system
used for transliteration will learn to ?transliterate?
(or actually translate) ?change? to ?badlao?. From
other examples, it will learn that a final ?s? can be
dropped. As a consequence, the Moses transliterator
may produce the non-transliteration ?badlao? for the
English word ?changes? in the held-out data. Such
matching predictions of the transliterator which are
actually translations lead to an overestimate of the
transliteration accuracy and may cause Algorithm 2
to predict a stopping iteration which is too early.
By splitting the list of word pairs in such a way
that inflectional variants of a word are placed either
in the training data, or in the held-out, but not in
both, this problem can be solved.4
The left graph in Figure 1 shows that the median9
held-out statistics obtained after a random data split
of a Hindi/English corpus contains two peaks which
occur too early. These peaks disappear in the right
graph of Figure 1 which shows the results obtained
after a split with the clustering method.
The overall trend of the smoothed curve in fig-
ure 1 (right) is very clear. We start by filtering out
non-transliteration pairs from the data, so the results
4This solution is appropriate for all of the language pairs
used in our experiments, but should be revisited if there is in-
flection realized as prefixes, etc.
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0 10 20 30 40 50 60 70 80 90
accu
racy
iterations
held outmedian9
0
0.1
0.2
0.3
0.4
0.5
0.6
0 10 20 30 40 50 60 70 80 90
accu
racy
iterations
held outmedian 9
Figure 1: Statistics of held-out prediction of En-
glish/Hindi data using modified Algorithm 2 with random
division of the list of word pairs (left) and using Algo-
rithm 2 (right). The dotted line shows unsmoothed held-
out scores and solid line shows median9 held-out scores
of the transliteration system go up. When no more
non-transliteration pairs are left, we start filtering
out transliteration pairs and the results of the system
go down. We use this stopping criterion for all lan-
guage pairs and achieve consistently good results.
4.2.3 Results on Parallel Corpora
According to the gold standard, the English/Hindi
and English/Arabic data sets contain 8% and 4%
transliteration pairs respectively. We repeat the same
mining procedure ? run Algorithm 2 up to 100 itera-
tions and return the stopping iteration. Then, we run
Algorithm 1 up to the stopping iteration returned by
Algorithm 2 and obtain the filtered data.
TP FN TN FP
EH Filtered 170 10 2039 45
EA Filtered 197 91 6580 59
Table 3: Transliteration mining results using the parallel
corpus of English/Hindi (EH) and English/Arabic (EA)
against the gold standard
Table 3 shows the mining results on the En-
glish/Hindi and English/Arabic corpora. The gold
standard is a subset of the data sets. The En-
glish/Hindi gold standard contains 180 translitera-
tion pairs and 2084 non-transliteration pairs. The
English/Arabic gold standard contains 288 translit-
eration pairs and 6639 non-transliteration pairs.
From the English/Hindi data, the mining system has
mined 170 transliteration pairs out of 180 transliter-
ation pairs. The English/Arabic mined data contains
197 transliteration pairs out of 288 transliteration
pairs. The mining system has wrongly identified a
few non-transliteration pairs as transliterations (see
435
table 3, last column). Most of these word pairs are
close transliterations and differ by only one or two
characters from perfect transliteration pairs. The
close transliteration pairs provide many valid multi-
grams which may be helpful for the mining system.
4.3 Integration into Word Alignment Model
In the previous section, we presented a method for
the extraction of transliteration pairs from a parallel
corpus. In this section, we will explain how to build
a transliteration module on the extracted transliter-
ation pairs and how to integrate it into MGIZA++
(Gao and Vogel, 2008) by interpolating it with the t-
table probabilities of the IBM models and the HMM
model. MGIZA++ is an extension of GIZA++. It
has the ability to resume training from any model
rather than starting with Model1.
4.3.1 Modified EM Training of the Word
Alignment Models
GIZA++ applies the IBM models (Brown et al,
1993) and the HMM model (Vogel et al, 1996)
in both directions, i.e., source to target and target
to source. The alignments are refined using the
grow-diag-final-and heuristic (Koehn et al, 2003).
GIZA++ generates a list of translation pairs with
alignment probabilities, which is called the t-table.
In this section, we propose a method to modify the
translation probabilities of the t-table by interpolat-
ing the translation counts with transliteration counts.
The interpolation is done in both directions. In the
following, we will only consider the e-to-f direction.
The transliteration module which is used to calcu-
late the conditional transliteration probability is de-
scribed in Algorithm 3.
We build a transliteration system by training
Moses on the filtered transliteration corpus (using
Algorithm 1) and apply it to the e side of the list
of word pairs. For every source word, we gener-
ate the list of 10-best transliterations nbestTI(e).
Then, we extract every f that cooccurs with e in a
parallel sentence and add it to nbestTI(e) which
gives us the list of candidate transliteration pairs
candidateTI(e). We use the sum of transliteration
probabilities
?
f ??CandidateTI(e) pmoses(f
?, e) as an
approximation for the prior probability pmoses(e) =?
f ? pmoses(f
?, e) which is needed to convert the
joint transliteration probability into a conditional
Algorithm 3 Estimation of transliteration probabili-
ties, e-to-f direction
1: unfiltered data?list of word pairs
2: filtered data ?transliteration pairs extracted using
Algorithm 1
3: Train a transliteration system on the filtered data
4: for all e do
5: nbestTI(e) ? 10 best transliterations for e ac-
cording to the transliteration system
6: cooc(e) ? set of all f that cooccur with e in a
parallel sentence
7: candidateTI(e)? cooc(e) ? nbestTI(e)
8: end for
9: for all f do
10: pmoses(f, e)? joint transliteration probability of
e and f according to the transliterator
11: pti(f |e)?
pmoses(f,e)P
f??CandidateTI(e) pmoses(f
?,e)
12: end for
probability. We use the constraint decoding option
of Moses to compute the joint probability of e and f.
It computes the probability by dividing the transla-
tion score of the best target sentence given a source
sentence by the normalization factor.
We combine the transliteration probabilities with
the translation probabilities of the IBM models and
the HMM model. The normal translation probability
pta(f |e) of the word alignment models is computed
with relative frequency estimates.
We smooth the alignment frequencies by adding
the transliteration probabilities weighted by the fac-
tor ? and get the following modified translation
probabilities
p?(f |e) =
fta(f, e) + ?pti(f |e)
fta(e) + ?
(2)
where fta(f, e) = pta(f |e)f(e). pta(f |e) is ob-
tained from the original t-table of the alignment
model. f(e) is the total corpus frequency of e. ?
is the transliteration weight which is optimized for
every language pair (see section 4.3.2). Apart from
the definition of the weight ?, our smoothing method
is equivalent to Witten-Bell smoothing.
We smooth after every iteration of the IBM mod-
els and the HMM model except the last iteration of
each model. Algorithm 4 shows the smoothing for
IBM Model4. IBM Model1 and the HMM model
are smoothed in the same way. We also apply Algo-
rithm 3 and Algorithm 4 in the alignment direction
436
Algorithm 4 Interpolation with the IBM Model4, e-
to-f direction
1: {We want to run four iterations of Model4}
2: f(e)? total frequency of e in the corpus
3: Run MGIZA++ for one iteration of Model4
4: I ? 1
5: while I < 4 do
6: Look up pta(f |e) in the t-table of Model4
7: fta(f, e)? pta(f |e)f(e) for all (f, e)
8: p?(f |e)? fta(f,e)+?pti(f |e)fta(e)+? for all (f, e)
9: Resume MGIZA++ training for 1 iteration using
the modified t-table probabilities p?(f |e)
10: I ? I + 1
11: end while
f to e. The final alignments are generated using the
grow-diag-final-and heuristic (Koehn et al, 2003).
4.3.2 Evaluation
The English/Hindi corpus available from WA05
consists of training, development and test data. As
development and test data for English/Arabic, we
use manually created gold standard word alignments
for 155 sentences extracted from the Hansards cor-
pus released by LDC. We use 50 sentences for de-
velopment and 105 sentences for test.
Baseline: We align the data sets using GIZA++
(Och and Ney, 2003) and refine the alignments us-
ing the grow-diag-final-and heuristic (Koehn et al,
2003). We obtain the baseline F-measure by com-
paring the alignments of the test corpus with the gold
standard alignments.
Experiments We use GIZA++ with 5 iterations of
Model1, 4 iterations of HMM and 4 iterations of
Model4. We interpolate translation and translitera-
tion probabilities at different iterations (and different
combinations of iterations) of the three models and
always observe an improvement in alignment qual-
ity. For the final experiments, we interpolate at every
iteration of the IBM models and the HMM model
except the last iteration of every model where we
could not interpolate for technical reasons.5 Algo-
5We had problems in resuming MGIZA++ training when
training was supposed to continue from a different model, such
as if we stopped after the 5th iteration of Model1 and then
tried to resume MGIZA++ from the first iteration of the HMM
model. In this case, we ran the 5th iteration of Model1, then the
first iteration of the HMM and only then stopped for interpola-
rithm 4 shows the interpolation of the transliteration
probabilities with IBM Model4. We used the same
procedure with IBM Model1 and the HMM model.
The parameter ? is optimized on development
data for every language pair. The word alignment
system is not very sensitive to ?. Any ? in the
range between 50 and 100 works fine for all lan-
guage pairs. The optimization helps to maximize the
improvement in word alignment quality. For our ex-
periments, we use ? = 80.
On test data, we achieve an improvement of
approximately 10% and 13.5% in precision and
3.5% and 13.5% in recall on English/Hindi and En-
glish/Arabic word alignment, respectively. Table 4
shows the scores of the baseline and our word align-
ment model.
Lang Pb Rb Fb Pti Rti Fti
EH 49.1 48.5 51.2 59.1 52.1 55.4
EA 50.8 49.9 50.4 64.4 63.6 64
Table 4: Word alignment results on the test data of En-
glish/Hindi (EH) and English/Arabic (EA) where Pb is
the precision of baseline GIZA++ and Pti is the precision
of our word alignment system
We compared our word alignment results with the
systems presented at WA05. Three systems, one
limited and two un-limited, participated in the En-
glish/Hindi task. We outperform the limited system
and one un-limited system.
5 Previous Research
Previous work on transliteration mining uses a man-
ually labelled set of training data to extract translit-
eration pairs from a parallel corpus or comparable
corpora. The training data may contain a few hun-
dred randomly selected transliteration pairs from a
transliteration dictionary (Yoon et al, 2007; Sproat
et al, 2006; Lee and Chang, 2003) or just a few
carefully selected transliteration pairs (Sherif and
Kondrak, 2007; Klementiev and Roth, 2006). Our
work is more challenging as we extract translitera-
tion pairs without using transliteration dictionaries
or gold standard transliteration pairs.
Klementiev and Roth (2006) initialize their
transliteration model with a list of 20 transliteration
tion; so we did not interpolate in just those iterations of training
where we were transitioning from one model to the next.
437
pairs. Their model makes use of temporal scoring
to rank the candidate transliterations. A lot of work
has been done on discovering and learning translit-
erations from comparable corpora by using temporal
and phonetic information (Tao et al, 2006; Klemen-
tiev and Roth, 2006; Sproat et al, 2006). We do not
have access to this information.
Sherif and Kondrak (2007) train a probabilistic
transducer on 14 manually constructed translitera-
tion pairs of English/Arabic. They iteratively extract
transliteration pairs from the test data and add them
to the training data. Our method is different from the
method of Sherif and Kondrak (2007) as our method
is fully unsupervised, and because in each iteration,
they add the most probable transliteration pairs to
the training data, while we filter out the least proba-
ble transliteration pairs from the training data.
The transliteration mining systems of the four
NEWS10 participants are either based on discrim-
inative or on generative methods. All systems use
manually labelled (seed) data for the initial training.
The system based on the edit distance method sub-
mitted by Jiampojamarn et al (2010) performs best
for the English/Russian task. Jiampojamarn et al
(2010) submitted another system based on a stan-
dard n-gram kernel which ranked first for the En-
glish/Hindi and English/Tamil tasks.6 For the En-
glish/Arabic task, the transliteration mining system
of Noeman and Madkour (2010) was best. They
normalize the English and Arabic characters in the
training data which increases the recall.7
Our transliteration extraction method differs in
that we extract transliteration pairs from a paral-
lel corpus without supervision. The results of the
NEWS10 experiments (Kumaran et al, 2010) show
that no single system performs well on all language
pairs. Our unsupervised method seems robust as its
performance is similar to or better than many of the
semi-supervised systems on three language pairs.
We are only aware of one previous work which
uses transliteration information for word alignment.
6They use the seed data as positive examples. In order to
obtain also negative examples, they generate all possible word
pairs from the source and target words in the seed data and ex-
tract the ones which are not transliterations but have a common
substring of some minimal length.
7They use the phrase table of Moses to build a mapping table
between source and target characters. The mapping table is then
used to construct a finite state transducer.
Hermjakob (2009) proposed a linguistically focused
word alignment system which uses many features
including hand-crafted transliteration rules for Ara-
bic/English alignment. His evaluation did not ex-
plicitly examine the effect of transliteration (alone)
on word alignment. We show that the integration
of a transliteration system based on unsupervised
transliteration mining increases the word alignment
quality for the two language pairs we tested.
6 Conclusion
We proposed a method to automatically extract
transliteration pairs from parallel corpora without
supervision or linguistic knowledge. We evaluated
it against the semi-supervised systems of NEWS10
and achieved high F-measure and performed bet-
ter than most of the semi-supervised systems. We
also evaluated our method on parallel corpora and
achieved high F-measure. We integrated the translit-
eration extraction module into the GIZA++ word
aligner and showed gains in alignment quality. We
will release our transliteration mining system and
word alignment system in the near future.
Acknowledgments
The authors wish to thank the anonymous re-
viewers for their comments. We would like to
thank Christina Lioma for her valuable feedback
on an earlier draft of this paper. Hassan Sajjad
was funded by the Higher Education Commission
(HEC) of Pakistan. Alexander Fraser was funded
by Deutsche Forschungsgemeinschaft grant Models
of Morphosyntax for Statistical Machine Transla-
tion. Helmut Schmid was supported by Deutsche
Forschungsgemeinschaft grant SFB 732.
References
Maximilian Bisani and Hermann Ney. 2008. Joint-
sequence models for grapheme-to-phoneme conver-
sion. Speech Communication, 50(5).
Peter F. Brown, Stephen A. Della Pietra, Vincent J. Della
Pietra, and R. L. Mercer. 1993. The mathematics of
statistical machine translation: parameter estimation.
Computational Linguistics, 19(2):263?311.
Kareem Darwish. 2010. Transliteration mining with
phonetic conflation and iterative training. In Proceed-
ings of the 2010 Named Entities Workshop, Uppsala,
Sweden. Association for Computational Linguistics.
438
Andreas Eisele and Yu Chen. 2010. MultiUN: A multi-
lingual corpus from United Nation documents. In Pro-
ceedings of the Seventh conference on International
Language Resources and Evaluation (LREC?10), Val-
letta, Malta.
Qin Gao and Stephan Vogel. 2008. Parallel implemen-
tations of word alignment tool. In Software Engineer-
ing, Testing, and Quality Assurance for Natural Lan-
guage Processing, Columbus, Ohio, June. Association
for Computational Linguistics.
Ulf Hermjakob. 2009. Improved word alignment with
statistics and linguistic heuristics. In Proceedings of
the 2009 Conference on Empirical Methods in Natural
Language Processing: Volume 1 - Volume 1, EMNLP
?09, Morristown, NJ, USA. Association for Computa-
tional Linguistics.
Sittichai Jiampojamarn, Kenneth Dwyer, Shane Bergsma,
Aditya Bhargava, Qing Dou, Mi-Young Kim, and
Grzegorz Kondrak. 2010. Transliteration generation
and mining with limited training resources. In Pro-
ceedings of the 2010 Named Entities Workshop, Upp-
sala, Sweden. Association for Computational Linguis-
tics.
Alexandre Klementiev and Dan Roth. 2006. Weakly
supervised named entity transliteration and discovery
from multilingual comparable corpora. In Proceed-
ings of the 21st International Conference on Compu-
tational Linguistics and the 44th annual meeting of the
ACL, Morristown, NJ, USA.
Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proceedings of
the Human Language Technology and North Ameri-
can Association for Computational Linguistics Con-
ference, pages 127?133, Edmonton, Canada.
A Kumaran, Mitesh M. Khapra, and Haizhou Li. 2010.
Whitepaper of news 2010 shared task on translitera-
tion mining. In Proceedings of the 2010 Named En-
tities Workshop the 48th Annual Meeting of the ACL,
Uppsala, Sweden.
Chun-Jen Lee and Jason S. Chang. 2003. Acqui-
sition of English-Chinese transliterated word pairs
from parallel-aligned texts using a statistical machine
transliteration model. In Proceedings of the HLT-
NAACL 2003Workshop on Building and using parallel
texts, Morristown, NJ, USA. ACL.
Joel Martin, Rada Mihalcea, and Ted Pedersen. 2005.
Word alignment for languages with scarce resources.
In ParaText ?05: Proceedings of the ACL Workshop
on Building and Using Parallel Texts, Morristown, NJ,
USA. Association for Computational Linguistics.
Sara Noeman and Amgad Madkour. 2010. Language
independent transliteration mining system using finite
state automata framework. In Proceedings of the 2010
Named Entities Workshop, Uppsala, Sweden. Associ-
ation for Computational Linguistics.
Franz J. Och and Hermann Ney. 2003. A systematic
comparison of various statistical alignment models.
Computational Linguistics, 29(1):19?51.
Tarek Sherif and Grzegorz Kondrak. 2007. Boot-
strapping a stochastic transducer for Arabic-English
transliteration extraction. In ACL, Prague, Czech Re-
public.
Richard Sproat, Tao Tao, and ChengXiang Zhai. 2006.
Named entity transliteration with comparable corpora.
In ACL.
Andreas Stolcke. 2002. SRILM - an extensible language
modeling toolkit. In Intl. Conf. Spoken Language Pro-
cessing, Denver, Colorado.
Tao Tao, Su-Yoon Yoon, Andrew Fister, Richard Sproat,
and ChengXiang Zhai. 2006. Unsupervised named
entity transliteration using temporal and phonetic
correlation. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing
(EMNLP), Sydney.
Stephan Vogel, Hermann Ney, and Christoph Tillmann.
1996. HMM-based word alignment in statistical trans-
lation. In 16th International Conference on Computa-
tional Linguistics, pages 836?841, Copenhagen, Den-
mark.
Su-Youn Yoon, Kyoung-Young Kim, and Richard Sproat.
2007. Multilingual transliteration using feature based
phonetic method. In Proceedings of the 45th Annual
Meeting of the ACL, Prague, Czech Republic.
439
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 469?477,
Jeju, Republic of Korea, 8-14 July 2012. c?2012 Association for Computational Linguistics
A Statistical Model for Unsupervised and Semi-supervised Transliteration
Mining
Hassan Sajjad Alexander Fraser Helmut Schmid
Institute for Natural Language Processing
University of Stuttgart
{sajjad,fraser,schmid}@ims.uni-stuttgart.de
Abstract
We propose a novel model to automatically
extract transliteration pairs from parallel cor-
pora. Our model is efficient, language pair
independent and mines transliteration pairs in
a consistent fashion in both unsupervised and
semi-supervised settings. We model transliter-
ation mining as an interpolation of translitera-
tion and non-transliteration sub-models. We
evaluate on NEWS 2010 shared task data and
on parallel corpora with competitive results.
1 Introduction
Transliteration mining is the extraction of translit-
eration pairs from unlabelled data. Most transliter-
ation mining systems are built using labelled train-
ing data or using heuristics to extract transliteration
pairs. These systems are language pair dependent or
require labelled information for training. Our sys-
tem extracts transliteration pairs in an unsupervised
fashion. It is also able to utilize labelled information
if available, obtaining improved performance.
We present a novel model of transliteration min-
ing defined as a mixture of a transliteration model
and a non-transliteration model. The transliteration
model is a joint source channel model (Li et al,
2004). The non-transliteration model assumes no
correlation between source and target word charac-
ters, and independently generates a source and a tar-
get word using two fixed unigram character models.
We use Expectation Maximization (EM) to learn pa-
rameters maximizing the likelihood of the interpola-
tion of both sub-models. At test time, we label word
pairs as transliterations if they have a higher proba-
bility assigned by the transliteration sub-model than
by the non-transliteration sub-model.
We extend the unsupervised system to a semi-
supervised system by adding a new S-step to the
EM algorithm. The S-step takes the probability es-
timates from unlabelled data (computed in the M-
step) and uses them as a backoff distribution to
smooth probabilities which were estimated from la-
belled data. The smoothed probabilities are then
used in the next E-step. In this way, the parame-
ters learned by EM are constrained to values which
are close to those estimated from the labelled data.
We evaluate our unsupervised and semi-
supervised transliteration mining system on the
datasets available from the NEWS 2010 shared task
on transliteration mining (Kumaran et al, 2010b).
We call this task NEWS10 later on. Compared with
a baseline unsupervised system our unsupervised
system achieves up to 5% better F-measure. On
the NEWS10 dataset, our unsupervised system
achieves an F-measure of up to 95.7%, and on three
language pairs, it performs better than all systems
which participated in NEWS10. We also evaluate
our semi-supervised system which additionally uses
the NEWS10 labelled data for training. It achieves
an improvement of up to 3.7% F-measure over our
unsupervised system. Additional experiments on
parallel corpora show that we are able to effectively
mine transliteration pairs from very noisy data.
The paper is organized as follows. Section 2 de-
scribes previous work. Sections 3 and 4 define our
unsupervised and semi-supervised models. Section
5 presents the evaluation. Section 6 concludes.
469
2 Previous Work
We first discuss the literature on semi-supervised
and supervised techniques for transliteration min-
ing and then describe a previously defined unsuper-
vised system. Supervised and semi-supervised sys-
tems use a manually labelled set of training data to
learn character mappings between source and tar-
get strings. The labelled training data either con-
sists of a few hundred transliteration pairs or of
just a few carefully selected transliteration pairs.
The NEWS 2010 shared task on transliteration min-
ing (NEWS10) (Kumaran et al, 2010b) is a semi-
supervised task conducted on Wikipedia InterLan-
guage Links (WIL) data. The NEWS10 dataset con-
tains 1000 labelled examples (called the ?seed data?)
for initial training. All systems which participated
in the NEWS10 shared task are either supervised or
semi-supervised. They are described in (Kumaran
et al, 2010a). Our transliteration mining model
can mine transliterations without using any labelled
data. However, if there is some labelled data avail-
able, our system is able to use it effectively.
The transliteration mining systems evaluated on
the NEWS10 dataset generally used heuristic meth-
ods, discriminative models or generative models for
transliteration mining (Kumaran et al, 2010a).
The heuristic-based system of Jiampojamarn et
al. (2010) is based on the edit distance method
which scores the similarity between source and tar-
get words. They presented two discriminative meth-
ods ? an SVM-based classifier and alignment-based
string similarity for transliteration mining. These
methods model the conditional probability distribu-
tion and require supervised/semi-supervised infor-
mation for learning. We propose a flexible genera-
tive model for transliteration mining usable for both
unsupervised and semi-supervised learning.
Previous work on generative approaches uses
Hidden Markov Models (Nabende, 2010; Darwish,
2010; Jiampojamarn et al, 2010), Finite State Au-
tomata (Noeman and Madkour, 2010) and Bayesian
learning (Kahki et al, 2011) to learn transliteration
pairs from labelled data. Our method is different
from theirs as our generative story explains the un-
labelled data using a combination of a transliteration
and a non-transliteration sub-model. The translit-
eration model jointly generates source and target
strings, whereas the non-transliteration system gen-
erates them independently of each other.
Sajjad et al (2011) proposed a heuristic-based un-
supervised transliteration mining system. We later
call it Sajjad11. It is the only unsupervised mining
system that was evaluated on the NEWS10 dataset
up until now, as far as we know. That system is com-
putationally expensive. We show in Section 5 that its
runtime is much higher than that of our system.
In this paper, we propose a novel model-based
approach to transliteration mining. Our approach
is language pair independent ? at least for alpha-
betic languages ? and efficient. Unlike the pre-
vious unsupervised system, and unlike the super-
vised and semi-supervised systems we mentioned,
our model can be used for both unsupervised and
semi-supervised mining in a consistent way.
3 Unsupervised Transliteration Mining
Model
A source word and its corresponding target word can
be character-aligned in many ways. We refer to a
possible alignment sequence which aligns a source
word e and a target word f as ?a?. The function
Align(e, f) returns the set of all valid alignment se-
quences a of a word pair (e, f). The joint transliter-
ation probability p1(e, f) of a word pair is the sum
of the probabilities of all alignment sequences:
p1(e, f) =
?
a?Align(e,f)
p(a) (1)
Transliteration systems are trained on a list of
transliteration pairs. The alignment between the
transliteration pairs is learned with Expectation
Maximization (EM). We use a simple unigram
model, so an alignment sequence from function
Align(e, f) is a combination of 0?1, 1?1, and 1?
0 character alignments between a source word e and
its transliteration f . We refer to a character align-
ment unit as ?multigram? later on and represent it
by the symbol ?q?. A sequence of multigrams forms
an alignment of a source and target word. The prob-
ability of a sequence of multigrams a is the product
of the probabilities of the multigrams it contains.
p(a) = p(q1, q2, ..., q|a|) =
|a|?
j=1
p(qj) (2)
470
While transliteration systems are trained on a
clean list of transliteration pairs, our translitera-
tion mining system has to learn from data con-
taining both transliterations and non-transliterations.
The transliteration model p1(e, f) handles only the
transliteration pairs. We propose a second model
p2(e, f) to deal with non-transliteration pairs (the
?non-transliteration model?). Interpolation with the
non-transliteration model allows the transliteration
model to concentrate on modelling transliterations
during EM training. After EM training, transliter-
ation word pairs are assigned a high probability by
the transliteration submodel and a low probability by
the non-transliteration submodel, and vice versa for
non-transliteration pairs. This property is exploited
to identify transliterations.
In a non-transliteration word pair, the characters
of the source and target words are unrelated. We
model them as randomly seeing a source word and a
target word together. The non-transliteration model
uses random generation of characters from two uni-
gram models. It is defined as follows:
p2(e, f) = pE(e) pF (f) (3)
pE(e) =
?|e|
i=1 pE(ei) and pF (f) =
?|f |
i=1 pF (fi).
The transliteration mining model is an interpo-
lation of the transliteration model p1(e, f) and the
non-transliteration model p2(e, f):
p(e, f) = (1? ?)p1(e, f) + ?p2(e, f) (4)
? is the prior probability of non-transliteration.
3.1 Model Estimation
In this section, we discuss the estimation of the pa-
rameters of the transliteration model p1(e, f) and the
non-transliteration model p2(e, f).
The non-transliteration model consists of two un-
igram character models. Their parameters are esti-
mated from the source and target words of the train-
ing data, respectively, and the parameters do not
change during EM training.
For the transliteration model, we implement a
simplified form of the grapheme-to-phoneme con-
verter, g2p (Bisani and Ney, 2008). In the follow-
ing, we use notations from Bisani and Ney (2008).
g2p learns m-to-n character alignments between a
source and a target word. We restrict ourselves to
0?1,1?1,1?0 character alignments and to a unigram
model.1 The Expectation Maximization (EM) algo-
rithm is used to train the model. It maximizes the
likelihood of the training data. In the E-step the EM
algorithm computes expected counts for the multi-
grams and in the M-step the multigram probabilities
are reestimated from these counts. These two steps
are iterated. For the first EM iteration, the multigram
probabilities are initialized with a uniform distribu-
tion and ? is set to 0.5.
The expected count of a multigram q (E-step) is
computed by multiplying the posterior probability
of each alignment a with the frequency of q in a and
summing these weighted frequencies over all align-
ments of all word pairs.
c(q) =
N?
i=1
?
a?Align(ei,fi)
(1? ?)p1(a, ei, fi)
p(ei, fi)
nq(a)
nq(a) is here the number of times the multigram q
occurs in the sequence a and p(ei, fi) is defined in
Equation 4. The new estimate of the probability of a
multigram is given by:
p(q) =
c(q)
?
q? c(q
?)
(5)
Likewise, we calculate the expected count of non-
transliterations by summing the posterior probabili-
ties of non-transliteration given each word pair:
cntr =
N?
i=1
pntr(ei, fi) =
N?
i=1
?p2(ei, fi)
p(ei, fi)
(6)
? is then reestimated by dividing the expected count
of non-transliterations by N .
3.2 Implementation Details
We use the Forward-Backward algorithm to estimate
the counts of multigrams. The algorithm has a for-
ward variable? and a backward variable ? which are
calculated in the standard way (Deligne and Bimbot,
1995). Consider a node r which is connected with
a node s via an arc labelled with the multigram q.
The expected count of a transition between r and s
is calculated using the forward and backward prob-
abilities as follows:
??rs =
?(r) p(q) ?(s)
?(E)
(7)
1In preliminary experiments, using an n-gram order of
greater than one or more than one character on the source side or
the target side or both sides of the multigram caused the translit-
eration model to incorrectly learn non-transliteration informa-
tion from the training data.
471
where E is the final node of the graph.
We multiply the expected count of a transition
by the posterior probability of transliteration (1 ?
pntr(e, f)) which indicates how likely the string pair
is to be a transliteration. The counts ?rs are then
summed for all multigram types q over all training
pairs to obtain the frequencies c(q) which are used
to reestimate the multigram probabilities according
to Equation 5.
4 Semi-supervised Transliteration Mining
Model
Our unsupervised transliteration mining system can
be applied to language pairs for which no labelled
data is available. However, the unsupervised sys-
tem is focused on high recall and also mines close
transliterations (see Section 5 for details). In a task
dependent scenario, it is difficult for the unsuper-
vised system to mine transliteration pairs according
to the details of a particular definition of what is con-
sidered a transliteration (which may vary somewhat
with the task). In this section, we propose an exten-
sion of our unsupervised model which overcomes
this shortcoming by using labelled data. The idea
is to rely on probabilities from labelled data where
they can be estimated reliably and to use probabili-
ties from unlabelled data where the labelled data is
sparse. This is achieved by smoothing the labelled
data probabilities using the unlabelled data probabil-
ities as a backoff.
4.1 Model Estimation
We calculate the unlabelled data probabilities in the
E-step using Equation 4. For labelled data (contain-
ing only transliterations) we set ? = 0 and get:
p(e, f) =
?
a?Align(e,f)
p1(e, f, a) (8)
In every EM iteration, we smooth the probability
distribution in such a way that the estimates of the
multigrams of the unlabelled data that do not occur
in the labelled data would be penalized. We obtain
this effect by smoothing the probability distribution
of unlabelled and labelled data using a technique
similar to Witten-Bell smoothing (Witten and Bell,
1991), as we describe below.
Figure 1: Semi-supervised training
4.2 Implementation Details
We divide the training process of semi-supervised
mining in two steps as shown in Figure 1. The first
step creates a reasonable alignment of the labelled
data from which multigram counts can be obtained.
The labelled data is a small list of transliteration
pairs. Therefore we use the unlabelled data to help
correctly align it and train our unsupervised min-
ing system on the combined labelled and unlabelled
training data. In the expectation step, the prior prob-
ability of non-transliteration ? is set to zero on the
labelled data since it contains only transliterations.
The first step passes the resulting multigram proba-
bility distribution to the second step.
We start the second step with the probability es-
timates from the first step and run the E-step sepa-
rately on labelled and unlabelled data. The E-step
on the labelled data is done using Equation 8, which
forces the posterior probability of non-transliteration
to zero, while the E-step on the unlabelled data uses
Equation 4. After the two E-steps, we estimate
a probability distribution from the counts obtained
from the unlabelled data (M-step) and use it as a
backoff distribution in computing smoothed proba-
bilities from the labelled data counts (S-step).
The smoothed probability estimate p?(q) is:
p?(q) =
cs(q) + ?sp(q)
Ns + ?s
(9)
where cs(q) is the labelled data count of the multi-
gram q, p(q) is the unlabelled data probability es-
timate, and Ns =
?
q cs(q), and ?s is the number
of different multigram types observed in the Viterbi
alignment of the labelled data.
472
5 Evaluation
We evaluate our unsupervised system and semi-
supervised system on two tasks, NEWS10 and paral-
lel corpora. NEWS10 is a standard task on translit-
eration mining from WIL. On NEWS10, we com-
pare our results with the unsupervised mining sys-
tem of Sajjad et al (2011), the best supervised
and semi-supervised systems presented at NEWS10
(Kumaran et al, 2010b) and the best supervised and
semi-supervised results reported in the literature for
the NEWS10 task. For the challenging task of min-
ing from parallel corpora, we use the English/Hindi
and English/Arabic gold standard provided by Saj-
jad et al (2011) to evaluate our results.
5.1 Experiments using the NEWS10 Dataset
We conduct experiments on four language pairs: En-
glish/Arabic, English/Hindi, English/Tamil and En-
glish/Russian using data provided at NEWS10. Ev-
ery dataset contains training data, seed data and ref-
erence data. The NEWS10 data consists of pairs of
titles of the same Wikipedia pages written in dif-
ferent languages, which may be transliterations or
translations. The seed data is a list of 1000 transliter-
ation pairs provided to semi-supervised systems for
initial training. We use the seed data only in our
semi-supervised system, and not in the unsupervised
system. The reference data is a small subset of the
training data which is manually annotated with pos-
itive and negative examples.
5.1.1 Training
We word-aligned the parallel phrases of the train-
ing data using GIZA++ (Och and Ney, 2003), and
symmetrized the alignments using the grow-diag-
final-and heuristic (Koehn et al, 2003). We extract
all word pairs which occur as 1-to-1 alignments (like
Sajjad et al (2011)) and later refer to them as the
word-aligned list. We compared the word-aligned
list with the NEWS10 reference data and found that
the word-aligned list is missing some transliteration
pairs because of word-alignment errors. We built an-
other list by adding a word pair for every source
word that cooccurs with a target word in a paral-
lel phrase/sentence and call it the cross-product list
later on. The cross-product list is noisier but con-
tains almost all transliteration pairs in the corpus.
Word-aligned Cross-product
P R F P R F
EA 27.8 97.1 43.3 14.3 98.0 25.0
EH 42.5 98.7 59.4 20.5 99.6 34.1
ET 32.0 98.1 48.3 17.2 99.6 29.3
ER 25.5 95.6 40.3 12.8 99.0 22.7
Table 1: Statistics of word-aligned and cross-product
list calculated from the NEWS10 dataset, before min-
ing. EA is English/Arabic, EH is English/Hindi, ET is
English/Tamil and ER is English/Russian
Table 1 shows the statistics of the word-aligned
list and the cross-product list calculated using the
NEWS10 reference data.2 The word-aligned list cal-
culated from the NEWS10 dataset is used to com-
pare our unsupervised system with the unsupervised
system of Sajjad et al (2011) on the same training
data. All the other experiments on NEWS10 use
cross-product lists. We remove numbers from both
lists as they are defined as non-transliterations (Ku-
maran et al, 2010b).
5.1.2 Unsupervised Transliteration Mining
We run our unsupervised transliteration mining
system on the word-aligned list and the cross-
product list. The word pairs with a posterior prob-
ability of transliteration 1 ? pntr(e, f) = 1 ?
?p2(ei, fi)/p(ei, fi) greater than 0.5 are selected as
transliteration pairs.
We compare our unsupervised system with the
unsupervised system of Sajjad11. Our unsupervised
system trained on the word-aligned list shows F-
measures of 91.7%, 95.5%, 92.9% and 77.7% which
is 4.3%, 3.3%, 2.8% and 1.7% better than the sys-
tem of Sajjad11 on English/Arabic, English/Hindi,
English/Tamil and English/Russian respectively.
Sajjad11 is computationally expensive. For in-
stance, a phrase-based statistical MT system is
built once in every iteration of the heuristic proce-
dure. We ran Sajjad11 on the English/Russian word-
aligned list using a 2.4 GHz Dual-Core AMD ma-
chine, which took almost 10 days. On the same ma-
chine, our transliteration mining system only takes
1.5 hours to finish the same experiment.
2Due to inconsistent word definition used in the reference
data, we did not achieve 100% recall in our cross-product list.
For example, the underscore is defined as a word boundary for
English WIL phrases. This assumption is not followed for cer-
tain phrases like ?New York? and ?New Mexico?.
473
Unsupervised Semi-supervised/Supervised
SJD OU OS SBest GR DBN
EA 87.4 92.4 92.7 91.5 94.1 -
EH 92.2 95.7 96.3 94.4 93.2 95.5
ET 90.1 93.2 94.6 91.4 95.5 93.9
ER 76.0 79.4 83.1 87.5 92.3 82.5
Table 2: F-measure results on NEWS10 datasets where
SJD is the unsupervised system of Sajjad11, OU is
our unsupervised system built on the cross-product list,
OS is our semi-supervised system, SBest is the best
NEWS10 system, GR is the supervised system of Kahki
et al (2011) and DBN is the semi-supervised system of
Nabende (2011)
Our unsupervised mining system built on the
cross-product list consistently outperforms the one
built on the word-aligned list. Later, we consider
only the system built on the cross-product list. Ta-
ble 2 shows the results of our unsupervised sys-
tem OU in comparison with the unsupervised sys-
tem of Sajjad11 (SJD), the best semi-supervised sys-
tems presented at NEWS10 (SBEST ) and the best
semi-supervised results reported on the NEWS10
dataset (GR, DBN ). On three language pairs, our
unsupervised system performs better than all semi-
supervised systems which participated in NEWS10.
It has competitive results with the best supervised
results reported on NEWS10 datasets. On En-
glish/Hindi, our unsupervised system outperforms
the state-of-the-art supervised and semi-supervised
systems. Kahki et al (2011) (GR) achieved
the best results on English/Arabic, English/Tamil
and English/Russian. For the English/Arabic task,
they normalized the data using language dependent
heuristics3 and also used a non-standard evaluation
method (discussed in Section 5.1.4).
On the English/Russian dataset, our unsupervised
system faces the problem that it extracts cognates
as transliterations. The same problem was reported
in Sajjad et al (2011). Cognates are close translit-
erations which differ by only one or two characters
from an exact transliteration pair. The unsupervised
system learns to delete the additional one or two
characters with a high probability and incorrectly
mines such word pairs as transliterations.
3They applied an Arabic word segmenter which uses lan-
guage dependent information. Arabic long vowels which have
identical sound but are written differently were merged to one
form. English characters were normalized by dropping accents.
Unsupervised Semi-supervised
P R F P R F
EA 89.2 95.7 92.4 92.9 92.4 92.7
EH 92.6 99.0 95.7 95.5 97.0 96.3
ET 88.3 98.6 93.2 93.4 95.8 94.6
ER 67.2 97.1 79.4 74.0 94.9 83.1
Table 3: Precision(P), Recall(R) and F-measure(F) of our
unsupervised and semi-supervised transliteration mining
systems on NEWS10 datasets
5.1.3 Semi-supervised Transliteration Mining
Our semi-supervised system uses similar initial-
ization of the parameters as used for unsupervised
system. Table 2 shows on three language pairs, our
semi-supervised system OS only achieves a small
gain in F-measure over our unsupervised system
OU . This shows that the unlabelled training data is
already providing most of the transliteration infor-
mation. The seed data is used to help the translit-
eration mining system to learn the right definition
of transliteration. On the English/Russian dataset,
our semi-supervised system achieves almost 7% in-
crease in precision with a 2.2% drop in recall com-
pared to our unsupervised system. This provides a
3.7% gain on F-measure. The increase in precision
shows that the seed data is helping the system in dis-
ambiguating transliteration pairs from cognates.
5.1.4 Discussion
The unsupervised system produces lists with high
recall. The semi-supervised system tends to better
balance out precision and recall. Table 3 compares
the precision, recall and F-measure of our unsuper-
vised and semi-supervised mining systems.
The errors made by our semi-supervised system
can be classified into the following categories:
Pronunciation differences: English proper
names may be pronounced differently in other lan-
guages. Sometimes, English short vowels are con-
verted to long vowels in Hindi such as the English
word ?Lanthanum? which is pronounced ?Laan-
thanum? in Hindi. Our transliteration mining system
wrongly extracts such pairs as transliterations.
In some cases, different vowels are used in two
languages. The English word ?January? is pro-
nounced as ?Janvary? in Hindi. Such word pairs are
non-transliterations according to the gold standard
but our system extracts them as transliterations. Ta-
474
Table 4: Word pairs with pronunciation differences
Table 5: Examples of word pairs which are wrongly an-
notated as transliterations in the gold standard
ble 4 shows a few examples of such word pairs.
Inconsistencies in the gold standard: There are
several inconsistencies in the gold standard where
our transliteration system correctly identifies a word
pair as a transliteration but it is marked as a non-
transliteration or vice versa. Consider the example
of the English word ?George? which is pronounced
as ?Jaarj? in Hindi. Our semi-supervised system
learns this as a non-transliteration but it is wrongly
annotated as a transliteration in the gold standard.
Arabic nouns have an article ?al? attached to them
which is translated in English as ?the?. There are
various cases in the training data where an English
noun such as ?Quran? is matched with an Arabic
noun ?alQuran?. Our mining system classifies such
cases as non-transliterations, but 24 of them are in-
correctly annotated as transliterations in the gold
standard. We did not correct this, and are there-
fore penalized. Kahki et al (2011) preprocessed
such Arabic words and separated ?al? from the noun
?Quran? before mining. They report a match if the
version of the Arabic word with ?al? appears with
the corresponding English word in the gold stan-
dard. Table 5 shows examples of word pairs which
are wrongly annotated as transliterations.
Cognates: Sometimes a word pair differs by only
one or two ending characters from a true translit-
eration. For example in the English/Russian train-
ing data, the Russian nouns are marked with cases
whereas their English counterparts do not mark the
case or translate it as a separate word. Often the
Russian word differs only by the last character from
a correct transliteration of the English word. Due
to the large amount of such word pairs in the En-
glish/Russian data, our mining system learns to
delete the final case marking characters from the
Russian words. It assigns a high transliteration prob-
Table 6: A few examples of English/Russian cognates
ability to these word pairs and extracts them as
transliterations. Table 6 shows some examples.
There are two English/Russian supervised sys-
tems which are better than our semi-supervised sys-
tem. The Kahki et al (2011) system is built on seed
data only. Jiampojamarn et al (2010)?s best sys-
tem on English/Russian is based on the edit distance
method. Both of these systems are focused on high
precision. Our semi-supervised system is focused
on high recall at the cost of lower precision.4
5.2 Transliteration Mining using Parallel
Corpora
The percentage of transliteration pairs in the
NEWS10 datasets is high. We further check the ef-
fectiveness of our unsupervised and semi-supervised
mining systems by evaluating them on parallel cor-
pora with as few as 2% transliteration pairs.
We conduct experiments using two language
pairs, English/Hindi and English/Arabic. The En-
glish/Hindi corpus is from the shared task on word
alignment organized as part of the ACL 2005 Work-
shop on Building and Using Parallel Texts (WA05)
(Martin et al, 2005). For English/Arabic, we use
200,000 parallel sentences from the United Nations
(UN) corpus (Eisele and Chen, 2010). The En-
glish/Hindi and English/Arabic transliteration gold
standards were provided by Sajjad et al (2011).
5.2.1 Experiments
We follow the procedure for creating the training
data described in Section 5.1.1 and build a word-
aligned list and a cross-product list from the parallel
corpus. We first train and test our unsupervised min-
ing system on the word-aligned list and compare our
results with Sajjad et al Table 7 shows the results.
Our unsupervised system achieves 0.6% and 1.8%
higher F-measure than Sajjad et al respectively.
The cross-product list is huge in comparison to
the word-aligned list. It is noisier than the word-
4We implemented a bigram version of our system to learn
the contextual information at the end of the word pairs, but only
achieved a gain of less than 1% F-measure over our unigram
semi-supervised system. Details are omitted due to space.
475
TP FN TN FP P R F
EHSJD 170 10 2039 45 79.1 94.4 86.1
EHO 176 4 2034 50 77.9 97.8 86.7
EASJD 197 91 6580 59 77.0 68.4 72.5
EAO 288 0 6440 199 59.1 100 74.3
Table 7: Transliteration mining results of our unsuper-
vised system and Sajjad11 system trained and tested
on the word-aligned list of English/Hindi and En-
glish/Arabic parallel corpus
TP FN TN FP P R F
EHU 393 19 12279 129 75.3 95.4 84.2
EHS 365 47 12340 68 84.3 88.6 86.4
EAU 277 11 6444 195 58.7 96.2 72.9
EAS 272 16 6497 142 65.7 94.4 77.5
Table 8: Transliteration mining results of our unsuper-
vised and semi-supervised systems trained on the word-
aligned list and tested on the cross-product list of En-
glish/Hindi and English/Arabic parallel corpus
aligned list but has almost 100% recall of transliter-
ation pairs. The English-Hindi cross-product list has
almost 55% more transliteration pairs (412 types)
than the word-aligned list (180 types). We can not
report these numbers on the English/Arabic cross-
product list since the English/Arabic gold standard
is built on the word-aligned list.
In order to keep the experiment computationally
inexpensive, we train our mining systems on the
word-aligned list and test them on the cross-product
list.5 We also perform the first semi-supervised eval-
uation on this task. For our semi-supervised sys-
tem, we additionally use the English/Hindi and En-
glish/Arabic seed data provided by NEWS10.
Table 8 shows the results of our unsupervised
and semi-supervised systems on the English/Hindi
and English/Arabic parallel corpora. Our unsu-
pervised system achieves higher recall than our
semi-supervised system but lower precision. The
semi-supervised system shows an improvement in
F-measure for both language pairs. We looked
into the errors made by our systems. The mined
transliteration pairs of our unsupervised system con-
tains 65 and 111 close transliterations for the En-
glish/Hindi and English/Arabic task respectively.
5There are some multigrams of the cross-product list which
are unknown to the model learned on the word-aligned list. We
define their probability as the inverse of the number of multi-
gram tokens in the Viterbi alignment of the labelled and unla-
belled data together.
The close transliterations only differ by one or two
characters from correct transliterations. We think
these pairs provide transliteration information to
the systems and help them to avoid problems with
data sparseness. Our semi-supervised system uses
the seed data to identify close transliterations as
non-transliterations and decreases the number of
false positives. They are reduced to 35 and 89
for English/Hindi and English/Arabic respectively.
The seed data and the training data used in the
semi-supervised system are from different domains
(Wikipedia and UN). Seed data extracted from the
same domain is likely to work better, resulting in
even higher scores than we have reported.
6 Conclusion and Future Work
We presented a novel model to automatically
mine transliteration pairs. Our approach is ef-
ficient and language pair independent (for alpha-
betic languages). Both the unsupervised and semi-
supervised systems achieve higher accuracy than the
only unsupervised transliteration mining system we
are aware of and are competitive with the state-
of-the-art supervised and semi-supervised systems.
Our semi-supervised system outperformed our un-
supervised system, in particular in the presence of
prevalent cognates in the Russian/English data.
In future work, we plan to adapt our approach
to language pairs where one language is alphabetic
and the other language is non-alphabetic such as En-
glish/Japanese. These language pairs require one-
to-many character mappings to learn transliteration
units, while our current system only learns unigram
character alignments.
Acknowledgments
The authors wish to thank the anonymous review-
ers. We would like to thank Syed Aoun Raza for
discussions of implementation efficiency. Hassan
Sajjad was funded by the Higher Education Com-
mission of Pakistan. Alexander Fraser was funded
by Deutsche Forschungsgemeinschaft grant Models
of Morphosyntax for Statistical Machine Transla-
tion. Helmut Schmid was supported by Deutsche
Forschungsgemeinschaft grant SFB 732. This work
was supported in part by the IST Programme of
the European Community, under the PASCAL2 Net-
work of Excellence, IST-2007-216886. This publi-
cation only reflects the authors? views.
476
References
Maximilian Bisani and Hermann Ney. 2008. Joint-
sequence models for grapheme-to-phoneme conver-
sion. Speech Communication, 50(5).
Kareem Darwish. 2010. Transliteration mining with
phonetic conflation and iterative training. In Proceed-
ings of the 2010 Named Entities Workshop, Uppsala,
Sweden.
Sabine Deligne and Fre?de?ric Bimbot. 1995. Language
modeling by variable length sequences : Theoreti-
cal formulation and evaluation of multigrams. In
Proceedings of the IEEE International Conference on
Acoustics, Speech, and Signal Processing, volume 1,
Los Alamitos, CA, USA.
Andreas Eisele and Yu Chen. 2010. MultiUN: A multi-
lingual corpus from United Nation documents. In Pro-
ceedings of the Seventh conference on International
Language Resources and Evaluation (LREC?10), Val-
letta, Malta.
Sittichai Jiampojamarn, Kenneth Dwyer, Shane Bergsma,
Aditya Bhargava, Qing Dou, Mi-Young Kim, and
Grzegorz Kondrak. 2010. Transliteration generation
and mining with limited training resources. In Pro-
ceedings of the 2010 Named Entities Workshop, Upp-
sala, Sweden.
Ali El Kahki, Kareem Darwish, Ahmed Saad El Din,
Mohamed Abd El-Wahab, Ahmed Hefny, and Waleed
Ammar. 2011. Improved transliteration mining using
graph reinforcement. In Proceedings of the Confer-
ence on Empirical Methods in Natural Language Pro-
cessing (EMNLP), Edinburgh, UK.
Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proceedings of
the Human Language Technology and North Ameri-
can Association for Computational Linguistics Con-
ference, Edmonton, Canada.
A Kumaran, Mitesh M. Khapra, and Haizhou Li. 2010a.
Report of NEWS 2010 transliteration mining shared
task. In Proceedings of the 2010 Named Entities Work-
shop, Uppsala, Sweden.
A Kumaran, Mitesh M. Khapra, and Haizhou Li. 2010b.
Whitepaper of NEWS 2010 shared task on translitera-
tion mining. In Proceedings of the 2010 Named Enti-
ties Workshop, Uppsala, Sweden.
Haizhou Li, Zhang Min, and Su Jian. 2004. A joint
source-channel model for machine transliteration. In
ACL ?04: Proceedings of the 42nd Annual Meeting on
Association for Computational Linguistics, Barcelona,
Spain.
Joel Martin, Rada Mihalcea, and Ted Pedersen. 2005.
Word alignment for languages with scarce resources.
In ParaText ?05: Proceedings of the ACL Workshop
on Building and Using Parallel Texts, Morristown, NJ,
USA.
Peter Nabende. 2010. Mining transliterations from
wikipedia using pair hmms. In Proceedings of the
2010 Named Entities Workshop, Uppsala, Sweden.
Peter Nabende. 2011. Mining transliterations from
Wikipedia using dynamic bayesian networks. In Pro-
ceedings of the International Conference Recent Ad-
vances in Natural Language Processing 2011, Hissar,
Bulgaria.
Sara Noeman and Amgad Madkour. 2010. Language
independent transliteration mining system using finite
state automata framework. In Proceedings of the 2010
Named Entities Workshop, Uppsala, Sweden.
Franz J. Och and Hermann Ney. 2003. A systematic
comparison of various statistical alignment models.
Computational Linguistics, 29(1).
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2011. An algorithm for unsupervised transliteration
mining with an application to word alignment. In Pro-
ceedings of the 49th Annual Conference of the Associ-
ation for Computational Linguistics, Portland, USA.
Ian H. Witten and Timothy C. Bell. 1991. The zero-
frequency problem: Estimating the probabilities of
novel events in adaptive text compression. In IEEE
Transactions on Information Theory, volume 37.
477
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 1?6,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
Translating Dialectal Arabic to English
Hassan Sajjad, Kareem Darwish
Qatar Computing Research Institute
Qatar Foundation
{hsajjad,kdarwish}@qf.org.qa
Yonatan Belinkov
CSAIL
Massachusetts Institute of Technology
belinkov@mit.edu
Abstract
We present a dialectal Egyptian Arabic
to English statistical machine translation
system that leverages dialectal to Modern
Standard Arabic (MSA) adaptation. In
contrast to previous work, we first nar-
row down the gap between Egyptian and
MSA by applying an automatic character-
level transformational model that changes
Egyptian to EG?, which looks simi-
lar to MSA. The transformations include
morphological, phonological and spelling
changes. The transformation reduces
the out-of-vocabulary (OOV) words from
5.2% to 2.6% and gives a gain of 1.87
BLEU points. Further, adapting large
MSA/English parallel data increases the
lexical coverage, reduces OOVs to 0.7%
and leads to an absolute BLEU improve-
ment of 2.73 points.
1 Introduction
Modern Standard Arabic (MSA) is the lingua
franca for the Arab world. Arabic speakers gen-
erally use dialects in daily interactions. There are
6 dominant dialects, namely Egyptian, Moroccan,
Levantine, Iraqi, Gulf, and Yemeni1. The dialects
may differ in vocabulary, morphology, syntax, and
spelling from MSA and most lack spelling con-
ventions.
Different dialects often make different lexical
choices to express concepts. For example, the con-
cept corresponding to ?Oryd? YK
P

@ (?I want?) is
expressed as ?EAwz? 	P?A? in Egyptian, ?Abgy?
?


	?K. @ in Gulf, ?Aby? ?
G. @ in Iraqi, and ?bdy? ?
 YK.
in Levantine2. Often, words have different or op-
posite meanings in different dialects.
1http://en.wikipedia.org/wiki/
Varieties_of_Arabic
2All transliterations follow the Buckwalter scheme
Arabic dialects may differ morphologically
from MSA. For example, Egyptian Arabic uses a
negation construct similar to the French ?ne pas?
negation construct. The Egyptian word ?mlEbt$?
?

J.??? (or alternatively spelled ?J.??A?) (?I did
not play?) is composed of ?m+lEbt+$?.
The pronunciations of letters often differ from
one dialect to another. For example, the letter ?q?

? is typically pronounced in MSA as an unvoiced
uvular stop (as the ?q? in ?quote?), but as a glot-
tal stop in Egyptian and Levantine (like ?A? in
?Alpine?) and a voiced velar stop in the Gulf (like
?g? in ?gavel?). Differing pronunciations often re-
flect on spelling.
Social media platforms allowed people to ex-
press themselves more freely in writing. Although
MSA is used in formal writing, dialects are in-
creasingly being used on social media sites. Some
notable trends on social platforms include (Dar-
wish et al, 2012):
- Mixed language texts where bilingual (or mul-
tilingual) users code switch between Arabic and
English (or Arabic and French). In the exam-
ple ?wSlny mrsy? ?


??Q? ?


	
???? (?got it thank
you?), ?thank you? is the transliterated French
word ?merci?.
? The use of phonetic transcription to match di-
alectal pronunciation. For example, ?Sdq? ?Y?
(?truth?) is often written as ?Sj? l .? in Gulf di-
alect.
? Creative spellings, spelling mistakes, and word
elongations are ubiquitous in social texts.
? The use of new words like ?lol? ??? (?LOL?).
? The attachment of new meanings to words such
as using ?THn? 	?j? to mean ?very? while it
means ?grinding? in MSA.
The Egyptian dialect has the largest number of
speakers and is the most commonly understood di-
alect in the Arab world. In this work, we focused
on translating dialectal Egyptian to English us-1
ing Egyptian to MSA adaptation. Unlike previous
work, we first narrowed the gap between Egyptian
and MSA using character-level transformations
and word n-gram models that handle spelling mis-
takes, phonological variations, and morphological
transformations. Later, we applied an adaptation
method to incorporate MSA/English parallel data.
The contributions of this paper are as follows:
? We trained an Egyptian/MSA transformation
model to make Egyptian look similar to MSA. We
publicly released the training data.
? We built a phrasal Machine Translation (MT)
system on adapted Egyptian/English parallel data,
which outperformed a non-adapted baseline by
1.87 BLEU points.
? We used phrase-table merging (Nakov and Ng,
2009) to utilize MSA/English parallel data with
the available in-domain parallel data.
2 Previous Work
Our work is related to research on MT from a re-
source poor language (to other languages) by piv-
oting on a closely related resource rich language.
This can be done by either translating between
the related languages using word-level translation,
character level transformations, and language spe-
cific rules (Durrani et al, 2010; Hajic? et al, 2000;
Nakov and Tiedemann, 2012), or by concatenating
the parallel data for both languages (Nakov and
Ng, 2009). These translation methods generally
require parallel data, for which hardly any exists
between dialects and MSA. Instead of translating
between a dialect and MSA, we tried to narrow
down the lexical, morphological and phonetic gap
between them using a character-level conversion
model, which we trained on a small set of parallel
dialect/MSA word pairs.
In the context of Arabic dialects3, most previous
work focused on converting dialects to MSA and
vice versa to improve the processing of dialects
(Sawaf, 2010; Chiang et al, 2006; Mohamed et
al., 2012; Utiyama and Isahara, 2008). Sawaf
(2010) proposed a dialect to MSA normalization
that used character-level rules and morphological
analysis. Salloum and Habash (2011) also used a
rule-based method to generate MSA paraphrases
of dialectal out-of-vocabulary (OOV) and low fre-
quency words. Instead of rules, we automatically
3Due to space limitations, we restrict discussion to work
on dialects only.
learnt character mappings from dialect/MSA word
pairs.
Zbib et al (2012) explored several methods for
dialect/English MT. Their best Egyptian/English
system was trained on dialect/English parallel
data. They used two language models built from
the English GigaWord corpus and from a large
web crawl. Their best system outperformed man-
ually translating Egyptian to MSA then translat-
ing using an MSA/English system. In contrast, we
showed that training on in-domain dialectal data
irrespective of its small size is better than training
on large MSA/English data. Our LM experiments
also affirmed the importance of in-domain English
LMs. We also showed that a conversion does not
imply a straight forward usage of MSA resources
and there is a need for adaptation which we ful-
filled using phrase-table merging (Nakov and Ng,
2009).
2.1 Baseline
We constructed baselines that were based on the
following training data:
- An Egyptian/English parallel corpus consist-
ing of ?38k sentences, which is part of the
LDC2012T09 corpus (Zbib et al, 2012). We ran-
domly divided it into 32k sentences for training,
2k for development and 4k for testing. We hence-
forth refer to this corpus as EG and the English
part of it as EGen. We did not have access to the
training/test splits of Zbib et al (2012) to directly
compare to their results.
- An MSA/English parallel corpus consisting of
200k sentences from LDC4. We refer to this cor-
pus as the AR corpus.
For language modeling, we used either EGen
or the English side of the AR corpus plus the En-
glish side of NIST12 training data and English Gi-
gaWord v5. We refer to this corpus as GW.
We tokenized Egyptian and Arabic accord-
ing to the ATB tokenization scheme using the
MADA+TOKAN morphological analyzer and to-
kenizer v3.1 (Roth et al, 2008). Word elonga-
tions were already fixed in the corpus. We word-
aligned the parallel data using GIZA++ (Och and
Ney, 2003), and symmetrized the alignments using
grow-diag-final-and heuristic (Koehn et al, 2003).
We trained a phrasal MT system (Koehn et al,
2003). We built five-gram LMs using KenLM
4Arabic News (LDC2004T17), eTIRR (LDC2004E72),
and parallel corpora the GALE program2
Train LM BLEU OOV
B1 AR GW 7.48 6.7
B2 EG GW 12.82 5.2
B3 EG EGen 13.94 5.2
B4 EG EGenGW 14.23 5.2
Table 1: Baseline results using the EG and AR
training sets with GW and EGen corpora for LM
training
with modified Kneser-Ney smoothing (Heafield,
2011). In case of more than one LM, we tuned
their weights on a development set using Mini-
mum Error Rate Training (Och and Ney, 2003).
We built several baseline systems as follows:
? B1 used AR for training a translation model and
GW for LM.
? B2-B4 systems used identical training data,
namely EG, with the GW, EGen, or both for B2,
B3, and B4 respectively for language modeling.
Table 1 reports the baseline results. The system
trained on AR (B1) performed poorly compared
to the one trained on EG (B2) with a 6.75 BLEU
points difference. This highlights the difference
between MSA and Egyptian. Using EG data for
training both the translation and language models
was effective. B4 used two LMs and yielded the
best results. For later comparison, we only use the
B4 baseline.
3 Proposed Methods
3.1 Egyptian to EG? Conversion
As mentioned previously, dialects differ from
MSA in vocabulary, morphology, and phonology.
Dialectal spelling often follows dialectal pronun-
ciation, and dialects lack standard spelling con-
ventions. To address the vocabulary problem, we
used the EG corpus for training.
To address the spelling and morphological dif-
ferences, we trained a character-level mapping
model to generate MSA words from dialectal
ones using character transformations. To train the
model, we extracted the most frequent words from
a dialectal Egyptian corpus, which had 12,527
news comments (containing 327k words) from Al-
Youm Al-Sabe news site (Zaidan and Callison-
Burch, 2011) and translated them to their equiv-
alent MSA words. We hired a professional trans-
lator, who generated one or more translations of
the most frequent 5,581 words into MSA. Out of
these word pairs, 4,162 involved character-level
transformations due to phonological, morphologi-
cal, or spelling changes. We aligned the translated
pairs at character level using GIZA++ and Moses
in the manner described in Section 2.1. As in the
baseline of Kahki et al (2011), given a source
word, we produced all of its possible segmenta-
tions along with their associated character-level
mappings. We restricted individual source char-
acter sequences to be 3 characters at most. We
retained all mapping sequences leading to valid
words in a large lexicon. We built the lexicon from
a set of 234,638 Aljazeera articles5 that span a 10
year period and contain 254M tokens. Spelling
mistakes in Aljazeera articles were very infre-
quent. We sorted the candidates by the product of
the constituent mapping probabilities and kept the
top 10 candidates. Then we used a trigram LM that
we built from the aforementioned Aljazeera arti-
cles to pick the most likely candidate in context.
We simply multiplied the character-level transfor-
mation probability with the LM probability ? giv-
ing them equal weight. Since Egyptian has a ?ne
pas? like negation construct that involves putting a
??? and ? ?? at the beginning and end of verbs,
we handled words that had negation by remov-
ing these two letters, then applying our character
transformation, and lastly adding the negation ar-
ticle ?lA? B before the verb. We converted theEG
train, tune, and test parts. We refer to the converted
corpus as EG?.
As an example, our system transformed
Yg ?. j. ?J
? ????jJ
K. ?


?

? @ ?. (?what is hap-
pening to them does not please anyone?) to
Yg I. j. ?K
 B ??? ??m
Proceedings of the Eighth Workshop on Statistical Machine Translation, pages 122?127,
Sofia, Bulgaria, August 8-9, 2013 c?2013 Association for Computational Linguistics
Munich-Edinburgh-Stuttgart Submissions of OSM Systems at WMT13
Nadir Durrani1, Helmut Schmid2, Alexander Fraser2,
Hassan Sajjad3, Richa?rd Farkas4
1University of Edinburgh ? dnadir@inf.ed.ac.uk
2Ludwig Maximilian University Munich ? schmid,fraser@cis.uni-muenchen.de
3Qatar Computing Research Institute ? hsajjad@qf.org.qa
4University of Szeged ? rfarkas@inf.u-szeged.hu
Abstract
This paper describes Munich-Edinburgh-
Stuttgart?s submissions to the Eighth
Workshop on Statistical Machine Transla-
tion. We report results of the translation
tasks from German, Spanish, Czech and
Russian into English and from English to
German, Spanish, Czech, French and Rus-
sian. The systems described in this paper
use OSM (Operation Sequence Model).
We explain different pre-/post-processing
steps that we carried out for different
language pairs. For German-English we
used constituent parsing for reordering
and compound splitting as preprocessing
steps. For Russian-English we transliter-
ated the unknown words. The translitera-
tion system is learned with the help of an
unsupervised transliteration mining algo-
rithm.
1 Introduction
In this paper we describe Munich-Edinburgh-
Stuttgart?s1 joint submissions to the Eighth Work-
shop on Statistical Machine Translation. We use
our in-house OSM decoder which is based on
the operation sequence N-gram model (Durrani
et al, 2011). The N-gram-based SMT frame-
work (Marin?o et al, 2006) memorizes Markov
chains over sequences of minimal translation units
(MTUs or tuples) composed of bilingual transla-
tion units. The OSM model integrates reordering
operations within the tuple sequences to form a
heterogeneous mixture of lexical translation and
1Qatar Computing Research Institute and University of
Szeged were partnered for RU-EN and DE-EN language pairs
respectively.
reordering operations and learns a Markov model
over a sequence of operations.
Our decoder uses the beam search algorithm in
a stack-based decoder like most sequence-based
SMT frameworks. Although the model is based
on minimal translation units, we use phrases dur-
ing search because they improve the search accu-
racy of our system. The earlier decoder (Durrani
et al, 2011) was based on minimal units. But we
recently showed that using phrases during search
gives better coverage of translation, better future
cost estimation and lesser search errors (Durrani
et al, 2013a) than MTU-based decoding. We have
therefore shifted to phrase-based search on top of
the OSM model.
This paper is organized as follows. Section 2
gives a short description of the model and search
as used in the OSM decoder. In Section 3 we
give a description of the POS-based operation se-
quence model that we test for our German-English
and English-German experiments. Section 4 de-
scribes our processing of the German and English
data for German-English and English-German ex-
periments. In Section 5 we describe the unsuper-
vised transliteration mining that has been done for
the Russian-English and English-Russian experi-
ments. In Section 6 we describe the sub-sampling
technique that we have used for several language
pairs. In Section 7 we describe the experimental
setup followed by the results. Finally we summa-
rize the paper in Section 8.
2 System Description
2.1 Model
Our systems are based on the OSM (Operation Se-
quence Model) that simultaneously learns trans-
lation and reordering by representing a bilingual
122
Figure 1: Bilingual Sentence with Alignments
sentence pair and its alignments as a unique se-
quence of operations. An operation either jointly
generates source and target words, or it performs
reordering by inserting gaps or jumping to gaps.
We then learn a Markov model over a sequence of
operations o1, o2, . . . , oJ that encapsulate MTUs
and reordering information as:
posm(o1, ..., oJ) =
J?
j=1
p(oj |oj?n+1, ..., oj?1)
By coupling reordering with lexical generation,
each (translation or reordering) decision depends
on n? 1 previous (translation and reordering) de-
cisions spanning across phrasal boundaries. The
reordering decisions therefore influence lexical se-
lection and vice versa. A heterogeneous mixture
of translation and reordering operations enables us
to memorize reordering patterns and lexicalized
triggers unlike the classic N-gram model where
translation and reordering are modeled separately.
2.2 Training
During training, each bilingual sentence pair is de-
terministically converted to a unique sequence of
operations.2 The example in Figure 1(a) is con-
verted to the following sequence of operations:
Generate(Beide, Both)? Generate(La?nder, coun-
tries)? Generate(haben, have)? Insert Gap?
Generate(investiert, invested)
At this point, the (partial) German and English
sentences look as follows:
Beide La?nder haben investiert
Both countries have invested
The translator then jumps back and covers the
skipped German words through the following se-
quence of operations:
Jump Back(1)?Generate(Millionen, millions)?
Generate(von, of)? Generate(Dollar, dollars)
2Please refer to Durrani et al (2011) for a list of opera-
tions and the conversion algorithm.
The generative story of the OSM model also
supports discontinuous source-side cepts and
source-word deletion. However, it doesn?t provide
a mechanism to deal with unaligned and discon-
tinuous target cepts. These are handled through
a 3-step process3 in which we modify the align-
ments to remove discontinuous and unaligned tar-
get MTUs. Please see Durrani et al (2011) for
details. After modifying the alignments, we con-
vert each bilingual sentence pair and its align-
ments into a sequence of operations as described
above and learn an OSM model. To this end,
a Kneser-Ney (Kneser and Ney, 1995) smoothed
9-gram model is trained with SRILM (Stolcke,
2002) while KenLM (Heafield, 2011) is used at
runtime.
2.3 Feature Functions
We use additional features for our model and em-
ploy the standard log-linear approach (Och and
Ney, 2004) to combine and tune them. We search
for a target string E which maximizes a linear
combination of feature functions:
E? = argmax
E
?
?
?
J?
j=1
?jhj(o1, ..., oJ)
?
?
?
where ?j is the weight associated with the fea-
ture hj(o1, ..., oj). Apart from the main OSM
feature we train 9 additional features: A target-
language model (see Section 7 for details), 2 lex-
ical weighting features, gap and open gap penalty
features, two distance-based distortion models and
2 length-based penalty features. Please refer to
Durrani et al (2011) for details.
2.4 Phrase Extraction
Phrases are extracted in the following way: The
aligned training corpus is first converted to an op-
eration sequence. Each subsequence of operations
that starts and ends with a translation operation, is
considered a ?phrase?. The translation operations
include Generate Source Only (X) operation which
deletes unaligned source word. Such phrases may
be discontinuous if they include reordering opera-
tions. We replace each subsequence of reordering
operations by a discontinuity marker.
3Durrani et al (2013b) recently showed that our post-
processing of alignments hurt the performance of the Moses
Phrase-based system in several language pairs. The solu-
tion they proposed has not been incorporated into the current
OSM decoder yet.
123
During decoding, we match the source tokens
of the phrase with the input. Whenever there is
a discontinuity in the phrase, the next source to-
ken can be matched at any position of the input
string. If there is no discontinuity marker, the next
source token in the phrase must be to the right of
the previous one. Finally we compute the number
of uncovered input tokens within the source span
of the hypothesized phrase and reject the phrase
if the number is above a threshold. We use a
threshold value of 2 which had worked well in
initial experiments. Once the positions of all the
source words of a phrase are known, we can com-
pute the necessary reordering operations (which
may be different from the ones that appeared in
the training corpus). This usage of phrases al-
lows the decoder to generalize from a seen trans-
lation ?scored a goal ? ein Tor schoss? (where
scored/a/goal and schoss/ein/Tor are aligned, re-
spectively) to ?scored a goal ? schoss ein Tor?.
The phrase can even be used to translate ?er schoss
heute ein Tor ? he scored a goal today? although
?heute? appears within the source span of the
phrase ?ein Tor schoss?. Without phrase-based
decoding, the unusual word translations ?schoss?
scored? and ?Tor?goal? (at least outside of the soc-
cer literature) are likely to be pruned.
The phrase tables are further filtered with
threshold pruning. The translation options with
a frequency less than x times the frequency of
the most frequent translation are deleted. We use
x = 0.02. We use additional settings to increase
this threshold for longer phrases. The phrase fil-
tering heuristic was used to speed up decoding. It
did not lower the BLEU score in our small scale
experiments (Durrani et al, 2013a), however we
could not test whether this result holds in a large
scale evaluation.
2.5 Decoder
The decoding framework used in the operation se-
quence model is based on Pharaoh (Koehn, 2004).
The decoder uses beam search to build up the
translation from left to right. The hypotheses are
arranged in m stacks such that stack i maintains
hypotheses that have already translated imany for-
eign words. The ultimate goal is to find the best
scoring hypothesis, that translates all the words
in the foreign sentence. During the hypothesis
extension each extracted phrase is translated into
a sequence of operations. The reordering opera-
tions (gaps and jumps) are generated by looking at
the position of the translator, the last foreign word
generated etc. (Please refer to Algorithm 1 in Dur-
rani et al (2011)). The probability of an opera-
tion depends on the n?1 previous operations. The
model is smoothed with Kneser-Ney smoothing.
3 POS-based OSM Model
Part-of-speech information is often relevant for
translation. The word ?stores? e.g. should be
translated to ?La?den? if it is a noun and to ?spei-
chert? when it is a verb. The sentence ?The small
child cries? might be incorrectly translated to ?Die
kleinen Kind weint? where the first three words
lack number, gender and case agreement.
In order to better learn such constraints which
are best expressed in terms of part of speech, we
add another OSM model as a new feature to the
log-linear model of our decoder, which is identi-
cal to the regular OSM except that all the words
have been replaced by their POS tags. The input
of the decoder consists of the input sentence with
automatically assigned part-of-speech tags. The
source and target part of the training data are also
automatically tagged and phrases with words and
POS tags on both sides are extracted. The POS-
based OSM model is only used in the German-to-
English and English-to-German experiments.4 So
far, we only used coarse POS tags without gender
and case information.
4 Constituent Parse Reordering
Our German-to-English system used constituent
parses for pre-ordering of the input. We parsed all
of the parallel German to English data available,
and the tuning, test and blind-test sets. We then
applied reordering rules to these parses. We used
the rules for reordering German constituent parses
of Collins et al (2005) together with the additional
rules described by Fraser (2009). These are ap-
plied as a preprocess to all German data (training,
tuning and test data). To produce the parses, we
started with the generative BitPar parser trained on
the Tiger treebank with optimizations of the gram-
mar, as described by (Fraser et al, 2013). We then
performed self-training using the high quality Eu-
roparl corpus - we parsed it, and then retrained the
parser on the output.
4This work is ongoing and we will present detailed exper-
iments in the future.
124
Following this, we performed linguistically-
informed compound splitting, using the system of
Fritzinger and Fraser (2010), which disambiguates
competing analyses from the high-recall Stuttgart
Morphological Analyzer SMOR (Schmid et al,
2004) using corpus statistics (Koehn and Knight,
2003). We also split portmanteaus like German
?zum? formed from ?zu dem? meaning ?to the?.
Due to time constraints, we did not address Ger-
man inflection. See Weller et al (2013) for further
details of the linguistic processing involved in our
German-to-English system.
5 Transliteration Mining/Handling
OOVs
The machine translation system fails to translate
out-of-vocabulary words (OOVs) as they are un-
known to the training data. Most of the OOVs
are named entities and simply passing them to
the output often produces correct translations if
source and target language use the same script.
If the scripts are different transliterating them to
the target language script could solve this prob-
lem. However, building a transliteration system
requires a list of transliteration pairs for training.
We do not have such a list and making one is a
cumbersome process. Instead, we use the unsu-
pervised transliteration mining system of Sajjad et
al. (2012) that takes a list of word pairs for train-
ing and extracts transliteration pairs that can be
used for the training of the transliteration system.
The procedure of mining transliteration pairs and
transliterating OOVs is described as follows:
We word-align the parallel corpus using
GIZA++ in both direction and symmetrize the
alignments using the grow-diag-final-and heuris-
tic. We extract all word pairs which occur as 1-
to-1 alignments (like Sajjad et al (2011)) and later
refer to them as the list of word pairs. We train the
unsupervised transliteration mining system on the
list of word pairs and extract transliteration pairs.
We use these mined pairs to build a transliteration
system using the Moses toolkit. The translitera-
tion system is applied in a post-processing step
to transliterate OOVs. Please refer to Sajjad et
al. (2013) for further details on our transliteration
work.
6 Sub-sampling
Because of scalability problems we were not able
to use the entire data made available for build-
ing the translation model in some cases. We used
modified Moore-Lewis sampling (Axelrod et al,
2011) for the language pairs es-en, en-es, en-fr,
and en-cs. In each case we included the News-
Commentary and Europarl corpora in their en-
tirety, and scored the sentences in the remaining
corpora (the selection corpus) using a filtering cri-
terion, adding 10% of the selection corpus to
the training data. We can not say with certainty
whether using the entire data will produce better
results with the OSM decoder. However, we know
that the same data used with the state-of-the-art
Moses produced worse results in some cases. The
experiments in Durrani et al (2013c) showed that
MML filtering decreases the BLEU scores in es-
en (news-test13: Table 19) and en-cs (news-test12:
Table 14). We can therefore speculate that being
able to use all of the data may improve our results
somewhat.
7 Experiments
Parallel Corpus: The amount of bitext used for
the estimation of the translation models is: de?en
? 4.5M and ru?en ? 2M parallel sentences. We
were able to use all the available data for cs-to-en
(? 15.6M sentences). However, sub-sampled data
was used for en-to-cs (? 3M sentences), en-to-fr
(? 7.8M sentences) and es?en (? 3M sentences).
Monolingual Language Model: We used all
the available training data (including LDC Giga-
word data) for the estimation of monolingual lan-
guage models: en? 287.3M sentences, fr? 91M,
es ? 65.7M, cs ? 43.4M and ru ? 21.7M sen-
tences. All data except for ru-en and en-ru was
true-cased. We followed the approach of Schwenk
and Koehn (2008) by training language models
from each sub-corpus separately and then linearly
interpolated them using SRILM with weights op-
timized on the held-out dev-set. We concatenated
the news-test sets from four years (2008-2011) to
obtain a large dev-set5 in order to obtain more sta-
ble weights (Koehn and Haddow, 2012).
Decoder Settings: For each extracted input
phrase only 15-best translation options were used
during decoding.6 We used a hard reordering limit
5For Russian-English and English-Russian language
pairs, we divided the tuning-set news-test 2012 into two
halves and used the first half for tuning and second for test.
6We could not experiment with higher n-best translation
options due to a bug that was not fixed in time and hindered
us from scaling.
125
of 16 words which disallows a jump beyond 16
source words. A stack size of 100 was used during
tuning and 200 for decoding the test set.
Results: Table 1 shows the uncased BLEU
scores along with the rank obtained on the sub-
mission matrix.7 We also show the results from
human evaluation.
Lang Evaluation
Automatic Human
BLEU Rank Win Ratio Rank
de-en 27.6 9/31 0.562 6-8
es-en 30.4 6/12 0.569 3-5
cs-en 26.4 3/11 0.581 2-3
ru-en 24.5 8/22 0.534 7-9
en-de 20.0 6/18
en-es 29.5 3/13 0.544 5-6
en-cs 17.6 14/22 0.517 4-6
en-ru 18.1 6/15 0.456 9-10
en-fr 30.0 7/26 0.541 5-9
Table 1: Translating into and from English
8 Conclusion
In this paper, we described our submissions to
WMT 13 in all the shared-task language pairs
(except for fr-en). We used an OSM-decoder,
which implements a model on n-gram of opera-
tions encapsulating lexical generation and reorder-
ing. For German-to-English we used constituent
parsing and applied linguistically motivated rules
to these parses, followed by compound splitting.
We additionally used a POS-based OSM model for
German-to-English and English-to-German exper-
iments. For Russian-English language pairs we
used unsupervised transliteration mining. Because
of scalability issues we could not use the entire
data in some language pairs and used only sub-
sampled data. Our Czech-to-English system that
was built from the entire data did better in both
automatic and human evaluation compared to the
systems that used sub-sampled data.
Acknowledgments
We would like to thank the anonymous reviewers
for their helpful feedback and suggestions. We
would like to thank Philipp Koehn and Barry Had-
dow for providing data and alignments. Nadir
7http://matrix.statmt.org/
Durrani was funded by the European Union Sev-
enth Framework Programme (FP7/2007-2013) un-
der grant agreement n ? 287658. Alexander
Fraser was funded by Deutsche Forschungsge-
meinschaft grant Models of Morphosyntax for
Statistical Machine Translation. Helmut Schmid
was supported by Deutsche Forschungsgemein-
schaft grant SFB 732. Richa?rd Farkas was
partially funded by the Hungarian National Ex-
cellence Program (TA?MOP 4.2.4.A/2-11-1-2012-
0001). This publication only reflects the authors?
views.
References
Amittai Axelrod, Xiaodong He, and Jianfeng Gao.
2011. Domain adaptation via pseudo in-domain data
selection. In Proceedings of the 2011 Conference on
Empirical Methods in Natural Language Process-
ing, pages 355?362, Edinburgh, Scotland, UK., July.
Association for Computational Linguistics.
Michael Collins, Philipp Koehn, and Ivona Kucerova.
2005. Clause Restructuring for Statistical Machine
Translation. In ACL05, pages 531?540, Ann Arbor,
MI.
Nadir Durrani, Helmut Schmid, and Alexander Fraser.
2011. A Joint Sequence Translation Model with In-
tegrated Reordering. In Proceedings of the 49th An-
nual Meeting of the Association for Computational
Linguistics: Human Language Technologies, pages
1045?1054, Portland, Oregon, USA, June.
Nadir Durrani, Alexander Fraser, and Helmut Schmid.
2013a. Model With Minimal Translation Units, But
Decode With Phrases. In The 2013 Conference of
the North American Chapter of the Association for
Computational Linguistics: Human Language Tech-
nologies, Atlanta, Georgia, USA, June. Association
for Computational Linguistics.
Nadir Durrani, Alexander Fraser, Helmut Schmid,
Hieu Hoang, and Philipp Koehn. 2013b. Can
Markov Models Over Minimal Translation Units
Help Phrase-Based SMT? In Proceedings of the
51st Annual Meeting of the Association for Compu-
tational Linguistics, Sofia, Bulgaria, August. Asso-
ciation for Computational Linguistics.
Nadir Durrani, Barry Haddow, Kenneth Heafield, and
Philipp Koehn. 2013c. Edinburgh?s Machine Trans-
lation Systems for European Language Pairs. In
Proceedings of the Eighth Workshop on Statistical
Machine Translation, Sofia, Bulgaria, August. As-
sociation for Computational Linguistics.
Alexander Fraser, Helmut Schmid, Richa?rd Farkas,
Renjing Wang, and Hinrich Schu?tze. 2013. Knowl-
edge sources for constituent parsing of German, a
morphologically rich and less-configurational lan-
guage. Computational Linguistics - to appear.
126
Alexander Fraser. 2009. Experiments in Morphosyn-
tactic Processing for Translating to and from Ger-
man. In Proceedings of the EACL 2009 Fourth
Workshop on Statistical Machine Translation, pages
115?119, Athens, Greece, March.
Fabienne Fritzinger and Alexander Fraser. 2010. How
to Avoid Burning Ducks: Combining Linguistic
Analysis and Corpus Statistics for German Com-
pound Processing. In Proceedings of the ACL 2010
Fifth Workshop on Statistical Machine Translation,
Uppsala, Sweden.
Kenneth Heafield. 2011. KenLM: Faster and Smaller
Language Model Queries. In Proceedings of the
Sixth Workshop on Statistical Machine Translation,
pages 187?197, Edinburgh, Scotland, United King-
dom, 7.
Reinhard Kneser and Hermann Ney. 1995. Improved
backing-off for m-gram language modeling. In In
Proceedings of the IEEE International Conference
on Acoustics, Speech and Signal Processing, vol-
ume I, pages 181?184, Detroit, Michigan, May.
Philipp Koehn and Barry Haddow. 2012. Towards Ef-
fective Use of Training Data in Statistical Machine
Translation. In Proceedings of the Seventh Work-
shop on Statistical Machine Translation, pages 317?
321, Montre?al, Canada, June. Association for Com-
putational Linguistics.
Philipp Koehn and Kevin Knight. 2003. Empirical
methods for compound splitting. In Proceedings of
the 10th Conference of the European Chapter of the
Association for Computational Linguistics (EACL),
pages 187?193, Morristown, NJ.
Philipp Koehn. 2004. Pharaoh: A Beam Search De-
coder for Phrase-Based Statistical Machine Transla-
tion Models. In AMTA, pages 115?124.
Jose? B. Marin?o, Rafael E. Banchs, Josep M. Crego,
Adria` de Gispert, Patrik Lambert, Jose? A. R. Fonol-
losa, and Marta R. Costa-jussa`. 2006. N-gram-
Based Machine Translation. Computational Lin-
guistics, 32(4):527?549.
Franz J. Och and Hermann Ney. 2004. The Alignment
Template Approach to Statistical Machine Transla-
tion. Computational Linguistics, 30(1):417?449.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2011. An algorithm for unsupervised transliteration
mining with an application to word alignment. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies - Volume 1, Portland, USA.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2012. A statistical model for unsupervised and
semi-supervised transliteration mining. In Proceed-
ings of the 50th Annual Meeting of the Association
for Computational Linguistics: Long Papers - Vol-
ume 1, Jeju, Korea.
Hassan Sajjad, Svetlana Smekalova, Nadir Durrani,
Alexander Fraser, and Helmut Schmid. 2013.
QCRI-MES Submission at WMT13: Using Translit-
eration Mining to Improve Statistical Machine
Translation. In Proceedings of the Eighth Workshop
on Statistical Machine Translation, Sofia, Bulgaria,
August. Association for Computational Linguistics.
Helmut Schmid, Arne Fitschen, and Ulrich Heid.
2004. SMOR: A German Computational Morphol-
ogy Covering Derivation, Composition, and Inflec-
tion. In Proceedings of the Fourth International
Conference on Language Resources and Evaluation
(LREC).
Holger Schwenk and Philipp Koehn. 2008. Large and
Diverse Language Models for Statistical Machine
Translation. In International Joint Conference on
Natural Language Processing, pages 661?666, Jan-
uary 2008.
Andreas Stolcke. 2002. SRILM - An Extensible Lan-
guage Modeling Toolkit. In Intl. Conf. Spoken Lan-
guage Processing, Denver, Colorado.
Marion Weller, Max Kisselew, Svetlana Smekalova,
Alexander Fraser, Helmut Schmid, Nadir Durrani,
Hassan Sajjad, and Richa?rd Farkas. 2013. Munich-
Edinburgh-Stuttgart Submissions at WMT13: Mor-
phological and Syntactic Processing for SMT. In
Proceedings of the Eighth Workshop on Statistical
Machine Translation, Sofia, Bulgaria, August. As-
sociation for Computational Linguistics.
127
Proceedings of the Eighth Workshop on Statistical Machine Translation, pages 219?224,
Sofia, Bulgaria, August 8-9, 2013 c?2013 Association for Computational Linguistics
QCRI-MES Submission at WMT13: Using Transliteration Mining to
Improve Statistical Machine Translation
Hassan Sajjad1, Svetlana Smekalova2, Nadir Durrani3,
Alexander Fraser4, Helmut Schmid4
1Qatar Computing Research Institute ? hsajjad@qf.org.qa
2University of Stuttgart ? smekalsa@ims.uni-stuttgart.de
3University of Edinburgh ? dnadir@inf.ed.ac.uk
4Ludwig-Maximilians University Munich ? (fraser|schmid)@cis.uni-muenchen.de
Abstract
This paper describes QCRI-MES?s sub-
mission on the English-Russian dataset to
the Eighth Workshop on Statistical Ma-
chine Translation. We generate improved
word alignment of the training data by
incorporating an unsupervised translitera-
tion mining module to GIZA++ and build
a phrase-based machine translation sys-
tem. For tuning, we use a variation of PRO
which provides better weights by optimiz-
ing BLEU+1 at corpus-level. We translit-
erate out-of-vocabulary words in a post-
processing step by using a transliteration
system built on the transliteration pairs
extracted using an unsupervised translit-
eration mining system. For the Russian
to English translation direction, we apply
linguistically motivated pre-processing on
the Russian side of the data.
1 Introduction
We describe the QCRI-Munich-Edinburgh-
Stuttgart (QCRI-MES) English to Russian and
Russian to English systems submitted to the
Eighth Workshop on Statistical Machine Trans-
lation. We experimented using the standard
Phrase-based Statistical Machine Translation
System (PSMT) as implemented in the Moses
toolkit (Koehn et al, 2007). The typical pipeline
for translation involves word alignment using
GIZA++ (Och and Ney, 2003), phrase extraction,
tuning and phrase-based decoding. Our system is
different from standard PSMT in three ways:
? We integrate an unsupervised transliteration
mining system (Sajjad et al, 2012) into the
GIZA++ word aligner (Sajjad et al, 2011).
So, the selection of a word pair as a correct
alignment is decided using both translation
probabilities and transliteration probabilities.
? The MT system fails when translating out-of-
vocabulary (OOV) words. We build a statis-
tical transliteration system on the translitera-
tion pairs mined by the unsupervised translit-
eration mining system and transliterate them
in a post-processing step.
? We use a variation of Pairwise Ranking Op-
timization (PRO) for tuning. It optimizes
BLEU at corpus-level and provides better
feature weights that leads to an improvement
in translation quality (Nakov et al, 2012).
We participate in English to Russian and Rus-
sian to English translation tasks. For the Rus-
sian/English system, we present experiments with
two variations of the parallel corpus. One set of
experiments are conducted using the standard par-
allel corpus provided by the workshop. In the sec-
ond set of experiments, we morphologically re-
duce Russian words based on their fine-grained
POS tags and map them to their root form. We
do this on the Russian side of the parallel corpus,
tuning set, development set and test set. This im-
proves word alignment and learns better transla-
tion probabilities by reducing the vocabulary size.
The paper is organized as follows. Section
2 talks about unsupervised transliteration mining
and its incorporation to the GIZA++ word aligner.
In Section 3, we describe the transliteration sys-
tem. Section 4 describes the extension of PRO
that optimizes BLEU+1 at corpus level. Section
5 and Section 6 present English/Russian and Rus-
sian/English machine translation experiments re-
spectively. Section 7 concludes.
219
2 Transliteration Mining
Consider a list of word pairs that consists of either
transliteration pairs or non-transliteration pairs.
A non-transliteration pair is defined as a word
pair where words are not transliteration of each
other. They can be translation, misalignment,
etc. Transliteration mining extracts transliteration
pairs from the list of word pairs. Sajjad et al
(2012) presented an unsupervised transliteration
mining system that trains on the list of word pairs
and filters transliteration pairs from that. It models
the training data as the combination of a translit-
eration sub-model and a non-transliteration sub-
model. The transliteration model is a joint source
channel model. The non-transliteration model as-
sumes no correlation between source and target
word characters, and independently generates a
source and a target word using two fixed uni-
gram character models. The transliteration mining
model is defined as an interpolation of the translit-
eration model and the non-transliteration model.
We apply transliteration mining to the list of
word pairs extracted from English/Russian paral-
lel corpus and mine transliteration pairs. We use
the mined pairs for the training of the translitera-
tion system.
2.1 Transliteration Augmented-GIZA++
GIZA++ aligns parallel sentences at word level. It
applies the IBM models (Brown et al, 1993) and
the HMM model (Vogel et al, 1996) in both direc-
tions i.e. source to target and target to source. It
generates a list of translation pairs with translation
probabilities, which is called the t-table. Sajjad
et al (2011) used a heuristic-based transliteration
mining system and integrated it into the GIZA++
word aligner. We follow a similar procedure but
use the unsupervised transliteration mining system
of Sajjad et al (2012).
We define a transliteration sub-model and train
it on the transliteration pairs mined by the unsuper-
vised transliteration mining system. We integrate
it into the GIZA++ word aligner. The probabil-
ity of a word pair is calculated as an interpolation
of the transliteration probability and the transla-
tion probability stored in the t-table of the differ-
ent alignment models used by the GIZA++ aligner.
This interpolation is done for all iterations of all
alignment models.
2.1.1 Estimating Transliteration Probabilities
We use the algorithm for the estimation of translit-
eration probabilities of Sajjad et al (2011). We
modify it to improve efficiency. In step 6 of Al-
gorithm 1 instead of taking all f that coocur with
e, we take only those that have a word length ra-
tio in range of 0.8-1.2.1 This reduces cooc(e) by
more than half and speeds up step 9 of Algorithm
1. The word pairs that are filtered out from cooc(e)
won?t have transliteration probability pti(f |e). We
do not interpolate in these cases and use the trans-
lation probability as it is.
Algorithm 1 Estimation of transliteration proba-
bilities, e-to-f direction
1: unfiltered data? list of word pairs
2: filtered data?transliteration pairs extracted using unsu-
pervised transliteration mining system
3: Train a transliteration system on the filtered data
4: for all e do
5: nbestTI(e) ? 10 best transliterations for e accord-
ing to the transliteration system
6: cooc(e)? set of all f that cooccur with e in a parallel
sentence with a word length in ratio of 0.8-1.2
7: candidateTI(e)? cooc(e) ? nbestTI(e)
8: for all f do
9: pmoses(f, e) ? joint transliteration probability of e
and f according to the transliterator
10: Calculate conditional transliteration probability
pti(f |e)? pmoses(f,e)?
f??CandidateTI(e) pmoses(f ?,e)
2.1.2 Modified EM Training
Sajjad et al (2011) modified the EM training of
the word alignment models. They combined the
translation probabilities of the IBM models and
the HMM model with the transliteration proba-
bilities. Consider pta(f |e) = fta(f, e)/fta(e) is
the translation probability of the word alignment
models. The interpolated probability is calcu-
lated by adding the smoothed alignment frequency
fta(f, e) to the transliteration probability weight
by the factor ?. The modified translation probabil-
ities is given by:
p?(f |e) = fta(f, e) + ?pti(f |e)fta(e) + ?
(1)
where fta(f, e) = pta(f |e)fta(e). pta(f |e) is ob-
tained from the original t-table of the alignment
model. fta(e) is the total corpus frequency of e.
? is the transliteration weight which is defined as
the number of counts the transliteration model gets
versus the translation model. The model is not
1We assume that the words with very different character
counts are less likely to be transliterations.
220
very sensitive to the value of ?. We use ? = 50
for our experiments. The procedure we described
of estimation of transliteration probabilities and
modification of EM is also followed in the oppo-
site direction f-to-e.
3 Transliteration System
The unsupervised transliteration mining system
(as described in Section 2) outputs a list of translit-
eration pairs. We consider transliteration word
pairs as parallel sentences by putting a space af-
ter every character of the words and train a PSMT
system for transliteration. We apply the transliter-
ation system to OOVs in a post-processing step on
the output of the machine translation system.
Russian is a morphologically rich language.
Different cases of a word are generally represented
by adding suffixes to the root form. For OOVs
that are named entities, transliterating the inflected
forms generates wrong English transliterations as
inflectional suffixes get transliterated too. To han-
dle this, first we need to identify OOV named en-
tities (as there can be other OOVs that are not
named entities) and then transliterate them cor-
rectly. We tackle the first issue as follows: If
an OOV word is starting with an upper case let-
ter, we identify it as a named entity. To correctly
transliterate it to English, we stem the named en-
tity based on a list of suffixes ( , , , , , )
and transliterate the stemmed form. For morpho-
logically reduced Russian (see Section 6.1), we
follow the same procedure as OOVs are unknown
to the POS tagger too and are (incorrectly) not re-
duced to their root forms. For OOVs that are not
identified as named entities, we transliterate them
without any pre-processing.
4 PRO: Corpus-level BLEU
Pairwise Ranking Optimization (PRO) (Hopkins
and May, 2011) is an extension of MERT (Och,
2003) that can scale to thousands of parameters.
It optimizes sentence-level BLEU+1 which is an
add-one smoothed version of BLEU (Lin and Och,
2004). The sentence-level BLEU+1 has a bias
towards producing short translations as add-one
smoothing improves precision but does not change
the brevity penalty. Nakov et al (2012) fixed this
by using several heuristics on brevity penalty, ref-
erence length and grounding the precision length.
In our experiments, we use the improved version
of PRO as provided by Nakov et al (2012). We
call it PROv1 later on.
5 English/Russian Experiments
5.1 Dataset
The amount of bitext used for the estimation of the
translation model is ? 2M parallel sentences. We
use newstest2012a for tuning and newstest2012b
(tst2012) as development set.
The language model is estimated using large
monolingual corpus of Russian ? 21.7M sen-
tences. We follow the approach of Schwenk and
Koehn (2008) by training domain-specific lan-
guage models separately and then linearly inter-
polate them using SRILM with weights optimized
on the held-out development set. We divide the
tuning set newstest2012a into two halves and use
the first half for tuning and second for test in or-
der to obtain stable weights (Koehn and Haddow,
2012).
5.2 Baseline Settings
We word-aligned the parallel corpus using
GIZA++ (Och and Ney, 2003) with 5 iterations
of Model1, 4 iterations of HMM and 4 iterations
of Model4, and symmetrized the alignments us-
ing the grow-diag-final-and heuristic (Koehn et al,
2003). We built a phrase-based machine transla-
tion system using the Moses toolkit. Minimum er-
ror rate training (MERT), margin infused relaxed
algorithm (MIRA) and PRO are used to optimize
the parameters.
5.3 Main System Settings
Our main system involves a pre-processing step
? unsupervised transliteration mining, and a post-
processing step ? transliteration of OOVs. For the
training of the unsupervised transliteration min-
ing system, we take the word alignments from
our baseline settings and extract all word pairs
which occur as 1-to-1 alignments (like Sajjad et
al. (2011)) and later refer to them as a list of
word pairs. The unsupervised transliteration min-
ing system trains on the list of word pairs and
mines transliteration pairs. We use the mined pairs
to build a transliteration system using the Moses
toolkit. The transliteration system is used in Algo-
rithm 1 to generate transliteration probabilities of
candidate word pairs and is also used in the post-
processing step to transliterate OOVs.
We run GIZA++ with identical settings as de-
scribed in Section 5.2. We interpolate for ev-
221
GIZA++ TA-GIZA++ OOV-TI
MERT 23.41 23.51 23.60
MIRA 23.60 23.73 23.85
PRO 23.57 23.68 23.70
PROv1 23.65 23.76 23.87
Table 1: BLEU scores of English to Russian ma-
chine translation system evaluated on tst2012 us-
ing baseline GIZA++ alignment and translitera-
tion augmented-GIZA++. OOV-TI presents the
score of the system trained using TA-GIZA++ af-
ter transliterating OOVs
ery iteration of the IBM Model1 and the HMM
model. We had problem in applying smoothing
for Model4 and did not interpolate transliteration
probabilities for Model4. The alignments are re-
fined using the grow-diag-final-and heuristic. We
build a phrase-based system on the aligned pairs
and tune the parameters using PROv1. OOVs are
transliterated in the post-processing step.
5.4 Results
Table 1 summarizes English/Russian results on
tst2012. Improved word alignment gives up to
0.13 BLEU points improvement. PROv1 improves
translation quality and shows 0.08 BLEU point
increase in BLEU in comparison to the parame-
ters tuned using PRO. The transliteration of OOVs
consistently improve translation quality by at least
0.1 BLEU point for all systems.2 This adds to a
cumulative gain of up to 0.2 BLEU points.
We summarize results of our systems trained on
GIZA++ and transliteration augmented-GIZA++
(TA-GIZA++) and tested on tst2012 and tst2013
in Table 2. Both systems use PROv1 for tuning
and transliteration of OOVs in the post-processing
step. The system trained on TA-GIZA++ per-
formed better than the system trained on the base-
line aligner GIZA++.
6 Russian/English Experiments
In this section, we present translation experiments
in Russian to English direction. We morphologi-
cally reduce the Russian side of the parallel data in
a pre-processing step and train the translation sys-
tem on that. We compare its result with the Rus-
sian to English system trained on the un-processed
parallel data.
2We see similar gain in BLEU when using operation se-
quence model (Durrani et al, 2011) for decoding and translit-
erating OOVs in a post-processing step (Durrani et al, 2013).
SYS tst2012 tst2013
GIZA++ 23.76 18.4
TA-GIZA++ 23.87 18.5*
Table 2: BLEU scores of English to Russian ma-
chine translation system evaluated on tst2012 and
tst2013 using baseline GIZA++ alignment and
transliteration augmented-GIZA++ alignment and
post-processed the output by transliterating OOVs.
Human evaluation in WMT13 is performed on
TA-GIZA++ tested on tst2013 (marked with *)
6.1 Morphological Processing
The linguistic processing of Russian involves POS
tagging and morphological reduction. We first tag
the Russian data using a fine grained tagset. The
tagger identifies lemmas and the set of morpholog-
ical attributes attached to each word. We reduce
the number of these attributes by deleting some
of them, that are not relevant for English (for ex-
ample, gender agreement of verbs). This gener-
ates a morphologically reduced Russian which is
used in parallel with English for the training of
the machine translation system. Further details on
the morphological processing of Russian are de-
scribed in Weller et al (2013).
6.1.1 POS Tagging
We use RFTagger (Schmid and Laws, 2008) for
POS tagging. Despite the good quality of tagging
provided by RFTagger, some errors seem to be un-
avoidable due to the ambiguity of certain gram-
matical forms in Russian. A good example of
this is neuter nouns that have the same form in
all cases, or feminine nouns, which have identi-
cal forms in singular genitive and plural nomina-
tive (Sharoff et al, 2008). Since Russian sentences
have free word order, and the case of nouns can-
not be determined on that basis, this imperfection
can not be corrected during tagging or by post-
processing the tagger output.
6.1.2 Morphological Reduction
English in comparison to Slavic group of lan-
guages is morphologically poor. For example, En-
glish has no morphological attributes for nouns
and adjectives to express gender or case; verbs in
English have no gender either. Russian, on the
contrary, has rich morphology. It suffices to say
that the Russian has 6 cases and 3 grammatical
genders, which manifest themselves in different
222
suffixes for nouns, pronouns, adjectives and some
verb forms.
When translating from Russian into English, a
lot of these attributes become meaningless and ex-
cessive. It makes sense to reduce the number of
morphological attributes before the text is sup-
plied for the training of the MT system. We ap-
ply morphological reduction to nouns, pronouns,
verbs, adjectives, prepositions and conjunctions.
The rest of the POS (adverbs, particles, interjec-
tions and abbreviations) have no morphological at-
tributes and are left unchanged.
We apply morphological reduction to train,
tune, development and test data. We refer to this
data set as morph-reduced later on.
6.2 Dataset
We use two variations of the parallel corpus to
build and test the Russian to English system. One
system is built on the data provided by the work-
shop. For the second system, we preprocess the
Russian side of the data as described in Section
6.1. Both the provided parallel corpus and the
morph-reduced parallel corpus consist of 2M par-
allel sentences each. We use them for the estima-
tion of the translation model. We use large train-
ing data for the estimation of monolingual lan-
guage model ? en? 287.3M sentences. We follow
the identical procedure of interpolated language
model as described in Section 5.1. We use new-
stest2012a for tuning and newstest2012b (tst2012)
for development.
6.3 System Settings
We use identical system settings to those described
in Section 5.3. We trained the systems sepa-
rately on GIZA++ and transliteration augmented-
GIZA++ to compare their results. All systems are
tuned using PROv1. The translation output is post-
processed to transliterate OOVs.
6.4 Results
Table 3 summarizes results of Russian to English
machine translation systems trained on the orig-
inal parallel corpus and on the morph-reduced
corpus and using GIZA++ and transliteration
augmented-GIZA++ for word alignment. The sys-
tem using TA-GIZA++ for alignment shows the
best results for both tst2012 and tst2013. The im-
proved alignment gives a BLEU improvement of
up to 0.4 points.
Original corpus
SYS tst2012 tst2013
GIZA++ 32.51 25.5
TA-GIZA++ 33.40 25.9*
Morph-reduced
SYS tst2012 tst2013
GIZA++ 31.22 24.30
TA-GIZA++ 31.40 24.45
Table 3: Russian to English machine translation
system evaluated on tst2012 and tst2013. Human
evaluation in WMT13 is performed on the system
trained using the original corpus with TA-GIZA++
for alignment (marked with *)
The system built on the morph-reduced data
shows degradation in results by 1.29 BLEU points.
However, the percentage of OOVs reduces for
both test sets when using the morph-reduced data
set compared to the original parallel corpus. We
analyze the output of the system and find that the
morph-reduced system makes mistakes in choos-
ing the right tense of the verb. This might be one
reason for poor performance. This implies that the
morphological reduction is slightly damaging the
data, perhaps for specific parts of speech. In the
future, we would like to investigate this issue in
detail.
7 Conclusion
In this paper, we described the QCRI-Munich-
Edinburgh-Stuttgart machine translation systems
submitted to the Eighth Workshop on Statistical
Machine Translation. We aligned the parallel cor-
pus using transliteration augmented-GIZA++ to
improve the word alignments. We built a phrase-
based system using the Moses toolkit. For tun-
ing the feature weights, we used an improvement
of PRO that optimizes for corpus-level BLEU. We
post-processed the output of the machine transla-
tion system to transliterate OOV words.
For the Russian to English system, we mor-
phologically reduced the Russian data in a pre-
processing step. This reduced the vocabulary size
and helped to generate better word alignments.
However, the performance of the SMT system
dropped by 1.29 BLEU points in decoding. We
will investigate this issue further in the future.
223
Acknowledgments
We would like to thank the anonymous reviewers
for their helpful feedback and suggestions. We
would like to thank Philipp Koehn and Barry Had-
dow for providing data and alignments. Nadir
Durrani was funded by the European Union Sev-
enth Framework Programme (FP7/2007-2013) un-
der grant agreement n ? 287658. Alexander Fraser
was funded by Deutsche Forschungsgemeinschaft
grant Models of Morphosyntax for Statistical Ma-
chine Translation. Helmut Schmid was supported
by Deutsche Forschungsgemeinschaft grant SFB
732. This publication only reflects the authors
views.
References
Peter F. Brown, Stephen A. Della Pietra, Vincent J.
Della Pietra, and R. L. Mercer. 1993. The mathe-
matics of statistical machine translation: parameter
estimation. Computational Linguistics, 19(2).
Nadir Durrani, Helmut Schmid, and Alexander Fraser.
2011. A joint sequence translation model with in-
tegrated reordering. In Proceedings of the 49th An-
nual Meeting of the Association for Computational
Linguistics: Human Language Technologies, Port-
land, USA.
Nadir Durrani, Helmut Schmid, Alexander Fraser, Has-
san Sajjad, and Richa?rd Farkas. 2013. Munich-
Edinburgh-Stuttgart submissions of OSM systems at
WMT13. In Proceedings of the Eighth Workshop on
Statistical Machine Translation, Sofia, Bulgaria.
Mark Hopkins and Jonathan May. 2011. Tuning as
ranking. In Proceedings of the Conference on Em-
pirical Methods in Natural Language Processing,
Edinburgh, United Kingdom.
Philipp Koehn and Barry Haddow. 2012. Towards
effective use of training data in statistical machine
translation. In Proceedings of the Seventh Work-
shop on Statistical Machine Translation, Montre?al,
Canada.
Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proceed-
ings of the Human Language Technology and North
American Association for Computational Linguis-
tics Conference, Edmonton, Canada.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proceedings of the 45th Annual Meeting of the Asso-
ciation for Computational Linguistics, Demonstra-
tion Program, Prague, Czech Republic.
Chin-Yew Lin and Franz Josef Och. 2004. OR-
ANGE: a method for evaluating automatic evalua-
tion metrics for machine translation. In Proceed-
ings of the 20th international conference on Compu-
tational Linguistics, Geneva, Switzerland.
Preslav Nakov, Francisco Guzma?n, and Stephan Vo-
gel. 2012. Optimizing for sentence-level BLEU+1
yields short translations. In Proceedings of the
24th International Conference on Computational
Linguistics, Mumbai, India.
Franz J. Och and Hermann Ney. 2003. A systematic
comparison of various statistical alignment models.
Computational Linguistics, 29(1).
Franz J. Och. 2003. Minimum error rate training in
statistical machine translation. In Proceedings of the
41st Annual Meeting of the Association for Compu-
tational Linguistics, Sapporo, Japan.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2011. An algorithm for unsupervised translitera-
tion mining with an application to word alignment.
In Proceedings of the 49th Annual Conference of
the Association for Computational Linguistics, Port-
land, USA.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2012. A statistical model for unsupervised and
semi-supervised transliteration mining. In Proceed-
ings of the 50th Annual Conference of the Associa-
tion for Computational Linguistics, Jeju, Korea.
Helmut Schmid and Florian Laws. 2008. Estimation
of conditional probabilities with decision trees and
an application to fine-grained pos tagging. In Pro-
ceedings of the 22nd International Conference on
Computational Linguistics - Volume 1, Manchester,
United Kingdom.
Holger Schwenk and Philipp Koehn. 2008. Large and
Diverse Language Models for Statistical Machine
Translation. In International Joint Conference on
Natural Language Processing, Hyderabad, India.
Serge Sharoff, Mikhail Kopotev, Tomaz Erjavec, Anna
Feldman, and Dagmar Divjak. 2008. Designing
and evaluating a russian tagset. In Proceedings of
the Sixth International Conference on Language Re-
sources and Evaluation.
Stephan Vogel, Hermann Ney, and Christoph Tillmann.
1996. HMM-based word alignment in statistical
translation. In 16th International Conference on
Computational Linguistics, Copenhagen, Denmark.
Marion Weller, Max Kisselew, Svetlana Smekalova,
Alexander Fraser, Helmut Schmid, Nadir Durrani,
Hassan Sajjad, and Richa?rd Farkas. 2013. Munich-
Edinburgh-Stuttgart submissions at WMT13: Mor-
phological and syntactic processing for SMT. In
Proceedings of the Eighth Workshop on Statistical
Machine Translation, Sofia, Bulgaria.
224
Proceedings of the Eighth Workshop on Statistical Machine Translation, pages 232?239,
Sofia, Bulgaria, August 8-9, 2013 c?2013 Association for Computational Linguistics
Munich-Edinburgh-Stuttgart Submissions at WMT13:
Morphological and Syntactic Processing for SMT
Marion Weller1, Max Kisselew1, Svetlana Smekalova1, Alexander Fraser2,
Helmut Schmid2, Nadir Durrani3, Hassan Sajjad4, Richa?rd Farkas5
1University of Stuttgart ? (wellermn|kisselmx|smekalsa)@ims.uni-stuttgart.de
2Ludwig-Maximilian University of Munich ? (schmid|fraser)@cis.uni-muenchen.de
3University of Edinburgh ? dnadir@inf.ed.ac.uk
4Qatar Computing Research Institute ? hsajjad@qf.org.qa
5University of Szeged ? rfarkas@inf.u-szeged.hu
Abstract
We present 5 systems of the Munich-
Edinburgh-Stuttgart1 joint submissions to
the 2013 SMT Shared Task: FR-EN, EN-
FR, RU-EN, DE-EN and EN-DE. The
first three systems employ inflectional gen-
eralization, while the latter two employ
parser-based reordering, and DE-EN per-
forms compound splitting. For our ex-
periments, we use standard phrase-based
Moses systems and operation sequence
models (OSM).
1 Introduction
Morphologically complex languages often lead to
data sparsity problems in statistical machine trans-
lation. For translation pairs with morphologically
rich source languages and English as target lan-
guage, we focus on simplifying the input language
in order to reduce the complexity of the translation
model. The pre-processing of the source-language
is language-specific, requiring morphological anal-
ysis (FR, RU) as well as sentence reordering (DE)
and dealing with compounds (DE). Due to time
constraints we did not deal with inflection for DE-
EN and EN-DE.
The morphological simplification process con-
sists in lemmatizing inflected word forms and deal-
ing with word formation (splitting portmanteau
prepositions or compounds). This needs to take
into account translation-relevant features (e.g. num-
ber) which vary across the different language pairs:
while French only has the features number and
gender, a wider array of features needs to be con-
sidered when modelling Russian (cf. table 6). In
addition to morphological reduction, we also apply
transliteration models learned from automatically
1The language pairs DE-EN and RU-EN were developed
in collaboration with the Qatar Computing Research Institute
and the University of Szeged.
mined transliterations to handle out-of-vocabulary
words (OOVs) when translating from Russian.
Replacing inflected word forms with simpler
variants (lemmas or the components of split com-
pounds) aims not only at reducing the general com-
plexity of the translation model, but also at decreas-
ing the amount of out-of-vocabulary words in the
input data. This is particularly the case with Ger-
man compounds, which are very productive and
thus often lack coverage in the parallel training
data, whereas the individual components can be
translated. Similarly, inflected word forms (e.g. ad-
jectives) benefit from the reduction to lemmas if
the full inflection paradigm does not occur in the
parallel training data.
For EN-FR, a translation pair with a morpho-
logically complex target language, we describe a
two-step translation system built on non-inflected
word stems with a post-processing component for
predicting morphological features and the genera-
tion of inflected forms. In addition to the advantage
of a more general translation model, this method
also allows the generation of inflected word forms
which do not occur in the training data.
2 Experimental setup
The translation experiments in this paper are car-
ried out with either a standard phrase-based Moses
system (DE-EN, EN-DE, EN-FR and FR-EN) or
with an operation sequence model (RU-EN, DE-
EN), cf. Durrani et al (2013b) for more details.
An operation sequence model (OSM) is a state-
of-the-art SMT-system that learns translation and
reordering patterns by representing a sentence pair
and its word alignment as a unique sequence of
operations (see e.g. Durrani et al (2011), Durrani
et al (2013a) for more details). For the Moses sys-
tems we used the old train-model perl scripts rather
than the EMS, so we did not perform Good-Turing
smoothing; parameter tuning was carried out with
batch-mira (Cherry and Foster, 2012).
232
1 Removal of empty lines
2 Conversion of HTML special characters like
&quot; to the corresponding characters
3 Unification of words that were written both
with an ? or with an oe to only one spelling
4 Punctuation normalization and tokenization
5 Putting together clitics and apostrophes like
l ? or d ? to l? and d?
Table 1: Text normalization for FR-EN.
Definite determiners la / l? / les ? le
Indefinite determiners un / une ? un
Adjectives Infl. form ? lemma
Portmanteaus e. g. au ? a` le
Verb participles Reduced to
inflected for gender non-inflected
and number verb participle form
ending in e?e/e?s/e?es ending in e?
Clitics and apostroph- d? ? de,
ized words are converted qu? ? que,
to their lemmas n? ? ne, ...
Table 2: Rules for morphological simplification.
The development data consists of the concate-
nated news-data sets from the years 2008-2011.
Unless otherwise stated, we use all constrained data
(parallel and monolingual). For the target-side lan-
guage models, we follow the approach of Schwenk
and Koehn (2008) and train a separate language
model for each corpus and then interpolate them
using weights optimized on development data.
3 French to English
French has a much richer morphology than English;
for example, adjectives in French are inflected with
respect to gender and number whereas adjectives
in English are not inflected at all. This causes data
sparsity in coverage of French inflected forms. We
try to overcome this problem by simplifying French
inflected forms in a pre-processing step in order to
adapt the French input better to the English output.
Processing of the training and test data The
pre-processing of the French input consists of two
steps: (1) normalizing not well-formed data (cf.
table 1) and (2) morphological simplification.
In the second step, the normalized training data
is annotated with Part-of-Speech tags (PoS-tags)
and word lemmas using RFTagger (Schmid and
Laws, 2008) which was trained on the French tree-
bank (Abeille? et al, 2003). French forms are then
simplified according to the rules given in table 2.
Data and experiments We trained a French to
English Moses system on the preprocessed and
System BLEU (cs) BLEU (ci)
Baseline 29.90 31.02
Simplified French* 29.70 30.83
Table 3: Results of the French to English system
(WMT-2012). The marked system (*) corresponds
to the system submitted for manual evaluation. (cs:
case-sensitive, ci: case-insensitive)
simplified constrained parallel data.
Due to tractability problems with word align-
ment, the 109 French-English corpus and the UN
corpus were filtered to a more manageable size.
The filtering criteria are sentence length (between
15 and 25 words), as well as strings indicating that
a sentence is neither French nor English, or other-
wise not well-formed, aiming to obtain a subset of
good-quality sentences. In total, we use 9M par-
allel sentences. For the English language model
we use large training data with 287.3M true-cased
sentences (including the LDC Giga-word data).
We compare two systems: a baseline with reg-
ular French text, and a system with the described
morphological simplifications. Results for the
WMT-2012 test set are shown in table 3. Even
though the baseline is better than the simplified
system in terms of BLEU, we assume that the trans-
lation model of the simplified system benefits from
the overall generalization ? thus, human annotators
might prefer the output of the simplified system.
For the WMT-2013 set, we obtain BLEU scores
of 29,97 (cs) and 31,05 (ci) with the system built
on simplified French (mes-simplifiedfrench).
4 English to French
Translating into a morphologically rich language
faces two problems: that of asymmetry of mor-
phological information contained in the source and
target language and that of data sparsity.
In this section we describe a two-step system de-
signed to overcome these types of problems: first,
the French data is reduced to non-inflected forms
(stems) with translation-relevant morphological fea-
tures, which is used to built the translation model.
The second step consists of predicting all neces-
sary morphological features for the translation out-
put, which are then used to generate fully inflected
forms. This two-step setup decreases the complex-
ity of the translation task by removing language-
specific features from the translation model. Fur-
thermore, generating inflected forms based on word
stems and morphological features allows to gener-
233
ate forms which do not occur in the parallel training
data ? this is not possible in a standard SMT setup.
The idea of separating the translation into two
steps to deal with complex morphology was in-
troduced by Toutanova et al (2008). Fraser et
al. (2012) applied this method to the language
pair English-German with an additional special
focus on word formation issues such as the split-
ting and merging of portmanteau prepositions and
compounds. The presented inflection prediction
systems focuses on nominal inflection; verbal in-
flection is not addressed.
Morphological analysis and resources The
morphological analysis of the French training data
is obtained using RFTagger, which is designed
for annotating fine-grained morphological tags
(Schmid and Laws, 2008). For generating inflected
forms based on stems and morphological features,
we use an extended version of the finite-state mor-
phology FRMOR (Zhou, 2007). Additionally, we
use a manually compiled list of abbreviations and
named entities (names of countries) and their re-
spective grammatical gender.
Stemming For building the SMT system, the
French data (parallel and monolingual) is trans-
formed into a stemmed representation. Nouns,
i.e. the heads of NPs or PPs, are marked with
inflection-relevant features: gender is considered
as part of the stem, whereas number is determined
by the source-side input: for example, we expect
source-language words in plural to be translated by
translated by stems with plural markup. This stem-
markup is necessary in order to guarantee that the
number information is not lost during translation.
For a better generalization, portmanteaus are split
into separate parts: au? a`+le (meaning, ?to the?).
Predicting morphological features For predict-
ing the morphological features of the SMT output
(number and gender), we use a linear chain CRF
(Lavergne et al, 2010) trained on data annotated
with these features using n-grams of stems and part-
of-speech tags within a window of 4 positions to
each side of the current word. Through the CRF,
the values specified in the stem-markup (number
and gender on nouns) are propagated over the rest
of the linguistic phrase, as shown in column 2 of
table 4. Based on the stems and the morphological
features, inflected forms can be generated using
FRMOR (column 3).
Post-processing As the French data has been
normalized, a post-processing step is needed in or-
der to generate correct French surface forms: split
portmanteaus are merged into their regular forms
based on a simple rule set. Furthermore, apostro-
phes are reintroduced for words like le, la, ne, ... if
they are followed by a vowel. Column 4 in table 4
shows post-processing including portmanteau for-
mation. Since we work on lowercased data, an
additional recasing step is required.
Experiments and evaluation We use the same
set of reduced parallel data as the FR-EN system;
the language model is built on 32M French sen-
tences. Results for the WMT-2012 test set are given
in table 5. Variant 1 shows the results for a small
system trained only on a part of the training data
(Europarl+News Commentary), whereas variant 2
corresponds to the submitted system. A small-scale
analysis indicated that the inflection prediction sys-
tem tends to have problems with subject-verb agree-
ment. We trained a factored system using addi-
tional PoS-tags with number information which
lead to a small improvement on both variants.
While the small model is significantly better than
the baseline2 as it benefits more from the general-
ization, the result for the full system is worse than
the baseline3. Here, given the large amount of
data, the generalization effect has less influence.
However, we assume that the more general model
from the inflection prediction system produces bet-
ter translations than a regular model containing a
large amount of irrelevant inflectional information,
particularly when considering that it can produce
well-formed inflected sequences that are inaccessi-
ble to the baseline. Even though this is not reflected
in terms of BLEU, humans might prefer the inflec-
tion prediction system.
For the WMT-2013 set, we obtain BLEU scores
of 29.6 (ci) and 28.30 (cs) with the inflection pre-
diction system mes-inflection (marked in table 5).
5 Russian-English
The preparation of the Russian data includes the
following stages: (1) tokenization and tagging and
(2) morphological reduction.
Tagging and tagging errors For tagging, we use
a version of RFTagger (Schmid and Laws, 2008)
2Pairwise bootstrap resampling with 1000 samples.
3However, the large inflection-prediction system has a
slightly better NIST score than the baseline (7.63 vs. 7.61).
234
SMT-output predicted generated after post- gloss
with stem-markup in bold print features forms processing
avertissement<Masc><Pl>[N] Masc.Pl avertissements avertissements warnings
sinistre[ADJ] Masc.Pl sinistres sinistres dire
de[P] ? de du from
le[ART] Masc.Sg le the
pentagone<Masc><Sg>[N] Masc.Sg pentagone pentagone pentagon
sur[P] ? sur sur over
de[P] ? de d? of
e?ventuel[ADJ] Fem.Pl e?ventuelles e?ventuelles potential
re?duction<Fem><Pl>[N] Fem.Pl re?ductions re?ductions reductions
de[P] ? de du of
le[ART] Masc.Sg le the
budget<Masc><Sg>[N] Masc.Sg budget budget budget
de[P] ? de de of
le[ART] Fem.Sg la la the
de?fense<Fem><Sg>[N] Fem.Sg de?fense de?fense de?fense
Table 4: Processing steps for the input sentence dire warnings from pentagon over potential defence cuts.
that has been developed based on data tagged with
TreeTagger (Schmid, 1994) using a model from
Sharoff et al (2008). The data processed by Tree-
Tagger contained errors such as wrong definition
of PoS for adverbs, wrong selection of gender for
adjectives in plural and missing features for pro-
nouns and adverbs. In order to train RFTagger, the
output of TreeTagger was corrected with a set of
empirical rules. In particular, the morphological
features of nominal phrases were made consistent
to train RFTagger: in contrast to TreeTagger, where
morphological features are regarded as part of the
PoS-tag, RFTagger allows for a separate handling
of morphological features and POS tags.
Despite a generally good tagging quality, some
errors seem to be unavoidable due to the ambiguity
of certain grammatical forms in Russian. A good
example of this are neuter nouns that have the same
form in all cases, or feminine nouns, which have
identical forms in singular genitive and plural nom-
inative (Sharoff et al, 2008). Since Russian has no
binding word order, and the case of nouns cannot
be determined on that basis, such errors cannot be
corrected with empirical rules implemented as post-
System BLEU (ci) BLEU (cs)
1 Baseline 24.91 23.40
InflPred 25.31 23.81
InflPred-factored 25.53 24.04
2 Baseline 29.32 27.65
InflPred* 29.07 27.40
InflPred-factored 29.17 27.46
Table 5: Results for French inflection prediction
on the WMT-2012 test set. The marked system (*)
corresponds to the system submitted for manual
evaluation.
processing. Similar errors occur when specifying
the case of adjectives, since the suffixes of adjec-
tives are even less varied as compared to the nouns.
In our application, we hope that this type of error
does not affect the result due to the following sup-
pression of a number of morphological attributes
including the case of adjectives.
Morphological reduction In comparison to
Slavic languages, English is morphologically poor.
For example, English has no morphological at-
tributes for nouns and adjectives to express gender
or case; verbs have no gender either. In contrast,
Russian is morphologically very rich ? there are
e.g. 6 cases and 3 grammatical genders, which
manifest themselves in different suffixes for nouns,
pronouns, adjectives and some verb forms. When
translating from Russian into English, many of
these attributes are (hopefully) redundant and are
therefore deleted from the training data. The mor-
phological reduction in our system was applied to
nouns, pronouns, verbs, adjectives, prepositions
and conjunctions. The rest of the POS (adverbs,
particles, interjections and abbreviations) have no
morphological attributes. The list of the original
and the reduced attributes is given in Table 6.
Transliteration mining to handle OOVs The
machine translation system fails to translate out-of-
vocabulary words (OOVs) as they are unknown to
the training data. Most of the OOVs are named en-
tities and transliterating them to the target language
script could solve this problem. The transliteration
system requires a list of transliteration pairs for
training. As we do not have such a list, we use
the unsupervised transliteration mining system of
Sajjad et al (2012) that takes a list of word pairs for
235
Part of Attributes Reduced
Speech RFTagger attributes
Noun Type Type
Gender Gender
Number Number
Case Case
nom,gen,dat,acc,instr,prep gen,notgen
Animate
Case 2
Pronoun Person Person
Gender Gender
Number Number
Case Case
nom,gen,dat,acc,instr,prep nom,notnom
Syntactic type
Animated
Verb Type Type
VForm VForm
Tense Tense
Person Person
Number Number
Gender
Voice Voice
Definiteness
Aspect Aspect
Case
Adjec- Type Type
tive Degree Degree
Gender
Number
Case
Definiteness
Prep- Type
osition Formation
Case
Conjunc- Type Type
tion Formation Formation
Table 6: Rules for simplifying the morphological
complexity for RU.
training and extracts transliteration pairs that can
be used for the training of the transliteration system.
The procedure of mining transliteration pairs and
transliterating OOVs is described as follows: We
word-align the parallel corpus using GIZA++ and
symmetrize the alignments using the grow-diag-
final-and heuristic. We extract all word pairs which
occur as 1-to-1 alignments (Sajjad et al, 2011) and
later refer to them as a list of word pairs. We train
the unsupervised transliteration mining system on
the list of word pairs and extract transliteration
pairs. We use these mined pairs to build a transliter-
ation system using the Moses toolkit. The translit-
eration system is applied as a post-processing step
to transliterate OOVs.
The morphological reduction of Russian (cf. sec-
tion 5) does not process most of the OOVs as they
are also unknown to the POS tagger. So OOVs that
we get are in their original form. When translit-
Original corpus
SYS WMT-2012 WMT-2013
GIZA++ 32.51 25.5
TA-GIZA++ 33.40 25.9*
Morph-reduced
SYS WMT-2012 WMT-2013
GIZA++ 31.22 24.3
TA-GIZA++ 31.40 24.45
Table 7: Russian to English machine translation
system evaluated on WMT-2012 and WMT-2013.
Human evaluation in WMT13 is performed on the
system trained using the original corpus with TA-
GIZA++ for alignment (marked with *).
erating them, the inflected forms generate wrong
English transliterations as inflectional suffixes get
transliterated too, specially OOV named entities.
We solved this problem by stemming the OOVs
based on a list of suffixes ( , , , , , ) and
transliterating the stemmed forms.
Experiments and results We trained the sys-
tems separately on GIZA++ and transliteration
augmented-GIZA++ (TA-GIZA++) to compare
their results; for more details see Sajjad et al
(2013). All systems are tuned using PROv1 (Nakov
et al, 2012). The translation output is post-
processed to transliterate OOVs.
Table 7 summarizes the results of RU-EN trans-
lation systems trained on the original corpus and
on the morph-reduced corpus. Using TA-GIZA++
alignment gives the best results for both WMT-
2012 and WMT-2013, leading to an improvement
of 0.4 BLEU points.
The system built on the morph-reduced data
leads to decreased BLEU results. However, the per-
centage of OOVs is reduced for both test sets when
using the morph-reduced data set compared to the
original data. An analysis of the output showed
that the morph-reduced system makes mistakes in
choosing the right tense of the verb, which might
be one reason for this outcome. In the future, we
would like to investigate this issue in detail.
6 German to English and English to
German
We submitted systems for DE-EN and EN-DE
which used constituent parses for pre-reordering.
For DE-EN we also deal with word formation is-
sues such as compound splitting. We did not per-
form inflectional normalization or generation for
German due to time constraints, instead focusing
236
our efforts on these issues for French and Russian
as previously described.
German to English German has a wider diver-
sity of clausal orderings than English, all of which
need to be mapped to the English SVO order. This
is a difficult problem to solve during inference, as
shown for hierarchical SMT by Fabienne Braune
and Fraser (2012) and for phrase-based SMT by
Bisazza and Federico (2012).
We syntactically parsed all of the source side
sentences of the parallel German to English data
available, and the tuning, test and blindtest sets.
We then applied reordering rules to these parses.
We use the rules for reordering German constituent
parses of Collins et al (2005) together with the
additional rules described by Fraser (2009). These
are applied as a preprocess to all German data.
For parsing the German sentences, we used the
generative phrase-structure parser BitPar with opti-
mizations of the grammar, as described by Fraser
et al (2013). The parser was trained on the Tiger
Treebank (Brants et al, 2002) along with utilizing
the Europarl corpus as unlabeled data. At the train-
ing of Bitpar, we followed the targeted self-training
approach (Katz-Brown et al, 2011) as follows. We
parsed the whole Europarl corpus using a grammar
trained on the Tiger corpus and extracted the 100-
best parse trees for each sentence. We selected the
parse tree among the 100 candidates which got the
highest usefulness scores for the reordering task.
Then we trained a new grammar on the concatena-
tion of the Tiger corpus and the automatic parses
from Europarl.
The usefulness score estimates the value of a
parse tree for the reordering task. We calculated
this score as the similarity between the word order
achieved by applying the parse tree-based reorder-
ing rules of Fraser (2009) and the word order indi-
cated by the automatic word alignment between
the German and English sentences in Europarl.
We used the Kendall?s Tau Distance as the simi-
larity metric of two word orderings (as suggested
by Birch and Osborne (2010)).
Following this, we performed linguistically-
informed compound splitting, using the system of
Fritzinger and Fraser (2010), which disambiguates
competing analyses from the high-recall Stuttgart
Morphological Analyzer SMOR (Schmid et al,
2004) using corpus statistics. We also split German
portmanteaus like zum? zu dem (meaning to the).
system BLEU BLEU system name
(ci) (cs)
DE-EN (OSM) 27.60 26.12 MES
DE-EN (OSM) 27.48 25.99 not submitted
BitPar not self-trained
DE-EN (Moses) 27.14 25.65 MES-Szeged-
reorder-split
DE-EN (Moses) 26.82 25.36 not submitted
BitPar not self-trained
EN-DE (Moses) 19.68 18.97 MES-reorder
Table 8: Results on WMT-2013 (blindtest)
English to German The task of mapping En-
glish SVO order to the different clausal orders in
German is difficult. For our English to German
systems, we solved this by parsing the English and
applying the system of Gojun and Fraser (2012) to
reorder English into the correct German clausal or-
der (depending on the clause type which is detected
using the English parse, see (Gojun and Fraser,
2012) for further details).
We primarily used the Charniak-Johnson gener-
ative parser (Charniak and Johnson, 2005) to parse
the English Europarl data and the test data. How-
ever, due to time constraints we additionally used
Berkeley parses of about 400K Europarl sentences
and the other English parallel training data. We
also left a small amount of the English parallel
training data unparsed, which means that it was
not reordered. For tune, test and blindtest (WMT-
2013), we used the Charniak-Johnson generative
parser.
Experiments and results We used all available
training data for constrained systems; results for
the WMT-2013 set are given in table 8. For the
contrastive BitPar results, we reparsed WMT-2013.
7 Conclusion
We presented 5 systems dealing with complex mor-
phology. For two language pairs with a morpho-
logically rich source language (FR and RU), the
input was reduced to a simplified representation
containing only translation-relevant morphologi-
cal information (e.g. number on nouns). We also
used reordering techniques for DE-EN and EN-DE.
For translating into a language with rich morphol-
ogy (EN-FR), we applied a two-step method that
first translates into a stemmed representation of
the target language and then generates inflected
forms based on morphological features predicted
on monolingual data.
237
Acknowledgments
We would like to thank the anonymous reviewers
for their helpful feedback and suggestions, Daniel
Quernheim for providing Berkeley parses of some
of the English data, Stefan Ru?d for help with the
manual evalution, and Philipp Koehn and Barry
Haddow for providing data and alignments.
Nadir Durrani was funded by the European
Union Seventh Framework Programme (FP7/2007-
2013) under grant agreement n. 287658. Alexan-
der Fraser was funded by Deutsche Forschungs-
gemeinschaft grant Models of Morphosyntax for
Statistical Machine Translation and from the Eu-
ropean Community?s Seventh Framework Pro-
gramme (FP7/2007-2013) under Grant Agreement
n. 248005. Marion Weller was funded from the
European Community?s Seventh Framework Pro-
gramme (FP7/2007-2013) under Grant Agreement
n. 248005. Svetlana Smekalova was funded by
Deutsche Forschungsgemeinschaft grant Models
of Morphosyntax for Statistical Machine Trans-
lation. Helmut Schmid and Max Kisselew were
supported by Deutsche Forschungsgemeinschaft
grant SFB 732. Richa?rd Farkas was supported by
the European Union and the European Social Fund
through project FuturICT.hu (grant n. TA?MOP-
4.2.2.C-11/1/KONV-2012-0013). This publication
only reflects the authors? views.
References
A. Abeille?, L. Cle?ment, and F. Toussenel. 2003. Build-
ing a treebank for french. In A. Abeille?, editor, Tree-
banks. Kluwer, Dordrecht.
Alexandra Birch and Miles Osborne. 2010. Lrscore for
evaluating lexical and reordering quality in mt. In
Proceedings of ACL WMT and MetricsMATR, Upp-
sala, Sweden.
Arianna Bisazza and Marcello Federico. 2012. Mod-
ified distortion matrices for phrase-based statistical
machine translation. In ACL, pages 478?487.
Sabine Brants, Stefanie Dipper, Silvia Hansen, Wolf-
gang Lezius, and George Smith. 2002. The TIGER
treebank. In Proceedings of the Workshop on Tree-
banks and Linguistic Theories.
Eugene Charniak and Mark Johnson. 2005. Coarse-
to-fine n-best parsing and MaxEnt discriminative
reranking. In ACL, pages 173?180, Ann Arbor, MI,
June. Association for Computational Linguistics.
Colin Cherry and George Foster. 2012. Batch tuning
strategies for statistical machine translation. In Pro-
ceedings of the North American Chapter of the Asso-
ciation for Computational Linguistics (NAACL).
Michael Collins, Philipp Koehn, and Ivona Kuc?erova?.
2005. Clause restructuring for statistical machine
translation. In Porceedings of ACL 2005.
Nadir Durrani, Helmut Schmid, and Alexander Fraser.
2011. A Joint Sequence Translation Model with In-
tegrated Reordering. In Proceedings of ACL-HLT
2011, Portland, Oregon, USA.
Nadir Durrani, Alexander Fraser, and Helmut Schmid.
2013a. Model With Minimal Translation Units, But
Decode With Phrases. In Proceedings of NAACL
2013, Atlanta, Georgia, USA.
Nadir Durrani, Helmut Schmid, Alexander Fraser, Has-
san Sajjad, and Richa?rd Farkas. 2013b. Munich-
Edinburgh-Stuttgart Submissions of OSM Systems
at WMT13. In Proceedings of the Eighth Workshop
on Statistical Machine Translation, Sofia, Bulgaria.
Anita Gojun Fabienne Braune and Alexander Fraser.
2012. Long-distance reordering during search for
hierarchical phrase-based SMT. In Proceedings of
EAMT 2012.
Alexander Fraser, Marion Weller, Aoife Cahill, and Fa-
bienne Cap. 2012. Modeling Inflection and Word-
Formation in SMT. In Proceedings of EACL 2012,
Avignon, France.
Alexander Fraser, Helmut Schmid, Richa?rd Farkas,
Renjing Wang, and Hinrich Schu?tze. 2013. Knowl-
edge sources for constituent parsing of German, a
morphologically rich and less-configurational lan-
guage. Computational Linguistics - to appear.
Alexander Fraser. 2009. Experiments in morphosyn-
tactic processing for translating to and from German.
In EACL WMT.
Fabienne Fritzinger and Alexander Fraser. 2010. How
to avoid burning ducks: Combining linguistic analy-
sis and corpus statistics for German compound pro-
cessing. In ACL WMT and Metrics MATR.
Anita Gojun and Alexander Fraser. 2012. Determin-
ing the placement of German verbs in English-to-
German SMT. In Proceedings of EACL 2012.
Jason Katz-Brown, Slav Petrov, Ryan McDon-
ald, Franz Och, David Talbot, Hiroshi Ichikawa,
Masakazu Seno, and Hideto Kazawa. 2011. Train-
ing a parser for machine translation reordering. In
Proceedings of EMNLP 2011, Edinburgh, Scotland.
Thomas Lavergne, Olivier Cappe?, and Franc?ois Yvon.
2010. Practical very large scale CRFs. In Proceed-
ings of ACL 2010, pages 504?513.
Preslav Nakov, Francisco Guzma?n, and Stephan Vo-
gel. 2012. Optimizing for sentence-level BLEU+1
yields short translations. Mumbai, India.
238
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2011. An algorithm for unsupervised transliteration
mining with an application to word alignment. In
Proceedings of ACL 2011, Portland, USA.
Hassan Sajjad, Alexander Fraser, and Helmut Schmid.
2012. A statistical model for unsupervised and semi-
supervised transliteration mining. In Proceedings of
ACL 2012, Jeju, Korea.
Hassan Sajjad, Svetlana Smekalova, Nadir Durrani,
Alexander Fraser, and Helmut Schmid. 2013.
QCRI-MES Submission at WMT13: Using Translit-
eration Mining to Improve Statistical Machine
Translation. In Proceedings of the Eighth Workshop
on Statistical Machine Translation, Sofia, Bulgaria.
Helmut Schmid and Florian Laws. 2008. Estimation
of conditional probabilities with decision trees and
an application to fine-grained pos tagging. In Pro-
ceedings of COLING 2008, Stroudsburg, PA, USA.
Helmut Schmid, Arne Fitschen, and Ulrich Heid. 2004.
SMOR: a German Computational Morphology Cov-
ering Derivation, Composition, and Inflection. In
Proceedings of LREC 2004.
Helmut Schmid. 1994. Probabilistic part-of-speech
tagging using decision trees. In Proceedings of the
International Conference on New Methods in Lan-
guage Processing.
Holger Schwenk and Philipp Koehn. 2008. Large
and diverse language models for statistical machine
translation. In Proceedings of IJCNLP 2008.
Serge Sharoff, Mikhail Kopotev, Tomaz Erjavec, Anna
Feldman, and Dagmar Divjak. 2008. Designing and
evaluating russian tagsets. In Proceedings of LREC
2008.
Kristina Toutanova, Hisami Suzuki, and Achim Ruopp.
2008. Applying Morphology Generation Models to
Machine Translation. In Proceedings of ACL-HLT
2008.
Zhenxia Zhou. 2007. Entwicklung einer franzo?sischen
Finite-State-Morphologie. Diploma Thesis, Insti-
tute for Natural Language Processing, University of
Stuttgart.
239
Proceedings of the EMNLP 2014 Workshop on Arabic Natural Langauge Processing (ANLP), pages 207?216,
October 25, 2014, Doha, Qatar.
c
?2014 Association for Computational Linguistics
Unsupervised Word Segmentation Improves
Dialectal Arabic to English Machine Translation
Kamla Al-Mannai
1
, Hassan Sajjad
1
, Alaa Khader
2
, Fahad Al Obaidli
1
,
Preslav Nakov
1
, Stephan Vogel
1
Qatar Computing Research Institute
1
, Carnegie Mellon University in Qatar
2
{kamlmannai,hsajjad,faalobaidli,pnakov,svogel}@qf.org.qa
1
, akhader@cmu.edu
2
Abstract
We demonstrate the feasibility of using
unsupervised morphological segmentation
for dialects of Arabic, which are poor in
linguistics resources. Our experiments us-
ing a Qatari Arabic to English machine
translation system show that unsupervised
segmentation helps to improve the transla-
tion quality as compared to using no seg-
mentation or to using ATB segmentation,
which was especially designed for Mod-
ern Standard Arabic (MSA). We use MSA
and other dialects to improve Qatari Ara-
bic to English machine translation, and we
show that a uniform segmentation scheme
across them yields an improvement of 1.5
BLEU points over using no segmentation.
1 Introduction
The Arabic language has many varieties, where
the Modern Standard Arabic (MSA) coexists with
various dialects. Dialects differ from MSA and
from each other lexically, phonologically, mor-
phologically and syntactically. MSA has stan-
dard orthography and is used in formal contexts
(e.g., publications, newspaper articles, etc.), while
the dialects are usually limited to daily verbal in-
teractions. However, with the recent rise of social
media, it has become increasingly common to use
dialects in written communication as well, which
has constituted the research in dialectal Arabic
(DA) as a separate field within the broader field
of natural language processing (NLP).
As DA NLP is still in its infancy, there is lack
of basic computational resources and tools, which
are needed in order to apply standard NLP ap-
proaches to the dialects of Arabic. For instance,
statistical approaches need a lot of training data,
which makes it very hard, if not impossible, to
apply them to resource-poor languages; this is
especially true for statistical machine translation
(SMT) of Arabic dialects.
The Arabic language and its dialects are highly
inflectional, and a word can appear in many more
inflected forms compared to English. Consider the
Arabic words

IJ
.
?? ,I
.
??K


,I
.
??

K, and
	
??J
.
??K


: they
all belong to one root word I
.
?? ?playing? /lEb/.
Each morphological variation is derived from a
root word with different affixes addressing differ-
ent functions. This causes data sparseness, and
covering all possible word forms of a root word
may not be always possible. Considering the dif-
ferent variants of Arabic, the problem is exacer-
abated as dialects could use different choices of af-
fixes for the same function. For example, the MSA
word
	
??J
.
??K


/yalEabuwn/, meaning ?they are play-
ing?, could be found as
	
??J
.
??K


/ylEbuwn/ in Gulf,
as @?J
.
??K


?? /Eam yilEabuA/ in Levantine, and as
@?J
.
??J


K
.
/biylEabwA/ in Egyptian Arabic.
One possible solution is to use a morphological
segmenter that segments words into simpler units
such as stems and affixes, which might be covered
in the training set (Zollmann et al., 2006; Tsai et
al., 2010). When applied to dialects, this may re-
duce the lexical gap between dialects and MSA by
matching the common stems. Unfortunately, there
are no standard morphological segmentation tools
for dialects. Due to the difference in morphology,
tools designed for MSA do not work well for di-
alects. Developing rule-based segmenters for each
dialect might appear to be the ideal solution, but,
as the orthography of dialects is not standardized,
crafting linguistic rules for them is very hard.
In this paper, we focus on training an unsuper-
vised model for word segmentation, which we ap-
ply to SMT for a given Arabic dialect. We train a
pre-existing unsupervised segmentation model on
the Arabic side of the training bi-text (and on some
other monolingual data), and then we optimize its
parameters based on the resulting SMT quality.
Similarly, a multi-dialectal word segmenter could
be developed by training on multi-dialectal data.
207
In particular, we develop a Qatari Arabic to En-
glish (QA-EN) SMT system, which we train on a
small pre-existing bi-text. As part of the devel-
opment of the unsupervised segmentation model,
we also collected some additional monolingual
data for Qatari Arabic. Qatari Arabic is a subdi-
alect of the more general Gulf dialect, among with
Saudi, Kuwaiti, Emirati, Bahraini, and Omani; we
collected additional monologual data for each of
these subdialects, and we release this data to the
research community.
We train an unsupervised segmentation tool,
Morphessor, and its MAP model (Creutz and La-
gus, 2007), using different variations of the col-
lected Qatari data. We optimize the single hy-
perparameter of the MAP model by maximizing
the translation quality of the QA-EN SMT sys-
tem in terms of BLEU. Our experimental results
demonstrate that the resulting unsupervised seg-
menter yields improvements in translation quality
when compared to (i) using no segmentation and
(ii) using an MSA-based ATB segmenter.
We further develop a multi-dialectal word seg-
mentation model, which we train on the Arabic
side of the multi-dialectal training data, which
consists of Qatari Arabic, Egyptian Arabic (EGY),
Levantine Arabic (LEV) and MSA to English,
i.e., a scaled combination of all the available par-
allel data. We train a QA-EN SMT system using
the segmented multi-dialectal data, and we show
an absolute gain of 1.5 BLEU points compared to
a baseline that uses no segmentation.
The rest of the paper is organized as follows:
First, we provide an overview of related work on
Dialectal Arabic NLP (Section 2). Next, we dis-
cuss and we illustrate the linguistic differences be-
tween different Arabic dialects in comparison with
and with a focus on Qatari Arabic (Section 3).
Then, we provide statistics about the corpora we
collected and used in our experiments, followed by
an illustration of the orthographic normalization
schemes we applied (Section 4). We next provide
a high-level description of our approach, which
uses morphological segmentation to combine re-
sources for other Arabic dialects in a QA-EN SMT
system effectively (Section 4.3). We also explain
our experimental setup and we present the results
(Section 5). We then discuss translating in the
reverse direction, i.e., into Qatari Arabic (Section
6). Finally, we point to possible directions for fu-
ture work and we conclude the paper (Section 7).
2 Related Work
NLP for DA is still in its early stages of develop-
ment and many challenges need to be overcomed
such as the lack of suitable tools and resources.
Collecting resources for dialectal Arabic:
Several researchers have directed efforts to de-
velop DA computational resources (Maamouri et
al., 2006; Al-Sabbagh and Girju, 2010; Zaidan and
Callison-Burch, 2011; Salama et al., 2014). Zbib
et al. (2012) built two dialectal Arabic-English
parallel corpora for Egyptian and Levantine Ara-
bic using crowdsourcing. Bouamor et al. (2014)
presented a multi-dialectal Arabic parallel corpus,
which covers five Arabic dialects besides MSA
and English. Mubarak and Darwish (2014) col-
lected a multi-dialectal corpus using Twitter. Un-
like previous work, we focus on Gulf subdialects,
particularly Qatari Arabic. The monolingual data
that we collected is a high-quality dialectal re-
source and originates from dialect-specific sources
such as novels and forums.
Adapting SMT resources for other Arabic di-
alects: Many researchers have explored the po-
tential of using MSA as a pivot language for im-
proving SMT of Arabic dialects (Bakr et al., 2008;
Sawaf, 2010; Salloum and Habash, 2011; Sajjad et
al., 2013a; Jeblee et al., 2014). This often involves
DA-MSA conversion schemes as an alternative in
the absence of DA-MSA parallel resources. In
contrast, limited work has been done on lever-
aging available resources for other dialects. Re-
cently, Zbib et al. (2012) have shown that using
a small amount of dialectal data could yield great
improvements for SMT. Here, we investigate the
potential of improving the resource adaptability of
Arabic dialects. Our work is different as we use
an unsupervised segmenter that helps in improv-
ing the lexical overlap between dialects and MSA.
Building morphological segmenters for the
Arabic dialects: Researchers have already fo-
cused efforts on crafting and extending existing
MSA tools to DA by mainly using a set of rules
(Habash et al., 2012). Habash and Rambow
(2006) presented MAGEAD, a knowledge-based
morphological analyzer and generator for Egyp-
tian and Levantine Arabic. Chiang et al. (2006)
developed a Levantine morphological analyzer on
top of an existing MSA analyzer using an explicit
knowledge base.
208
Riesa and Yarowsky (2006) trained a supervised
trie-based model using a small lexicon of dialec-
tal affixes. In our work, we eliminate the need
for linguistic knowledge by training an unsuper-
vised model using available resources. The unsu-
pervised mode of learning allowed us to develop a
multi-dialectal morphological segmenter.
3 Arabic Dialects
In this section, we highlight some of the linguis-
tic differences between Arabic dialects and MSA,
with a focus on the Qatari dialect.
3.1 Phonological Variations
The Gulf dialect often preserves the phonological
representation of MSA, which is not the case with
many other Arabic dialects. For example, in Egyp-
tian (EGY) and in some Levantine (LEV) dialects,
the MSA consonants

H /v/,

? /q/, and
	
X /*/ are
realized as

H /t/, glottal stop /?/, and
	
? /Z/, re-
spectively. While, their MSA pronunciations are
preserved in Gulf Arabic.
In Gulf Arabic, there are some phonological dif-
ferences between countries such as Kuwait (KW),
Saudi Arabia (SA), Bahrain (BH), Qatar (QA),
United Arab Emirates (AE), and Oman (OM).
Here, we focus our discussion on Qatari Arabic,
and we compare it to MSA and other dialects.
The QA dialect borrows two Persian characters
namely h

/J/ and

? /V/. For instance, the MSA
letter h
.
/j/ is converted to /J/ in QA, e.g., ?A?

Jk
.
@

?meeting? is pronounced as /<jtimAE/ in MSA
and /<JtimAE/ in QA. The Persian character h

/J/
is also used in place of ? /k/ in some MSA words
when they are used in QA. For example, ??
?
?
?fish?
/samak/ is pronounced i

?
?
?
/smaJ/ in QA, while
the EGY and the LEV dialects maintain the MSA
pronunciation. The Persian

? /V/ is used to map
the sound of the English letter ?v? in borrowed for-
eign words, e.g., ?K


YJ


	
? ?video? is pronounced as
?K


YJ



? /Viydyw/ as opposed to /fiydywu/; the form
in which it is written in MSA.
The MSA consonant
	
? /D/ is not used in the
QA dialect. It is substituted by
	
? /Z/ in Qatari. For
example, the MSA pronunciation /HaD/ of
	
?k
?to encourage? is transformed to
	
?k /HaZ/ in QA,
but it is maintained in EGY.
Meanwhile, the MSA consonant
	
? /Z/ is re-
alized as /D/ in EGY. For example, the MSA
pronunciation /HaZ/ of
	
?k ?luck? is maintained
in QA and transformed to /HaD/ in EGY. This
change is consistent in all words within each di-
alect. However, such phonological variations be-
tween dialects have the potential to add ambiguity
to dialectal Arabic.
The MSA consonant h
.
/j/ can be used to distin-
guish between different dialects, particularly Gulf
subdialects. h
.
/j/ is pronounced as ?


/y/ in KW,
BH, QA, AE,

? /q/ in OM, much like in EGY,
and h
.
/j/ in SA, much like in LEV. For exam-
ple, the MSA word Yj
.
?? ?mosque? /masjid/ is
pronounced as /masjid/ in MSA, SA, LEV, Y

???
/masqid/ in OM, EGY, YJ


?? /masyid/ in KW,
BH, QA, AE, while the MSA pronunciation is
preserved in SA. This change does not apply to
names. However, we should note that it is not con-
sistent in QA, e.g., the MSA pronunciation of h
.
/j/
in ?J
.
k
.
?mountain? /jabal/ and h
.
QK
.
?tower? /burj/ is
preserved in QA.
3.2 Morphological Variations
In Arabic, a root can produce surface wordforms
by means of inflectional and derivational morpho-
logical processes (Habash, 2010).
An inflectional word form is a variant of a root
word with the same meaning but expressing a dif-
ferent function, e.g., gender, number, case. It is
usually formed by adding a prefix, a suffix, or a
circumfix to a stem word. Note that Arabic di-
alects can make different lexical choices for affix-
ations compared to MSA. For example, the MSA
future prefix ? /s/ is replaced by H
.
/b/ in QA
and by ? /h/ in EGY and LEV. Thus, the MSA
word ??

AJ


? ?he will eat? /say>kul/ becomes ?? AJ


K
.
/biyAkil/ in QA and ?? AJ


? /hayAkul/ in EGY and
LEV.
A derivational word form is formed by applying
a pattern to a root word, e.g., ?player? is derived
from ?play? using the pattern noun + ?er?. An
example of an Arabic derivational form is ??
	
?

K
?do? /tafaE?al/. The root is ??
	
? /faEal/ and it uses
the imperative pattern

H+??
	
?. In EGY, @ /A/ is
added as a prefix; so, it becomes ??
	
?

K@ /AitfaE
?
il/.
209
Meanwhile, the original form is preserved in QA.
Changing the structure of a pattern in a dialect
will result in producing a new dialect-specific or-
thography for every word that is represented by the
structure. For example, the MSA word ??
?

K
?learn?
/taEal?am/ becomes ??
?

K
@ /AitEalim/ in EGY, while
the MSA form is preserved in QA.
3.3 Lexical Variations
Lexical variations are among the most obvious
differences between Arabic dialects. For exam-
ple, the MSA word @
	
XA? ?what? /mA*A/ would be
found as ?

? /$uw/ in LEV, ?K


@

/<yh/ in EGY, and
?
	
J

? /$nuw/ in GLF. We can find lexical variations
in subdialects as well. For example, the MSA
negation word
	
?? /lan/, ?not?, is expressed as I
.
?
/mab/ in QA, as ?? /muw/ in KW, and as I
.
?? /ma-
hab/ in SA.
3.4 Orthographic Variations
Due to the lack of orthographic standardization of
dialectal Arabic, some MSA words can be found
in dialectal text with both MSA and phonologi-
cal spellings. For example, the MSA word

???
g
.
?gathering? /jamEap/ can be also spelled as ???
?

/yamEah/, which is a phonetic variation in QA.
Some dialectal words also vary in spelling due
to variation in their pronunciation, e.g.,
	
??

?

@
/A$uwf/, a QA word meaning ?I see?, can be also
spelled as
	
??k
.
@ /Ajuwf/.
In dialectal Arabic, different orthographic
forms are also possible for entire phrases. For
instance, words followed or preceded by pro-
nouns are commonly reduced to a single word,
e.g., A??

I?

? /glt lahA/ ?I told her? is written as
A??

J?

?. Also, commonly used religious phrases can
be found written as a single unit, e.g., ?<? @ Z A

? A?
/mA $A? A
?
lah/ ?God has willed it? as ?<?A

??.
4 Methodology
In the section, we present some statistics about the
Arabic dialectal data that we have collected. We
processed it to remove orthographic inconsisten-
cies. Then, we used a pre-existing unsupervised
morphological segmenter, Morfessor, in order to
segment the text.
Corpus QCA AVIA
QA
AVIA
O
Sents 14.7 0.9 2
Tokens 115 6.7 15
Table 1: Statistics about the collected parallel cor-
pora (in thousands). AVIA
O
shows the statistics
about the AVIA corpus excluding Qatari data.
4.1 Data Collection
We did an extensive search for available monolin-
gual and bilingual resources for the Gulf dialect,
with a focus on Qatari Arabic. Tables 1 and 2
present some statistics about the corpora we col-
lected. More detailed description follows below.
Bilingual corpora:
? The QCA speech corpus, comprises 14.7k
sentences that are phonetically transcribed from
TV broadcasts in Qatari Arabic and translated to
English; see (Elmahdy et al., 2014) for more de-
tail. The corpus was designed for speech recog-
nition and we faced several normalization-related
issues that we had to resolve before it could be
used for machine translation and language mod-
eling. One example is the usage of five Per-
sian characters to represent some sounds in Ara-
bic words. Moreover, the English side had some
grammatical and spelling errors. We normalized
the Arabic side and corrected the English side of
the corpus as described in Section 4.2. The cor-
pus can be found at http://sprosig.isle.
illinois.edu/corpora/1.
? The AVIA corpus
1
is designed as a refer-
ence source of dialectal Arabic. It consists of 3k
sentences in four Gulf subdialects: Emirati (AE),
Kuwaiti (KW), Qatari (QA), and Hejazi (SA).
2
The data consists of dialectal sentences that con-
tain words commonly used in daily conversation.
Monolingual corpora: We further collected
monolingual corpora consisting of a total of 2.7M
tokens for various Gulf subdialects. The Qatari
part of the data consists of 470K tokens. Most of
the corpus is a collection of novels, belonging to
the romance genre.
3
For the Qatari dialect, we also
collected Qatari forum data.
4
1
http://terpconnect.umd.edu/
?
nlynn/
AVIA/Level3/
2
The website also contains small parallel corpora for
MSA, EGY and LEV to English, but here we focus on Gulf
subdialects only.
3
http://forum.te3p.com/264311-52.html
4
www.qatarshares.com/vb/index.php
210
Corpus Novel Forum
AE BH KW OM QA SA QA
Tokens 573 244 178 372 412 614 69
Types 43 22 27 27 43 71 15
Table 2: Statistics about the collected monolingual
corpora (in thousands of words).
To the best of our knowledge, this is the first
collection of monolingual corpora for Gulf Ara-
bic subdialects. It can be helpful for, e.g., lan-
guage modeling when translating into Arabic, for
learning the similarities and differences between
Gulf subdialects, etc. Table 2 shows some statis-
tics about the data after punctuation tokenization.
4.2 Orthographic Normalization
The inconsistency in the orthographic spelling of
the same word can increase data sparseness. Thus,
we normalize the Arabic text in the collected re-
sources by applying the reduced orthographic nor-
malization scheme, e.g., Tah Marbota is reduced to
Hah. We also normalize extended lines between
letters, e.g., Q?? ?sugar? /sukar/ is changed
to Q??, and we reduce character elongations to
be just two characters long. In order to main-
tain consistency among different resources, we re-
move supplementary diacritics, e.g.,

Y


?

? ?knots?
/Euqad/ is normalized to Y

??, and we map Per-
sian letters to their phonological correspondences
in Qatari Arabic
5
, i.e., ? /G/ to

? /g/,

? /V/ to
	
?
/f/, H

/P/ to H
.
/b/, and

P and h

/J/ to h
.
/j/.
For the English texts, the orthographic varia-
tions were already normalized. However, the En-
glish side of the QCA corpus had some spelling
and grammatical errors, which we corrected man-
ually. On the grammatical side, we only corrected
a subset of the data, which we used for tuning and
testing our SMT system (see Section 5).
4.3 Morphological Decomposition
There is no general Arabic morphological seg-
menter that works for all variations of Arabic. The
most commonly used segmenters for Arabic were
designed for MSA (Habash et al., 2009; Green and
DeNero, 2012). Due to the lexical and morpholog-
ical differences between dialects and MSA, these
MSA-based morphological tools do not work well
for dialects.
5
This issue relates to the QCA corpus.
In this work, we used an unsupervised morpho-
logical segmenter, Morfessor-categories MAP
6
,
an unsupervised model with a single hyper-
parameter (Creutz and Lagus, 2007). We chose
Morfessor because of its superior performance on
Arabic compared to other unsupervised models
(Siivola et al., 2007; Poon et al., 2009).
The model has a single hyperparameter, the per-
plexity threshold parameter B, which controls the
granularity of segmentation. The recommended
value ranges from 1 to 400 where 1 means max-
imum fine-grained segmentation, and 400 restricts
it to the least segmented output. We set the thresh-
old empirically to 70, as shown in Section 5.1.
5 Experimental Setup
We performed an extrinsic evaluation of the varia-
tions in segmentation by building a Qatari Arabic
to English machine translation system on each of
them. We also tested Morfessor on other available
dialects and on MSA, and we will show below how
a uniform segmentation can help to better adapt re-
sources for dialects and MSA for SMT. This sec-
tion describes our experimental setup.
Datasets: We divided the QCA corpus into 1k
sentences each for development and testing, and
we used the remaining 12k for training.
We adapted parallel corpora for Egyptian, Lev-
antine and MSA to English to be used for Qatari
Arabic to English SMT. For MSA, we used par-
allel corpora of TED talks (Cettolo et al., 2012)
and the AMARA corpus (Abdelali et al., 2014),
which consists of educational videos. Since the
QCA corpus is in the speech domain, we believe
that an MSA corpus of spoken domain would be
more helpful than a text domain such as News. For
Egyptian and Levantine, we used the parallel cor-
pus provided by Zbib et al. (2012). There is no
Gulf?English parallel data available in the litera-
ture. The data that we found was a very small col-
lection of subdialects of Gulf Arabic; we did not
use it for MT experiments. However, we used the
Qatari part of the AVIA corpus to train Morfessor.
Machine translation system settings: We used
a phrase-based statistical machine translation
model as implemented in the Moses toolkit
(Koehn et al., 2007) for machine translation.
6
This is an extension of the basic Morfessor method and
is based on a Maximum a Posteriori model.
211
We built separate directed word alignments
for source-to-target and target-to-source using
IBM model 4 (Brown et al., 1993), and we
symmetrized them using the grow-diag-final-and
heuristics (Koehn et al., 2003). We then extracted
phrase pairs with a maximum length of seven, and
we scored them using maximum likelihood esti-
mation with Kneser-Ney smoothing (Kneser and
Ney, 1995). We also built a lexicalized reordering
model, msd-bidirectional-fe. We built a 5-gram
language model on the English side of QCA-train
using KenLM (Heafield, 2011). Finally, we built a
log-linear model using the above features.
We tuned the model weights by optimizing
BLEU (Papineni et al., 2002) on the tuning set, us-
ing PRO (Hopkins and May, 2011) with sentence-
level BLEU+1 optimization (Nakov et al., 2012).
In testing, we used minimum Bayes risk decoding
(Kumar and Byrne, 2004), cube pruning, and the
operation sequence model (Durrani et al., 2011).
Baseline: Our baseline Qatari Arabic to English
MT system is trained on the QCA bitext without
any segmentation of Qatari Arabic. For the exper-
iments described in this paper, we used the English
side of the QCA corpus for language modeling.
5.1 Experimental Results
In this section, we first present our work on using
Morfessor for segmenting Qatari Arabic. We tried
different values of its parameter, and we trained it
using corpora of different sizes to find balanced
settings that improve SMT quality as compared
with no segmentation and with segmentation us-
ing the Stanford ATB segmenter. We further ap-
plied our selected settings to segment MSA, EGY
and LEV and used them for Qatari Arabic to En-
glish machine translation. Our results show that a
uniform segmentation scheme across different di-
alects improves machine translation.
Morfessor training variations: We trained
Morfessor using three corpora: (i) QCA,
(ii) AVIA
QA
plus Qatari Novels, and (iii) a com-
bination thereof. Table 3 shows the results for
our SMT system when trained on the QCA par-
allel corpus, which was segmented using different
training models of Morfessor with B = 40. The
result for segmented Qatari Arabic is always bet-
ter than the baseline, irrespective of the training
model used for segmentation. We can see that the
Morfessor model trained on a large monolingual
corpus, i.e., on (ii) or (iii), yields better results.
Morfessor BLEU OOV%
Baseline 12.2 16.6
QCA 12.5 0.6
AVIA
QA
, Novels 13.5 0.8
QCA, AVIA
QA
, Novels 13.4 0.7
Table 3: Study of the effect of varying the train-
ing datasets for Morfessor on the Qatari to English
SMT. ?Baseline? shows the output of the MT sys-
tem with no segmentation.
B 10 40 70 100 130
BLEU 13.3 13.5 13.8 12.9 12.6
OOV 0.3 0.8 1.4 2.8 2.8
After merging
BLEU 12.5 13.4 13.7 12.8 12.3
OOV 1.5 1.9 3.9 6.5 9.8
Table 4: The effect of varying the perplexity
threshold parameter B of Morfessor on SMT qual-
ity. ?After merging? are the results using the post-
processed Qatari segmented data.
The high reduction in OOV in Table 3 is be-
cause of the fine-grained segmentation. We tried
different values for the perplexity parameter B
in order to find a good balance between better
BLEU scores and linguistically correct segmen-
tations. The first part of Table 4 shows the ef-
fect of different values of B on the quality of the
machine translation system trained on AVIA
QA
,
Qatari Novels. We achieved the best SMT score at
B = 70.
We further analyzed the output of Morfessor
at B = 70 and we noticed that it tends to gener-
ate very small segments of length two and three
characters long. The segmentation produces more
than one stem in a word and does not generate le-
gal word units. For example, the word

??A
	
J??@?
?and the industry? /wAlSinAEp/ is segmented as
PRE/? + PRE/?@ + STM/? + PRE/
	
? + PRE/ @
+ STM/? + SUF/

?. We apply a post-processing
step that merges all stems in a word and affixes
between them to one stem. So, a word can have
only one stem. For example, the word

??A
	
J??@?
would be segmented as PRE/?@? + STM/?A
	
J? +
SUF/

?. This yielded linguistically correct segmen-
tations in many cases. The second part of Table
4 shows the effect of the post-processing on the
BLEU score. We can see that it remains almost
the same with an increase in OOV rate.
212
For rest of the experiments in this paper, we
used a value of 70 for the perplexity threshold
parameter plus the post-processing on segmenta-
tion. We trained Morfessor on the concatenation
of QCA, AVIA
Q
A and Novels.
7
Using other Arabic variations: In this section,
we present experiments using MSA, EGY and
LEV to English bitexts combined with the QCA
bitext for Qatari Arabic to English machine trans-
lation. We explored three segmentation options for
the Arabic side of the data: (i) no segmentation,
(ii) ATB segmentation, and (iii) unsupervised seg-
mentation using Morfessor.
The QCA corpus is of much smaller size com-
pared to other Arabic variants, say MSA. It is pos-
sible that in the training of the machine transla-
tion models, the large corpus dominates the QCA
corpus. In order to avoid that, we balanced the
two corpora by replicating the smaller corpus X
number of times in order to make it approximately
equal to the large corpus (Nakov and Ng, 2009).
8
The complete procedure is described below.
In a nutshell, for building a machine transla-
tion system using the MSA plus Qatari corpus, we
first balanced the Qatari corpus to make it approx-
imately equal to MSA and concatenated them. For
training Morfessor, the Qatari Arabic data con-
sisted of QCA, Novels and AVIA
QA
, while for
SMT, it consisted of QCA only. In both cases,
we balanced it to be approximately equal to MSA.
We then trained Morfessor on the balanced (QCA,
Novels, AVIA
QA
) plus MSA data and we seg-
mented the Arabic side of the balanced QCA plus
MSA training data for machine translation. We
built a machine translation system on the seg-
mented data. We segmented the testing and tuning
data sets similarly. We used the same balancing
when we combined EGY-EN and LEV-EN with
the Qatari Arabic ? English data.
We also tried training multiple unsupervised
models, but this yielded lower SMT quality com-
pared to using a single model trained on multi-
dialects. Using different models could result
in having different segmentation schemes, which
might not help in reducing the vocabulary mis-
match between different variants of Arabic.
7
We did not see a big difference in training Morfessor
with and without the QCA corpus, and we decided to use
the complete data for training.
8
Due to the spoken nature of the QCA corpus, it contains
shorter sentences. Thus, we balanced the corpora based on
the number of tokens rather than on the number of sentences.
Train NONE ATB Morfessor
QCA 12.2 12.9 13.7
?QCA,MSA 12.7 13.3 14.6
?QCA,EGY 13.0 13.5 14.5
?QCA,LEV 13.8 13.7 15.2
Table 5: BLEU scores for Qatari Arabic to English
SMT using three different segmentation settings.
?QCA means the modified QCA corpus with num-
ber of tokens approximately equal to MSA, EGY
and LEV in the respective experiments.
Table 5 shows the results. There are two things
to point here. First, the SMT systems that used
the unsupervised morphological segmenter, Mor-
fessor, outperformed the systems that used no seg-
mentation and those using the ATB segmentation.
The Morfessor-based systems showed consistent
improvements compared to the ATB-based sys-
tems over the no-segmentation systems. This val-
idates our point that unsupervised morphological
segmentation generalizes well for a variety of di-
alects and these SMT results complement that.
The second observation is that adding a bitext for
other dialects and MSA improves machine trans-
lation quality for Qatari?English SMT.
6 Translation into Qatari Arabic
Our monolingual corpora of Gulf subdialects
could be also helpful when translating English into
Qatari Arabic. We conducted a few basic experi-
ments in this direction but without segmentation.
We trained an English to Qatari Arabic SMT
system on the QCA bitext, using the same settings
as described in Section 5. We then normalized the
output of the translation system using the QCRI-
Normalizer (Sajjad et al., 2013b).
9
As a language
model, we used the Arabic side of the QCA cor-
pus, novels and forum data, standalone and to-
gether. Table 6 presents the results of the effect of
varying the language model on the quality of the
SMT system. The best system shows an improve-
ment of 0.22 BLEU points absolute compared to
the baseline system that only uses the Arabic side
of the QCA corpus for LM training.
The SMT system achieved the largest gain when
adding QA forum data to the QCA data. SA and
AE monolingual data also showed good improve-
ments. This might be due to their relatively large
sizes; we need further investigation.
9
http://alt.qcri.org/tools/
213
LM BLEU
QCA 2.78
QCA+QA-Novels 2.64
QCA+QA-Novels+BH-Novels 2.86
QCA+QA-Novels+KW-Novels 2.78
QCA+QA-Novels+AE-Novels 2.92
QCA+QA-Novels+SA-Novels 2.96
QCA+ALL-Novels 2.80
QCA+QA-Novels+QForum 3.00
Table 6: Results for English to Qatari SMT for
varying language models. In all cases, the transla-
tion model is trained on the QCA bitext only.
Note the quite low BLEU scores, especially
compared to the reverse translation direction. One
reason is the morphologically rich nature of Qatari
Arabic, which makes translating into it a hard
problem. The small amount of training data fur-
ther adds to it. We expect to see larger gains com-
pared to Qatari Arabic to English machine transla-
tion when segmentation is used.
7 Conclusion and Future Work
We have demonstrated the feasibility of using
an unsupervised morphological segmenter to in-
crease the resource adaptability of Arabic variants.
We evaluated the segmentation on a Qatari dialect
by building a Qatari Arabic to English machine
translation system. We further adapted MSA,
EGY and LEV in the simplest machine translation
settings and we showed a consistent improvement
of 1.5 BLEU points when compared to the respec-
tive baseline system that uses no segmentation.
In the future, we would like to explore the
impact of segmentation on both the translation
model and the language model when translating
into Qatari Arabic. This involves greater chal-
lenges, as a desegmenter is required for the trans-
lation output with every segmentation scheme.
References
Ahmed Abdelali, Francisco Guzman, Hassan Sajjad,
and Stephan Vogel. 2014. The AMARA corpus:
Building parallel language resources for the educa-
tional domain. In Proceedings of the 9th Interna-
tional Conference on Language Resources and Eval-
uation, Reykjavik, Iceland, May.
Rania Al-Sabbagh and Roxana Girju. 2010. Mining
the web for the induction of a dialectical Arabic lexi-
con. In Proceedings of the 7th International Confer-
ence on Language Resources and Evaluation, Val-
letta, Malta, May.
Hitham Abo Bakr, Khaled Shaalan, and Ibrahim
Ziedan. 2008. A hybrid approach for convert-
ing written Egyptian colloquial dialect into dia-
critized Arabic. In Proceedings of the 6th Inter-
national Conference on Informatics and Systems,
Cairo, Egypt, March.
Houda Bouamor, Nizar Habash, and Kemal Oflazer.
2014. A multidialectal parallel corpus of Arabic. In
Proceedings of the 9th edition of the Language Re-
sources and Evaluation Conference, Reykjavik, Ice-
land, May.
Peter F. Brown, Stephen A. Della Pietra, Vincent J.
Della Pietra, and R. L. Mercer. 1993. The mathe-
matics of statistical machine translation: parameter
estimation. Computational Linguistics, 19(2), June.
Mauro Cettolo, Christian Girardi, and Marcello Fed-
erico. 2012. Wit
3
: Web inventory of transcribed
and translated talks. In Proceedings of the 16
th
Con-
ference of the European Association for Machine
Translation, Trento, Italy, May.
David Chiang, Mona Diab, Nizar Habash, Owen Ram-
bow, and Safiullah Shareef. 2006. Parsing Arabic
dialects. In Proceedings of the 11th Conference of
the European Chapter of the Association for Com-
putational Linguistics, Trento, Italy, April.
Mathias Creutz and Krista Lagus. 2007. Unsuper-
vised models for morpheme segmentation and mor-
phology learning. ACM Transactions on Speech and
Language Processing, 4(1), January.
Nadir Durrani, Helmut Schmid, and Alexander Fraser.
2011. A joint sequence translation model with in-
tegrated reordering. In Proceedings of the 49th An-
nual Meeting of the Association for Computational
Linguistics: Human Language Technologies, Port-
land, OR, June.
Mohamed Elmahdy, Mark Hasegawa-Johnson, and
Eiman Mustafawi. 2014. Development of a TV
broadcasts speech recognition system for Qatari
Arabic. In Proceedings of the 9th edition of the Lan-
guage Resources and Evaluation Conference, Reyk-
javik, Iceland, May.
Spence Green and John DeNero. 2012. A class-based
agreement model for generating accurately inflected
translations. In Proceedings of the 50th Annual
Meeting of the Association for Computational Lin-
guistics, Jeju Island, Korea, July.
Nizar Habash and Owen Rambow. 2006. MAGEAD:
a morphological analyzer and generator for the Ara-
bic dialects. In Proceedings of the 21st International
Conference on Computational Linguistics and the
44th annual meeting of the Association for Compu-
tational Linguistics, Sydney, Australia, July.
Nizar Habash, Owen Rambow, and Ryan Roth. 2009.
Mada+TOKAN: A toolkit for Arabic tokenization,
diacritization, morphological disambiguation, pos
214
tagging, stemming and lemmatization. In Proceed-
ings of the 2nd International Conference on Ara-
bic Language Resources and Tools (MEDAR), Cairo,
Egypt, April.
Nizar Habash, Ramy Eskander, and Abdelati Hawwari.
2012. A morphological analyzer for Egyptian Ara-
bic. In Proceedings of the 12th Meeting of the Spe-
cial Interest Group on Computational Morphology
and Phonology, Montreal, Canada, June.
Nizar Y Habash. 2010. Introduction to Arabic natural
language processing. Synthesis Lectures on Human
Language Technologies, 3(1), August.
Kenneth Heafield. 2011. KenLM: Faster and smaller
language model queries. In Proceedings of the 6th
Workshop on Statistical Machine Translation, Edin-
burgh, UK, July.
Mark Hopkins and Jonathan May. 2011. Tuning as
ranking. In Proceedings of the Conference on Em-
pirical Methods in Natural Language Processing,
Scotland, UK, July.
Serena Jeblee, Weston Feely, Houda Bouamor, Alon
Lavie, Nizar Habash, and Kemal Oflazer. 2014.
Domain and Dialect Adaptation for Machine Trans-
lation into Egyptian Arabic. In Proceedings of
the Arabic Natural Language Processing Workshop,
Doha, Qatar, October.
Reinhard Kneser and Hermann Ney. 1995. Improved
backing-off for ngram langauge modeling. In Pro-
ceedings of the IEEE International Conference on
Acoustics, Speech and Signal Processing, Detroit,
Michigan, May.
Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proceed-
ings of the Human Language Technology and North
American Association for Computational Linguis-
tics Conference, Edmonton, Canada, May.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proceedings of the 45th Annual Meeting of the Asso-
ciation for Computational Linguistics, Demonstra-
tion Program, Prague, Czech Republic, June.
Shankar Kumar and William Byrne. 2004. Minimum
bayes-risk decoding for statistical machine transla-
tion. In Proceedings of the Human Language Tech-
nology Conference of the North American Chapter
of the Association for Computational Linguistics,
Boston, MA, May.
Mohamed Maamouri, Ann Bies, Tim Buckwalter,
Mona Diab, Nizar Habash, Owen Rambow, and
Dalila Tabessi. 2006. Developing and using a pi-
lot dialectal Arabic treebank. In Proceedings of
the 5th International Conference on Language Re-
sources and Evaluation, Genova, Italy, May.
Hamdy Mubarak and Kareem Darwish. 2014. Using
Twitter to collect a multi-dialectal corpus of Arabic.
In Proceedings of the Arabic Natural Language Pro-
cessing Workshop, Doha, Qatar, October.
Preslav Nakov and Hwee Tou Ng. 2009. Improved
statistical machine translation for resource-poor lan-
guages using related resource-rich languages. In
Proceedings of the 2009 Conference on Empirical
Methods in Natural Language Processing, Suntec,
Singapore, August.
Preslav Nakov, Francisco Guzman, and Stephan Vo-
gel. 2012. Optimizing for sentence-level BLEU+1
yields short translations. In Proceedings of the
24th International Conference on Computational
Linguistics, Mumbai, India, December.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. Bleu: a method for automatic
evaluation of machine translation. In Proceedings
of the 40th annual meeting on association for com-
putational linguistics, Philadelphia, PA, July.
Hoifung Poon, Colin Cherry, and Kristina Toutanova.
2009. Unsupervised morphological segmentation
with log-linear models. In Proceedings of Human
Language Technologies: The 2009 Annual Confer-
ence of the North American Chapter of the Asso-
ciation for Computational Linguistics, Denver, CO,
June.
Jason Riesa and David Yarowsky. 2006. Minimally
supervised morphological segmentation with appli-
cations to machine translation. In Proceedings of
the 7th Conference of the Association for Machine
Translation in the Americas, MA, USA, August.
Hassan Sajjad, Kareem Darwish, and Yonatan Be-
linkov. 2013a. Translating dialectal Arabic to En-
glish. In Proceedings of the 51st Annual Meeting
of the Association for Computational Linguistics,
Sofia, Bulgaria, August.
Hassan Sajjad, Francisco Guzman, Preslav Nakov,
Ahmed Abdelali, Kenton Murray, Fahad Al Obaidli,
and Stephan Vogel. 2013b. QCRI at IWSLT 2013:
Experiments in Arabic-English and English-Arabic
Spoken Language Translation. In Proceedings of the
10th International Workshop on Spoken Language
Translation, Hiedelberg, Germany, December.
Ahmed Salama, Houda Bouamor, Behrang Mohit, and
Kemal Oflazer. 2014. YouDACC: the youtube di-
alectal Arabic commentary corpus. In Proceedings
of the 9th edition of the Language Resources and
Evaluation Conference, Reykjavik, Iceland, May.
Wael Salloum and Nizar Habash. 2011. Dialectal
to standard Arabic paraphrasing to improve Arabic-
English statistical machine translation. In Proceed-
ings of the First Workshop on Algorithms and Re-
sources for Modelling of Dialects and Language Va-
rieties, Edinburgh, Scotland, July.
215
Hassan Sawaf. 2010. Arabic dialect handling in hybrid
machine translation. In Proceedings of the 9th Con-
ference of the Association for Machine Translation
in the Americas, Denver, CO, October.
Vesa Siivola, Mathias Creutz, and Mikko Kurimo.
2007. Morfessor and VariKN machine learning
tools for speech and language technology. In
Proceedings of the 8th International Conference
on Speech Communication and Technology (Inter-
speech), Antwerpen, Belgium, August.
Ming-Feng Tsai, Preslav Nakov, and Hwee Tou Ng.
2010. Morphological analysis for resource-poor
machine translation. Technical report, Kent Ridge,
Singapore, December.
Omar F Zaidan and Chris Callison-Burch. 2011. The
Arabic online commentary dataset: an annotated
dataset of informal Arabic with high dialectal con-
tent. In Proceedings of the 49th Annual Meeting of
the Association for Computational Linguistics: Hu-
man Language Technologies: short papers-Volume
2, Portland, OR, June.
Rabih Zbib, Erika Malchiodi, Jacob Devlin, David
Stallard, Spyros Matsoukas, Richard Schwartz, John
Makhoul, Omar F. Zaidan, and Chris Callison-
Burch. 2012. Machine translation of Arabic di-
alects. In Proceedings of the 2012 Conference of
the North American Chapter of the Association for
Computational Linguistics: Human Language Tech-
nologies, Montreal, Canada, June.
Andreas Zollmann, Ashish Venugopal, and Stephan
Vogel. 2006. Bridging the inflection morphol-
ogy gap for Arabic statistical machine translation.
In Proceedings of the Human Language Technol-
ogy Conference of the NAACL, Companion Volume:
Short Papers, New York, NY, June.
216
