Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the ACL, pages 92?100,
Boulder, Colorado, June 2009. c?2009 Association for Computational Linguistics
Efficiently Parsable Extensions to Tree-Local Multicomponent TAG
Rebecca Nesson
School of Engineering
and Applied Sciences
Harvard University
Cambridge, MA
nesson@seas.harvard.edu
Stuart M. Shieber
School of Engineering
and Applied Sciences
Harvard University
Cambridge, MA
shieber@seas.harvard.edu
Abstract
Recent applications of Tree-Adjoining Gram-
mar (TAG) to the domain of semantics as well
as new attention to syntactic phenomena have
given rise to increased interested in more ex-
pressive and complex multicomponent TAG
formalisms (MCTAG). Although many con-
structions can be modeled using tree-local
MCTAG (TL-MCTAG), certain applications
require even more flexibility. In this pa-
per we suggest a shift in focus from con-
straining locality and complexity through tree-
and set-locality to constraining locality and
complexity through restrictions on the deriva-
tional distance between trees in the same tree
set in a valid derivation. We examine three
formalisms, restricted NS-MCTAG, restricted
Vector-TAG and delayed TL-MCTAG, that
use notions of derivational distance to con-
strain locality and demonstrate how they
permit additional expressivity beyond TL-
MCTAG without increasing complexity to the
level of set local MCTAG.
1 Introduction
Tree-Adjoining Grammar (TAG) has long been pop-
ular for natural language applications because of its
ability to naturally capture syntactic relationships
while also remaining efficient to process. More re-
cent applications of TAG to the domain of seman-
tics as well as new attention to syntactic phenomena
such as scrambling have given rise to increased in-
terested in multicomponent TAG formalisms (MC-
TAG), which extend the flexibility, and in some
cases generative capacity of the formalism but also
have substantial costs in terms of efficient process-
ing. Much work in TAG semantics makes use of
tree-local MCTAG (TL-MCTAG) to model phenom-
ena such as quantifier scoping, Wh-question forma-
tion, and many other constructions (Kallmeyer and
Romero, 2004; Romero et al, 2004). Certain ap-
plications, however, appear to require even more
flexibility than is provided by TL-MCTAG. Scram-
bling is one well-known example (Rambow, 1994).
In addition, in the semantics domain, the use of a
new TAG operation, flexible composition, is used to
perform certain semantic operations that seemingly
cannot be modeled with TL-MCTAG alone (Chiang
and Scheffler, 2008) and in work in synchronous
TAG semantics, constructions such as nested quanti-
fiers require a set-local MCTAG (SL-MCTAG) anal-
ysis (Nesson and Shieber, 2006).
In this paper we suggest a shift in focus from
constraining locality and complexity through restric-
tions that all trees in a tree set must adjoin within
a single tree or tree set to constraining locality and
complexity through restrictions on the derivational
distance between trees in the same tree set in a
valid derivation. We examine three formalisms, two
of them introduced in this work for the first time,
that use derivational distance to constrain locality
and demonstrate by construction of parsers their re-
lationship to TL-MCTAG in both expressivity and
complexity. In Section 2 we give a very brief in-
troduction to TAG. In Section 3 we elaborate fur-
ther the distinction between these two types of lo-
cality restrictions using TAG derivation trees. Sec-
tion 4 briefly addresses the simultaneity requirement
present in MCTAG formalisms but not in Vector-
92
SX
a
X
?
Y
b
S
X
a
Y
b
S
X
a
Y
b
Y
?
c
Y
Z
S
X
a Y
b c
Y
Z
? ?
Figure 1: An example of the TAG operations substitu-
tion and adjunction.
TAG formalisms and argues for dropping the re-
quirement. In Sections 5 and 6 we introduce two
novel formalisms, restricted non-simultaneous MC-
TAG and restricted Vector-TAG, respectively, and
define CKY-style parsers for them. In Section 7
we recall the delayed TL-MCTAG formalism intro-
duced by Chiang and Scheffler (2008) and define a
CKY-style parser for it as well. In Section 8 we
explore the complexity of all three parsers and the
relationship between the formalisms. In Section 9
we discuss the linguistic applications of these for-
malisms and show that they permit analyses of some
of the hard cases that have led researchers to look
beyond TL-MCTAG.
2 Background
A tree-adjoining grammar consists of a set of el-
ementary tree structures of arbitrary depth, which
are combined by operations of adjunction and sub-
stitution. Auxiliary trees are elementary trees in
which the root and a frontier node, called the foot
node and distinguished by the diacritic ?, are labeled
with the same nonterminalA. The adjunction opera-
tion entails splicing an auxiliary tree in at an internal
node in an elementary tree also labeled with nonter-
minal A. Trees without a foot node, which serve as
a base for derivations and may combine with other
trees by substitution, are called initial trees. Exam-
ples of the adjunction and substitution operations are
given in Figure 1. For further background, refer to
the survey by (Joshi and Schabes, 1997).
Shieber et al (1995) and Vijay-Shanker (1987)
apply the Cocke-Kasami-Younger (CKY) algorithm
first introduced for use with context-free grammars
in Chomsky normal form (Kasami, 1965; Younger,
1967) to the TAG parsing problem to generate
parsers with a time complexity of O(n6|G|2). In
order to clarify the presentation of our extended TL-
MCTAG parsers below, we briefly review the algo-
rithm of Shieber et al (1995) using the inference
rule notation from that paper. As shown in Figure 2,
items in CKY-style TAG parsing consist of a node
in an elementary tree and the indices that mark the
edges of the span dominated by that node. Nodes,
notated ?@a?, are specified by three pieces of infor-
mation: the identifier ? of the elementary tree the
node is in, the Gorn address a of the node in that
tree1, and a diacritic, ?, indicating that an adjunc-
tion or substitution is still available at that node or ?,
indicating that one has already taken place.
Each item has four indices, indicating the left and
right edges of the span covered by the node as well
as any gap in the node that may be the result of a
foot node dominated by the node. Nodes that do
not dominate a foot node will have no gap in them,
which we indicate by the use of underscores in place
of the indices for the gap. To limit the number of in-
ference rules needed, we define the following func-
tion i ? j for combining indices:
i ? j =
?
????
????
i j =
j i =
i i = j
undefined otherwise
The side conditions Init(?) and Aux(?) hold if ?
is an initial tree or an auxiliary tree, respectively.
Label(?@a) specifies the label of the node in tree
? at address a. Ft(?) specifies the address of the
foot node of tree ?. Adj(?@a, ?) holds if tree ?
may adjoin into tree ? at address a. Subst(?@a, ?)
holds if tree ? may substitute into tree ? at address
a. These conditions fail if the adjunction or substitu-
tion is prevented by constraints such as mismatched
node labels.
Multi-component TAG (MCTAG) generalizes
TAG by allowing the elementary items to be sets
of trees rather than single trees (Joshi and Schabes,
1997). The basic operations are the same but all
trees in a set must adjoin (or substitute) into another
tree or tree set in a single step in the derivation.
An MCTAG is tree-local if tree sets are required
to adjoin within a single elementary tree (Weir,
1A Gorn address uniquely identifies a node within a tree.
The Gorn address of the root node is ?. The jth child of the
node with address i has address i ? j.
93
Goal Item: ??@??, 0, , , n? Init(?)
Label(?@?) = S
Terminal Axiom: ??@a?, i? 1, , , i? Label(?@a) = wi
Empty Axiom: ??@a?, i, , , i? Label(?@a) = ?
Foot Axiom: ??@Ft(?)?, p, p, q, q? Aux(?)
Unary Complete: ??@(a ? 1)?, i, j, k, l? ?@(a ? 2) undefined
??@a?, i, j, k, l?
Binary Complete: ??@(a ? 1)?, i, j, k, l?, ??@(a ? 2)?, l, j?, k?,m?
??@a?, i, j ? j?, k ? k?,m?
Adjoin: ??@??, i, p, q, l?, ??@a?, p, j, k, q? Adj(?@a, ?)
??@a?, i, j, k, l?
No Adjoin: ??@a?, i, j, k, l?
??@a?, i, j, k, l?
Substitute: ??@??, i, , , l? Subst(?@a, ?)
??@a?, i, , , l?
Figure 2: The CKY algorithm for TAG
1988). Although tree-local MCTAG (TL-MCTAG)
has the same generative capacity as TAG (Weir,
1988), the conversion to TAG is exponential and
the TL-MCTAG formalism is NP-hard to recognize
(S?gaard et al, 2007). An MCTAG is set-local
if tree sets required to adjoin within a single ele-
mentary tree set (Weir, 1988). Set-local MCTAG
(SL-MCTAG) has equivalent expressivity to linear
context-free rewriting systems and recognition is
provably PSPACE complete (Nesson et al, 2008).
3 Domains of Locality and Derivation
Trees
The domains of locality of TL-MCTAG and SL-
MCTAG (and trivially, TAG) can be thought of as
lexically defined. That is, all locations at which the
adjunction of one tree set into another may occur
must be present within a single lexical item. How-
ever, we can also think of locality derivationally. In
a derivationally local system the constraint is on the
relationships allowed between members of the same
tree set in the derivation tree.
TAG derivation trees provide the information
about how the elementary structures of the grammar
combine that is necessary to construct the derived
tree. Nodes in a TAG derivation tree are labeled with
identifiers of elementary structures. One elementary
structure is the child of another in the derivation tree
if it adjoins or substitutes into it in the derivation.
Arcs in the derivation tree are labeled with the ad-
dress in the target elementary structure at which the
operation takes place.
In MCTAG the derivation trees are often drawn
with identifiers of entire tree sets as the nodes of
the tree because the lexical locality constraints re-
quire that each elementary tree set be the deriva-
tional child of only one other tree set. However, if
we elaborate the derivation tree to include a node for
each tree in the grammar rather than only for each
tree set we can see a stark contrast in the derivational
94
SA B
? ?
A
?
B
?
a
b
{ }
A
a
B
A
?
B
?
A B
b{ }
1:
2:
3:
1
2a 2b
3a 3b
3a 3b
2a 2b
???
???
Figure 3: An example SL-MCTAG grammar that gener-
ates the language ww and associated derivation tree that
demonstrating an arbitrarily long derivational distance
between the trees of a given tree set and their nearest com-
mon ancestor. Note that if this grammar is interpreted as
a TL-MCTAG grammar only two derivations are possible
(for the strings aa and bb).
locality of these two formalisms. In TL-MCTAG
all trees in a set must adjoin to the same tree. This
means that they must all be siblings in the derivation
tree. In SL-MCTAG, on the other hand, it is possi-
ble to generate derivations with arbitrarily long dis-
tances before the nearest common ancestor of two
trees from the same elementary tree set is reached.
An example SL-MCTAG grammar that can produce
an arbitrarily long derivational distance to the near-
est common ancestor of the trees in a given tree set
is given in Figure 3.
Chiang and Scheffler (2008) recently introduced
one variant of MCTAG, delayed Tree-Local MC-
TAG (delayed TL-MCTAG) that uses a derivational
notion of locality. In this paper we introduce two ad-
ditional derivationally local TAG-based formalisms,
restricted non-simultaneous MCTAG (restricted NS-
MCTAG) and restricted Vector TAG (restricted V-
TAG) and demonstrate by construction of parsers
how each gives rise to a hierarchy of derivation-
ally local formalisms with a well-defined efficiency
penalty for each step of derivational distance permit-
ted.
4 The Simultaneity Requirement
In addition to lexical locality constraints the defini-
tion of MCTAG requires that all trees from a set ad-
join simultaneously. In terms of well-formed deriva-
tion trees, this amounts to disallowing derivations
in which a tree from a given set is the ancestor of
a tree from the same tree set. For most linguistic
applications of TAG, this requirement seems natu-
ral and is strictly obeyed. There are a few appli-
cations, including flexible composition and scram-
bling in free-word order languages that benefit from
TAG-based grammars that drop the simultaneity re-
quirement (Chiang and Scheffler, 2008; Rambow,
1994). From a complexity perspective, however,
checking the simultaneity requirement is expensive
(Kallmeyer, 2007). As a result, it can be advan-
tageous to select a base formalism that does not
require simultaneity even if the grammars imple-
mented with it do not make use of that additional
freedom.
5 Restricted Non-simultaneous MCTAG
The simplest version of a derivationally local TAG-
based formalism is most similar to non-local MC-
TAG. There is no lexical locality requirement at all.
In addition, we drop the simultaneity requirement.
Thus the only constraint on elementary tree sets is
the limit, d, on the derivational distance between
the trees in a given set and their nearest common
ancestor. We call this formalism restricted non-
simultaneous MCTAG. Note that if we constrain d to
be one, this happens to enforce both the derivational
delay limit and the lexical locality requirement of
TL-MCTAG.
A CKY-style parser for restricted NS-MCTAG
with a restriction of d is given in Figure 4. The items
of this parser contain d lists, ?1, . . . ,?d, called his-
tories that record the identities of the trees that have
already adjoined in the derivation in order to enforce
the locality constraints. The identities of the trees in
a tree set that have adjoined in a given derivation are
maintained in the histories until all the trees from
that set have adjoined. Once the locality constraint
is checked for a tree set, the Filter side condition
expunges those trees from the histories. A tree is
recorded in this history list with superscript i, where
i is the derivational distance between the location
where the recorded tree adjoined and the location of
the current item. The locality constraint is enforced
at the point of adjunction or substitution where the
95
Goal Item Init(?1)
??0@??, 0, , , n, ?, . . . , ?? Label(?0@?) = S
|?| = 1
Terminal Axiom
??x@a?, i? 1, , , i, ?, . . . , ?? Label(?x@a) = wi
Empty Axiom
??x@a?, i, , , i, ?, . . . , ?? Label(?x@a) = ?
Foot Axiom
??x@Ft(?x)?, p, p, q, q, ?, . . . , ?? Aux(?x)
Unary Complete
??x@(a ? 1)?, i, j, k, l,?1, . . . ,?d? ?x@(a ? 2) undefined
??x@a?, i, j, k, l,?1, . . . ,?d?
Binary Complete Filter(?11 ? ?12, . . . ,
??x@(a ? 1)?, i, j, k, l,?11, . . . ,?d1???x@(a ? 2)?, l, j?, k?,m,?12, . . . ,?d2? ?d1 ? ?d2) =
??x@a?, i, j ? j?, k ? k?,m,?1, . . . ,?d? ?1, . . . ,?d
Adjoin: Adj(?x@a, ?y)
??y@??, i, p, q, l,?11, . . . ,?d?11 , ????x@a?, p, j, k, q,?12, . . . ,?d2? Filter(?12 ? {?y},?22 ? ?11,
??x@a?, i, j, k, l,?1, . . . ,?d? . . . ,?d2 ? ?d?11 ) =
?1, . . . ,?d
Substitute:
??y@??, i, , , l,?11, . . . ,?d?11 , ?? Subst(?x@a, ?y)
??x@a?, i, , , l,?1, . . . ,?d? Filter({?y},?11, . . . ,?d?11 )
= ?1, . . . ,?d
No Adjoin:
??x@a?, i, j, k, l,?1, . . . ,?d?
??x@a?, i, j, k, l,?1, . . . ,?d?
Figure 4: Axioms and inference rules for the CKY algorithm for restricted NS-MCTAG with a restriction of d.
history at the limit of the permissible delay must be
empty for the operation to succeed.
6 Restricted V-TAG
A Vector-TAG (V-TAG) (Rambow, 1994) is similar
to an MCTAG in that the elementary structures are
sets (or vectors) of TAG trees. A derivation in a V-
TAG is defined as in TAG. There is no locality re-
quirement or other restriction on adjunction except
that if one tree from a vector is used in a derivation,
all trees from that vector must be used in the deriva-
tion. The trees in a vector may be connected by
dominance links between the foot nodes of auxiliary
trees and any node in other trees in the vector. All
adjunctions must respect the dominance relations in
that a node ?1 that dominates a node ?2 must appear
on the path from ?2 to the root of the derived tree.
The definition of V-TAG is very similar to that of
non-local MCTAG as defined by Weir (1988) except
that in non-local MCTAG all trees from a tree set are
required to adjoin simultaneously.
Restricted V-TAG constrains V-TAG in several
ways. First, the dominance chain in each elementary
tree vector is required to define a total order over
the trees in the vector. This means there is a sin-
gle base tree in each vector. Note also that all trees
other than the base tree must be auxiliary trees in or-
der to dominate other trees in the vector. The base
tree may be either an initial tree or an auxiliary tree.
Second, a restricted V-TAG has a restriction level,
d, that determines the largest derivational distance
that may exists between the base tree and the high-
est tree in a tree vector in a derivation. Restricted
V-TAG differs from restricted NS-MCTAG in one
important respect: the dominance requirements of
restricted V-TAG require that trees from the same
96
set must appear along a single path in the derived
tree, whereas in restricted NS-MCTAG trees from
the same set need not adhere to any dominance rela-
tionship in the derived tree.
A CKY-style parser for restricted V-TAG with re-
striction level d is given in Figure 5. Parsing is sim-
ilar to delayed TL-MCTAG in that we have a set
of histories for each restriction level. However, be-
cause of the total order over trees in a vector, the
parser only needs to maintain the identity of the
highest tree from a vector that has been used in the
derivation along with its distance from the base tree
from that vector. The Filter side condition accord-
ingly expunges trees that are the top tree in the dom-
inance chain of their tree vector. The side conditions
for the Adjoin non-base rule enforce that the domi-
nance constraints are satisfied and that the deriva-
tional distance from the base of a tree vector to its
currently highest adjoined tree is maintained accu-
rately. We note that in order to allow a non-total or-
dering of the trees in a vector we would simply have
to record all trees in a tree vector in the histories as
is done in the delayed TL-MCTAG parser.
7 Delayed TL-MCTAG
Chiang and Scheffler (2008) introduce the de-
layed TL-MCTAG formalism which makes use of
a derivational distance restriction in a somewhat dif-
ferent way. Rather than restricting the absolute dis-
tance between the trees of a set and their nearest
common ancestor, given a node ? in a derivation
tree, delayed TL-MCTAG restricts the number of
tree sets that are not fully dominated by ?. Bor-
rowing directly from Chiang and Scheffler (2008),
Figure 7 gives two examples.
Parsing for delayed TL-MCTAG is not discussed
by Chiang and Scheffler (2008) but can be accom-
plished using a similar CKY-style strategy as in the
two parsers above. We present a parser in Fig-
ure 6. Rather than keeping histories that record
derivational distance, we keep an active delay list
for each item that records the delays that are active
(by recording the identities of the trees that have ad-
joined) for the tree of which the current node is a
part. At the root of each tree the active delay list is
filtered using the Filter side condition to remove all
tree sets that are fully dominated and the resulting
Figure 7: Examples of 1-delay (top) and 2-delay (bottom)
taken from Chiang and Scheffler (2008). The delays are
marked with dashed boxes on the derivation trees.
list is checked using the Size to ensure that it con-
tains no more than d distinct tree sets where d is the
specified delay for the grammar. The active delays
for a given tree are passed to its derivational parent
when it adjoins or substitutes.
Delayed TL-MCTAG differs from both of the pre-
vious formalisms in that it places no constraint on
the length of a delay. On the other hand while
the previous formalisms allow unlimited short de-
lays to be pending at the same time, in delayed TL-
MCTAG, only a restricted number of delays may be
active at once. Similar to restricted V-TAG, there
is no simultaneity requirement, so a tree may have
another tree from the same set as an ancestor.
8 Complexity
The complexity of the restricted NS-MCTAG and
restricted V-TAG parsers presented above depends
on the number of possible histories that may appear
in an item. For each step of derivational distance
permitted between trees of the same set, the corre-
sponding history permits many more entries. His-
tory ?1 may contain trees that have adjoined into
the same tree as the node of the current item. The
number of entries is therefore limited by the num-
ber of adjunction sites in that tree, which is in turn
limited by the number of nodes in that tree. We will
call the maximum number of nodes in a tree in the
grammar t. Theoretically, any tree in the grammar
could adjoin at any of these adjunction sites, mean-
ing that the number of possible values for each entry
in the history is bounded by the size of the grammar
|G|. Thus the size of ?1 is O(|G|t). For ?2 the en-
97
Unary Complete
??x@(a ? 1)?, i, j, k, l,?1, . . . ,?d? ?x@(a ? 2) undefined
??x@a?, i, j, k, l,?1, . . . ,?d?
Binary Complete
??x@(a ? 1)?, i, j, k, l,?11, . . . ,?d1???x@(a ? 2)?, l, j?, k?,m,?12, . . . ,?d2?
??x@a?, i, j ? j?, k ? k?,m,?11 ? ?12, . . . ,?d1 ? ?d2?
Adjoin base: Adj(?x@a, ?1)
??1@??, i, p, q, l,?11, . . . ,?d?11 , ????x@a?, p, j, k, q,?12, . . . ,?d2? Filter(?12 ? {?1},?22 ? ?11,
??x@a?, i, j, k, l,?1, . . . ,?d? . . . ,?d2 ? ?d?11 ) =
?1, . . . ,?d
Adjoin non-base:
??y@??, i, p, q, l,?11, . . . ,?d?11 , ????x@a?, p, j, k, q,?12, . . . ,?d2? Adj(?x@a, ?y)
??x@a?, i, j, k, l,?1, . . . ,?d? Filter(?12? ,?22? ? ?11, . . . ,
for unique ?i2 s.t. ?y?1 ? ?i2,?i2? = (?i2 ? ?i?11 ? {?y})? {?y?1} ?d2? ? ?d?11 ) =
for ?i2 s.t. ?y?1 /? ?i2,?i2? = ?i2 ? ?i?11 ?1, . . . ,?d
Substitute:
??1@??, i, , , l,?11, . . . ,?d?11 , ?? Subst(?x@a, ?1)
??x@a?, i, , , l,?1, . . . ,?d? Filter({?1},?11, . . . ,?d?11 )
= ?1, . . . ,?d
No Adjoin:
??x@a?, i, j, k, l,?1, . . . ,?d?
??x@a?, i, j, k, l,?1, . . . ,?d?
Figure 5: Inference rules for the CKY algorithm for restricted V-TAG with a restriction of d. Item form, goal item and
axioms are omitted because they are identical to those in restricted NS-MCTAG parser.
tries correspond to tree that have adjoined into a tree
that has adjoined into the tree of the current item.
Thus, for each of the t trees that may have adjoined
at a derivational distance of one, there are t more
trees that may have adjoined at a derivational dis-
tance of two. The size of ?2 is therefore |G|t2 . The
combined size of the histories for a grammar with a
delay or restriction of d is therefore O(|G|
?d
i=1 t
d).
Replacing the sum with its closed form solution, we
have O(|G| t
d+1?1
t?1 ?1) histories.
Using the reasoning about the size of the histories
given above, the restricted NS-MCTAG parser pre-
sented here has a complexity of O(n6 |G|1+ t
d+1?1
t?1 ),
where t is as defined above and d is the limit on de-
lay of adjunction. For a tree-local MCTAG, the com-
plexity reduces to O(n6 |G|2+t). For the linguis-
tic applications that motivate this chapter no delay
greater than two is needed, resulting in a complexity
of O(n6 |G|2+t+t2).
The same complexity analysis applies for re-
stricted V-TAG. However, we can provide a some-
what tighter bound by noting that the rank, r, of
the grammar?how many tree sets adjoin in a sin-
gle tree?and the fan out, f of the grammar?how
many trees may be in a single tree set?are limited
by t. That is, a complete derivation containing |D|
tree sets can contain no more than t |D| individual
trees and also no more than rf |D| individual trees.
In the restricted V-TAG algorithm we maintain only
one tree from a tree set in the history at a time, so
rather than maintaining O(t) entries in each history,
we only need to maintain the smaller O(r) entries.
The complexity of the delayed TL-MCTAG
parser depends on the number of possible active de-
lay lists. As above, each delay list may have a maxi-
mum of t entries for trees that adjoin directly into it.
The restriction on the number of active delays means
that the active delay lists passed up from these child
nodes at the point of adjunction or substitution can
have size no more than d. This results in an addi-
tional td(f ? 1) possible entries in the active de-
98
Goal Item: Init(?1)
??0@??, 0, , , n, ?, . . . , ?? Label(?0@?) = S
|?| = 1
Terminal Axiom
??x@a?, i? 1, , , i, ?, . . . , {?x}? Label(?x@a) = wi
Empty Axiom
??x@a?, i, , , i, ?, . . . , {?x}? Label(?x@a) = ?
Foot Axiom
??x@Ft(?x)?, p, p, q, q, ?, . . . , {?x}? Aux(?x)
Unary Complete
??x@(a ? 1)?, i, j, k, l,?? ?x@(a ? 2) undefined
??x@a?, i, j, k, l,??
Binary Complete
??x@(a ? 1)?, i, j, k, l,?1???x@(a ? 2)?, l, j?, k?,m,?2?
??x@a?, i, j ? j?, k ? k?,m,?1 ? ?2?
Adjoin:
??y@??, i, p, q, l,?????x@a?, p, j, k, q,??? Adj(?x@a, ?y)
??x@a?, i, j, k, l,??? ? ??? Filter(??,???)
Size(???) ? d
Substitute:
??y@??, i, , , l,??? Subst(?x@a, ?y)
??x@a?, i, , , l,??? ? {?x}? Filter(??,???)
Size(???) ? d
No Adjoin:
??x@a?, i, j, k, l,??
??x@a?, i, j, k, l,??
Figure 6: Axioms and inference rules for the CKY algorithm for delayed TL-MCTAG with a delay of d.
lay list, giving a total number of active delay lists
of O(|G|t(1+d(f?1))). Thus the complexity of the
parser is O(n6 |G|2+t(1+d(f?1))).
9 Conclusion
Each of the formalisms presented above extends the
flexibility of MCTAG beyond that of TL-MCTAG
while maintaining, as we have shown herein, com-
plexity much less than that of SL-MCTAG. All three
formalisms permit modeling of flexible composi-
tion (because they permit one member of a tree set
to be a derivational ancestor of another tree in the
same set), at least restricted NS-MCTAG and re-
stricted V-TAG permit analyses of scrambling, and
all three permit analyses of the various challeng-
ing semantic constructions mentioned in the intro-
duction. We conclude that extending locality by
constraining derivational distance may be an effec-
tive way to add flexibility to MCTAG without losing
computational tractability.
Acknowledgments
This material is based upon work supported by the
National Science Foundation under Grant No. BCS-
0827979.
References
David Chiang and Tatjana Scheffler. 2008. Flexible com-
position and delayed tree-locality. In The Ninth Inter-
national Workshop on Tree Adjoining Grammars and
Related Formalisms (TAG+9).
Aravind K. Joshi and Yves Schabes. 1997. Tree-
adjoining grammars. In G. Rozenberg and A. Salo-
maa, editors, Handbook of Formal Languages, pages
69?124. Springer.
99
Laura Kallmeyer and Maribel Romero. 2004. LTAG
semantics with semantic unification. In Proceedings
of the 7th International Workshop on Tree-Adjoining
Grammars and Related Formalisms (TAG+7), pages
155?162, Vancouver, May.
Laura Kallmeyer. 2007. A declarative characterization
of different types of multicomponent tree adjoining
grammars. In Andreas Witt Georg Rehm and Lothar
Lemnitzer, editors, Datenstrukturen fu?r linguistische
Ressourcen und ihre Anwendungen, pages 111?120.
T. Kasami. 1965. An efficient recognition and syntax
algorithm for context-free languages. Technical Re-
port AF-CRL-65-758, Air Force Cambridge Research
Laboratory, Bedford, MA.
Rebecca Nesson and Stuart M. Shieber. 2006. Sim-
pler TAG semantics through synchronization. In Pro-
ceedings of the 11th Conference on Formal Grammar,
Malaga, Spain, 29?30 July.
Rebecca Nesson, Giorgio Satta, and Stuart M. Shieber.
2008. Complexity, parsing, and factorization of tree-
local multi-component tree-adjoining grammar. Tech-
nical report, Harvard University.
Owen Rambow. 1994. Formal and computational as-
pects of natural language syntax. Ph.D. thesis, Uni-
versity of Pennsylvania, Philadelphia, PA.
Maribel Romero, Laura Kallmeyer, and Olga Babko-
Malaya. 2004. LTAG semantics for questions. In
Proceedings of the 7th International Workshop on
Tree-Adjoining Grammars and Related Formalisms
(TAG+7), pages 186?193, Vancouver, May.
Stuart M. Shieber, Yves Schabes, and Fernando C. N.
Pereira. 1995. Principles and implementation of
deductive parsing. Journal of Logic Programming,
24(1?2):3?36, July?August. Also available as cmp-
lg/9404008.
Anders S?gaard, Timm Lichte, and Wolfgang Maier.
2007. On the complexity of linguistically motivated
extensions of tree-adjoining grammar. In Recent Ad-
vances in Natural Language Processing 2007.
K. Vijay-Shanker. 1987. A study of tree-adjoining gram-
mars. PhD Thesis, Department of Computer and In-
formation Science, University of Pennsylvania.
David Weir. 1988. Characterizing mildly context-
sensitive grammar formalisms. PhD Thesis, Depart-
ment of Computer and Information Science, Univer-
sity of Pennsylvania.
D.H. Younger. 1967. Recognition and parsing of
context-free languages in time n3. Information and
Control, 10(2):189?208.
100
Proceedings of ACL-08: HLT, pages 604?612,
Columbus, Ohio, USA, June 2008. c?2008 Association for Computational Linguistics
Optimal k-arization of Synchronous Tree-Adjoining Grammar
Rebecca Nesson
School of Engineering
and Applied Sciences
Harvard University
Cambridge, MA 02138
nesson@seas.harvard.edu
Giorgio Satta
Department of
Information Engineering
University of Padua
I-35131 Padova, Italy
satta@dei.unipd.it
Stuart M. Shieber
School of Engineering
and Applied Sciences
Harvard University
Cambridge, MA 02138
shieber@seas.harvard.edu
Abstract
Synchronous Tree-Adjoining Grammar
(STAG) is a promising formalism for syntax-
aware machine translation and simultaneous
computation of natural-language syntax and
semantics. Current research in both of these
areas is actively pursuing its incorporation.
However, STAG parsing is known to be
NP-hard due to the potential for intertwined
correspondences between the linked nonter-
minal symbols in the elementary structures.
Given a particular grammar, the polynomial
degree of efficient STAG parsing algorithms
depends directly on the rank of the grammar:
the maximum number of correspondences that
appear within a single elementary structure.
In this paper we present a compile-time
algorithm for transforming a STAG into a
strongly-equivalent STAG that optimally
minimizes the rank, k, across the grammar.
The algorithm performs inO(|G|+ |Y | ? L3
G
)
time where L
G
is the maximum number of
links in any single synchronous tree pair in
the grammar and Y is the set of synchronous
tree pairs of G.
1 Introduction
Tree-adjoining grammar is a widely used formal-
ism in natural-language processing due to its mildly-
context-sensitive expressivity, its ability to naturally
capture natural-language argument substitution (via
its substitution operation) and optional modifica-
tion (via its adjunction operation), and the existence
of efficient algorithms for processing it. Recently,
the desire to incorporate syntax-awareness into ma-
chine translation systems has generated interest in
the application of synchronous tree-adjoining gram-
mar (STAG) to this problem (Nesson, Shieber, and
Rush, 2006; Chiang and Rambow, 2006). In a par-
allel development, interest in incorporating seman-
tic computation into the TAG framework has led
to the use of STAG for this purpose (Nesson and
Shieber, 2007; Han, 2006b; Han, 2006a; Nesson
and Shieber, 2006). Although STAG does not in-
crease the expressivity of the underlying formalisms
(Shieber, 1994), STAG parsing is known to be NP-
hard due to the potential for intertwined correspon-
dences between the linked nonterminal symbols in
the elementary structures (Satta, 1992; Weir, 1988).
Without efficient algorithms for processing it, its po-
tential for use in machine translation and TAG se-
mantics systems is limited.
Given a particular grammar, the polynomial de-
gree of efficient STAG parsing algorithms depends
directly on the rank of the grammar: the maximum
number of correspondences that appear within a sin-
gle elementary structure. This is illustrated by the
tree pairs given in Figure 1 in which no two num-
bered links may be isolated. (By ?isolated?, we
mean that the links can be contained in a fragment
of the tree that contains no other links and domi-
nates only one branch not contained in the fragment.
A precise definition is given in section 3.)
An analogous problem has long been known
to exist for synchronous context-free grammars
(SCFG) (Aho and Ullman, 1969). The task of
producing efficient parsers for SCFG has recently
been addressed by binarization or k-arization of
SCFG grammars that produce equivalent grammars
in which the rank, k, has been minimized (Zhang
604
AB
C
D
w
A
B
C
DE F G
1
2
3
4
A
B C
D E F G
A
B C
D
2
3
1
4
1 2 3 4 2 4 31
w ?w w ?x x ? y ?y z z ?
A
B C
D 1
w
3 4
E 2
x
5 A
B C
D
1
3 4E
2
5
w ? x ?
?1 : ?2 : ?3 :
Figure 1: Example of intertwined links that cannot be binarized. No two links can be isolated in both trees in a tree
pair. Note that in tree pair ?
1
, any set of three links may be isolated while in tree pair ?
2
, no group of fewer than four
links may be isolated. In ?
3
no group of links smaller than four may be isolated.
S
V P
V
likes
red candies
aime
les b o n b o n srouges
Det
N P?
S
V P
V N P?
N P
N
N P
NN ?
N
A d j N ?
N
A d j
S
N P V P
J o h n V
likes
J ean
aime
S
N P V P
V
les
Det
N PN P
red
N
A d j
candies
N
b o n b o n s
N
rouges
N
A d j
2
1
2
1 J ean
N PN P
J o h n
N P? 1 N P? 1
likes
J o h n candies
red
1 2
1
( a ) ( b ) ( c )
Figure 2: An example STAG derivation of the English/French sentence pair ?John likes red candies?/?Jean aime les
bonbons rouges?. The figure is divided as follows: (a) the STAG grammar, (b) the derivation tree for the sentence
pair, and (c) the derived tree pair for the sentences.
and Gildea, 2007; Zhang et al, 2006; Gildea, Satta,
and Zhang, 2006). The methods for k-arization
of SCFG cannot be directly applied to STAG be-
cause of the additional complexity introduced by
the expressivity-increasing adjunction operation of
TAG. In SCFG, where substitution is the only avail-
able operation and the depth of elementary struc-
tures is limited to one, the k-arization problem re-
duces to analysis of permutations of strings of non-
terminal symbols. In STAG, however, the arbitrary
depth of the elementary structures and the lack of
restriction to contiguous strings of nonterminals in-
troduced by adjunction substantially complicate the
task.
In this paper we offer the first algorithm address-
ing this problem for the STAG case. We present
a compile-time algorithm for transforming a STAG
into a strongly-equivalent STAG that optimally min-
imizes k across the grammar. This is a critical mini-
mization because k is the feature of the grammar that
appears in the exponent of the complexity of parsing
algorithms for STAG. Following the method of Seki
et al (1991), an STAG parser can be implemented
with complexity O(n4?(k+1) ? |G|). By minimizing
k, the worst-case complexity of a parser instanti-
ated for a particular grammar is optimized. The k-
arization algorithm performs in O(|G|+ |Y | ? L3G)
time where LG is the maximum number of links in
any single synchronous tree pair in the grammar and
Y is the set of synchronous tree pairs of G. By com-
parison, a baseline algorithm performing exhaustive
search requires O(|G|+ |Y | ? L6G) time.
1
The remainder of the paper proceeds as follows.
In section 2 we provide a brief introduction to the
STAG formalism. We present the k-arization algo-
rithm in section 3 and an analysis of its complexity
in section 4. We prove the correctness of the algo-
rithm in section 5.
1In a synchronous tree pair with L links, there are O(L4)
pairs of valid fragments. It takes O(L) time to check if the two
components in a pair have the same set of links. Once the syn-
chronous fragment with the smallest number of links is excised,
this process iterates at most L times, resulting in time O(L6G).
605
DE F
A
B
C
1
2
3 4
y z
5
H
I J2 3
1
NM 4
w ? x ?
5
L
y ?
K
? :
x
G
z ?
n 1 :
n 2 :
n 3 :
n 4 :
n 5 :
Figure 3: A synchronous tree pair containing frag-
ments ?
L
= ?
L
(n
1
, n
2
) and ?
R
= ?
R
(n
3
). Since
links(n
1
, n
2
) = links(n
3
) = { 2 , 4 , 5}, we can de-
fine synchronous fragment ? = ??
L
, ?
R
?. Note also
that node n
3
is a maximal node and node n
5
is not.
?(n
1
) = 2 5 5 3 3 2 4 4 ; ?(n
3
) = 2 5 5 4 4 2 .
2 Synchronous Tree-Adjoining Grammar
A tree-adjoining grammar (TAG) consists of a set of
elementary tree structures of arbitrary depth, which
are combined by substitution, familiar from context-
free grammars, or an operation of adjunction that is
particular to the TAG formalism. Auxiliary trees
are elementary trees in which the root and a frontier
node, called the foot node and distinguished by the
diacritic ?, are labeled with the same nonterminalA.
The adjunction operation involves splicing an auxil-
iary tree in at an internal node in an elementary tree
also labeled with nonterminal A. Trees without a
foot node, which serve as a base for derivations, are
called initial trees. For further background, refer to
the survey by Joshi and Schabes (1997).
We depart from the traditional definition in nota-
tion only by specifying adjunction and substitution
sites explicitly with numbered links. Each link may
be used only once in a derivation. Operations may
only occur at nodes marked with a link. For sim-
plicity of presentation we provisionally assume that
only one link is permitted at a node. We later drop
this assumption.
In a synchronous TAG (STAG) the elementary
structures are ordered pairs of TAG trees, with a
linking relation specified over pairs of nonterminal
nodes. Each link has two locations, one in the left
tree in a pair and the other in the right tree. An ex-
ample of an STAG derivation including both substi-
tution and adjunction is given in Figure 2. For fur-
ther background, refer to the work of Shieber and
Schabes (1990) and Shieber (1994).
3 k-arization Algorithm
For a synchronous tree pair ? = ??L, ?R?, a frag-
ment of ?L (or ?R) is a complete subtree rooted at
some node n of ?L, written ?L(n), or else a subtree
rooted at n with a gap at node n?, written ?L(n, n?);
see Figure 3 for an example. We write links(n) and
links(n, n?) to denote the set of links of ?L(n) and
?L(n, n
?
), respectively. When we do not know the
root or gap nodes of some fragment ?L, we also
write links(?L).
We say that a set of links ? from ? can be iso-
lated if there exist fragments ?L and ?R of ?L
and ?R, respectively, both with links ?. If this is
the case, we can construct a synchronous fragment
? = ??L, ?R?. The goal of our algorithm is to de-
compose ? into synchronous fragments such that the
maximum number of links of a synchronous frag-
ment is kept to a minimum, and ? can be obtained
from the synchronous fragments by means of the
usual substitution and adjunction operations. In or-
der to simplify the presentation of our algorithm we
assume, without any loss of generality, that all ele-
mentary trees of the source STAG have nodes with
at most two children.
3.1 Maximal Nodes
A node n of ?L (or ?R) is called maximal if
(i) links(n) 6= ?, and (ii) it is either the root node
of ?L or, for its parent node n?, we have links(n?) 6=
links(n). Note that for every node n? of ?L such
that links(n?) 6= ? there is always a unique maxi-
mal node n such that links(n?) = links(n). Thus,
for the purpose of our algorithm, we need only look
at maximal nodes as places for excising tree frag-
ments. We can show that the number of maxi-
mal nodes Mn in a subtree ?L(n) always satisfies
|links(n)| ?Mn ? 2? |links(n)| ? 1.
Let n be some node of ?L, and let l(n) be the
(unique) link impinging on n if such a link exists,
and l(n) = ? otherwise. We associate n with a
string ?(n), defined by a pre- and post-order traver-
sal of fragment ?L(n). The symbols of ?(n) are the
links in links(n), viewed as atomic symbols. Given
a node n with p children n1, . . . , np, 0 ? p ? 2,
we define ?(n) = l(n)?(n1) ? ? ??(np) l(n). See
again Figure 3 for an example. Note that |?(n)| =
2? |links(n)|.
606
31
1
1
1
2
2
2
2
X X X X
R
R
R
R
R
R
G
G
G
G
G
G
X
?
X
?
X
?
?
X
?
X
?
excise adjoin transform
?
L
:
n
1
:
n
2
:
Figure 4: A diagram of the tree transformation performed
when fragment ?
L
(n
1
, n
2
) is removed. In this and the
diagrams that follow, patterned or shaded triangles rep-
resent segments of the tree that contain multiple nodes
and at least one link. Where the pattern or shading corre-
sponds across trees in a tree pair, the set of links contained
within those triangles are equivalent.
3.2 Excision of Synchronous Fragments
Although it would be possible to excise synchronous
fragments without creating new nonterminal nodes,
for clarity we present a simple tree transforma-
tion when a fragment is excised that leaves exist-
ing nodes intact. A schematic depiction is given in
Figure 4. In the figure, we demonstrate the exci-
sion process on one half of a synchronous fragment:
?L(n1, n2) is excised to form two new trees. The
excised tree is not processed further. In the exci-
sion process the root and gap nodes of the original
tree are not altered. The material between them is
replaced with a single new node with a fresh non-
terminal symbol and a fresh link number. This non-
terminal node and link form the adjunction or sub-
stitution site for the excised tree. Note that any link
impinging on the root node of the excised fragment
is by our convention included in the fragment and
any link impinging on the gap node is not.
To regenerate the original tree, the excised frag-
ment can be adjoined or substituted back into the
tree from which it was excised. The new nodes that
were generated in the excision may be removed and
the original root and gap nodes may be merged back
together retaining any impinging links, respectively.
Note that if there was a link on either the root or gap
node in the original tree, it is not lost or duplicated
1 1 0 0 0 0 0 0 0 0 1
2 0 1 0 0 0 0 1 0 1 0
5 0 0 1 1 0 0 0 0 0 0
5 0 0 1 1 0 0 0 0 0 0
3 0 0 0 0 0 0 0 1 1 0
3 0 0 0 0 0 0 0 1 1 0
2 0 1 0 0 0 0 1 0 0 0
4 0 0 0 0 1 1 0 0 0 0
4 0 0 0 0 1 1 0 0 0 0
1 1 0 0 0 0 0 0 0 0 1
1 2 5 5 4 4 2 3 3 1
0
Figure 5: Table pi with synchronous fragment
??
L
(n
1
, n
2
), ?
R
(n
3
)? from Figure 3 highlighted.
in the process.
3.3 Method
Let nL and nR be the root nodes of trees ?L and ?R,
respectively. We know that links(nL) = links(nR),
and |?(nL)| = |?(nR)|, the second string being a
rearrangement of the occurrences of symbols in the
first one. The main data structure of our algorithm is
a Boolean matrix pi of size |?(nL)|?|?(nL)|, whose
rows are addressed by the occurrences of symbols in
?(nL), in the given order, and whose columns are
similarly addressed by ?(nR). For occurrences of
links x1 , x2 , the element of pi at a row addressed by
x1 and a column addressed by x2 is 1 if x1 = x2,
and 0 otherwise. Thus, each row and column of pi
has exactly two non-zero entries. See Figure 5 for
an example.
For a maximal node n1 of ?L, we let pi(n1) de-
note the stripe of adjacent rows of pi addressed by
substring ?(n1) of ?(nL). If n1 dominates n2 in ?L,
we let pi(n1, n2) denote the rows of pi addressed by
?(n1) but not by ?(n2). This forms a pair of hori-
zontal stripes in pi. For nodes n3, n4 of ?R, we sim-
ilarly define pi(n3) and pi(n3, n4) as vertical stripes
of adjacent columns. See again Figure 5.
Our algorithm is reported in Figure 6. For each
synchronous tree pair ? = ??L, ?R? from the in-
put grammar, we maintain an agenda B with all
candidate fragments ?L from ?L having at least
two links. These fragments are processed greed-
ily in order of increasing number of links. The
function ISOLATE(), described in more detail be-
607
1: Function KARIZE(G) {G a binary STAG}
2: G? ? STAG with empty set of synch trees;
3: for all ? = ??L, ?R? in G do
4: init pi and B;
5: while B 6= ? do
6: ?L ? next fragment from B;
7: ?R ? ISOLATE(?L, pi, ?R);
8: if ?R 6= null then
9: add ??L, ?R? to G?;
10: ? ? excise ??L, ?R? from ?;
11: update pi and B;
12: add ? to G?;
13: return G?
Figure 6: Main algorithm.
low, looks for a right fragment ?R with the same
links as ?L. Upon success, the synchronous frag-
ment ? = ??L, ?R? is added to the output grammar.
Furthermore, we excise ? from ? and update data
structures pi and B. The above process is iterated
until B becomes empty. We show in section 5 that
this greedy strategy is sound and complete.
The function ISOLATE() is specified in Figure 7.
We take as input a left fragment ?L, which is asso-
ciated with one or two horizontal stripes in pi, de-
pending on whether ?L has a gap node or not. The
left boundary of ?L in pi is the index x1 of the col-
umn containing the leftmost occurrence of a 1 in the
horizontal stripes associated with ?L. Similarly, the
right boundary of ?L in pi is the index x2 of the col-
umn containing the rightmost occurrence of a 1 in
these stripes. We retrieve the shortest substring ?(n)
of ?(nR) that spans over indices x1 and x2. This
means that n is the lowest node from ?R such that
the links of ?L are a subset of the links of ?R(n).
If the condition at line 3 is satisfied, all of the ma-
trix entries of value 1 that are found from column
x1 to column x2 fall within the horizontal stripes
associated with ?L. In this case we can report the
right fragment ?R = ?R(n). Otherwise, we check
whether the entries of value 1 that fall outside of
the two horizontal stripes in between columns x1
and x2 occur within adjacent columns, say from col-
umn x3 ? x1 to column x4 ? x2. In this case,
we check whether there exists some node n? such
that the substring of ?(n) from position x3 to x4 is
1: Function ISOLATE(?L, pi, ?R)
2: select n ? ?R such that ?(n) is the shortest
string within ?(nR) including left/right bound-
aries of ?L in pi;
3: if |?(n)| = 2? |links(?L)| then
4: return ?R(n);
5: select n? ? ?R such that ?(n?) is the gap string
within ?(n) for which links(n) ? links(n?) =
links(?L);
6: if n? is not defined then
7: return null; {more than one gap}
8: return ?R(n, n?);
Figure 7: Find synchronous fragment.
an occurrence of string ?(n?). This means that n?
is the gap node, and we report the right fragment
?L = ?R(n, n
?
). See again Figure 5.
We now drop the assumption that only one link
may impinge on a node. When multiple links im-
pinge on a single node n, l(n) is an arbitrary order
over those links. In the execution of the algorithm,
any stripe that contains one link in l(n) it must in-
clude every link in l(n). This prevents the excision
of a proper subset of the links at any node. This pre-
serves correctness because excising any proper sub-
set would impose an order over the links at n that
is not enforced in the input grammar. Because the
links at a node are treated as a unit, the complexity
of the algorithm is not affected.
4 Complexity
We discuss here an implementation of the algo-
rithm of section 3 resulting in time complexity
O(|G|+ |Y | ? L3G), where Y is the set of syn-
chronous tree pairs of G and LG is the maximum
number of links in a synchronous tree pair in Y .
Consider a synchronous tree pair ? = ??L, ?R?
with L links. If M is the number of maximal nodes
in ?L or ?R, we have M = ?(L) (Section 3.1). We
implement the sparse table pi inO(L) space, record-
ing for each row and column the indices of its two
non-zero entries. We also assume that we can go
back and forth between maximal nodes n and strings
?(n) in constant time. Here each ?(n) is represented
by its boundary positions within ?(nL) or ?(nR),
nL and nR the root nodes of ?L and ?R, respectively.
608
At line 2 of the function ISOLATE() (Figure 7) we
retrieve the left and right boundaries by scanning the
rows of pi associated with input fragment ?L. We
then retrieve node n by visiting all maximal nodes
of ?L spanning these boundaries. Under the above
assumptions, this can be done in time O(L). In a
similar way we can implement line 5, resulting in
overall run time O(L) for function ISOLATE().
In the function KARIZE() (Figure 6) we use buck-
ets Bi, 1 ? i ? L, where each Bi stores the candi-
date fragments ?L with |links(?L)| = i. To populate
these buckets, we first process fragments ?L(n) by
visiting bottom up the maximal nodes of ?L. The
quantity |links(n)| is computed from the quantities
|links(ni)|, where ni are the highest maximal nodes
dominated by n. (There are at most two such nodes.)
Fragments ?L(n, n?) can then be processed using
the relation |links(n, n?)| = |links(n)| ? |links(n?)|.
In this way each fragment is processed in constant
time, and population of all the buckets takes O(L2)
time.
We now consider the while loop at lines 5 to 11 in
function KARIZE(). For a synchronous tree pair ?,
the loop iterates once for each candidate fragment
?L in some bucket. We have a total of O(L2) it-
erations, since the initial number of candidates in
the buckets is O(L2), and the possible updating of
the buckets after a synchronous fragment is removed
does not increase the total size of all the buckets. If
the links in ?L cannot be isolated, one iteration takes
time O(L) (the call to function ISOLATE()). If the
links in ?L can be isolated, then we need to restruc-
ture pi and to repopulate the buckets. The former
can be done in time O(L) and the latter takes time
O(L2), as already discussed. Crucially, the updat-
ing of pi and the buckets takes place no more than
L ? 1 times. This is because each time we excise
a synchronous fragment, the number of links in ? is
reduced by at least one.
We conclude that function KARIZE() takes time
O(L3) for each synchronous tree ?, and the total
running time is O(|G|+ |Y | ? L3G), where Y is the
set of synchronous tree pairs of G. The term |G| ac-
counts for the reading of the input, and dominates
the complexity of the algorithm only in case there
are very few links in each synchronous tree pair.
A
B C
D 1
w
3 4
E 2
x
5
B
D 1
w
3
6
n 1 :
n 2 :
n 3 :
n 4 :
? : ?
?
:
A?
A
Figure 8: In ? links 3 and 5 cannot be isolated because
the fragment would have to contain two gaps. However,
after the removal of fragment ?(n
1
, n
2
), an analogous
fragment ??(n
3
, n
4
) may be removed.
5 Proof of Correctness
The algorithm presented in the previous sections
produces an optimal k-arization for the input gram-
mar. In this section we sketch a proof of correctness
of the strategy employed by the algorithm.2
The k-arization strategy presented above is
greedy in that it always chooses the excisable frag-
ment with the smallest number of links at each step
and does not perform any backtracking. We must
therefore show that this process cannot result in a
non-optimal solution. If fragments could not overlap
each other, this would be trivial to show because the
excision process would be confluent. If all overlap-
ping fragments were cases of complete containment
of one fragment within another, the proof would also
be trivial because the smallest-to-largest excision or-
der would guarantee optimality. However, it is pos-
sible for fragments to partially overlap each other,
meaning that the intersection of the set of links con-
tained in the two fragments is non-empty and the dif-
ference between the set of links in one fragment and
the other is also non-empty. Overlapping fragment
configurations are given in Figure 9 and discussed in
detail below.
The existence of partially overlapping fragments
complicates the proof of optimality for two reasons.
First, the excision of a fragment ? that is partially
overlapped with another fragment ? necessarily pre-
cludes the excision of ? at a later stage in the ex-
2Note that the soundness of the algorithm can be easily veri-
fied from the fact that the removal of fragments can be reversed
by performing standard STAG adjunction and substitution oper-
ations until a single STAG tree pair is produced. This tree pair
is trivially homomorphic to the original tree pair and can easily
be mapped to the original tree pair.
609
(1, 1?)
[ [
A
B
C
D
n 1 :
n 2 :
n 3 :
n 4 :
A
B C
n 5 :
n 6 : n 7 :
A
B
C D
n 8 :
n 9 :
n 10 : n 11 :
(2) (3 )
Figure 9: The four possible configurations of overlapped
fragments within a single tree. For type 1, let ? =
?(n
1
, n
3
) and ? = ?(n
2
, n
4
). The roots and gaps of the
fragments are interleaved. For type 1?, let ? = ?(n
1
, n
3
)
and ? = ?(n
2
). The root of ? dominates the gap of ?.
For type 2, let ? = ?(n
5
, n
6
) and ? = ?(n
5
, n
7
). The
fragments share a root and have gap nodes that do not
dominate each other. For type 3 let ? = ?(n
8
, n
10
) and
? = ?(n
9
, n
11
). The root of ? dominates the root of ?,
both roots dominate both gaps, but neither gap dominates
the other.
cision process. Second, the removal of a fragment
may cause a previously non-isolatable set of links to
become isolatable, effectively creating a new frag-
ment that may be advantageous to remove. This is
demonstrated in Figure 8. These possibilities raise
the question of whether the choice between remov-
ing fragments ? and ? may have consequences at a
later stage in the excision process. We demonstrate
that this choice cannot affect the k found for a given
grammar.
We begin by sketching the proof of a lemma that
shows that removal of a fragment ? that partially
overlaps another fragment ? always leaves an anal-
ogous fragment that may be removed.
5.1 Validity Preservation
Consider a STAG tree pair ? containing the set of
links ? and two synchronous fragments ? and ?
with ? containing links links(?) and ? containing
links(?) (links(?), links(?) ( ?).
If ? and ? do not overlap, the removal of ? is
defined as validity preserving with respect to ?.
If ? and ? overlap, removal of ? from ? is valid-
ity preserving with respect to ? if after the removal
there exists a valid synchronous fragment (contain-
ing at most one gap on each side) that contains all
and only the links (links(?)? links(?))?{x}where
x is the new link added to ?.
remove ?
remove ?
A
B
C
D
E
F G
n 1 :
n 2 :
n 3 :
n 4 :
n 5 :
n 6 : n 7 :
An 1 : En 5 :
Cn 3 :
x x
Dn 4 :
Fn 6 :
H I
An 1 :
Bn 2 :
J x
Dn 4 :
En 5 :
K x
Dn 4 :
Figure 10: Removal from a tree pair ? containing type 1?
type 2 fragment overlap. The fragment ? is represented
by the horizonal-lined pieces of the tree pair. The frag-
ment ? is represented by the vertical-lined pieces of the
tree pair. Cross-hatching indicates the overlapping por-
tion of the two fragments.
We prove a lemma that removal of any syn-
chronous fragment from an STAG tree pair is va-
lidity preserving with respect to all of the other syn-
chronous fragments in the tree pair.
It suffices to show that for two arbitrary syn-
chronous fragments ? and ?, the removal of ? is
validity preserving with respect to ?. We show this
by examination of the possible configurations of ?
and ?.
Consider the case in which ? is fully contained
within ?. In this case links(?) ( links(?). The re-
moval of ? leaves the root and gap of ? intact in both
trees in the pair, so it remains a valid fragment. The
new link is added at the new node inserted where
? was removed. Since ? is fully contained within
?, this node is below the root of ? but not below
its gap. Thus, the removal process leaves ? with the
links (links(?)?links(?))?{x}, where x is the link
added in the removal process; the removal is validity
preserving.
Synchronous fragments may partially overlap in
several different ways. There are four possible con-
figurations for an overlapped fragment within a sin-
gle tree, depicted in Figure 9. These different single-
tree overlap types can be combined in any way to
form valid synchronous fragments. Due to space
constraints, we consider two illustrative cases and
leave the remainder as an exercise to the reader.
An example of removing fragments from
a tree set containing type 1?type 2 over-
lapped fragments is given in Figure 10.
Let ? = ??L(n1, n3), ?R(n5, n6)?. Let
610
? = ??L(n2, n4), ?R(n5, n7)?. If ? is re-
moved, the validity preserving fragment for ? is
???L(n1, n4), ?
?
R(n5)?. It contains the links in the
vertical-lined part of the tree and the new link x .
This forms a valid fragment because both sides con-
tain at most one gap and both contain the same set
of links. In addition, it is validity preserving for ?
because it contains exactly the set of links that were
in links(?) and not in links(?) plus the new link
x . If we instead choose to remove ?, the validity
preserving fragment for ? is ???L(n1, n4), ?
?
R(n5)?.
The links in each side of this fragment are the same,
each side contains at most one gap, and the set of
links is exactly the set left over from links(?) once
links(?) is removed plus the newly generated link x .
An example of removing fragments from a tree
set containing type 1??type 3 (reversed) overlapped
fragments is given in Figure 11. If ? is re-
moved, the validity preserving fragment for ? is
???L(n1), ?
?
R(n4)?. If ? is removed, the validity pre-
serving fragment for ? is ???L(n1, n8), ?
?
R(n4)?.
Similar reasoning follows for all remaining types
of overlapped fragments.
5.2 Proof Sketch
We show that smallest-first removal of fragments is
optimal. Consider a decision point at which a choice
is made about which fragment to remove. Call the
size of the smallest fragments at this pointm, and let
the set of fragments of size m be X with ?, ? ? X .
There are two cases to consider. First, consider
two partially overlapped fragments ? ? X and
? /? X . Note that |links(?)| < |links(?)|. Valid-
ity preservation of ? with respect to ? guarantees
that ? or its validity preserving analog will still be
available for excision after ? is removed. Excising
? increases k more than excising ? or any fragment
that removal of ? will lead to before ? is considered.
Thus, removal of ? cannot result in a smaller value
for k if it is removed before ? rather than after ?.
Second, consider two partially overlapped frag-
ments ?, ? ? X . Due to the validity preservation
lemma, we may choose arbitrarily between the frag-
ments in X without jeopardizing our ability to later
remove other fragments (or their validity preserving
analogs) in that set. Removal of fragment ? cannot
increase the size of any remaining fragment.
Removal of ? or ? may generate new fragments
remove ?
remove ?
A
B
C
n 1 :
n 2 :
n 3 :
E
F G
n 5 :
n 6 : n 7 :
Dn 4 : An 1 :
Cn 3 :
xH En 5 :
x
Fn 6 :
I
Dn 4 : An 1 :
Bn 2 :
xJ ?
Dn 4 :
K x
Gn 7 :
n 8 :
Figure 11: Removal from a tree pair ? containing a type
1
??type 3 (reversed) fragment overlap. The fragment ? is
represented by the horizontal lined pieces of the tree pair.
The fragment ? is represented by the vertical-lined pieces
of the tree pair. Cross-hatching indicates the overlapping
portion of the two fragments.
that were not previously valid and may reduce the
size of existing fragments that it overlaps. In addi-
tion, removal of ?may lead to availability of smaller
fragments at the next removal step than removal of ?
(and vice versa). However, since removal of either ?
or ? produces a k of size at leastm, the later removal
of fragments of size less than m cannot affect the k
found by the algorithm. Due to validity preservation,
removal of any of these smaller fragments will still
permit removal of all currently existing fragments or
their analogs at a later step in the removal process.
If the removal of ? generates a new fragment ? of
size larger thanm all remaining fragments inX (and
all others smaller than ?) will be removed before ?
is considered. Therefore, if removal of ? generates a
new fragment smaller than ?, the smallest-first strat-
egy will properly guarantee its removal before ?.
6 Conclusion
In order for STAG to be used in machine translation
and other natural-language processing tasks it must
be possible to process it efficiently. The difficulty in
parsing STAG stems directly from the factor k that
indicates the degree to which the correspondences
are intertwined within the elementary structures of
the grammar. The algorithm presented in this pa-
per is the first method available for k-arizing a syn-
chronous TAG grammar into an equivalent grammar
with an optimal value for k. The algorithm operates
offline and requires only O(|G|+ |Y | ? L3G) time.
Both the derivation trees and derived trees produced
are trivially homomorphic to those that are produced
by the original grammar.
611
References
Aho, Alfred V. and Jeffrey D. Ullman. 1969. Syntax di-
rected translations and the pushdown assembler. Jour-
nal of Computer and System Sciences, 3(1):37?56.
Chiang, David and Owen Rambow. 2006. The hid-
den TAG model: synchronous grammars for parsing
resource-poor languages. In Proceedings of the 8th
International Workshop on Tree Adjoining Grammars
and Related Formalisms (TAG+ 8), pages 1?8.
Gildea, Daniel, Giorgio Satta, and Hao Zhang. 2006.
Factoring synchronous grammars by sorting. In Pro-
ceedings of the International Conference on Compu-
tational Linguistics and the Association for Computa-
tional Linguistics (COLING/ACL-06), July.
Han, Chung-Hye. 2006a. Pied-piping in relative clauses:
Syntax and compositional semantics based on syn-
chronous tree adjoining grammar. In Proceedings
of the 8th International Workshop on Tree Adjoining
Grammars and Related Formalisms (TAG+ 8), pages
41?48, Sydney, Australia.
Han, Chung-Hye. 2006b. A tree adjoining grammar
analysis of the syntax and semantics of it-clefts. In
Proceedings of the 8th International Workshop on Tree
Adjoining Grammars and Related Formalisms (TAG+
8), pages 33?40, Sydney, Australia.
Joshi, Aravind K. and Yves Schabes. 1997. Tree-
adjoining grammars. In G. Rozenberg and A. Sa-
lomaa, editors, Handbook of Formal Languages.
Springer, pages 69?124.
Nesson, Rebecca and Stuart M. Shieber. 2006. Sim-
pler TAG semantics through synchronization. In Pro-
ceedings of the 11th Conference on Formal Grammar,
Malaga, Spain, 29?30 July.
Nesson, Rebecca and Stuart M. Shieber. 2007. Extrac-
tion phenomena in synchronous TAG syntax and se-
mantics. In Proceedings of Syntax and Structure in
Statistical Translation (SSST), Rochester, NY, April.
Nesson, Rebecca, Stuart M. Shieber, and Alexander
Rush. 2006. Induction of probabilistic synchronous
tree-insertion grammars for machine translation. In
Proceedings of the 7th Conference of the Associa-
tion for Machine Translation in the Americas (AMTA
2006), Boston, Massachusetts, 8-12 August.
Satta, Giorgio. 1992. Recognition of linear context-free
rewriting systems. In Proceedings of the 10th Meet-
ing of the Association for Computational Linguistics
(ACL92), pages 89?95, Newark, Delaware.
Seki, H., T. Matsumura, M. Fujii, and T. Kasami. 1991.
On multiple context-free grammars. Theoretical Com-
puter Science, 88:191?229.
Shieber, Stuart M. 1994. Restricting the weak-generative
capacity of synchronous tree-adjoining grammars.
Computational Intelligence, 10(4):371?385, Novem-
ber.
Shieber, Stuart M. and Yves Schabes. 1990. Syn-
chronous tree adjoining grammars. In Proceedings of
the 13th International Conference on Computational
Linguistics (COLING ?90), Helsinki, August.
Weir, David. 1988. Characterizing mildly context-
sensitive grammar formalisms. PhD Thesis, Depart-
ment of Computer and Information Science, Univer-
sity of Pennsylvania.
Zhang, Hao and Daniel Gildea. 2007. Factorization of
synchronous context-free grammars in linear time. In
NAACL Workshop on Syntax and Structure in Statisti-
cal Translation (SSST), April.
Zhang, Hao, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for ma-
chine translation. In Proceedings of the Human Lan-
guage Technology Conference/North American Chap-
ter of the Association for Computational Linguistics
(HLT/NAACL).
612
Proceedings of SSST, NAACL-HLT 2007 / AMTA Workshop on Syntax and Structure in Statistical Translation, pages 9?16,
Rochester, New York, April 2007. c?2007 Association for Computational Linguistics
Extraction Phenomena in Synchronous TAG Syntax and Semantics
Rebecca Nesson and Stuart M. Shieber
School of Engineering and Applied Sciences
Harvard University
Cambridge, MA 02138
{nesson,shieber}@deas.harvard.edu
Abstract
We present a proposal for the structure
of noun phrases in Synchronous Tree-
Adjoining Grammar (STAG) syntax and
semantics that permits an elegant and uni-
form analysis of a variety of phenom-
ena, including quantifier scope and ex-
traction phenomena such as wh-questions
with both moved and in-place wh-words,
pied-piping, stranding of prepositions, and
topicalization. The tight coupling be-
tween syntax and semantics enforced by
the STAG helps to illuminate the critical
relationships and filter out analyses that
may be appealing for either syntax or se-
mantics alone but do not allow for a mean-
ingful relationship between them.
1 Introduction
Nesson and Shieber (2006) showed how a now-
standard variant of the tree-adjoining grammar
(TAG) formalism (multi-component, multiple ad-
junction, finite-feature-based TAG), when synchro-
nized, leads to a natural analysis of the syntax-
semantics relation, including handling of syntactic
movement phenomena such as wh questions and rel-
ativization, semantic ?movement? phenomena such
as quantification, quantifier scope ambiguity, and
even their interactions as found in pied-piped rela-
tive clauses.1 phenomena were previously viewed
1This work was supported in part by grant IIS-0329089 from
the National Science Foundation.
as problematic for TAG analyses, leading to the hy-
pothesizing of various extensions to the TAG for-
malism (Kallmeyer and Romero, 2004, and work
cited therein). Independently, Han (2006a) devel-
oped a similar synchronous TAG analysis of pied-
piping, providing evidence for the naturalness of the
analysis.
Here, we update the analyses of noun phrases
found in the previous works in one simple way,
again with no additional formal TAG innovations,
and show that it allows a further coverage of extrac-
tion and quantification phenomena as well as in-situ
wh-phrases and topicalization. We emphasize that
no novel formal devices are postulated to achieve
this increased coverage ? just a simple, natural and
uniform change to the canonical structure of NPs
and their semantics.
A word may be useful on the pertinence of this
work in a workshop on ?syntax and structure in ma-
chine translation?, above and beyond the intrinsic
importance of exploring the ?applications of [syn-
chronous/transduction grammars] to related areas
including. . . formal semantics? underlying the work-
shop. Tree-structured mappings are advocated for
machine translation systems because they allow for
the expression of generalizations about relationships
between languages more accurately and effectively.
Evidence for this benefit ought to be found in the
ability of the formalisms to characterize the primi-
tive linguistic relationships as well, in particular, the
form-meaning relationship for a natural language.
The present work is part of a general program to
explore the suitability of synchronous grammars for
expressing this primary linguistic relationship. Inso-
9
far as it is successful, it lends credence to the use of
these formal tools for a variety of language process-
ing tasks, including MT. Insofar as it reveals insuffi-
ciencies in the formalism, it may lead to insights in
the design or deployment of alternative systems.
We present a proposal for the structure of noun
phrases in Synchronous Tree-Adjoining Grammar
(STAG) syntax and semantics that permits an elegant
and uniform analysis of a variety of phenomena, in-
cluding quantifier scope and extraction phenomena
such as wh-questions with both moved and in-situ
wh-words, pied-piping, stranding of prepositions,
and topicalization. Furthermore, the tight coupling
between syntax and semantics enforced by grammar
synchronization helps to illuminate the critical rela-
tionships and filter out analyses that may be appeal-
ing for either syntax or semantics alone but do not
allow for a meaningful relationship between them.
We begin in Section 2 with a brief review of syn-
chronous TAG and its application to English syntax
and semantics. In Section 3, we present an analysis
of quantifier scope that elucidates the relationship
between the syntactic and semantic structures and
explains an anomaly of previously proposed analy-
ses. We apply the underlying idea from Section 3
to wh-questions in Section 4, showing that an al-
teration of the standard TAG syntax analysis of wh-
questions produces the same derived trees while also
elegantly modeling in-place wh-words. In Section 5
we present a challenging case for STAG syntax and
semantics, the stranding of prepositions. This case
is particularly difficult because the syntactic analy-
ses suggested by previous work in STAG syntax do
not encapsulate the relationships that appear neces-
sary for the semantics. Our proposed analysis falls
out naturally from the revision to the syntax of wh-
words and respects both Frank?s Condition on Ele-
mentary Tree Minimality (CETM) and the seman-
tic relationships in the construction. In Section 6
we give an analysis of topicalization that also fol-
lows from the underlying ideas of the earlier analy-
ses. We summarize the main ideas of the analysis in
Section 7.
2 Introduction to Synchronous TAG
A tree-adjoining grammar (TAG) consists of a
set of elementary tree structures of arbitrary depth,
S
NP? V P
NP?V
likes
NP
John
S
V P
NP?V
likes
NP
John
V P
Adv V P?
S
NP? V P
NP?V
likesapparently
V P
Adv
S
NP?
V P
NP?V
likes
apparently
=?
=?
Figure 1: Example TAG substitution and adjunction.
which are combined with two operations, substitu-
tion and adjunction. Internal nodes in the elementary
trees are labeled with a nonterminal symbol. Fron-
tier nodes may be labeled with either terminal sym-
bols or nonterminal symbols annotated with one of
the diacritics ? or ?. The ? diacritic marks a frontier
nonterminal node as a substitution node, the target
of the substitution operation. The substitution op-
eration occurs when an elementary tree rooted in a
nonterminal symbol A replaces a substitution node
with the same nonterminal symbol.
Auxiliary trees are elementary trees in which the
root and a frontier node, called the foot node and
distinguished by the diacritic ?, are labeled with the
same nonterminal A. The adjunction operation in-
volves splicing an auxiliary tree in at an internal
node in an elementary tree also labeled with non-
terminal A. Trees without a foot node, intended for
substitution rather than adjunction into other trees,
are called initial trees. Examples of the substitu-
tion and adjunction operations on sample elemen-
tary trees are shown in Figure 1. For further infor-
mation, refer to Joshi and Schabes (1997).
Synchronous TAG (Shieber, 1994; Shieber and
Schabes, 1990) extends TAG by taking the elemen-
tary structures to be pairs of TAG trees with links
between particular nodes in those trees. Derivation
proceeds as in TAG except that all operations must
be paired. That is, a tree can only be substituted or
adjoined at a node if its pair is simultaneously sub-
stituted or adjoined at a linked node. We notate the
links by using boxed indices i marking linked nodes.
10
mary
j o h n
apparently
likes
1 2
3
4
1
23
4
NP
NP
e
e
V P
Adv V P?
t
t ?
S
NP? V P
NP?V
t
e?
e?
likes
? t , t ?
apparently
John
M a r y
?e , t?
likes
j o h n
apparently
mary
2
3 4
V P
V
likes
V P
Adv
apparently
NP
NP
John M a r y
S
likes
t
?e , t?apparently
t
? t , t ?
mary
e j o h n
e
( a ) ( b ) ( c )
Figure 2: An English syntax/semantics STAG fragment (a), derived tree pair (b), and derivation tree (c) for
the sentence ?John apparently likes Mary.?
As first described by Shieber and Schabes (1990),
STAG can be used to provide a semantics for a TAG
syntactic analysis by taking the tree pairs to repre-
sent a syntactic analysis synchronized with a seman-
tic analysis.
For example, Figure 2(a) contains a sample En-
glish syntax/semantics grammar fragment that can
be used to analyze the sentence ?John apparently
likes Mary?. The node labels we use in the seman-
tics correspond to the semantic types of the phrases
they dominate.
Figure 2(c) shows the derivation tree for the sen-
tence. Substitutions are notated with a solid line and
adjunctions are notated with a dashed line. Each link
in the derivation tree specifies a link number in the
elementary tree pair, providing the location at which
the operations take place. In this case, the tree pairs
for the noun phrases John and Mary substitute into
the likes tree pair at links 3 and 4 , respectively. The
word apparently adjoins at link 2 . The tree pair so
derived is shown in Figure 2(b). The resulting se-
mantic representation can be read off the right-hand
derived tree by treating the leftmost child of a node
as a functor and its siblings as its arguments. Our
sample sentence thus results in the semantic repre-
sentation apparently(likes( john,mary)).
3 Quantifier Scope
We start by reviewing the prior approach to quan-
tifier semantics in synchronous TAG. Consider the
sentence ?Everyone likes someone.? We would like
to allow both the reading where some takes scope
over every and the reading where every takes scope
over some. We start with the proposal of Shieber and
Schabes (1990), which used multi-component TAG
for the semantic portion of a synchronous TAG.
Each quantified noun phrase has a two-component
tree set as its semantics. One component introduces
the variable quantified over in the scope of the quan-
tifier; the other adjoins over the scope to provide the
quantifier and restriction. Williford (1993) explored
the use of multiple adjunction (Schabes and Shieber,
1993) to achieve scope ambiguity. Since the scope
components of subject and object noun phrases
adjoin at the same location in the semantic tree,
they give rise to a systematic ambiguity as to which
dominates the other in the derived tree, reflecting
the semantic scope ambiguity of the sentence; the
derivation tree itself is therefore a scope neutral
representation. Previous work by Han (2006a;
2006b) and Nesson and Shieber (2006) describe
this approach in detail, showing its applicability to
a range of semantic phenomena.
A range of research has proceeded in an alter-
native line of using complex-feature-based TAG ?
rather than synchronous TAG ? for TAG seman-
tics (Kallmeyer and Romero, 2004, and work cited
therein). Semantic representations are carried in fea-
tures associated with nodes. Nonetheless, multi-
component TAG with separate trees for bound po-
sition and scope is used here too. However, the two
trees are syntactic trees, the quantified NP tree and a
vestigial S tree, respectively. (An example is shown
in Figure 6.) In such analyses, the single-node aux-
iliary S tree is used for the scope part of the syntax
in order to get the desired relationship between the
quantifier and the quantified expression in features
threaded through the derivation tree and hence in the
semantics.
The present analysis marries these two ap-
11
NP
Det N?
tevery x
x
t
t ?
e
x
11
every
?e, t??
NP
Det N?
t
t
t ?
e11 ?e, t??
s o m e
so m e
y
y
y
23
4
S
NP? V P
NP?V
likes
likes
1 2
4
t
e ?
e ??e, t? 3
3 4
personone
?e, t?N
NP
Det
every
S
V P
V
likes
NP
Det N
so m e
N t
person
?e, t?
ys o m e
y
t
ttevery x
x
t
person
?e, t?
one one likes
?e, t? e
xe
y
t
person
?e, t?
t
tt
t
person
?e, t?
likes
?e, t? e
xe
y
every
s o m e
x
y
y
x
likes
every s o m e
personperson
3
1 1
4
( a )
( b )( c )
S ? S ? 31 4
Figure 3: The elementary tree pairs (a), derivation tree (b), and derived trees (c) for the sentence ?Everyone
likes someone?. Note that the derivation tree is a scope neutral representation: depending on whether every
or some adjoins higher, we obtain different semantic derived trees and scope orderings.
proaches. Like the previous STAG work, we pro-
pose a solution in which a multi-component tree set
provides semantics for quantified phrases, with mul-
tiple adjunction providing scope ambiguity. Like
the complex-feature-based approach, we reflect the
multi-component structure in the syntax as well. It
is this single change in the analysis that makes pos-
sible the coverage of the wide range of phenomena
we describe here.
Combining these two approaches, we give both
the syntactic and semantic trees for quantifiers two
parts, as depicted in Figure 3(a). In the semantics,
the top part corresponds to the scope of the quan-
tifier and attaches where the quantifier takes scope.
The bottom part corresponds to the bound variable
of the quantifier. By multiply adjoining the scope
parts of the semantic trees of the quantifiers at the
same location in the likes tree, we generate both
available scope readings of the sentence.2 Corre-
spondingly on the syntax side, an NP tree provides
the content of the noun phrase with a vestigial S tree
available as well. Prior to the analyses given in this
paper, the use of two trees in the quantifier syntax
was an arbitrary stipulation used to make the seman-
tic analysis possible. The pairing of the upper tree
2Nesson and Shieber (2006) provide a more in-depth expla-
nation of the multiple-adjunction-driven approach to scope neu-
trality in STAG.
in the syntax with the scope tree in the semantics
explicitly demonstrates their relationship and leads
naturally to the exploration of non-degenerate upper
trees in the syntax that we explore in this paper.
In order to use these multi-component quantifiers,
we change the links in the elementary trees for verbs
to allow a single link to indicate two positions in
the syntax and semantics where a tree pair can ad-
join, as shown in Figure 3(a). We add four-way
links and drop the two-way links used by the un-
quantified noun phrases in the first example. This
choice forces all noun phrase tree pairs to be multi-
component in the syntax and semantics. Essentially,
all noun phrases are ?lifted? a` la Montague. We ex-
plore the consequences of this in Section 6.
We turn now to the ramifications of this new
syntactico-semantic STAG representation, showing
its utility for a range of phenomena.
4 Wh-questions
The structure we propose for quantifiers suggests a
new possibility for the TAG analysis of wh-words.
We propose to simply treat wh-words as regular
noun phrases by making them a multi-component
tree set with an auxiliary tree that adjoins at the root
of the verb tree and contains the lexical content and
an initial tree with an empty frontier that substitutes
at the argument position. This syntactic tree set can
12
S?WH
N P
x
e
t
who t ?
x
S
who
!
S?WH
who N P
!
S
or
which
N P
S
WH N ?
S?
N P
!
S?
S
!
N P
which
N P
WH N ?
t
which x t t ?
e
x
e
x
? e , t??or
Figure 4: Elementary tree pairs for who and which. The left and middle tree sets are the syntactic alternatives
used to model wh-movement and in-situ wh-words. The tree sets on the right provide the semantics.
23
4
S
NP? V P
NP?V
likes
31 4
2
3
4
S
V P
NP?V
likes
31 4
S
W H ?
23
4 S
NP? V P
V
likes
31 4
S
W H ?
NP
! NP
!
Figure 5: Traditional elementary trees for the verb
likes. Using a revised, elementary syntax tree set for
wh-words like who, only the left tree is necessary.
be paired with a multi-component semantic tree set
that has an auxiliary tree containing the scope part
and an initial tree that contains the bound variable.
Wh-questions with the wh-word in place can be ele-
gantly modeled with an alternative syntactic tree set
in which the auxiliary tree has no lexical content and
the wh-word is on the frontier of the initial tree that
substitutes into the argument position. The seman-
tic tree sets for both syntactic variations is the same.
These trees are shown in Figure 4.
Besides the incorporation of a semantics, the ba-
sic analyses for wh-questions familiar from TAG
syntax are otherwise unchanged because the top
piece of the syntax tree set still ends up at the root of
the main verb in sentences such as the following:
(1) Who likes Mary?
who(x, likes(mary,x))
(2) Which person does John like?3
which(x, person(x), likes(x, john))
3The presence of do-support in wh-questions can be handled
independently using a feature on the NP node into which the
bottom part of the wh-word tree pair substitutes that governs
whether and where a do tree adjoins.
(3) Which person does Bill think John likes?
which(x, person(x), thinks(bill, likes(x, john)))
(4) Who does each person like?
who(x,each(y, person(y), likes(x,y)))
each(y, person(y),who(x, likes(x,y)))
Note that in Sentence 3 thinks is not constrained
to appear to the right of who in the syntax, because
thinks and who both adjoin at the same location in
the syntax. However, we can use a feature to force
embedding verbs to adjoin lower than wh-words.
The same situation exists in Sentence 4, though only
in the semantics; the order of words in the syntax
is well-defined but the multiple adjunction of the
scope of who and the scope of each underspecifies
the scope ordering between them. Both scope or-
derings are indeed arguably valid. Again, the pref-
erences for certain orderings can be regulated us-
ing a feature. These issues highlight the many open
questions about how to combine quantification and
wh-terms, but also provides a first step towards their
analysis within a concise STAG construction.
Our approach has several distinct advantages.
First, it allows wh-words to be analyzed in a way that
is uniform with the analysis of other noun phrases
and allows us to simplify the lexical entries for
verbs. In the traditional TAG analysis, wh-words
substitute into specialized lexical trees for verbs that
add an additional frontier node for the wh-word and
abstract over one of the arguments of the verb by
adding an empty terminal node at the frontier. Our
revision to the elementary trees for wh-words allows
us to remove several tree pairs from the elementary
tree sets for verbs such as like. Instead of requir-
ing an elementary tree pair for declarative sentences
and an additional elementary tree for each argument
13
S?? S?
W H
whom
N P
J ohn
?
Sd oe s
V P
V
lik e
S?
Det
a
N ?
N P ?
N
P Ppicture
o f
?
?
?
?
?
?
?
a
b
c
d
e
?
?
?
?
?
?
?
?
?
?
?
?
?
?
a
b
c
d
e
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
a
b
c
d
e
f
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
a
b
c
d
e
f
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
W H ? S
N PN P
N P[ ]
N P
!
Figure 6: Kallmeyer and Scheffler?s syntactic analy-
sis for Sentence 6.
that can be replaced by a fronted wh-word to form a
question (as shown in Figure 5), we can use just the
single declarative sentence elementary tree.
Second, it provides a simple and elegant char-
acterization of the syntax and semantics of wh-
movement and the relationship between fronted and
in-place wh-words. Using the alternative syntax tree
set given in Figure 4 we model in-place use of wh-
words as in Sentence 5 while still maintaining the
usual semantic analysis:
(5) John likes who?
who(x, likes(x, john))
5 Stranded Prepositions
Sentence 6 presents a particularly challenging case
for TAG semantics. The problem arises because who
must contribute its bound variable, x, to the noun
phrase ?a picture of x?. However, in the standard
syntactic analysis who substitutes into the likes tree,
and in any reasonable semantic analysis, who takes
scope at the root of the likes tree.
(6) Who does John like a picture of?
who(x,a(y, and(picture(y),of (x,y)),
likes( john,y)))
Kallmeyer and Scheffler (2004) propose a syntac-
tic analysis in which ?a picture of? adjoins into the
syntactic tree for ?likes?. The syntax for this anal-
ysis is shown for comparison in Figure 6. As-
sociated with the syntactic analysis is a semantic
analysis, which differs from ours in that all of the
semantic computation is accomplished by use of
a flexible set of features that are associated with
nodes in the syntactic trees. This analysis main-
tains Frank?s Constraint on Elementary Tree Min-
imality (CETM) if one analyzes the prepositional
phrase as a complement of picture but it does so at
the expense of a straightforward compositional se-
mantics.4 The source of the problem is that who
contributes its bound variable to likes to form an
intermediate semantics who(x, likes( john,x)), then
a picture of combines non-compositionally to form
the complete semantics given in Sentence 6.
Kroch (1989) describes the intuition eschewing
this analysis: ?The problem is that under such a
derivation, the preposed wh-phrase changes its the-
matic role with each adjunction and the interpreta-
tion of the derived tree is not a simple function of the
interpretations of its component elementary trees.?
When we consider the semantics of the two sen-
tences, the anomaly of this analysis becomes appar-
ent. In the first sentence the entity liked by John is
referred to by the variable contributed by who. In the
second sentence John likes an entirely different en-
tity: the entity referred to by the variable contributed
by a. Kallmeyer and Scheffler obtain the correct se-
mantics by making use of non-local TAG operations
to have the scope part of a adjoin into likes to cap-
ture the semantics of the likes proposition and em-
ploying a feature-based mechanism for swapping the
variables as necessary.
Our revision to the syntax of wh-words provides
an alternative way of maintaining the CETM that of-
fers a much simpler semantic analysis. The details
of the analysis are given in Figure 7. We adjoin who
into the preposition of at link 1 where it contributes
both variable and scope. The tree pair for of at-
taches to a at link 1 , thus allowing the scope parts
of the quantifier a and the wh-word who to end up
taking scope over the main verb as in the analysis of
prepositional phrases given by Nesson and Shieber
(2006). It also places all the bound variables in the
correct propositions without use of non-local opera-
tions or additional manipulation. A diagram of the
derived syntax and semantics is given in Figure 8.
4In addition to suggesting a non-compositional seman-
tics, their syntactic analysis makes use of non-local multi-
component TAG in order to achieve the necessary semantic rela-
tionships. Although their use of non-local TAG may be benign
in terms of complexity, our analysis is set-local. Our proposal
therefore simplifies the syntactic analysis while also bringing it
in line with a straightforward, compositional semantics.
14
NP?
V P
V
likes
t
e ?
?e, t?
?e, ?e, t??
NP? e ?
likes
S
3
4
31 4 1 2 3 4
3
4
2
likes
john a
picture of
w h o
1
12
43
Det
a
yN P
N ?
t
t ?a t
?e, t?? ey
y
1S ? 1
1
1
22
N P
P P
P
of
t ?
?e, t?
?e, t??a n d
e ?of
?e, t?
S ?
NP?
NP?
1 1
11
S ?W H
w h o NP
!
x
e
t
w h o t ?
x
S
john john
N P e
t ?S ?
N ?e, t?
picture picture
Figure 7: The elementary tree pairs and derivation tree for the sentence ?Who does John like a picture of??.
NP?
V P
V
likes
NP?
S
3
4
31 4
2
Det
a
NP
N ?
S ? 1
1
2
NP
P P
P
o f
S ?
NP?
NP?
1
1
john
NP
S ?
N
picture
S ?W H
w h o
NP
!
S
t
e ?
?e, t?
?e, ?e, t??
e ?
likes
1 2 3 4
3
4
y
t
t ?a t
?e, t??
e
y
y
1
1 2
t ?
?e, t?
?e, t??a n d
e ?o f
?e, t?
1
1
x
e
t
w h o t ?
x
john
e
t ?
?e, t?
picture
Figure 8: The derived syntax and semantics for Sentence 6.
6 Topicalization
The insight that allows us to model in-place wh-
words extends to an elegant analysis of topicaliza-
tion as well. The vestigial S? tree that we added
to the tree set for the syntax of every noun phrase
need not always be contentless. Just as we moved
the wh-word who from the top tree in its set to the
bottom tree to model in-situ wh-words, we can move
the lexical content of noun phrases to the top tree in
their sets to model topicalization. For instance, the
alternative tree pair for Mary shown in Figure 9 pro-
vides for an analysis of the sentence
(7) Mary, John likes.
likes(mary,john)
The analysis interacts properly with that for prepo-
sition stranding, so that the sentence
S?
NP e
t ?
S
!
NP
Mary
Mary
S?
NP
S
!
y
t
t ?a t
?e, t?? ey
y
1
1 2D et
a
NP
N ?
1
2
Figure 9: Alternative tree pairs for Mary and a that
model topicalization.
(8) A picture of Mary, John likes.
a(x, and(picture(x), of(mary,x)), likes(x,john))
follows from the tree pair for a in the same figure.
7 Conclusion
In this paper we have proposed a uniform change
to the structure of noun phrases in the STAG
syntactico-semantic grammar. The formal tools we
avail ourselves of comprise synchronous TAG with
15
set-local multicomponent adjunction and multiple
adjunction. Nothing more is required.
All noun phrases now have a uniform multi-
component structure in both the syntax and the
semantics. In the semantics the top part corresponds
to the scope-giving piece provided by the noun
phrase and the bottom part to the bound variable
or simple noun-phrase meaning. In the syntax, the
top part corresponds to the lexical material that
should appear moved to the edge of the sentence or
clause; the bottom part corresponds to the lexical
material that will fill an argument position of some
head. By moving lexical material among the pieces
of the multi-component set in the syntax, we can
simply model phenomena like in-place wh-words
and topicalization.
Making the top parts of wh-word tree sets into
auxiliary trees allows them to adjoin not just to the
main verb but also to heads of modifying clauses,
such as prepositional phrases. This allows us to
handle more complex sentences like Sentence 6
without violating either the CETM or going beyond
simple compositional semantics. In order to allow
the scope-giving part of the wh-word to percolate
up to the root of the semantics of the main verb,
each tree set that it adjoins into on its way must
also have a scope part in the semantics to which
it can adjoin. Scope carriers, such as prepositions,
are therefore also multi-component in the semantics
with a top node to which scope-givers can adjoin.
One nice property of this analysis is that it predicts
the observed facts about disallowed scope orderings
in sentences that have three quantifiers, one of
which is in a modifying clause. The scope part of
the quantifier of the modified clause and the scope
part of the quantifier of the modifying clause form
an indivisible set as the derivation proceeds so that
when they adjoin multiply with the scope part of the
unmodified clause, that quantifier cannot intervene
between them.
Our synchronous grammar treatment of the
syntax-semantic relation with TAG is at least as
simple and arguably more accurate than previous
TAG proposals, offering treatments of such phe-
nomena as in-situ wh-words, stranded prepositions,
and topicalization.
References
Chung-Hye Han. 2006a. Pied-piping in relative clauses:
Syntax and compositional semantics based on syn-
chronous tree adjoining grammar. In Proceedings
of the 8th International Workshop on Tree Adjoining
Grammars and Related Formalisms (TAG+ 8), pages
41?48, Sydney, Australia.
Chung-Hye Han. 2006b. A tree adjoining grammar anal-
ysis of the syntax and semantics of it-clefts. In Pro-
ceedings of the 8th International Workshop on Tree
Adjoining Grammars and Related Formalisms (TAG+
8), pages 33?40, Sydney, Australia.
Aravind K. Joshi and Yves Schabes. 1997. Tree-
adjoining grammars. In G. Rozenberg and A. Salo-
maa, editors, Handbook of Formal Languages, pages
69?124. Springer.
Laura Kallmeyer and Maribel Romero. 2004. LTAG se-
mantics with semantic unification. In Proceedings of
TAG+7, pages 155?162, Vancouver, May.
Laura Kallmeyer and Tatjana Scheffler. 2004. LTAG
analysis for pied-piping and stranding of wh-phrases.
In Proceedings of TAG+7, pages 32?39, Vancouver,
May.
Anthony Kroch. 1989. Asymmetries in long distance
extraction in a tree adjoining grammar. In Mark Baltin
and Anthony Kroch, editors, Alternative Conceptions
of Phrase Structure. University of Chicago Press.
Rebecca Nesson and Stuart M. Shieber. 2006. Sim-
pler TAG semantics through synchronization. In Pro-
ceedings of the 11th Conference on Formal Grammar,
Malaga, Spain, 29?30 July.
Yves Schabes and Stuart M. Shieber. 1993. An alterna-
tive conception of tree-adjoining derivation. Compu-
tational Linguistics, 20(1):91?124.
Stuart M. Shieber and Yves Schabes. 1990. Synchronous
tree-adjoining grammars. In Proceedings of the 13th
International Conference on Computational Linguis-
tics, volume 3, pages 253?258, Helsinki.
Stuart M. Shieber. 1994. Restricting the weak-generative
capacity of synchronous tree-adjoining grammars.
Computational Intelligence, 10(4):371?385, Novem-
ber.
Sean Williford. 1993. Application of synchronous tree-
adjoining grammar to quantifier scoping phenomena in
English. Undergraduate Thesis, Harvard College.
16
Complexity, Parsing, and Factorization
of Tree-Local Multi-Component
Tree-Adjoining Grammar
Rebecca Nesson?
School of Engineering and Applied
Sciences,
Harvard University
Giorgio Satta??
Department of Information Engineering
University of Padua
Stuart M. Shieber?
School of Engineering and Applied
Sciences
Harvard University
Tree-Local Multi-Component Tree-Adjoining Grammar (TL-MCTAG) is an appealing formal-
ism for natural language representation because it arguably allows the encapsulation of the
appropriate domain of locality within its elementary structures. Its multicomponent structure
allows modeling of lexical items that may ultimately have elements far apart in a sentence, such
as quantifiers and wh-words. When used as the base formalism for a synchronous grammar, its
flexibility allows it to express both the close relationships and the divergent structure necessary
to capture the links between the syntax and semantics of a single language or the syntax of
two different languages. Its limited expressivity provides constraints on movement and, we
posit, may have generated additional popularity based on a misconception about its parsing
complexity.
Although TL-MCTAG was shown to be equivalent in expressivity to TAG when it was
first introduced, the complexity of TL-MCTAG is still not well understood. This article offers
a thorough examination of the problem of TL-MCTAG recognition, showing that even highly
restricted forms of TL-MCTAG are NP-complete to recognize. However, in spite of the provable
difficulty of the recognition problem, we offer several algorithms that can substantially improve
processing efficiency. First, we present a parsing algorithm that improves on the baseline parsing
? School of Engineering and Applied Sciences, Harvard University, 38 Plymouth St., Cambridge, MA
02141. E-mail: nesson@seas.harvard.edu.
?? Department of Information Engineering, University of Padua, via Gradenigo 6/A, 1-35131 Padova, Italy.
E-mail: satta@dei.unipd.it.
? School of Engineering and Applied Sciences, Harvard University, Maxwell Dworkin Laboratory,
33 Oxford Street, Cambridge, MA 02138. E-mail: shieber@seas.harvard.edu.
Submission received: 4 November 2008; revised submission received: 13 November 2009; accepted for
publication: 18 March 2010.
? 2010 Association for Computational Linguistics
Computational Linguistics Volume 36, Number 3
method and runs in polynomial time when both the fan-out and rank of the input grammar are
bounded. Second, we offer an optimal, efficient algorithm for factorizing a grammar to produce a
strongly equivalent TL-MCTAG grammar with the rank of the grammar minimized.
1. Introduction
Tree-Local Multi-Component Tree-Adjoining Grammar (TL-MCTAG) is an appealing
formalism for natural language representation because it arguably allows the encapsu-
lation of the appropriate domain of locality within its elementary structures (Kallmeyer
and Romero 2007). Its flexible multicomponent structure allows modeling of lexical
items that may ultimately have elements far apart in a sentence, such as quantifiers and
wh-words. Its limited expressivity provides constraints on movement and, we posit,
may have generated additional popularity based on a misconception about its parsing
complexity.
TL-MCTAG can model highly structurally divergent but closely related elementary
structures, such as the syntax and the semantics of a single word or construction or the
syntax of a single word or construction and its translation into another language, with a
pair of elementary trees. This flexibility permits conceptually simple, highly expressive,
and tightly coupled modeling of the relationship between the syntax and semantics of
a language or the syntax and semantics of two languages. As a result, it has frequently
been put to use in a growing body of research into incorporating semantics into the Tree-
Adjoining Grammar (TAG) framework (Kallmeyer and Joshi 2003; Han 2006; Nesson
and Shieber 2006, 2007). It is also under investigation as a possible base formalism
for use in synchronous-grammar based machine translations systems (Nesson 2009).
Similar pairing of elementary structures of the TAG formalism is too constrained to
capture the inherent divergence in structure between different languages or even be-
tween the syntax and semantics of a language. Pairing of more expressive formalisms is
too flexible to provide appropriate constraints and has unacceptable consequences for
processing efficiency.
Although TL-MCTAG was first introduced by Weir (1988) and shown at that time
to be equivalent in expressivity to TAG, the complexity of TL-MCTAG is still not
well understood. Perhaps because of its equivalence to TAG, questions of processing
efficiency have not been adequately addressed. This article offers a thorough exami-
nation of the problem of TL-MCTAG recognition, showing that even highly restricted
forms of TL-MCTAG are NP-complete to recognize. However, in spite of the provable
difficulty of the recognition problem, we offer several algorithms that can substantially
improve processing efficiency. First, we present a parsing algorithm that improves
on the baseline parsing method and runs in polynomial time when both the fan-out
(the maximum number of trees in a tree set) and rank (the maximum number of
trees that may be substituted or adjoined into a given tree) of the input grammar are
bounded. Second, we offer an optimal, efficient algorithm for factorizing a grammar
to produce a strongly equivalent TL-MCTAG grammar with the rank of the grammar
minimized.
1.1 Summary of Results
TAG is a mildly context-sensitive grammar formalism widely used in natural language
processing. Multicomponent TAG (MCTAG) refers to a group of formalisms that
444
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
generalize TAG by allowing elementary structures to be sets of TAG trees. One member
of the MCTAG formalism group is Tree-Local MCTAG (TL-MCTAG), in which all
trees from a single elementary tree set are constrained to adjoin or substitute into a
single tree in another elementary tree set. Weir (1988) shows that this constraint is
sufficient to guarantee that TL-MCTAG has weak generative capacity equivalent to the
polynomially parsable TAG.
Recent work on the complexity of several TAG variants has demonstrated indirectly
that the universal recognition problem for TL-MCTAG is NP-hard. This result calls
into question the practicality of systems that employ TL-MCTAG as the formalism for
expressing a natural language grammar. In this article we present a more fine-grained
analysis of the processing complexity of TL-MCTAG. We demonstrate (Section 3) that
even under restricted definitions where either the rank or the fan-out of the grammar is
bounded, the universal recognition problem is NP-complete.
We define a novel variant of multi-component TAG formalisms that treats the
elementary structures as vectors of trees rather than as unordered sets (Section 4). We
demonstrate that this variant of the definition of the formalism (the vector definition) is
consistent with the linguistic applications of the formalism presented in the literature.
Universal recognition of the vector definition of TL-MCTAG is NP-complete when
both the rank and fan-out are unbounded. However, when the rank is bounded, the
universal recognition problem is polynomial in both the length of the input string and
the grammar size.
We present a novel parsing algorithm for TL-MCTAG (Section 5) that accommo-
dates both the set and vector definitions of TL-MCTAG. Although no algorithms for
parsing TL-MCTAG have previously been published, the standard method for parsing
linear context-free rewriting systems (LCFRS)?equivalent formalisms can be applied
directly to TL-MCTAG to produce a quite inefficient baseline algorithm in which the
polynomial degree of the length of the input string depends on the input grammar.
We offer an alternative parser for TL-MCTAG in which the polynomial degree of the
length of the input string is constant, though the polynomial degree of the grammar size
depends on the input grammar. This alternative parsing algorithm is more appealing
than the baseline algorithm because it performs universal recognition of TL-MCTAG
(vector definition) with constant polynomial degree in both the length of the input string
and the grammar size when rank is bounded.
It may not be generally desirable to impose an arbitrary rank bound on TL-MCTAGs
to be used for linguistic applications. However, it is possible given a TL-MCTAG to
minimize the rank of the grammar. In the penultimate section of the paper (Section 6)
we offer a novel and efficient algorithm for transforming an arbitrary TL-MCTAG into
a strongly equivalent TL-MCTAG where the rank is minimized.
1.2 Related Work
Our work on TL-MCTAG complexity bears comparison to that of several others.
Kallmeyer (2009) provides a clear and insightful breakdown of the different charac-
teristics of MCTAG variants and the effect of these characteristics on expressivity and
complexity. That work clarifies the definitions of MCTAG variants and the relationship
between them rather than presenting new complexity results. However, it suggests
the possibility of proving results such as ours in its assertion that, after a standard
TAG parse, a check of whether particular trees belong to the same tree set cannot
be performed in polynomial time. Kallmeyer also addresses the problem of parsing
445
Computational Linguistics Volume 36, Number 3
MCTAG, although not specifically for TL-MCTAG. The method proposed differs from
ours in that MCTAGs are parsed first as a standard TAG, with any conditions on tree
or set locality checked on the derivation forest as a second step. No specific algorithm
is presented for performing the check of tree-locality on a TAG derivation forest, so it is
difficult to directly compare the methods. However, that method cannot take advantage
of the gains in efficiency produced by discarding inappropriate partial parses at the
time that they are first considered. Aside from Kallmeyer?s work, little attention has
been paid to the problem of directly parsing TL-MCTAG.
S?gaard, Lichte, and Maier (2007) present several proofs regarding the complexity
of the recognition problem for some linguistically motivated extensions of TAG that are
similar to TL-MCTAG. Their work shows the NP-hardness of the recognition problem
for these variants and, as an indirect result, also demonstrates the NP-hardness of TL-
MCTAG recognition. This work differs from ours in that it does not directly show the
NP-hardness of TL-MCTAG recognition and does not further locate and constrain the
source of the NP-hardness of the problem to the rank of the input grammar, nor does it
provide mitigation through rank reduction of the grammar or by other means.
Our work on TL-MCTAG factorization is thematically though not formally related
to the body of work on induction of TAGs from a treebank exemplified by Chen and
Shanker (2004). The factorization performed in their work is done on the basis of syn-
tactic constraints rather than with the goal of reducing complexity. Working from a
treebank of actual natural language sentences, their work does not have the benefit of
explicitly labeled adjunction sites but rather must attempt to reconstruct a derivation
from complete derived trees.
The factorization problem we address is more closely related to work on factorizing
synchronous context-free grammars (CFGs) (Gildea, Satta, and Zhang 2006; Zhang and
Gildea 2007) and on factorizing synchronous TAGs (Nesson, Satta, and Shieber 2008).
Synchronous grammars are a special case of multicomponent grammars, so the prob-
lems are quite similar to the TL-MCTAG factorization problem. However, synchronous
grammars are fundamentally set-local rather than tree-local formalisms, which in some
cases simplifies their analysis. In the case of CFGs, the problem reduces to one of
identifying problematic permutations of non-terminals (Zhang and Gildea 2007) and
can be done efficiently by using a sorting algorithm to binarize any non-problematic per-
mutations until only the intractable correspondences remain (Gildea, Satta, and Zhang
2006). This method is unavailable in the TAG case because the elementary structures
may have depth greater than one and therefore the concept of adjacency relied upon
in their work is inapplicable. The factorization algorithm of Nesson, Satta, and Shieber
(2008) is the most closely related to this one but is not directly applicable to TL-MCTAG
because each link is presumed to have exactly two locations and all adjunctions occur
in a set-local rather than tree-local manner.
2. Technical Background
A tree-adjoining grammar consists of a set of elementary tree structures of arbitrary
depth, which are combined by the operations of adjunction and substitution. Auxiliary
trees are elementary trees in which the root and a frontier node, called the foot node
and distinguished by the diacritic ?, are labeled with the same nonterminal A. The
adjunction operation entails splicing in an auxiliary tree in an internal node within
an elementary tree also labeled with nonterminal A. Trees without a foot node, which
serve as a base case for derivations and may combine with other trees by substitution,
446
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
are called initial trees. Examples of the adjunction and substitution operations are
given in Figure 1. For further background, we refer the reader to the survey by Joshi
and Schabes (1997).
A TAG derivation can be fully specified by a derivation tree, which records how
the elementary structures are combined using the TAG operations to form the derived
tree. The nodes of the derivation tree are labeled by the names of the elementary trees
and the edges are labeled by the addresses at which the child trees substitute or adjoin.
In contrast to CFGs, the derivation and derived trees are distinct.
We depart from the traditional definition in notation only by specifying adjunc-
tion sites explicitly with numbered links in order to simplify the presentation of the
issues raised by multi-component adjunctions. Each link may be used only once in a
derivation. Adjunctions may only occur at nodes marked with a link. A numbered link
at a single site in a tree specifies that a single adjunction is available at that site. An
obligatory adjunction constraint indicates that at least one link at a given node must
be used (Joshi, Levy, and Takahashi, 1975; Vijay-Shanker and Joshi 1985). We notate
obligatory adjunction constraints by underlining the label of the node to which the
constraint applies. Because we use explicit links, the edges in the derivation tree are
labeled with the number of the link used rather than the traditional label of the address
at which the operation takes place.
Multiple adjunction refers to permitting an unbounded number of adjunctions to
occur at a single adjunction site (Vijay-Shanker 1987; Shieber and Schabes 1994). In
the standard definition of TAG, multiple adjunction is disallowed to ensure that each
derivation tree unambiguously specifies a single derived tree (Vijay-Shanker 1987). Be-
cause each available adjunction is explicitly notated with a numbered link, our notation
implicitly disallows multiple adjunction but permits a third possibility: bounded mul-
tiple adjunction. Bounded multiple adjunction permits the formalism to obtain some
of the potential linguistic advantages of allowing multiple adjunction while preventing
unbounded multiple adjunction. The usual constraint of allowing only one adjunction
at a given adjunction site may be enforced in our link notation by permitting only one
link at a particular link site to be used.
MCTAG generalizes TAG by allowing the elementary items to be sets of trees rather
than single trees (Joshi and Schabes 1997). The basic operations are the same but all trees
in a set must adjoin (or substitute) into another tree set in a single step in the derivation.
To allow for multi-component adjunction, a numbered link may appear on two or more
nodes in a tree, signifying that the adjoining trees must be members of the same tree
set. Any tree in a set may adjoin at any link location if it meets other adjunction or
substitution conditions such as a matching node label. Thus a single multicomponent
Figure 1
An example of TAG operations substitution and adjunction used here to model natural
language syntax.
447
Computational Linguistics Volume 36, Number 3
Figure 2
An example of the way in which two tree sets may produce several different derived trees when
combined under the standard definition of multicomponent TAG.
link may give rise to many distinct derived trees even when the link is always used
by the same multicomponent tree set. An example is given in Figure 2. This standard
definition of multicomponent adjunction we will call the set definition for contrast with
a variation we introduce in Section 4. A derivation tree for a multicomponent TAG is
the same as for TAG except that the nodes are labeled with the names of elementary
tree sets.
An MCTAG is tree-local if tree sets are required to adjoin within a single elementary
tree (Weir 1988). Using the numbered link notation introduced earlier for adjunction
sites, a tree-local MCTAG (TL-MCTAG) is one in which the scope of the link numbers
is a single elementary tree. An example TL-MCTAG operation is given in Figure 3. In
contrast, an MCTAG is set-local if the trees from a single tree set are required to adjoin
within a single elementary tree set and an MCTAG is non-local if the trees from a single
tree set may adjoin to trees that are not within a single tree set. In a set-local MCTAG
the scope of a link is a single elementary tree set, and in a non-local MCTAG the scope
of a link is the entire grammar.
Weir (1988) noted in passing that TL-MCTAG has generative capacity equivalent to
TAG; a combination of well-chosen additional constraints and additions of duplicates
of trees to the grammar can produce a weakly equivalent TAG. Alternatively, a feature-
based TAG where the features enforce the same constraints may be used. Although the
generative capacity of the formalism is not increased, any such conversion from TL-
MCTAG to TAG may require an exponential increase in the size of the grammar as we
prove in Section 3.
3. Complexity
We present several complexity results for TL-MCTAG. S?gaard, Lichte, and Maier (2007)
show indirectly that TL-MCTAG membership is NP-hard. For clarity, we present a direct
Figure 3
An example TL-MCTAG operation demonstrating the use of TL-MCTAG to model wh-question
syntax.
448
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
proof here. We then present several novel results demonstrating that the hardness result
holds under significant restrictions of the formalism.
For a TL-MCTAG G we write |G| to denote the size of G, defined as the total number
of nodes appearing in all elementary trees in the tree sets of the grammar. Fan-out, f ,
measures the number of trees in the largest tree set in the grammar. We show that even
when the fan-out is bounded to a maximum of two, the NP-hardness result still holds.
The rank, r, of a grammar is the maximum number of derivational children possible
for any tree in the grammar, or in other words, the maximum number of links in any
tree in the grammar. We show that when rank is bounded, the NP-hardness result also
holds.
A notable aspect of all of the proofs given here is that they do not make use of
the additional expressive power provided by the adjunction operation of TAG. Put
simply, the trees in the tree sets used in our constructions meet the constraints of Tree
Insertion Grammar (TIG), a known context-free?equivalent formalism (Schabes and
Waters 1995). As a result, we can conclude that the increase in complexity stems from
the multi-component nature of the formalism rather than from the power added by an
unconstrained adjunction operation.
3.1 Universal Recognition of TL-MCTAG is NP-Complete
In this section we prove that universal recognition of TL-MCTAG is NP-complete when
neither the rank nor the fan-out of the grammar is bounded.
Recall the 3SAT decision problem, which is known to be NP-complete. Let V =
{v1, . . . , vp} be a set of variables and C = {c1, . . . , cn} be a set of clauses. Each clause in C
is a disjunction of three literals over the alphabet of all literals LV = {v1, v1, . . . , vp, vp}.
We represent each clause by a set of three literals. The language 3SAT is defined as the
set of all conjunctive formulas over the members of C that are satisfiable.
Theorem 1
The universal recognition problem for TL-MCTAG with unbounded rank and fan-out
is NP-hard.
Proof
Let ?V, C? be an arbitrary instance of the 3SAT problem.1 We use the derivations of the
grammar to guess the truth assignments for V and use the tree sets to keep track of the
dependencies among different clauses in C. Two tree sets are constructed for each vari-
able, one corresponding to an assignment of true to the variable and one corresponding
to an assignment of false. The links in the single initial tree permit only one of these two
sets to be used. The tree set for a particular truth assignment for a particular variable vi
makes it possible to introduce, by means of another adjunction, terminal symbols taken
from the set {1, . . . , n} that correspond to each clause in C that would be satisfied by the
given assignment to vi. In this way, the string w = 1 ? ? ? n can be generated if and only if
all clauses are satisfied by the truth assignment to some variable they contain.
1 We follow the proof strategy of Satta and Peserico (2005) in this and the proof of Theorem 3.
449
Computational Linguistics Volume 36, Number 3
We define a tree-local MCTAG G containing the following tree sets. The initial tree
set S contains the single tree:
In this tree, the ?rows? correspond to the variables and the ?columns? to the clauses.
Each non-terminal node within a row is labeled with the same link to ensure that a tree
set representing a single variable?s effect on each clause will adjoin at each link.
For every variable vi, 1 ? i ? p, tree set Ti, used when representing an assignment of
the value true to vi, contains n trees, one for each clause cj, 1 ? j ? n, defined as follows:
For every variable vi, 1 ? i ? p, tree set Fi ? used when representing an assignment
of the value false to vi ? contains n trees, one for each clause cj, 1 ? j ? n, defined as
follows:
For every clause cj, 1 ? j ? n, tree set Cj contains a single tree as shown here. This
tree allows the corresponding clause number terminal symbol to be recognized by an
appropriate variable instance.2
2 Note that because adjunction is not obligatory, the tree from Cj need not adjoin into the tree for a
particular variable. In fact, to generate w, exactly one instance of Cj must adjoin for each clause even if
more than one variable satisfies the clause. If w can be generated, however, we can conclude that at least
one variable must have satisfied each clause.
450
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
From the definition of G it directly follows that w ? L(G) implies the existence of a
truth assignment that satisfies C. A satisfying truth assignment can be read directly off
of any derivation tree for w. If Ti (respectively, Fi) is a child of S in the derivation tree,
then vk is true (respectively, false). The converse can be shown by using a satisfying
truth assignment for C to construct a derivation for w ? L(G).
?G, w? can be constructed in deterministic polynomial time because the number of
tree sets in the grammar is 2p + 2n + 1, the total number of trees in the grammar is
bounded by n(2p + 2n + 1), and the length of w is n. All trees in the grammar have
constant size except for the initial tree, which has size np. 
Theorem 2
The universal recognition problem for TL-MCTAG with unbounded rank and fan-out
is in NP.
Proof
We show that given an arbitrary TL-MCTAG grammar G and any input string w, the
determination of w ? L(G) can be performed in non-deterministic polynomial time.
Note that the collection of elementary tree sets of G that can generate the empty
string, E , can be generated in time polynomial in |G| using the standard graph reach-
ability algorithm used for context-free grammars in time polynomial in |G| (Sippu and
Soisalon-Soininen 1988).
We begin by showing that given an arbitrary input string w and derivation tree D
for w ? L(G), there must exist a truncated derivation tree for w that has size no larger
than |G| ? |w|. We define a truncated derivation tree as a derivation tree in which the
children of elementary tree sets in E are optionally removed.
Consider D. Each node in D represents an elementary structure of G: a tuple of
one or more TAG trees. We call a node n of D a non-splitting node if a single one
of its children in the derivation tree, ni, generates the same lexical material from the
input string as n itself.3 We call it a splitting node if more than one of its children
generates a non-empty part of the portion of the input string generated by n itself
or if n itself contributes lexical material. We proceed from the root of D examining
chains of non-splitting nodes. Assume that the root of D is a non-splitting node. This
means that it has a single child node, ni, that generates the lexical material for the entire
input string. Its other children all generate the empty string (and therefore must also be
members of E). We truncate the derivation tree at each child of n other than ni. We now
iterate the process on node ni. If during the examination of a chain of non-splitting
nodes we encounter a node identical to one that we have already seen, we remove
the entire cycle from the derivation tree because it is not essential to the derivation.
Because all cycles are removed, the longest possible chain of non-splitting nodes we
can find before encountering a splitting node or reaching the bottom of the derivation
tree is |G|.
If a splitting node is encountered, we truncate all child nodes that generate the
empty string and then iterate the process of non-splitting node identification on those
3 The child tree tuple ni may generate the same lexical material in several distinct pieces, which are
arranged into the string generated by n when the adjunction occurs. Because the adjunction necessarily
connects all of these pieces into a single string in a single predetermined way, it does not matter for our
proof that the lexical material derived by the child may be in any order before the adjunctions.
451
Computational Linguistics Volume 36, Number 3
children that generate lexical material. In the worst case, the process encounters w ? 1
splitting nodes, each of which may be separated by a chain of non-splitting nodes
of maximum length bounded by |G|. This process, therefore, produces a truncated
derivation tree with size bounded by |G| ? |w|.
The truncation of the tree at each node that generates the empty string is necessary
because the size of the subderivation tree generating the empty string may not be
bounded by a polynomial in the size of the grammar. However, the content of the part
of the derivation tree used to generate the empty string is not necessary for determining
membership of w ? L(G) because we know that each truncated node is a member of E .
To show that TL-MCTAG membership is in NP, we construct a Turing machine
that will non-deterministically guess a truncated derivation tree of size no larger than
|G| ? |w|. It then checks that the guessed derivation successfully derives w. Because the
correctness of the derivation can be checked in linear time, this is sufficient to show that
TL-MCTAG membership is in NP. 
We know from the equivalence of LCFRS and SL-MCTAG (and the rule-to-tree-
tuple conversion method used to prove equivalency) (Weir 1988) and the fact that
LCFRS membership is PSPACE-complete that SL-MCTAG membership is also PSPACE-
complete (Kaji et al 1992, 1994). Until the results shown in Theorems 1 and 2 it was
not known whether TL-MCTAG was in NP. Although the difference in generative
capacity between TL-MCTAG and SL-MCTAG is well known, this proven difference
in complexity (assuming NP = PSPACE) is novel.
To understand the reason underlying the difference, we note that the bound on the
length of non-splitting chains does not hold for set-local MCTAG. In set-local MCTAG
a tree tuple may be non-splitting while also performing a permutation of the order of
the lexical output generated by its children. Permutation is possible because set-locality
allows the tuple of strings generated by a tree tuple to be held separate for an arbitrary
number of steps in a derivation. This directly follows the basis of the reasoning of Kaji
et al (1992) in their proof that LCFRS is PSPACE-complete.
3.2 Universal Recognition of TL-MCTAG with Bounded Fan-Out is NP-Complete
The grammar constructed in the proof of Theorem 1 has fan-out n, the number of
clauses. However, the hardness result proved herein holds even if we restrict tree sets
to have at most two elements (TL-MCTAG(2)).4 The result provided here is as tight
as possible. If tree sets are restricted to a maximum size of one (TL-MCTAG(1)), the
formalism reduces to TAG and the hardness result does not hold.
Theorem 3
The universal recognition problem for TL-MCTAG(2) with fan-out limited to two and
unbounded rank is NP-complete.
Proof
Let ?V, C? be an arbitrary instance of the 3SAT problem. We define a more complex
string w = w(1)w(2) ? ? ?w(p)wc where wc is a representation of C and w(i) controls the truth
assignment for the variable vi, 1 ? i ? p. The proof strategy is as follows. We construct
4 We use the postfix (2) to indicate the restriction on the fan-out.
452
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
a TL-MCTAG(2) grammar G such that each w(i) can be derived from G in exactly two
ways using the left members of tree sets of size 2 that correspond to the variables (and a
single initial tree set of size 1). We call the part of w comprising w(1)w(2) ? ? ?w(p) the prefix
string. The prefix string enforces the constraint of permitting only two derivations by
requiring a strictly alternating string of terminal symbols that can only be generated
by the grammar when the truth assignment is stable for a particular variable. The
derivation of the prefix string w(1)w(2) ? ? ?w(p) therefore corresponds to a guess of a truth
assignment for V. The right trees from the tree sets derive the components of wc that are
compatible with the guessed truth assignments for v1, . . . , vp. Subsequently we explain
how ?G, w? is constructed given an instance of 3SAT ?V, C?.
For every variable vi, 1 ? i ? p, let Ai = {cj | vi ? cj} and Ai = {cj | vi ? cj} be the
sets of clauses in which vi occurs positively and negatively, respectively; let alo mi =
|Ai| + |Ai| be the number of occurrences of the variable vi. Let ?? = {ai, bi | 1 ? i ? p}
be an alphabet of not already used symbols; let w(i) (again for 1 ? i ? p) denote a
sequence of mi + 1 alternating symbols ai and bi such that if mi is even w(i) = (aibi)mi/2ai
and if mi is odd w(i) = (aibi)(mi+1)/2. We define three functions, ?, ?, and ?, to aid in
the construction. The functions ? and ? are used to produce pieces of the prefix string
and will only produce the correct prefix string for a variable if the truth assignment is
consistent within the derivation. The function ? is used to produce strings representing
the clauses satisfied by a particular truth assignment to a variable. For every variable
vi, 1 ? i ? p, the clauses ?(i, 1), ?(i, 2), . . . , ?(i, |Ai|) are all the clauses in Ai and the
clauses ?(i, |Ai| + 1), . . . , ?(i, mi) are all the clauses in Ai. Further, for every 1 ? i ? p, let
?(i, 1) = aibi and let ?(i, h) = ai if h is even and ?(i, h) = bi if h is odd, for 2 ? h ? mi. For
every 1 ? i ? p, let ?(i, h) = ai if h is odd, and ?(i, h) = bi if h is even for 1 ? h ? mi ? 1
and let ?(i, mi) = aibi if mi is odd and biai if mi is even. The crucial property of ? and
? is that a string w(i) can be parsed either as a sequence of ?(i, ?) or ?(i, ?) strings, not
intermixed elements. The grammar must ?commit? to parsing the string one way or the
other, corresponding to committing to a value for the variable vi.
We define a TL-MCTAG(2) G to consist of the tree sets described herein. We con-
struct: (1) a tree set of length two for each combination of a variable and clause that the
variable can satisfy under some truth assignment, (2) two filler tree sets for each variable
(one for each truth assignment) of length two that only contribute the string indicating
the truth assignment of the variable but no satisfied clause, and (3) a singleton tree
set containing only an initial tree rooted in S. The initial tree has n + 1 branches with
the first branch intended to yield the prefix string w(1) ? ? ?w(p) and the (k + 1)-st branch
intended to yield ck where 1 ? k ? n. Although it is possible to generate strings not of
the form of w using this construction, given a pair ?G, w? where w respects the definition
above, we show that w ? L(G) if and only if C is satisfiable.
The initial tree set S contains the single tree pictured in Figure 4.5 The name of each
link in the initial tree set is composed of three indices that indicate the role of the link.
The first index, i, corresponds to variable vi. The second is an index into the series 1 ? ? ?mi
where mi is defined from vi as described previously. The third index, j, corresponds to a
clause cj. The use of multiple indices to name the links is for clarity only. They may be
renamed freely.
5 Although we permit the presence of multiple links at a single node in the S tree, we follow the usual TAG
convention of disallowing multiple adjunction. If one of the links at a node is used, the other links at that
node are assumed to be unavailable in the derivation.
453
Computational Linguistics Volume 36, Number 3
Figure 4
The start tree for TL-MCTAG(2) grammar G. The multiply-indexed link numbers are for clarity
only and are treated as simple link names.
For every variable vi, 1 ? i ? p, and index h, 1 ? h ? mi:
 if h ? |Ai|, tree set T(h)+i contains the following two trees:
 if h > |Ai|, tree set F(h)+i contains the following two trees:
454
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
 for all h, tree set T(h)?i contains the following two trees:
 for all h, tree set F(h)?i contains the following two trees:
An illustrative example is provided in Figure 5. In this example we demonstrate
derivations of two possible satisfying truth assignments for Boolean formula (x ? y ?
z) ? (x ? y ? z) ? (y ? y ? z). The truth assignments correspond to whether the T or F tree
sets are used in the derivation of the prefix string for a particular variable. As can be seen
from the example, the structure of the prefix string enforces the requirement that either
all T tree sets or all F tree sets are chosen for a particular variable. Each tree set marked
with a + is used to satisfy a single clause. Which clause a tree set satisfies can be read
off the link number at which it adjoins.
Inspection of the grammar and construction of the input string show that |G| and
|w| are polynomially related to p and n. The sum of the mi is maximally 3n. There are no
Figure 5
Example derivations of two satisfying assignments for the boolean formula
(x ? y ? z) ? (x ? y ? z) ? (y ? y ? z).
455
Computational Linguistics Volume 36, Number 3
more than 9pn + 1 tree sets and no more than 18pn + 1 total trees. The size of the initial
tree is bounded by 3pn and all other trees have constant size.
From a derivation of w ? L(G) we can find a truth assignment satisfying C by
examining the derivation. If the tree sets T(h)+i or T
(h)?
i are children of S for some i
and all h where 1 ? i ? p and 1 ? h ? mi, then vi is true. If the tree sets F(h)+i or F
(h)?
i
are children of S for some i and all h where 1 ? i ? p and 1 ? h ? mi, then vi is false.
By the construction, if w is of the form just described, for a given variable vi only
two derivations of w(i) will be possible, one in which all tree sets corresponding to
that variable are T tree sets and one in which all are F tree sets. Starting from a truth
assignment that satisfies C, we can prove that w ? L(G) by induction on |V|.
That this problem is in NP can be seen from the same reasoning as in the proof of
Theorem 2. 
3.3 Universal Recognition of TL-MCTAG with Bounded Rank is NP-Complete
We now show that universal recognition of TL-MCTAG is NP-complete even when the
rank is bounded.
We briefly recall here the definition of a decision problem called 3PAR. Let t and si ?
t be positive integers, 1 ? i ? 3m, m ? 1. The language 3PAR is defined as the set of all
tuples ?s1, . . . , s3m, t?, satisfying the following condition: The multiset Q = {s1, . . . , s3m}
can be partitioned into multisets Qi, 1 ? i ? m, such that for every 1 ? i ? m, |Qi| = 3
and
?
s?Qi s = t.
Language 3PAR is strongly NP-complete (Garey and Johnson 1979). This means that
3PAR is NP-complete even in case the integers si are all represented in unary notation.
Theorem 4
The universal recognition problem for TL-MCTAG with rank 1 and unbounded fan-out
is NP-complete.
Proof
We provide a reduction from 3PAR.6 Let ?s1, . . . , s3m, t? be an input instance of the 3PAR
problem, with all of the integers si represented in unary notation. Our target grammar G
is defined as follows. We use a set of nonterminal symbols {S, A}, with S being the start
symbol. We take the set of terminal symbols to be {a, $}. G contains two elementary
tree sets. The first set has a single elementary tree ?, corresponding to a context-free
production of the form S ? (AAA$)m?1AAA:
6 We follow the proof strategy of Barton (1985) in this proof.
456
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
Tree ? has a unique link impinging on all of the 3m occurrences of nonterminal
A. The second (multi)set of G contains elementary trees ?i , 1 ? i ? 3m. Each ?i corre-
sponds to a context-free production of the form A ? asi :
We also construct a string w = (at$)m?1at.
If there exists a partition for multiset Q = {s1, . . . , s3m} satisfying the 3PAR require-
ment, we can directly construct a derivation for w in G, by sorting the elementary trees in
the second set accordingly, and by inserting these trees into the link of the elementary
tree ?. Conversely, from any derivation of w in G, we can read off a partition for Q
satisfying the requirement for membership in 3PAR for the input instance of the 3PAR
problem.
Finally, it is easy to see that G and w can be constructed in linear deterministic time
with respect to the size of the input instance of the 3PAR problem.
That this problem is in NP can be seen from the same reasoning as in the proof of
Theorem 2. 
3.4 Universal Recognition of TL-MCTAG with Fixed Input String is NP-Complete
We now show the unusual complexity result that universal recognition of TL-MCTAG is
NP-complete even when the input string is fixed. Although it is uncommon to require
this result, we rely on it in Section 5 to demonstrate that our parser has better time
complexity than the baseline parsing method for TL-MCTAG that we generalize from
the standard parsing method for LCFRS-equivalent formalisms.
We reduce from a variant of the 3SAT problem introduced above in which each
variable occurs in at most four clauses with no repeats in a clause. This problem was
shown to be NP-complete by Tovey (1984).
Theorem 5
Universal recognition of TL-MCTAG is NP-complete when the input string is fixed.
Proof
Let ?V, C? be an arbitrary instance of the 3SAT problem where each variable occurs in
no more than four clauses and does not repeat within a single clause. As in the proof of
Theorem 1, we use the derivations of the grammar to guess the truth assignments for
V and use the tree sets to keep track of the dependencies among different clauses in C.
Two tree sets are constructed for each variable, one corresponding to a true assignment
and one corresponding to a false assignment. The prohibition on multiple adjunction
ensures that only one of these two tree sets can be used for each variable. The tree set of
a particular truth assignment for a particular variable vi makes it possible to satisfy the
obligatory adjunction constraints for the nonterminal symbols representing each of the
clauses that vi satisfies in the 3SAT formula.7 Additional adjunction sites for each clause
7 Obligatory adjunction constraints are standard in the definition of TAG and MCTAG (Joshi, Levy, and
Takahashi, 1975; Weir 1988). However, obligatory adjunction may be avoided in this proof by creating a
457
Computational Linguistics Volume 36, Number 3
provide overflow space in the event that more than one variable satisfies a particular
clause. We fix the input string w to be the empty string. None of the trees of the grammar
contain any terminal symbols. However, a successful parse of the empty string can only
be achieved if all of the obligatory adjunction constraints are satisfied and this occurs
if and only if all clauses of the formula are satisfied by the truth assignment to some
variable.
We define a tree-local MCTAG G containing the following tree sets. We notate
obligatory adjunction constraints by underlining the nodes at which they apply. The
initial tree set S contains the single tree:
For every variable vi, 1 ? i ? p, tree set Ti (respectively, Fi) is used when represent-
ing an assignment of the value true (respectively, false) to vi. Ti (respectively, Fi) contains
at most five trees, one for the variable itself and one for each clause cj, 1 ? j ? n, such
that when vi is true (respectively false) cj is satisfied. More formally, tree set Ti contains
trees Vi? and Cj? if and only if vi ? cj, for 1 ? j ? n. Tree set Fi contains trees Vi? and Cj?
if and only if vi ? cj, for 1 ? j ? n.
Note that the diagram of the initial tree does not show the explicitly notated link
locations that we have used throughout the article. We omit the link locations to avoid
cluttering the diagram. However, because each variable occurs at most four times in the
formula, the total number of links is bounded by pn12.
From the definition of G it directly follows that ? ? L(G) implies the existence of a
truth assignment that satisfies C. A satisfying truth assignment can be read directly off
of any derivation tree for w. If Ti (respectively, Fi) is a child of S in the derivation tree,
then vk is true (respectively, false). The converse can be shown by using a satisfying
truth assignment for C to construct a derivation for w ? L(G).
?G, w? can be constructed in deterministic polynomial time because the number of
tree sets in the grammar is 2p + 1, the total number of trees in the grammar is bounded
by n(2p + 1), and the length of w is 0. All trees in the grammar have constant size except
for the initial tree, which has size 3n + p.
That this problem is in NP can be seen from the same reasoning as in the proof of
Theorem 2. 
larger grammar in which a separate tree set is created for each combination of clauses that may be
satisfied by a given variable. Because each variable may appear in no more than four clauses, this
increases the number of tree sets in the grammar by 24. We leave the details of this alternative proof
strategy to the reader.
458
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
4. An Alternative Definition of TL-MCTAG: Tree Vectors
The proof of NP-hardness of TL-MCTAG in the bounded rank case given in Theorem 4
depends crucially on the treatment of the elementary structures of the TL-MCTAG as
unordered sets. In order to produce the satisfying partitions for the 3PAR problem, any
tree from the second tree set must be able to adjoin at any location of link 1 in the first
tree set. This is in accordance with the usual definition of multi-component TAG. An
alternative definition of multi-component TAG in which the elementary structures are
treated as vectors is suggested by the explicit use of numbered links at the available
adjunction sites. Under this definition, each location of a link is also given an index and
only the tree at that index in a given vector may adjoin at that link location. An example
contrasting the two definitions is given in Figure 6.
The dependence of our bounded-rank proof on the set definition of TL-MCTAG
does not in itself show that vector-definition TL-MCTAG is polynomial in the bounded
rank case. We show this constructively in Section 5 by presenting a parser for vector
definition TL-MCTAG for which the polynomial degree of both the length of the in-
put string and the grammar size is constant when the rank of the input grammar is
bounded.
The difference in complexity between the set and vector definitions of TL-MCTAG
makes the vector definition an appealing possibility for research using TL-MCTAG for
natural language applications. Although all uses of TL-MCTAG in the computational
linguistics literature assume the set definition of TL-MCTAG, the linguistic analyses
therein do not require the additional flexibility provided by the set definition (Kallmeyer
and Joshi 2003; Nesson and Shieber 2006, 2007; Kallmeyer and Romero 2007; Nesson
2009). This is not a coincidence. Multicomponent tree sets are generally used to model
syntactic and semantic constructs in which one tree in the set strictly dominates another
and has a different syntactic or semantic type: for instance, a quantifier and its bound
variable. The locations at which the trees in these sets adjoin are not interchangeable
both because of the dominance constraint and because of the difference in type (and,
correspondingly, root node label). As a result, these grammars may be converted to the
Figure 6
An example contrasting the set definition of MCTAG (shown in Figure 2) with the vector
definition.
459
Computational Linguistics Volume 36, Number 3
Figure 7
The deductive rule generated for tree ? using the naive TAG parsing method.
vector definition without any change in the elementary trees, the generated language, or
grammar size but with crucial gains in the worst case bounds on processing efficiency.8
5. Parsing
Although no algorithms for parsing TL-MCTAG have previously been published, the
standard method for parsing LCFRS-equivalent formalisms can be applied directly to
TL-MCTAG to produce an algorithm with complexity O(|G|p|w|q) (Seki et al 1991). We
offer a novel parser for TL-MCTAG for which q is constant. With our algorithm, for
the set definition of TL-MCTAG p depends on both the rank and fan-out of the input
grammar. For the vector definition of TL-MCTAG p depends on the rank of the input
grammar but contains no index of the fan-out.
We begin with a brief introduction to TAG parsing before discussing our novel TL-
MCTAG parsing algorithm.
5.1 CKY-Style TAG Parsing
Following the method of Seki et al (1991), a naive parser for TAG may be constructed
by generating a single inference rule for each tree in the grammar. For a tree containing
r links, the rule will have r antecedents with each antecedent item representing a tree
that can adjoin at one of the links. Each adjoining tree will cover a span of the input
string that can be represented by four indices, indicating the left and right edges of the
span and of the subspan that will ultimately be dominated by its foot node. Because the
location of the links within the consequent tree is known, the indices in the antecedent
items are not entirely independent. An example is given in Figure 7. Observation shows
that there will be a worst case of 2(r + 1) independent indices in a given rule. Because
each adjoining tree is independent, there may be r + 1 different trees represented in a
single rule. This results in a time complexity of O(n2(r+1)|G|r+1) where n is the length
of the input string, |G| is a representation of the grammar size, and r is the rank of the
input grammar.
8 Various sorts of multicomponent TAGs have been proposed for analysis of scrambling (Rambow 1994;
Kallmeyer 2005). Scrambling entails several different trees of the same type adjoining in different orders,
and therefore seems like a candidate for making use of the flexibility provided by the set definition.
However, in these analyses the elementary tree structures are composed of one VP-rooted auxiliary tree
and one VP-rooted initial tree. Because auxiliary trees and initial trees cannot adjoin at the same link
location for structural reasons, these analyses do not ultimately make use of the flexibility in the selection
of an adjunction site that the set definition provides. The different VP-rooted auxiliary trees which could
benefit from interchanging adjunction sites achieve this flexibility because they appear in different tree
sets, not because they are members of a single set using the set definition.
460
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
Following Graham, Harrison, and Ruzzo (1980) in their optimization of the Earley
parser (Earley 1970), the identifiers of specific trees need not be represented in the items
of the parser. Rather the tree identifiers may be replaced by the labels of the root nodes
of those trees, effectively bundling items of trees that share a root node label and cover
the same span. This modification to the algorithm reduces the time complexity of the
parser to O(n2(r+1)|G|).
We refer to this method of reducing complexity by removing unnecessary informa-
tion about specific elementary structures from the items of the parser as the GHR opti-
mization. When applied, it reduces the time complexity in the grammar size but does
not alter the basic form of the time complexity expression. There remains a single term
consisting of the product of a polynomial in the input string length and a polynomial in
the grammar size. We will return to this observation when examining the complexity of
TL-MCTAG parsing.
Shieber, Schabes, and Pereira (1995) and Vijay-Shanker (1987) apply the Cocke-
Kasami-Younger (CKY) algorithm, first introduced for use with CFGs in Chomsky
normal form (Kasami 1965; Younger 1967), to the TAG parsing problem to generate
parsers with a time complexity of O(n6|G|2). The speed-up in the parser comes from
traversing elementary trees bottom-up, handling only one link at a time. As a result, no
inference rule needs to maintain information about more than one link at a time. If the
GHR optimization is applied, the time complexity is reduced to O(n6|G|).
In order to clarify the presentation of our TL-MCTAG parser, we briefly review the
algorithm of Shieber, Schabes, and Pereira (1995) with minor modifications, using the
deductive inference rule notation from that paper. As shown in Figure 8, items in CKY-
style TAG parsing consist of a node in an elementary tree and the indices that mark
the edges of the span dominated by that node. Nodes, notated ?@a  , are specified by
three pieces of information: the identifier ? of the elementary tree the node is in, the
Gorn address a of the node in that tree,9 and the link  available at that node if there
is one. When no link is present, it is indicated by an underscore, . The node notation
?@a   may be read as ?node ? at address a with link ?.
Each item has four indices, indicating the left and right edges of the span covered by
the node as well as any gap in the node that may be the result of a foot node dominated
by the node. The indices are constrained to be non-decreasing from left to right in an
item. Nodes that do not dominate a foot node will have no gap in them, which we
indicate by the use of underscores in place of the indices for the gap. To limit the number
of inference rules needed, we define the following function i ? j for combining indices:
i ? j =
?
?
?
?
?
?
?
i j =
j i =
i i = j
undefined otherwise
The Adjoin rule has two indices, p and q, that appear in the antecedent but not in
the consequent. These indices specify the gap in one antecedent item and the edges of
the span in the other antecedent item, indicating that one antecedent item will fill the
gap in the span of the other antecedent item. The Foot Axiom similarly makes use of
unbound indices p and q. In this rule the entire span of the item is the gap that must be
9 A Gorn address uniquely identifies a node within a tree. The Gorn address of the root node is ?. The jth
child of the node with address i has address i ? j.
461
Computational Linguistics Volume 36, Number 3
Figure 8
The CKY algorithm for binary-branching TAG.
filled when the item adjoins to another item. As noted in Shieber, Schabes, and Pereira
(1995), the parser can be made more efficient by only introducing foot items of this sort
once an appropriate tree to adjoin into has been parsed for the span from p to q.
Each item of the form ??@a  , i, , , l? maintains the invariant that the input gram-
mar can derive a subtree rooted at ?@a with no foot node that spans wi+1 . . .wl. Items
of the form ??@a  , i, j, k, l? maintain the invariant that the input grammar can derive
a subtree rooted at ?@a with a foot node such that the fringe of the tree is the string
wi+1 . . . wjLabel(Foot(?))wk+1 . . . wl. The invariants for items of the form ??@a  , i, , , l?
and ??@a  , i, j, k, l? are similar except that no adjunction operation may occur at ?@a.
The side conditions Init(?) and Aux(?) hold if ? is an initial tree or an auxiliary
tree, respectively. Label(?@a) specifies the label of the node in tree ? at address a. Ft(?)
specifies the address of the foot node of tree ?. Link(?@a) specifies the link available at
node ?@a if there is one and null (represented as in the inference rules) otherwise.
Adj(?@a  , ?) holds if  is a link at which tree ? may adjoin into tree ? at address a.
Subst(?@a  , ?) holds if  is a link at which tree ? may substitute into tree ? at address
a. If  is null or the adjunction or substitution is prevented by other constraints such as
mismatched node labels, these conditions fail.
462
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
Figure 9
The deductive rule generated for tree ? using the baseline TL-MCTAG parsing method.
Consistent with the usual definition of TAG, only one link is permitted at a given
node. This effectively rules out multiple adjunction. Bounded multiple adjunction may
be permitted without affecting the complexity of the parsing algorithm by allowing a
list of links at a node. Although it first appears that the introduction of multiple links at
a single node could result in an exponential increase in the number of derivations, this
is not the case. The link diacritics themselves carry no information about the trees which
may adjoin at the associated adjunction site. Any restrictions, such as the requirement
of a matching node label, arise from the node itself. As a result, the links are fully
interchangeable and serve only as counters of the number of available adjunctions at a
node.10
5.2 CKY-Style Tree-Local MCTAG Parsing
As shown in Figure 9, the naive algorithm for parsing TAG may also be applied to
TL-MCTAG. The only difference is that each link may have multiple locations within a
given tree. Let r and f represent the rank and fan-out of the input grammar, respectively.
The time complexity of the naive parser will therefore be O(n2(rf+1)|G|r+1). However,
the GHR optimization cannot straightforwardly be applied because the maintenance of
tree locality requires items to carry information about the identities of the specific trees
involved rather than just the labels of the root nodes. Theorem 5 addresses the case in
which the input string length is 0. Therefore, in this case, any factor in the complexity
including the input string length cannot contribute to the overall time complexity. By
showing that the problem is NP-complete when the input string length is 0, Theorem 5
demonstrates that there must be some exponential factor or term in the time complex-
ity expression other than the input string length factor. Due to the earlier observation
that the GHR optimization does not change the form of the time complexity expression,
Theorem 5 therefore shows that the GHR optimization cannot reduce the exponent
of the grammar size term to a constant unless P = NP. This leaves open the possibility
of the existence of an algorithm that is polynomial in the grammar size but has an addi-
tional exponential term in the time complexity expression. However, such an algorithm,
if it exists, cannot be generated by application of the GHR optimization to the baseline
parser.
We can generalize the CKY TAG parsing algorithm presented above to the TL-
MCTAG case. This is an improvement over the standard LCFRS algorithm because it
reduces the q in the |w|q factor of the complexity to a constant. The direct specification
10 Note, however, that the finite length of the lists of links is necessary for multiple adjunction to remain
benign.
463
Computational Linguistics Volume 36, Number 3
of a CKY-style tree-local MCTAG parser is given in Figures 10 and 11. For a tree set or
vector ? from G, we notate the trees in the set or vector using indices that are indicated
as subscripts on the tree set identifier. A tree set or vector ? from G with length two will
therefore contain trees ?1 and ?2. Under the set definition these indices serve only as a
way of differentiating the members of the tree set. Under the vector definition, the index
must match the index of the link location where the tree will adjoin.
In order to directly parse tree-local MCTAG, items must keep track of the trees that
adjoin at each multicomponent link. We handle this by adding a link history to each
item. Under the set definition, a link history is an associative array of links notated with
indices and tree set identifiers notated with indices to identify a unique tree within the
set. Note that because under the set definition a tree may adjoin at any location of a
link, the indices of the link and tree set need not match. The axioms introduce empty
link histories, indicating that no adjunctions have yet occurred. When an adjunction
takes place, the tree identifier of the adjoining tree is associated with the link at which it
adjoins. In order for an adjunction to take place at a multicomponent link, the adjoining
tree?s tree set must be the same as that of any tree identifier already stored for that
link. This is enforced by the Valid(?) condition (Figure 12) defined on link histories. The
Filter(?, ?@a  ) function removes links that are completely used from the argument
link history. An empty link history indicates that tree locality has been enforced for the
subtree specified by the item; thus no additional information need be maintained or
passed on to later stages of the parse.
For the vector definition, the link histories may be simplified because each location
of a link fully specifies which tree from within a vector may adjoin there. As a result, the
link history is an associative array of links (not annotated with indices) and tree vector
identifiers. An example contrasting the link histories for the set and vector definitions
is given in Figure 13.
Figure 10
Modified item form, goal, and axioms for the CKY algorithm for tree-local MCTAG. Inference
rules of the algorithm are given in Figure 11.
464
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
Figure 11
Modified inference rules for the CKY algorithm for tree-local MCTAG. Alternative Adjoin,
Substitute, and No Adjoin rules are given for the set and vector definitions of TL-MCTAG. The
item form, goal item, and axioms are given in Figure 10.
The addition of a link history to each item increases the complexity of the algorithm.
The maximum link history length is bounded by the rank of the input grammar, r.
Under the set definition, the number of possible values for each element of a link history
is on the order of the number of tree sets in the grammar multiplied by the power
set of the fan-out: |G| ? 2f . Thus, for the set definition, the complexity of the algorithm
465
Computational Linguistics Volume 36, Number 3
Figure 12
Definition of the Valid condition, which ensures that all locations of a link are used by unique
trees from the same tree set. Under the set definition there is an entry for each link location and
both the identity of the tree set and the uniqueness of the tree from that tree set must be checked.
Under the vector definition only the link name and the tree vector identifier are stored because
the link locations uniquely select trees from within tree vectors.
Figure 13
A sample TL-MCTAG with examples of the possible link histories under the set and vector
definitions when the parser reaches the top of the circled node. Although the tree sets are
notated in set definition, the reader may substitute angle braces to get the corresponding vector
definition items.
is O(n6|G|r+22rf ). Under the vector definition, the number of possible values for each
element of a link history is on the order of the number of tree sets in the grammar. Thus,
for the vector definition, the complexity of the algorithm is O(n6|G|r+2). Note that the
variable representing fan-out, f , is present only in the complexity of the set definition.
This demonstrates the novel result that when rank is bounded, even with unbounded
fan-out, parsing the vector definition of TL-MCTAG is polynomial.
Permitting multiple adjunction may be accomplished by a method similar to the
one described for the TAG algorithm. Rather than associating each node with at most
one link, we permit nodes to be accompanied by a set of links. In contrast to the
TAG case, here we must use a set rather than a list to allow for the expressivity that
multiple adjunction can provide. In the TAG case a list is sufficient because the links
at a node are fully interchangeable. In the TL-MCTAG case, because the links are
defined not just by the node where they appear but by the full set of nodes at which
locations of that link appear, the links at a given node are not interchangeable. It must
be possible to use them in any order.11 Because the links can be used in any order, the
11 For links that share all locations it is still possible to enforce a strict order over them without
compromising expressivity.
466
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
addition of multiple adjunction adds a factor of 2r to the time complexity of the parsing
algorithm.
6. Link Factorization
The parser presented in the previous section has the advantage of running in polyno-
mial time if the elementary structures of the input TL-MCTAG are defined as vectors
and if the rank of the grammar is bounded by some constant. Bounding the rank by
a constant might be too strong a limitation in natural language parsing applications,
however. Thus, in the general case the running time of our algorithm contains a factor
that is an exponential function of the rank of the input grammar. To optimize parsing
time, then, we seek a method to ?factorize? the elementary trees of the grammar in
such a way that the rank is effectively reduced and the set of derived trees is preserved.
Although the precise meaning of factorization should be inferred from the subsequent
definitions, informally, by factorize we mean splitting a single elementary tree into sev-
eral smaller elementary trees without violating the locality constraints of the grammar
formalism. In this section we present a novel and efficient algorithm for factorizing a
TL-MCTAG into a strongly equivalent TL-MCTAG in which rank is minimized across
the grammar. Here, strongly equivalent means that the two grammars generate the
same set of derived trees.12
6.1 Preliminaries
Let ? be some elementary tree. We write |?| to denote the number of nodes of ?. For a
link l, we write |l| to denote the number of nodes of l.
For an elementary tree ?, we call a fragment of ? a complete subtree rooted at some
node n of ?, written ?(n), or else a subtree rooted at n with a gap at node n? in its
yield, written ?(n, n?). See Figure 14 for an example. We also use ? to denote a generic
fragment with or without a gap node in its yield.
Consider some fragment ? of ?. Let N? be the set of all nodes of ? and let N? be the
set of nodes of ? with the exclusion of the gap node, in case ? has such a node. We say
that ? is an isolated fragment iff ? includes at least one link and no link in ? impinges
both on nodes in N? and on nodes in N? ? N?. Figure 14 provides an example.
Intuitively, we can ?excise? an isolated fragment from ? without splitting apart
the links of ? itself, and therefore preserving the tree locality. This operation may also
reduce the number of links in ?, which is our main goal. The factorization algorithm we
present in Section 6.2 is based on the detection and factorization of isolated fragments.
Let n be a node from some elementary tree ?. We write lnodes(n) to denote the set
of all nodes from fragment ?(n) that are part of some link from ?. Node n is maximal if
 lnodes(n) = ?; and
 n is either the root node of ? or, for its parent node n?, we have
lnodes(n?) = lnodes(n).
12 The trees are not actually the same because of the small, reversible transformation that we make to ensure
that the factorized trees obey the TAG constraint that auxiliary trees must have matching root and foot
node labels. This transformation adds additional nodes into the tree structure but does not change the
shape of the trees and can be reversed to produce trees that are actually the same as the derived trees of
the original grammar.
467
Computational Linguistics Volume 36, Number 3
Figure 14
An elementary tree ? demonstrating fragments, isolation, and maximal nodes. Fragment
?1 = ?(n1, n2) contains all locations of links 2 and 3 , because links at the root node of a
fragment are contained within that fragment. It does not contain any locations of link 4 , because
links at the gap node of a fragment are not contained within that fragment. Because links 2 and
3 impinge only on nodes in ?1 and all other links impinge only on nodes not in ?1, ?1 is an
isolated fragment. Fragment ?2 = ?(n4) is not an isolated fragment because it contains only one
of the link locations of 4 . Note also that n4 is a maximal node but n5 is not.
Note that for every node n? of ? such that lnodes(n?) = ? there is always a unique
maximal node n such that lnodes(n?) = lnodes(n) (see Figure 14). Thus, for the purpose
of TL-MCTAG factorization, we can consider only maximal nodes. The first criterion
in the definition of maximal node, stating that a maximal node always dominates
(possibly reflexively) some node involved in a link, will often be implicitly used in the
following.
We need to distinguish the nodes in lnodes(n) depending on their impinging links.
Assume that {l1, l2, . . . , lr} is the set of all links occurring in ?. For 1 ? j ? r, we write
lnodes(n, lj) to denote the set of all nodes from fragment ?(n) with impinging link lj.
Thus,
?r
j=1 lnodes(n, lj) = lnodes(n). We associate with each maximal node n of ? a
signature ?(n), defined as a vector of size r and taking values over the subsets of
lnodes(n). For each j, 1 ? j ? r, we define
?(n)[j] =
?
?
?
lnodes(n, lj), if 0 < |lnodes(n, lj)| < |lj|;
?, if |lnodes(n, lj)| = 0 or
|lnodes(n, lj)| = |lj|.
Observe that, in this definition, ?(n)[j] = ? means that none or all of the nodes of lj are
found within fragment ?(n). The empty signature, written 0, is the signature with all of
its components set to ?.
Consider maximal nodes n1 and n2 such that n1 = n2, ?(n1) = 0, and ?(n2) = 0.
It is not difficult to see that ?(n1) = ?(n2) always implies that one of the two nodes
dominates the other. This observation is implicitly used in several places subsequently.
When visiting nodes of ? in a path from some leaf node to the root node,13 one
may encounter several maximal nodes having the same non-empty signature. In our
factorization algorithm, we need to consider pairs of such nodes that are as close as
possible. Consider two maximal nodes n1 and n2, n1 = n2, such that n1 dominates n2.
13 We view trees as directed graphs with arcs directed from each node to its parent.
468
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
The ordered pair (n1, n2) is called a minimal pair if ?(n1) = ?(n2) = 0 and, for every
maximal node n3 in the path from n2 to n1 with n3 = n1 and n3 = n2, we have ?(n3) =
?(n1). Consider now a sequence ?n1, n2, . . . , nq?, q ? 2, of nodes from ?. Such a sequence
is called a maximal chain if each pair (ni?1, ni) is a minimal pair, 2 ? i ? q, and all nodes
n from ? with ?(n) = ?(n1) are included in the sequence itself.
Notice that two maximal nodes belonging to two different maximal chains must
have different signatures, and thus one maximal node cannot belong to more than one
maximal chain. We now prove some basic properties of the notions just introduced that
will be used later in the development of our factorization algorithm and in the proof of
some of its mathematical properties.
Lemma 1
Let ? be an elementary tree and let n, n? be maximal nodes, with n properly dominating
n? in (ii).
(i) ?(n) = 0 if and only if ?(n) is an isolated fragment;
(ii) ?(n) = ?(n?) if and only if ?(n, n?) is an isolated fragment.
Proof
(i). If ?(n) = 0, then for each link l we have that either all nodes impinged on by l are
dominated (possibly reflexively) by n or none of these nodes is dominated by n. Because
n is maximal, we further conclude that at least some link l is found within ?(n).
Conversely, if ?(n) is an isolated fragment then all or none of the nodes impinged
on by some link l are dominated by n, and thus ?(n) = 0.
(ii). Let ?(n) = ?(n?), with n properly dominating n?. For each link lj, there are two
possible cases. First consider the case where ?(n)[j] = ?(n?)[j] = ?. In order for this to be
true, the link must be in one of three configurations, all of which satisfy the requirement
that the locations of lj must be all inside or all outside of the fragment ?(n1, n2).
 lnodes(n, j) = ?. In this configuration no one of the nodes on which lj
impinges is dominated by n.
 |lnodes(n, j)| = |lj|. We distinguish two possible cases.
? lnodes(n?, j) = ?. In this configuration all the nodes on which lj
impinges are within the fragment ?(n1, n2).
? |lnodes(n?, j)| = |lj|. In this configuration all the nodes on which lj
impinges are ?below? the fragment ?(n, n?).
Now consider the case where ?(n)[j] = ?(n?)[j] = ?. The nodes in lnodes(n?, j) are dom-
inated (possibly reflexively) by n? and therefore fall ?below? ?(n, n?). The remaining
nodes on which lj impinges cannot be dominated (possibly reflexively) by n. We thus
conclude that no nodes impinged on by lj occur within the fragment ?(n, n?).
Assume now that ?(n, n?) can be isolated. We can use exactly the same arguments
in the analysis of sets lnodes(n, j) and lnodes(n?, j), and conclude that ?(n) = ?(n?). 
The next lemma will be useful later in establishing that the factorization found by
our algorithm is optimal, namely, that it achieves the smallest rank under the imposed
conditions.
469
Computational Linguistics Volume 36, Number 3
Lemma 2
Let (n1, n2) be some minimal pair. Then
(i) for any node n3 in the path from n2 to n1, ?(n3) = 0;
(ii) for any minimal pair (n3, n4), neither or both of n3 and n4 are found in the
path from n2 to n1.
Proof
(i). Because ?(n2) = 0, there is some link lj for which ?(n2)[j] = lnodes(n2, j) = ?. Be-
cause n3 dominates n2, n3 dominates the nodes in lnodes(n2, j). Therefore, the only way
?(n3) could equal 0 is if |lnodes(n3, j)| = |lj|. But then ?(n1)[j] = ? because n1 dominates
n3. This is a contradiction.
(ii). Assume that n4 is on the path from n2 to n1. From the definition of minimal
pair, there must exist a link lk such that ?(n4)[k] = ?(n2)[k]. By the same reasoning
as in the proof of statement (i) for any link lj such that ?(n2)[j] = ?, we must have
?(n2)[j] = ?(n4)[j] = ?(n1)[j]. We thus conclude that ?(n2)[k] = ? and ?(n4)[k] = ?. Be-
cause ?(n4)[k] = ?(n3)[k] = ? and ?(n2)[k] = ?(n1)[k] = ?, node n3 must be in the path
from n2 to n1.
By a similar argument, we can argue that if n3 is on the path from n2 to n1, then
node n4 must be in that path as well. 
6.2 Factorization Algorithm
Let G be an input TL-MCTAG grammar. In this subsection we provide a method for the
construction of a TL-MCTAG that produces a grammar that generates the same derived
trees as G and that has minimal rank. We start with the discussion of some preprocessing
of the input.
We annotate each elementary tree ? as follows: We compute sets lnodes(n, lj)
for all nodes n and all links lj of ?. This can easily be done with a bottom up
visit of ?, by observing that if an internal node n has children n1, n2, . . . , nk then
lnodes(n, lj) =
?k
i=1 lnodes(ni, lj) ? Xj, where Xj = ? if lj does not impinge on n and Xj =
{n} if it does. Using sets lnodes(n, lj), we can then mark all nodes n in ? that are maximal,
and compute the associated signatures ?(n).
We also mark all maximal chains within ?. This simple procedure is reported in
Figure 15. We maintain an associative array with node signatures as entries and node
lists as values. We visit all maximal nodes of ? in a top?down fashion, creating a list for
each different signature and appending to such a list all nodes having that signature.
In the following algorithm we excise isolated fragments from each elementary tree
?. We now introduce some conventions for doing this. Although it would be possible to
Figure 15
Construction of maximal chains in the factorization algorithm.
470
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
excise fragments without the introduction of additional tree structure, we adopt instead
two simple tree transformations that preserve auxiliary tree root and foot label matching
and result in some simplification of the notation used by the algorithm, particularly in
case the root node of a fragment is the same as the gap node of a second fragment within
?. A schematic depiction of both transformations is given in Figure 16.
When a fragment ?(n) is excised, we leave a copy of the root node n without its
impinging links that dominates a fresh node n? with a fresh link indicating obligatory
substitution of the excised fragment. The excised fragment consists of ?(n) including
any links impinging on n, but has a fresh root node immediately dominating n with the
same label as n?. This is shown in the top row of Figure 16.
A similar transformation is used to excise a fragment ?(n, n?). Nodes n and n? of
the original tree are not altered, and thus they retain their names. The material between
them is replaced with a single new node with a fresh nonterminal symbol and a fresh
link. This link indicates the obligatory adjunction of the excised fragment. A new root
and gap node are added to ?(n, n?) to form the excised fragment. This is shown in the
bottom row of Figure 16. We remark that any link impinging on the root node of the
excised fragment is by our convention included in the excised fragment, and any link
impinging on the gap node is not.
To regenerate the original tree, the excised fragment ?(n, n?) can be adjoined back
into the tree from which it was excised. The new nodes that have been generated in
the excision may be removed and the original root and gap nodes may be merged back
together retaining any impinging links.
We need to introduce one more convention for tree excision. Consider a maximal
chain c = ?n1, n2, . . . , nq? in ?, q ? 2. In case q = 2, our algorithm processes c by excis-
ing a fragment ?(n1, n2) from ?, exactly as explained above. In case q > 2, a special
processing is required for c. Chain c represents q ? 1 minimal pairs, corresponding to
fragments ?(ni?1, ni), 2 ? i ? q. We do not excise these q ? 1 fragments one by one,
Figure 16
Diagrams of the tree transformations performed when fragments ?(n) and ?(n, n?) are removed.
471
Computational Linguistics Volume 36, Number 3
because this would create q ? 1 > 1 new links within ?. We follow instead a procedure
that ?binarizes? c, as explained here.
Let us recursively define an elementary tree ?c as follows, for |c| = q and q ? 3:
 In case q = 3, ?c is a tree composed of two nodes besides the root and the
gap nodes, n and n?, with n immediately dominating n?. Node n hosts
the (obligatory) adjunction of the fragment ?(n1, n2) and node n? hosts
the (obligatory) adjunction of ?(n2, n3). Both fragments are transformed
as previously discussed.
 In case q > 3, ?c is a tree composed of two nodes besides the root and the
gap nodes specified as above, with n? hosting the (obligatory) adjunction
of the transformed fragment ?(nq?1, nq). Node n hosts the adjunction of
tree ?c? , with c? = ?n1, . . . , nq?1?.
Note that each tree ?c has rank two.
When processing a maximal chain c with q > 2, the whole fragment ?(n1, nq) is
excised, using this convention. This results in a single fresh link added to ?. In this case
the link refers to the adjunction of a newly created elementary tree ?c, defined as above.
An example of the binarization of a maximal chain with q = 4 is reported in Figure 17.
We can now discuss the factorization algorithm, reported in Figure 18. For a maxi-
mal node n in an elementary tree ?, we write links(n) to denote the number of links from
? that are entirely contained in fragment ?(n). We process each tree set I? of the source
grammar and each elementary tree ? in I? as follows.
Figure 17
The binarization procedure applied to a maximal chain c = ?n1, n2, n3, n4?.
472
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
Figure 18
The factorization algorithm for tree-local MCTAG.
In the first phase, we add to an agenda A each maximal node n different from the
root of ? such that ?(n) = 0. We associate this agenda item with the score links(n). At
the same time, each maximal chain ?n1, n2, . . . , nq?, q ? 2, is added to A, with associated
score links(n1) ? links(nq).
In the second phase, we process all items in A, in order of increasing score, ignoring
those items that have a score of one. If the current item is a maximal node n, we excise
the fragment ?(n) from ?, leaving in place a fresh node with a single node link denoting
obligatory substitution. If the current item is a maximal chain of the form ?n1, n2?, we
excise from ? the fragment ?(n1, n2), leaving in place a fresh node with a single node
link denoting obligatory adjunction of the excised fragment. Finally, if the current item
is a maximal chain c = ?n1, . . . , nq? with q > 2, we excise from ? the whole fragment
?(n1, nq), and we apply to the chain the binarization procedure described in this sub-
section. This results in the addition to the output grammar of fragments ?(ni?1, ni), for
2 ? i ? q, and of newly created elementary tree ?c and elementary trees ?c? for each
chain c? that is a proper prefix of c. After the processing of all elementary trees in tree
set I? is completed, the resulting version of set I? is also added to the output grammar.
As a simple example of a run of the factorization algorithm, we discuss the process-
ing of the elementary tree ? depicted in Figure 19. Tree ? has four links, called li,
1 ? i ? 4. Link l1 impinges on nodes n11 and n12, link l2 impinges on nodes n21 and
n22. Links l3 and l4 impinge on a single node each, and the impinging nodes are called
n3 and n4, respectively. In Figure 19 we have outlined the maximal nodes n, n?, and n??
473
Computational Linguistics Volume 36, Number 3
Figure 19
An example tree to be processed by the factorization algorithm.
that are relevant to this example. Node n dominates both n? and n?? but none of n? and n??
dominates the other. Note that within ? there must exist maximal nodes other than n, n?,
and n??. For instance, there must be a maximal node dominating (possibly reflexively)
node n3 but not node n4. However, this node dominates a single link, and will not be
processed by the algorithm because of the requirement at line 12 in Figure 18. We thus
ignore this and other maximal nodes in what follows.
We have
lnodes(n?, l1) = {n11}, lnodes(n, l1) = {n11},
lnodes(n?, li) = ?, 2 ? i ? 4, lnodes(n, l2) = {n21, n22},
lnodes(n??, li) = ?, 1 ? i ? 2, lnodes(n, l3) = {n3},
lnodes(n??, l3) = {n3}, lnodes(n, l4) = {n4},
lnodes(n??, l4) = {n4},
and
?(n?) = [{n11}, ?, ?, ?],
?(n??) = 0,
?(n) = ?(n?).
The algorithm in Figure 15 will then mark the chain ?n, n??. When processing the elemen-
tary tree ?, the algorithm in Figure 18 will add to its agenda an item n?? with a score of
links(n??) = 2, as well as the above chain, with a score of links(n) ? links(n?) = 3 ? 0 = 3.
Node n?? is processed first, and fragment ?(n??) is excised from ? leaving in its place
a fresh link l5. Later on, the algorithm pops the chain ?n, n?? from the agenda, and
fragment ?(n, n?) is excised from ? leaving in its place a fresh link l6. The algorithm
then stops. The resulting factorization consists in fragment ?(n??) with links l3 and l4,
fragment ?(n, n?) with links l2 and l5, and what is left of the elementary tree ?, with
links l1 and l6.
The discussion of the correctness of the algorithm is reported in the next section,
along with some other mathematical properties.
474
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
6.3 Mathematical Properties
We discuss in this section some mathematical properties of our factorization algorithm.
Let G be the input TL-MCTAG and let G? be the output of the algorithm. We start with
the issue of correctness. First, notice that our algorithm stops after a finite number of
steps, because the number of possible excisions for G is finite. Assume now that ? and
?? are two isolated fragments within some elementary tree ?, and ?? is itself a fragment
within ?. It is easy to see that excising ?? from ? results in a new fragment of ? that is
still an isolated fragment. Using this observation together with Lemma 1, we can then
conclude that all fragments that are excised by the algorithm are isolated fragments.
This in turn implies that each fragment excision in our algorithm preserves tree locality,
and G? is still a TL-MCTAG.
Each fragment that is excised from some source tree must obligatorily be adjoined
back into that tree, at the point from which it was removed. Thus, G? generates the same
derived trees as G, modulo our trivial tree transformation for the root and the gap nodes.
This proves the correctness of our factorization algorithm.
One remark is in order here. Note that we always excise fragments that have at
least two links. This can be shown inductively as follows. Consider first the smallest
fragments that are excised from some elementary tree ?, that is, those fragments that
do not contain any other fragment within themselves. These fragments always have
at least two links, because of the requirement stated in line 12 in the algorithm. In the
inductive case, let ? be some fragment of ? from which a second fragment ?? has been
already excised in some iteration of the loop at lines from 11 to 23. Fragment ?? is thus
replaced by some link l?. Because of the definition of maximal node, ? must contain at
least one link l that is not contained in ??. In case l itself is part of some excised fragment
???, there will still be some other fresh link replacing ???. We thus conclude that, when
excised, ? always has at least two links. Because excised fragments always have at least
two links and since we never consider elementary trees as candidate fragments (line 6),
we can conclude that our algorithm always finds a non-trivial factorization of G.
We can now turn to an analysis of the computational complexity of our algorithm.
Consider an elementary tree ? of G with r links and with a maximum of f nodes per
link. In the preprocessing phase of the algorithm, the computation of sets lnodes(n, lj)
can be carried out in time O(|?| ? r ? f ). To see this, notice that there are no more than
|?| ? r such sets. Furthermore, we have |lnodes(n, lj)| ? f for each j, and each node in
lnodes(n, lj) is processed in constant time through the union operator, when constructing
the set lnodes(n?, lj) for the parent node n? of n. Clearly, O(|?| ? r ? f ) is also a time upper
bound for the computation of quantities ?(n) and links(n) for all nodes in ?, and for
extracting a list of the maximal nodes therein as well.14
In what follows, we will need to compare signatures of different nodes for equality.
Despite the fact that each signature has r elements, and each element of a signature is a
set with O( f ) elements, there are at most |?| different signatures. We can therefore use
an atomic symbol to name each signature (perfect hashing). In this way, signatures can
be compared in constant time.
The marking of all maximal chains within ?, as specified by the algorithm in
Figure 15, can be implemented in time O(|?|). This is done by encoding the associative
14 We remark here that a further improvement in efficiency could be achieved by replacing the sets of nodes
in a signature with the single node that is the least common ancestor of the set of nodes. However, using
the set of nodes substantially improves the clarity of the presentation of the algorithm, so we do not
pursue this optimization here.
475
Computational Linguistics Volume 36, Number 3
array L in the algorithm through a one-dimensional array indexed by signature names.
Each element of the array points to a linked list of nodes, representing a maximal chain.
We now analyze the running time of the factorization function in Figure 18. Let us
first consider a single elementary tree ?. We implement the priority queue A through
a heap data structure. The loops at lines 6 and 9 run in time O(|?| ? log(|?|)): This is
the standard result for populating a heap; see for instance Cormen et al (2001). At
each iteration of the while loop at lines 11 to 23, we extract some fragment ?(n) or
?(n1, nq). The processing of each such fragment ? takes an amount of time O(|?|),
where |?| is the number of nodes of ?. In such an iteration, ? needs to be re-edited
into a new elementary tree with the number of nodes |?| ? |?| + c, where c ? 3 is a
constant that depends on the specific transformation in Figure 16 that was applied in
the excision of the fragment tree. Nonetheless, if a suitable representation is maintained
for ?, making use of nodes and pointers, the re-editing of ? can be done in constant
time. Then a single iteration of the while loop takes time O(|?|), where ? is the excised
fragment. We can then conclude that all iterations of the while loop take an amount of
time O(|?| ? log(|?|)).15
Now let ?M be the elementary tree of G with the largest size, and let rG and fG be the
rank and fan-out of G, respectively. Putting everything together, the total running time
of the factorization algorithm is O(|G| ? (rG ? fG + log(|?M|))), where |G|, the size of the
input grammar, is defined as the sum of terms |?| for all elementary trees ? of G. Because
we always have fG ? |?M|, this upper bound can be rewritten as O(|G| ? |?M| ? rG).
A special case is worth discussing here. If the maximum number of links impinging
on a node of our elementary trees is bounded by some constant, we have rG ? fG =
O(|?M|). In this case, the above bound reduces to O(|G| ? |?M|). The constant bound on
the number of links impinging on the nodes of a grammar holds for all of the grammars
we have studied in Section 3.
We now argue that our algorithm provides the factorization G? of G with the
smallest possible rank, under the assumption that G and G? are strongly equivalent,
that is, that they generate the same derived trees.
A factorization f of G is called maximal if no one of its fragments has a smaller
isolated fragment within itself. We start by observing that the factorization of G found
by our algorithm is maximal. To see this, consider the excision by our algorithm of
a maximal chain ?n1, . . . , nq? within an elementary tree ?. This item is added to the
priority heap at line 10, with a score of links(n1) ? links(nq). This score is the number of
links found in fragment ?(n1, nq), with the exclusion of the links at the gap node nq.
The chain is then factorized into fragments ?(ni?1, ni), for each i with 2 ? i ? q. Assume
that some fragment ?(ni?1, ni) contains in turn a maximal chain ?n?1, . . . , n?q?? or else
an isolated fragment of the form ?(n?). In the first case we have links(n?1) ? links(n?q? ) <
links(n1) ? links(nq) and in the second case we have links(n?) < links(n1) ? links(nq).
Thus the smaller chain or fragment is processed earlier than our maximal chain, and
by the time our maximal chain is processed, the smaller chain or fragment has already
been excised. A similar argument shows that the excision by our algorithm of an isolated
fragment of the form ?(n) happens after the excision of any maximal chain or fragment
included within ?(n) itself.
15 We mention here a second possible optimization of the algorithm. The priority queue allows us to excise
tree segments always from the input elementary tree ?, making the algorithm easier to analyze.
However, as one of the reviewers has pointed out to us, we could do away with the use of the priority
queue and process fragment trees in any order. This results in running time O(|?|) for the factorization
function in Figure 18.
476
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
We now show that the maximal factorization of G is unique. Let ? and ?? be two
isolated fragments of some elementary tree ?. We say that ? and ?? partially overlap if
the set of nodes shared by ? and ?? is not empty and is a proper subset of the nodes of
both fragments. It is not difficult to see that if ? and ?? partially overlap, then at least
one among ? and ?? must have the form ?(n1, n2).
Without any loss of generality, we assume that the elementary trees of G are always
factorized at their maximal nodes, as discussed in Section 6.1. Let us assume that f
and f ? are two distinguishable maximal factorizations of G. Because no fragment of one
factorization can be a sub-fragment of some fragment of the other factorization, there
must be some fragment ? of f and some fragment ?? of f ? such that ? and ?? partially
overlap.
Assume that ? has the form ?(n1). Then ?? must have the form ?(n2, n3), and n1
must be in the path from n3 to n2. Because ?? is as small as possible, (n2, n3) must be a
minimal pair. We have then established a violation of Lemma 2(i). Assume now that ?
has the form ?(n1, n2). Again, (n1, n2) must be a minimal pair. If ?? has the form ?(n3),
this argument applies again, resulting in a violation of Lemma 2(i). If ?? has the form
?(n3, n4), then (n3, n4) must be a minimal pair. Furthermore, n1, n2, n3, and n4 must all
be on the same path within ?, with n1, n2 in alternation with n3, n4. This establishes a
violation of Lemma 2(ii). The assumption that f and f ? partially overlap then leads to a
contradiction, and we must conclude that the maximal factorization of G is unique.
We can also use this argument against the existence of overlapping fragments to
show that any factorization f of G other than the unique maximal factorization fM must
be coarser than fM, meaning that each fragment ? of f is also a fragment of fM, or else
? can be represented as a combination of the fragments of fM (through substitution and
adjunction). This means that no factorization of G can have rank smaller than the rank
of the maximal factorization fM. We conclude that our algorithm is optimal.
This discussion on the optimality of the factorization algorithm crucially assumes
strong equivalence with the source TL-MCTAG G. Of course there might be TL-
MCTAGs that are weakly equivalent to G, that is, they generate the same language,
and have rank strictly smaller than the rank of G?. However, finding such structurally
different grammars is a task that seems to require techniques quite different from the
factorization techniques we have developed in this section. Furthermore, the task might
be computationally unfeasible, considering the fact that the weak equivalence problem
for TL-MCTAG is undecidable. (Such a problem is undecidable even for CFGs.)
We remark here that if we are allowed to change G by recasting its elementary trees
in some suitable way, we might be able to further reduce the rank with respect to the
algorithm we have presented in this section. In this case the output grammar would
not preserve the derived trees, that is, we lose the strong equivalence, but still retain
the derivation trees unaltered. Although this is likely not desirable for applications
in which the input grammar consists of linguistically motivated trees, there may be
other applications for which the preservation of the internal structure of the trees is
less important than the processing efficiency that can be gained by more aggressive
factorization. Furthermore, it is well known that the desired derived tree for the source
grammar can be easily reconstructed from the derivation tree.
Consider for instance cases in which the input TL-MCTAG is not in binary form,
that is, some nodes have more than two children. Currently, the definition of fragment
does not allow splitting apart a subset of the children of a given node from the remaining
ones. However, if we allow binarization of the elementary trees of the source grammar,
then we might be able to isolate sets of links that could not be factorized in the source
grammar itself. It is not difficult to construct an elementary tree ? with r links such
477
Computational Linguistics Volume 36, Number 3
that no factorization of ? is possible if we are required to preserve ??s structure, but if
we drop such a requirement then we could binarize ? in such a way that a factorization
can be obtained through the application of the algorithm above, such that any tree in the
factorization has no more than two links. However, the general problem of restructuring
elementary trees in such a way that an optimal factorization is possible is not trivial and
requires further research. We leave this problem for future work.
A second case arises when multiple links impinge on the same node of an elemen-
tary tree. As presented, the factorization algorithm is designed to handle grammars in
which multiple adjunction is permitted. However, if multiple adjunction is disallowed
and the grammar contains trees in which multiple links impinge on the same node,
the use of one link at a node will disqualify any other impinging links from use. This
opens up the possibility of further reducing the rank of the grammar by producing
tree sets that do not contain any nodes on which multiple links impinge. This can
be accomplished by performing a first-pass grammar transformation in which a copy
of each elementary tree set is added to the grammar for each distinct, maximal, non-
conflicting set of links appearing in the tree set. This transformation in itself may result
in a reduction of the rank of the source grammar. The factorization algorithm can then be
applied to the new grammar. However, if the elementary trees in the source grammar
contain clusters of links that are mutually overlapping, the suggested transformation
may blow up the size of the input grammar in a way that is not bounded by any
polynomial function.
7. Conclusion
This paper explores the complexity of TL-MCTAG, showing that recognition is NP-
complete under a range of interesting restrictions. It then provides a parsing algorithm
that performs better than the extrapolation of the standard multiple CFG parsing
method to TL-MCTAG. As shown by our proofs, the difficulty in parsing TL-MCTAG
stems from the rank of the input grammar. We offer a novel and efficient algorithm for
minimizing the rank of the input grammar while preserving its strong generative capac-
ity. It fits into an active line of research into efficient processing of multicomponent and
synchronous formalisms that appear computationally intractable but have desirable
characteristics for meeting the expressive needs of natural language. It presents novel
complexity results and algorithms for TL-MCTAG, a widely known and used formalism
in computational linguistics that may be applied more effectively in natural-language
processing using algorithms that process it as efficiently as possible.
Acknowledgments
This work was supported in part by the
National Science Foundation under award
BCS-0827979. The second author has been
partially supported by MIUR under project
PRIN No. 2007TJNZRE 002.
References
Barton, G. Edward. 1985. On the complexity
of ID/LP parsing. Computational
Linguistics, 11(4):205?218.
Chen, John and Vijay K. Shanker. 2004.
Automated extraction of TAGs from the
Penn treebank. In H. Blunt, J. Carroll, and
G. Satta, editors, New Developments in
Parsing Technology. Kluwer Academic,
Amsterdam, pages 73?89.
Cormen, Thomas H., Charles E. Leiserson,
Ronald L. Rivest, and Clifford Stein. 2001.
Introduction to Algorithms. The MIT Press,
Cambridge, MA.
Earley, J. 1970. An Efficient Context-free
Parsing Algorithm. Ph.D. thesis, University
of California, Berkeley, CA.
Garey, M. R. and D. S. Johnson. 1979.
Computers and Intractability. Freeman and
Co., New York, NY.
Gildea, Daniel, Giorgio Satta, and Hao
Zhang. 2006. Factoring synchronous
478
Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG
grammars by sorting. In The International
Conference on Computational Linguistics/
Association for Computational Linguistics
(COLING/ACL-06) Poster Session
pages 279?286, Sydney.
Graham, S. L., M. A. Harrison, and W. L.
Ruzzo. 1980. An improved context-free
recognizer. ACM Transactions on
Programming Languages and Systems,
2:415?462.
Han, Chung-Hye. 2006. Pied-piping in
relative clauses: Syntax and compositional
semantics based on synchronous tree
adjoining grammar. In Proceedings of the 8th
International Workshop on Tree Adjoining
Grammars and Related Formalisms (TAG+ 8),
pages 41?48, Sydney.
Joshi, A. K., L. S. Levy, and M. Takahashi.
1975. Tree adjunct grammars. Journal of
Computer and System Sciences,
10(1):136?163.
Joshi, Aravind K. and Yves Schabes. 1997.
Tree-adjoining grammars. In G. Rozenberg
and A. Salomaa, editors, Handbook of
Formal Languages, volume 3. Springer,
Berlin, pages 69?124.
Kaji, Yuichi, Ryuchi Nakanishi, Hiroyuki
Seki, and Tadao Kasami. 1992. The
universal recognition problems for
multiple context-free grammars and for
linear context-free rewriting systems.
IEICE Transactions on Information and
Systems, E75-D(1):78?88.
Kaji, Yuichi, Ryuchi Nakanishi, Hiroyuki
Seki, and Tadao Kasami. 1994. The
computational complexity of the universal
recognition problem for parallel multiple
context-free grammars. Computational
Intelligence, 10(4):440?452.
Kallmeyer, Laura. 2005. Tree-local
multicomponent tree adjoining grammars
with shared nodes. Computational
Linguistics, 31(2):187?225.
Kallmeyer, Laura. 2009. A declarative
characterization of different types of
multicomponent tree adjoining grammars.
Research on Language and Computation,
7(1):55?99.
Kallmeyer, Laura and Aravind K. Joshi.
2003. Factoring predicate argument and
scope semantics: Underspecified
semantics with LTAG. Research on
Language and Computation, 1:3?58.
Kallmeyer, Laura and Maribel Romero.
2007. Reflexives and reciprocals in
LTAG. In Proceedings of the Seventh
International Workshop on Computational
Semantics ICWS-7, pages 271?282,
Tilburg.
Kasami, T. 1965. An efficient recognition
and syntax algorithm for context-free
languages. Technical Report
AF-CRL-65-758, Air Force Cambridge
Research Laboratory, Bedford, MA.
Nesson, Rebecca. 2009. Synchronous and
Multicomponent Tree-Adjoining Grammars:
Complexity, Algorithms and Linguistic
Applications. Ph.D. thesis, Harvard
University, Cambridge, MA.
Nesson, Rebecca, Giorgio Satta, and Stuart
Shieber. 2008. Optimal k-arization of
synchronous tree-adjoining grammar. In
the Association for Computational Linguistics
(ACL-2008), pages 604?612, Columbus, OH.
Nesson, Rebecca and Stuart M. Shieber.
2006. Simpler TAG semantics through
synchronization. In Proceedings of the
11th Conference on Formal Grammar,
pages 129?142, Malaga.
Nesson, Rebecca and Stuart M. Shieber.
2007. Extraction phenomena in
synchronous TAG syntax and semantics.
In Proceedings of Syntax and Structure in
Statistical Translation (SSST), pages 9?16,
Rochester, NY.
Rambow, Owen. 1994. Formal and
computational aspects of natural language
syntax. Ph.D. thesis, University of
Pennsylvania, Philadelphia, PA.
Satta, Giorgio and Enoch Peserico. 2005.
Some computational complexity results for
synchronous context-free grammars. In
Proceedings of Human Language Technology
Conference and Conference on Empirical
Methods in Natural Language Processing
(HLT05/EMNLP05), pages 803?810,
Vancouver.
Schabes, Yves and Richard C. Waters. 1995.
Tree insertion grammar: A cubic-time
parsable formalism that lexicalizes
context-free grammar without changing
the trees produced. Computational
Linguistics, 21(4):479?513.
Seki, H., T. Matsumura, M. Fujii, and
T. Kasami. 1991. On multiple context-free
grammars. Theoretical Computer Science,
88:191?229.
Shieber, Stuart M. and Yves Schabes. 1994.
An alternative conception of tree-adjoining
derivation. Computational Linguistics,
20(1):91?124.
Shieber, Stuart M., Yves Schabes, and
Fernando C. N. Pereira. 1995. Principles
and implementation of deductive parsing.
Journal of Logic Programming, 24(1?2):3?36.
Sippu, S. and E. Soisalon-Soininen. 1988.
Parsing Theory: Languages and Parsing.
Springer-Verlag, Berlin.
479
Computational Linguistics Volume 36, Number 3
S?gaard, Anders, Timm Lichte, and
Wolfgang Maier. 2007. On the complexity
of linguistically motivated extensions of
tree-adjoining grammar. In Recent
Advances in Natural Language Processing
2007, Borovets.
Tovey, C. A. 1984. A simplified NP-complete
satisfiability problem. Discrete Applied
Mathematics, 8(1):85?90.
Vijay-Shanker, K. 1987. A study of
tree-adjoining grammars. Ph.D. thesis,
Department of Computer and Information
Science, University of Pennsylvania,
Philadelphia, PA.
Vijay-Shanker, K. and Aravind K. Joshi. 1985.
Some computational properties of
tree-adjoining grammars. In Proceedings of
the 23rd Annual Meeting of the Association
for Computational Linguistics, pages 82?93,
Chicago, IL.
Weir, David. 1988. Characterizing mildly
context-sensitive grammar formalisms.
Ph.D. thesis, Department of Computer and
Information Science, University of
Pennsylvania, Philadelphia, PA.
Younger, D. H. 1967. Recognition and
parsing of context-free languages in time
n3. Information and Control, 10(2):189?208.
Zhang, Hao and Daniel Gildea. 2007.
Factorization of synchronous context-free
grammars in linear time. In NAACL
Workshop on Syntax and Structure in
Statistical Translation (SSST), pages 25?32,
Rochester, NY.
480
