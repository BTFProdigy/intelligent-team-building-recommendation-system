Rapid Prototyping of Robust Language Understanding Modules
for Spoken Dialogue Systems
?Yuichiro Fukubayashi, ?Kazunori Komatani, ?Mikio Nakano,
?Kotaro Funakoshi, ?Hiroshi Tsujino, ?Tetsuya Ogata, ?Hiroshi G. Okuno
?Graduate School of Informatics, Kyoto University
Yoshida-Hommachi, Sakyo, Kyoto
606-8501, Japan
{fukubaya,komatani}@kuis.kyoto-u.ac.jp
{ogata,okuno}@kuis.kyoto-u.ac.jp
?Honda Research Institute Japan Co., Ltd.
8-1 Honcho, Wako, Saitama
351-0188, Japan
nakano@jp.honda-ri.com
{funakoshi,tsujino}@jp.honda-ri.com
Abstract
Language understanding (LU) modules for
spoken dialogue systems in the early phases
of their development need to be (i) easy
to construct and (ii) robust against vari-
ous expressions. Conventional methods of
LU are not suitable for new domains, be-
cause they take a great deal of effort to
make rules or transcribe and annotate a suf-
ficient corpus for training. In our method,
the weightings of the Weighted Finite State
Transducer (WFST) are designed on two
levels and simpler than those for conven-
tional WFST-based methods. Therefore,
our method needs much fewer training data,
which enables rapid prototyping of LU mod-
ules. We evaluated our method in two dif-
ferent domains. The results revealed that our
method outperformed baseline methods with
less than one hundred utterances as training
data, which can be reasonably prepared for
new domains. This shows that our method
is appropriate for rapid prototyping of LU
modules.
1 Introduction
The language understanding (LU) of spoken dia-
logue systems in the early phases of their devel-
opment should be trained with a small amount of
data in their construction. This is because large
amounts of annotated data are not available in the
early phases. It takes a great deal of effort and time
to transcribe and provide correct LU results to a
Figure 1: Relationship between our method and con-
ventional methods
large amount of data. The LU should also be robust,
i.e., it should be accurate even if some automatic
speech recognition (ASR) errors are contained in its
input. A robust LU module is also helpful when col-
lecting dialogue data for the system because it sup-
presses incorrect LU and unwanted behaviors. We
developed a method of rapidly prototyping LU mod-
ules that is easy to construct and robust against var-
ious expressions. It makes LU modules in the early
phases easier to develop.
Several methods of implementing an LU mod-
ule in spoken dialogue systems have been proposed.
Using grammar-based ASR is one of the simplest.
Although its ASR output can easily be transformed
into concepts based on grammar rules, complicated
grammars are required to understand the user?s ut-
terances in various expressions. It takes a great deal
of effort to the system developer. Extracting con-
210
Figure 2: Example of WFST for LU
cepts from user utterances by keyword spotting or
heuristic rules has also been proposed (Seneff, 1992)
where utterances can be transformed into concepts
without major modifications to the rules. However,
numerous complicated rules similarly need to be
manually prepared. Unfortunately, neither method
is robust against ASR errors.
To cope with these problems, corpus-based (Su-
doh and Tsukada, 2005; He and Young, 2005) and
Weighted Finite State Transducer (WFST)-based
methods (Potamianos and Kuo, 2000; Wutiwi-
watchai and Furui, 2004) have been proposed as LU
modules for spoken dialogue systems. Since these
methods extract concepts using stochastic analy-
sis, they do not need numerous complicated rules.
These, however, require a great deal of training data
to implement the module and are not suitable for
constructing new domains.
Here, we present a new WFST-based LU module
that has two main features.
1. A statistical language model (SLM) for ASR
and a WFST for parsing that are automatically
generated from the domain grammar descrip-
tion.
2. Since the weighting for the WFST is simpler
than that in conventional methods, it requires
fewer training data than conventional weight-
ing schemes.
Our method accomplishes robust LU with less ef-
fort using SLM-based ASR and WFST parsing. Fig-
ure 1 outlines the relationships between our method
and conventional schemes. Since rule- or grammar-
based approaches do not require a large amount of
data, they take less effort than stochastic techniques.
However, they are not robust against ASR errors.
Stochastic approaches, on the contrary, take a great
deal of effort to collect data but are robust against
ASR errors. Our method is an intermediate approach
that lies between these. That is, it is more robust than
rule- or grammar-based approaches and takes less
effort than stochastic techniques. This characteristic
makes it easier to rapidly prototype LU modules for
a new domain and helps development in the early
phases.
2 Related Work and WFST-based
Approach
A Finite State Transducer (FST)-based LU is ex-
plained here, which accepts ASR output as its in-
put. Figure 2 shows an example of the FST for a
video recording reservation domain. The input, ?,
means that a transition with no input is permitted at
the state transition. In this example, the LU mod-
ule returns the concept [month=2, day=22] for the
utterance ?It is February twenty second please?.
Here, a FILLER transition in which any word is ac-
cepted is appropriately allowed between phrases. In
Figure 2, ?F? represents 0 or more FILLER tran-
sitions. A FILLER transition from the start to the
end is inserted to reject unreliable utterances. This
FILLER transition enables us to ignore unnecessary
words listed in the example utterances in Table 1.
The FILLER transition helps to suppress the inser-
tion of incorrect concepts into LU results.
However, many output sequences are obtained for
one utterance due to the FILLER transitions, be-
cause the utterance can be parsed with several paths.
We used a WFST to select the most appropriate
path from several output sequences. The path with
the highest cumulative weight, w, is selected in a
211
Table 2: Many LU results for input ?It is February twenty second please?
LU output LU result w
It is February twenty second please month=2, day=22 2.0
It is FILLER twenty second please day=22 1.0
It is FILLER twenty second FILLER day=22 1.0
FILLER FILLER FILLER FILLER FILLER FILLER n/a 0
Table 1: Examples of utterances with FILLERs
ASR output
Well, it is February twenty second please
It is uhm, February twenty second please
It is February, twe-, twenty second please
It is February twenty second please, OK?
(LU result = [month=2, day=22])
WFST-based LU. In the example in Table 2, the
concept [month=2, day=22] has been selected, be-
cause its cumulative weight, w, is 2.0, which is the
highest.
The weightings of conventional WFST-based ap-
proaches used an n-gram of concepts (Potamianos
and Kuo, 2000) and that of word-concept pairs (Wu-
tiwiwatchai and Furui, 2004). They obtained the
n-grams from several thousands of annotated ut-
terances. However, it takes a great deal of ef-
fort to transcribe and annotate a large corpus. Our
method enables prototype LU modules to be rapidly
constructed that are robust against various expres-
sions with SLM-based ASR and WFST-based pars-
ing. The SLM and WFST are generated automat-
ically from a domain grammar description in our
toolkit. We need fewer data to train WFST, because
its weightings are simpler than those in conventional
methods. Therefore, it is easy to develop an LU
module for a new domain with our method.
3 Domain Grammar Description
A developer defines grammars, slots, and concepts
in a domain in an XML file. This description en-
ables an SLM for ASR and parsing WFST to be au-
tomatically generated. Therefore, a developer can
construct an LU module rapidly with our method.
Figure 3 shows an example of a descrip-
tion. A definition of a slot is described in
keyphrase-class tags and its keyphrases and
...
<keyphrase-class name="month">
...
<keyphrase>
<orth>February</orth>
<sem>2</sem>
</keyphrase>
...
</keyphrase-class>
...
<action type="specify-attribute">
<sentence> {It is} [*month] *day [please]
</sentence>
</action>
Figure 3: Example of a grammar description
the values are in keyphrase tags. The month is
defined as a slot in this figure. February and 2 are
defined as one of the phrases and values for the slot
month. A grammar is described in a sequence of
terminal and non-terminal symbols. A non-terminal
symbol represents a class of keyphrases, which is
defined in keyphrase-class. It begins with an
asterisk ?*? in a grammar description in sentence
tags. Symbols that can be skipped are enclosed
by brackets []. The FILLER transition described
in Section 2 is inserted between the symbols un-
less they are enclosed in brackets [] or braces {}.
Braces are used to avoid FILLER transitions from
being inserted. For example, the grammar in Figure
3 accepts ?It is February twenty second please.? and
?It is twenty second, OK??, but rejects ?It is Febru-
ary.? and ?It, uhm, is February twenty second.?.
A WFST for parsing can be automatically gener-
ated from this XML file. The WFST in Figure 2 is
generated from the definition in Figure 3. Moreover,
we can generate example sentences from the gram-
mar description. The SLM for the speech recognizer
is generated with our method by using many exam-
ple sentences generated from the defined grammar.
212
4 Weighting for ASR Outputs on Two
Levels
We define weights on two levels for a WFST. The
first is a weighting for ASR outputs, which is set to
select paths that are reliable at a surface word level.
The second is a weighting for concepts, which is
used to select paths that are reliable on a concept
level. The weighting for concepts reflects correct-
ness at a more abstract level than the surface word
level. The weighting for ASR outputs consists of
two categories: a weighting for ASR N-best outputs
and one for accepted words. We will describe the
definitions of these weightings in the following sub-
sections.
4.1 Weighting for ASR N-Best Outputs
The N-best outputs of ASR are used for an input of
a WFST. Weights are assigned to each sentence in
ASR N-best outputs. Larger weights are given to
more reliable sentences, whose ranks in ASR N-best
are higher. We define this preference as
wis =
e??scorei
?N
j e??scorej
,
where wis is a weight for the i-th sentence in ASRN-best outputs, ? is a coefficient for smoothing, and
scorei is the log-scaled score of the i-th ASR out-put. This weighting reflects the reliability of the
ASR output. We set ? to 0.025 in this study after
a preliminary experiment.
4.2 Weighting for Accepted Words
Weights are assigned to word sequences that have
been accepted by the WFST. Larger weights are
given to more reliable sequences of ASR outputs at
the surface word level. Generally, longer sequences
having more words that are not fillers and more re-
liable ASR outputs are preferred. We define these
preferences as the weights:
1. word(const.): ww = 1.0,
2. word(#phone): ww = l(W ), and
3. word(CM): ww = CM(W ) ? ?w.
The word(const.) gives a constant weight to
all accepted words. This means that sequences
with more words are simply preferred. The
word(#phone) takes the length of each accepted
word into consideration. This length is measured by
its number of phonemes, which are normalized by
that of the longest word in the vocabulary. The nor-
malized values are denoted as l(W ) (0 < l(W ) ?
1). By adopting word(#phone), the length of se-
quences is represented more accurately. We also
take the reliability of the accepted words into ac-
count as word(CM). This uses confidence measures
(Lee et al, 2004) for a word, W , in ASR outputs,
which are denoted as CM(W ). The ?w is the thresh-old for determining whether word W is accepted or
not. The ww obtains a negative value for an unreli-able word W when CM(W ) is lower than ?w. Thisrepresents a preference for longer and more reliable
sequences.
4.3 Weighting for Concepts
In addition to the ASR level, weights on a concept
level are also assigned. The concepts are obtained
from the parsing results by the WFST, and contain
several words. Weights for concepts are defined by
using the measures of all words contained in a con-
cept.
We prepared three kinds of weights for the con-
cepts:
1. cpt(const.): wc = 1.0,
2. cpt(avg):
wc =
?
W (CM(W ) ? ?c)
#W , and
3. cpt(#pCM(avg)):
wc =
?
W (CM(W ) ? l(W ) ? ?c)
#W ,
where W is a set of accepted words, W , in the corre-
sponding concept, and #W is the number of words
in W .
The cpt(const.) represents a preference for
sequences with more concepts. The cpt(avg)
is defined as the weight by using the CM(W )
of each word contained in the concept. The
cpt(#pCM(avg)) represents a preference for longer
and reliable sequences with more concepts. The ?cis the threshold for the acceptance of a concept.
213
Table 3: Examples of weightings when parameter set is: word(CM) and cpt(#pCM(avg))
ASR onput No, it is February twenty second
LU output FILLER it is February twenty second
CM(W ) 0.3 0.7 0.6 0.9 1.0 0.9
l(W ) 0.3 0.2 0.2 0.9 0.6 0.5
Concept - - - month=2 day=22
word - 0.7 ? ?w 0.6 ? ?w 0.9 ? ?w 1.0 ? ?w 0.9 ? ?wcpt - - - (0.9 ? 0.9 ? ?c)/1 (1.0 ? 0.6 ? ?c + 0.9 ? 0.5 ? ?c)/2
'
&
$
%
Reference From June third please
ASR output From June third uhm FIT please LU result
CM(W ) 0.771 0.978 0.757 0.152 0.525 0.741
LU reference From June third FILLER FILLER FILLER month:6, day:3
Our method From June third FILLER FILLER FILLER month:6, day:3
Keyword spotting From June third FILLER FIT please month:6, day:3, car:FIT
(?FIT? is the name of a car.)
Figure 4: Example of LU with WFST
4.4 Calculating Cumulative Weight and
Training
The LU results are selected based on the weighted
sum of the three weights in Subsection 4.3 as
wi = wis + ?w
?
ww + ?c
?
wc
The LU module selects an output sequence with
the highest cumulative weight, wi, for 1 ? i ? N .
Let us explain how to calculate cumulative weight
wi by using the example specified in Table 3. Here,
word(CM) and cpt(#pCM(avg)) are selected as pa-
rameters. The sum of weights in this table for ac-
cepted words is ?w(4.1 ? 5?w), when the input se-quence is ?No, it is February twenty second.?.
The sum of weights for concepts is ?c(1.335 ? 2?c)because the weight for ?month=2? is ?c(0.81 ? ?c)and the weight for ?day=22? is ?c(0.525 ? ?c).Therefore, cumulative weight wi for this input se-
quence is wis + ?w(4.1 ? 5?w) + ?c(1.335 ? 2?c).In the training phase, various combinations of pa-
rameters are tested, i.e., which weightings are used
for each of ASR output and concept level, such as
N = 1 or 10, coefficient ?w,c = 1.0 or 0, and thresh-old ?w,c = 0 to 0.9 at intervals of 0.1, on the train-ing data. The coefficient ?w,c = 0 means that acorresponding weight is not added. The optimal pa-
rameter settings are obtained after testing the various
combinations of parameters. They make the concept
error rate (CER) minimum for a training data set.
We calculated the CER in the following equation:
CER = (S +D + I)/N , where N is the number of
concepts in a reference, and S, D, and I correspond
to the number of substitution, deletion, and insertion
errors.
Figure 4 shows an example of LU with our
method, where it rejects misrecognized concept
[car:FIT], which cannot be rejected by keyword
spotting.
5 Experiments and Evaluation
5.1 Experimental Conditions
We discussed our experimental investigation into the
effects of weightings in Section 4. The user utter-
ance in our experiment was first recognized by ASR.
Then, the i-th sentence of ASR output was input to
WFST for 1 ? i ? N , and the LU result for the
highest cumulative weight, wi, was obtained.
We used 4186 utterances in the video recording
reservation domain (video domain), which consisted
of eight different dialogues with a total of 25 differ-
ent speakers. We also used 3364 utterances in the
rent-a-car reservation domain (rent-a-car domain) of
214
eight different dialogues with 23 different speakers.
We used Julius 1 as a speech recognizer with an
SLM. The language model was prepared by using
example sentences generated from the grammars of
both domains. We used 10000 example sentences in
the video and 40000 in the rent-a-car domain. The
number of the generated sentences was determined
empirically. The vocabulary size was 209 in the
video and 891 in the rent-a-car domain. The average
ASR accuracy was 83.9% in the video and 65.7%
in the rent-a-car domain. The grammar in the video
domain included phrases for dates, times, channels,
commands. That of the rent-a-car domain included
phrases for dates, times, locations, car classes, op-
tions, and commands. The WFST parsing mod-
ule was implemented by using the MIT FST toolkit
(Hetherington, 2004).
5.2 Performance of WFST-based LU
We evaluated our method in the two domains: video
and rent-a-car. We compared the CER on test data,
which was calculated by using the optimal settings
for both domains. We evaluated the results with 4-
fold cross validation. The number of utterances for
training was 3139 (=4186*(3/4)) in the video and
2523 (=3364*(3/4)) in the rent-a-car domain.
The baseline method was simple keyword spot-
ting because we assumed a condition where a large
amount of training data was not available. This
method extracts as many keyphrases as possible
from ASR output without taking speech recogni-
tion errors and grammatical rules into consideration.
Both grammar-based and SLM-based ASR outputs
are used for input in keyword spotting (denoted as
?Grammar & spotting? and ?SLM & spotting? in
Table 4). The grammar for grammar-based ASR
was automatically generated by the domain descrip-
tion file. The accuracy of grammar-based ASR was
66.3% in the video and 43.2% in the rent-a-car do-
main.
Table 4 lists the CERs for both methods. In key-
word spotting with SLM-based ASR, the CERs were
improved by 5.2 points in the video and by 22.2
points in the rent-a-car domain compared with those
with grammar-based ASR. This is because SLM-
based ASR is more robust against fillers and un-
1http://julius.sourceforge.jp/
Table 4: Concept error rates (CERs) in each domain
Domain Grammar &spotting SLM &spotting Ourmethod
Video 22.1 16.9 13.5
Rent-a-car 51.1 28.9 22.0
known words than grammar-based ASR. The CER
was improved by 3.4 and 6.9 points by optimal
weightings for WFST. Table 5 lists the optimal pa-
rameters in both domains. The ?c = 0 in the videodomain means that weights for concepts were not
used. This result shows that optimal parameters de-
pend on the domain for the system, and these need
to be adapted for each domain.
5.3 Performance According to Training Data
We also investigated the relationship between the
size of the training data for our method and the CER.
In this experiment, we calculated the CER in the
test data by increasing the number of utterances for
training. We also evaluated the results by 4-fold
cross validation.
Figures 5 and 6 show that our method outper-
formed the baseline methods by about 80 utterances
in the video domain and about 30 utterances in
the rent-a-car domain. These results mean that our
method can effectively be used to rapidly prototype
LU modules. This is because it can achieve robust
LU with fewer training data compared with conven-
tional WFST-based methods, which need over sev-
eral thousand sentences for training.
6 Conclusion
We developed a method of rapidly prototyping ro-
bust LU modules for spoken language understand-
ing. An SLM for a speech recognizer and a WFST
for parsing were automatically generated from a do-
main grammar description. We defined two kinds
of weightings for the WFST at the word and con-
cept levels. These two kinds of weightings were
calculated by ASR outputs. This made it possi-
ble to create an LU module for a new domain with
less effort because the weighting scheme was rel-
atively simpler than those of conventional methods.
The optimal parameters could be selected with fewer
training data in both domains. Our experiment re-
215
Table 5: Optimal parameters in each domain
Domain N ?w ww ?c wc
Video 1 1.0 word(const.) 0 -
Rent-a-car 10 1.0 word(CM)-0.0 1.0 cpt(#pCM(avg))-0.8
 0
 5
 10
 15
 20
 25
 30
 35
 40
 3000 1000 500 250 100 50 10
C
E
R
#utt. for training
Grammar-based ASR & keyword spotting
SLM-based ASR & keyword spotting
Our method
Figure 5: CER in video domain
 0
 5
 10
 15
 20
 25
 30
 50
 55
 3000 1000 500 250 100 50 10
C
E
R
#utt. for training
Grammar-based ASR & keyword spotting
SLM-based ASR & keyword spotting
Our method
Figure 6: CER in rent-a-car domain
vealed that the CER could be improved compared to
the baseline by training optimal parameters with a
small amount of training data, which could be rea-
sonably prepared for new domains. This means that
our method is appropriate for rapidly prototyping
LU modules. Our method should help developers
of spoken dialogue systems in the early phases of
development. We intend to evaluate our method on
other domains, such as database searches and ques-
tion answering in future work.
Acknowledgments
We are grateful to Dr. Toshihiko Ito and Ms. Yuka
Nagano of Hokkaido University for constructing the
rent-a-car domain system.
References
Yulan He and Steve Young. 2005. Spoken Language
Understanding using the Hidden Vector State Model.Speech Communication, 48(3-4):262?275.
Lee Hetherington. 2004. The MIT finite-state trans-ducer toolkit for speech and language processing. InProc. 6th International Conference on Spoken Lan-guage Processing (INTERSPEECH-2004 ICSLP).
Akinobu Lee, Kiyohiro Shikano, and Tatsuya Kawahara.
2004. Real-time word confidence scoring using lo-cal posterior probabilities on tree trellis search. InProc. 2004 IEEE International Conference on Acous-tics, Speech, and Signal Processing (ICASSP 2004),volume 1, pages 793?796.
Alexandors Potamianos and Hong-Kwang J. Kuo. 2000.
Statistical recursive finite state machine parsingfor speech understanding. In Proc. 6th Interna-tional Conference on Spoken Language Processing(INTERSPEECH-2000 ICSLP), pages 510?513.
Stephanie Seneff. 1992. TINA: A natural language sys-tem for spoken language applications. ComputationalLinguistics, 18(1):61?86.
Katsuhito Sudoh and Hajime Tsukada. 2005. Tightly in-
tegrated spoken language understanding using word-to-concept translation. In Proc. 9th European Con-ference on Speech Communication and Technology(INTERSPEECH-2005 Eurospeech), pages 429?432.
Chai Wutiwiwatchai and Sadaoki Furui. 2004. Hybridstatistical and structural semantic modeling for Thaimulti-stage spoken language understanding. In Proc.HLT-NAACL Workshop on Spoken Language Under-standing for Conversational Systems and Higher LevelLinguistic Information for Speech Processing, pages
2?9.
216
Proceedings of the 7th SIGdial Workshop on Discourse and Dialogue, pages 9?17,
Sydney, July 2006. c?2006 Association for Computational Linguistics
Multi-Domain Spoken Dialogue System
with Extensibility and Robustness against Speech Recognition Errors
Kazunori Komatani Naoyuki Kanda Mikio Nakano?
Kazuhiro Nakadai? Hiroshi Tsujino? Tetsuya Ogata Hiroshi G. Okuno
Kyoto University, Yoshida-Hommachi, Sakyo, Kyoto 606-8501, Japan
{komatani,ogata,okuno}@i.kyoto-u.ac.jp
? Honda Research Institute Japan Co., Ltd., 8-1 Honcho, Wako, Saitama 351-0188, Japan
{nakano,nakadai,tsujino}@jp.honda-ri.com
Abstract
We developed a multi-domain spoken dia-
logue system that can handle user requests
across multiple domains. Such systems
need to satisfy two requirements: extensi-
bility and robustness against speech recog-
nition errors. Extensibility is required to
allow for the modification and addition
of domains independent of other domains.
Robustness against speech recognition er-
rors is required because such errors are
inevitable in speech recognition. How-
ever, the systems should still behave ap-
propriately, even when their inputs are er-
roneous. Our system was constructed on
an extensible architecture and is equipped
with a robust and extensible domain selec-
tion method. Domain selection was based
on three choices: (I) the previous domain,
(II) the domain in which the speech recog-
nition result can be accepted with the high-
est recognition score, and (III) other do-
mains. With the third choice we newly
introduced, our system can prevent dia-
logues from continuously being stuck in
an erroneous domain. Our experimental
results, obtained with 10 subjects, showed
that our method reduced the domain selec-
tion errors by 18.3%, compared to a con-
ventional method.
1 Introduction
Many spoken dialogue systems have been devel-
oped for various domains, including: flight reser-
vations (Levin et al, 2000; Potamianos and Kuo,
2000; San-Segundo et al, 2000), train travel in-
formation (Lamel et al, 1999), and bus informa-
tion (Komatani et al, 2005b; Raux and Eskenazi,
2004). Since these systems only handle a sin-
gle domain, users must be aware of the limita-
tions of these domains, which were defined by
the system developer. To handle various domains
through a single interface, we have developed a
multi-domain spoken dialogue system, which is
composed of several single-domain systems. The
system can handle complicated tasks that contain
requests across several domains.
Multi-domain spoken dialogue systems need to
satisfy the following two requirements: (1) exten-
sibility and (2) robustness against speech recog-
nition errors. Many such systems have been de-
veloped on the basis of a master-slave architec-
ture, which is composed of a single master module
and several domain experts handling each domain.
This architecture has the advantage that each do-
main expert can be independently developed, by
modifying existing experts or adding new experts
into the system. In this architecture, the master
module needs to select a domain expert to which
response generation and dialogue management for
the user?s utterance are committed. Hereafter, we
will refer to this selecting process domain selec-
tion.
The second requirement is robustness against
speech recognition errors, which are inevitable in
systems that use speech recognition. Therefore,
these systems must robustly select domains even
when the input may be incorrect due to speech
recognition errors.
We present an architecture for a multi-domain
spoken dialogue system that incorporates a new
domain selection method that is both extensi-
ble and robust against speech recognition errors.
Since our system is based on extensible architec-
ture similar to that developed by O?Neill (O?Neill
et al, 2004), we can add and modify the domain
9
Speech recognition
Domain selection
Utterance generation
Speech synthesis
User
utterance
System
response
User System
Central module Expert for domain A
method
Language understanding
Dialogue state update
Dialogue management
Dialogue statesvariable
Expert for domain B
method
variable
Expert for domain B
method
variable
Expert for domain B
method
Language understanding
Dialogue state update
Dialogue management
Dialogue statesvariable
Figure 1: Distributed-type architecture for multi-domain spoken dialogue systems
experts easily. In order to maintain robustness,
domain selection takes into consideration vari-
ous features concerning context and situations of
the dialogues. We also designed a new selection
framework that satisfies the extensibility issue by
abstracting the transitions between the current and
next domains. Specifically, our system selects the
next domain based on: (I) the previous domain,
(II) the domain in which the speech recognition
result can be accepted with the highest recognition
score, and (III) other domains. Conventional meth-
ods cannot select the correct domain when neither
the previous domain nor the speech recognition re-
sults for a current utterance are correct. To over-
come this drawback, we defined another choice as
(III) that enables the system to detect an erroneous
situation and thus prevent the dialogue from con-
tinuing to be incorrect. We modeled this frame-
work as a classification problem using machine
learning, and showed it is effective by perform-
ing an experimental evaluation of 2,205 utterances
collected from 10 subjects.
2 Architecture used for Multi-Domain
Spoken Dialogue Systems
In multi-domain spoken dialogue systems, the sys-
tem design is more complicated than in single do-
main systems. When the designed systems are
closely related to each other, a modification in a
certain domain may affect the whole system. This
type of a design makes it difficult to modify ex-
isting domains or to add new domains. Therefore,
a distributed-type architecture has been previously
proposed (Lin et al, 2001), which enables system
developers to design each domain independently.
In this architecture, the system is composed of
two kinds of components: a part that can be de-
signed independently of all other domains, and a
part in which relations among domains should be
considered. By minimizing the latter component,
a system developer can design each domain semi-
independently, which enables domains to be eas-
ily added or modified. Many existing systems are
based on this architecture (Lin et al, 2001; O?Neill
et al, 2004; Pakucs, 2003; Nakano et al, 2005).
Thus, we adopted the distributed-type architec-
ture (Nakano et al, 2005). Our system is roughly
composed of two parts, as shown in Figure 1: sev-
eral experts that control dialogues in each domain,
and a central module that controls each expert.
When a user speaks to the system, the central mod-
ule drives a speech recognizer, and then passes
the result to each domain expert. Each expert,
which controls its own domains, executes a lan-
guage understanding module, updates its dialogue
states based on the speech recognition result, and
returns the information required for domain selec-
tion1. Based on the information obtained from
the experts, the central module selects an appro-
priate domain for giving the response. An expert
then takes charge of the selected domain and deter-
mines the next dialogue act based on its dialogue
state. The central module generates a response
based on the dialogue act obtained from the expert,
and outputs the synthesized speech to the user.
Communications between the central module and
each expert are realized using method-calls in the
central module. Each expert is required to have
several methods, such as utterance understanding
or response selection, to be considered an expert
1Dialogue states in a domain that are not selected during
domain selection are returned to their previous states.
10
in this architecture.
As was previously described, the central mod-
ule is not concerned with processing the speech
recognition results; instead, the central module
leaves this task to each expert. Therefore, it is
important that the central module selects an ex-
pert that is committed to the process of the speech
recognition result. Furthermore, information used
during domain selection should also be domain
independent, because this allows easier domain
modification and addition, which is, after all, the
main advantage of distributed-type architecture.
3 Extensible and Robust Domain
Selection
Domain selection in the central module should
also be performedwithin an extensible framework,
and also should be robust against speech recogni-
tion errors.
In many conventional methods, domain selec-
tion is based on estimating the most likely do-
mains based on the speech recognition results.
Since these methods are heavily dependent on
the performance of the speech recognizers, they
are not robust because the systems will fail when
a speech recognizer fails. To behave robustly
against speech recognition errors, the success of
speech recognition and of domain selection should
be treated separately. Furthermore, in some con-
ventional methods, accurate language models are
required to construct the domain selection parts
before new domains are added to a multi-domain
system. This means that they are not extensible.
When selecting a domain, other studies have
used the information on the domain in which a pre-
vious response was made. Lin et al (2001) gave
preference to the domain selected in the previous
turn by adding a certain score as an award when
comparing the N-best candidates of the speech
recognition for each domain. Lane and Kawa-
hara (2005) also assigned a similar preference in
the classification with Support Vector Machine
(SVM). A system described in (O?Neill et al,
2004) does not change its domain until its sub-task
is completed, which is a constraint similar to keep-
ing dialogue in one domain. Since these methods
assume that the previous domain is most likely the
correct domain, it is expected that these methods
keep a system in the domain despite errors due
to speech recognition problems. Thus, should do-
main selection be erroneous, the damage due to the
Same domain as
previous response
Domain having 
the highest score in
speech recognizer
User utterancePrevious turn Current turn
(I)
(II)
(III)
?????
????
?
???
Other domains
except (I), (II)
Selected
domain
Figure 2: Overview of domain selection
error is compounded, as the system assumes that
the previous domain is always correct. Therefore,
we solve this problem by considering features that
represent the confidence of the previously selected
domain.
We define domain selection as being based on
the following 3-class categorization: (I) the previ-
ous domain, (II) the domain in which the speech
recognition results can be accepted with the high-
est recognition score, which is different from the
previous domain, and (III) other domains. Figure
2 depicts the three choices. This framework in-
cludes the conventional methods as choices (I) and
(II). Furthermore, it considers the possibility that
the current interpretations may be wrong, which
is represented as choice (III). This framework also
has extensibility for adding new domains, since it
treats domain selection not by detecting each do-
main directly, but by defining only a relative re-
lationship between the previous and current do-
mains.
Since our framework separates speech recogni-
tion results and domain selection, it can keep di-
alogues in the correct domain even when speech
recognition results are wrong. This situation is
represented as choice (I). An example is shown
in Figure 3. Here, the user?s first utterance (U1)
is about the restaurant domain. Although the sec-
ond utterance (U2) is also about the restaurant do-
main, an incorrect interpretation for the restaurant
domain is obtained because the utterance contains
an out-of-vocabulary word and is incorrectly rec-
ognized. Although a response for utterance U2
should ideally be in the restaurant domain, the sys-
tem control shifts to the temple sightseeing infor-
mation domain, in which an interpretation is ob-
tained based on the speech recognition result. This
11
? ?
U1: Tell me bars in Kawaramachi area.
(domain: restaurant)
S1: Searching for bars in Kawaramachi area.
30 items found.
U2: I want Tamanohikari (name of liquor).
(domain: restaurant)
Tamanohikari is out-of-vocabulary word, and
misrecognized as Tamba-bashi (name of place).
(domain: temple)
S2 (bad): Searching spots near Tamba-bashi. 10 items
found. (domain: temple)
S2 (good): I do not understand what you said. Do you
have any other preferences? (domain: restaurant)
? ?
Figure 3: Example in which choice (I) is appropri-
ate in spite of speech recognition error
is shown as utterance S2 (bad). In such cases, our
framework is capable of behaving appropriately.
This is shown as S2 (good), which is made by
selecting choice (I). Accepting erroneous recogni-
tion results is more harmful than rejecting correct
ones for the following reasons: 1) a user needs to
solve the misunderstanding as a result of the false
acceptance, and 2) an erroneous utterance affects
the interpretation of the utterances following it.
Furthermore, we define choice (III), which de-
tects the cases where normal dialogue manage-
ment is not suitable, in which case the central
module selects an expert based on either the pre-
vious domain or the domain based on the speech
recognition results. The situation corresponds to
a succession of recognition errors. However, this
problem is more difficult to solve than merely de-
tecting a simple succession of the errors because
the system needs to distinguish between speech
recognition errors and domain selection errors in
order to generate appropriate next utterances. Fig-
ure 4 shows an example of such a situation. Here,
the user?s utterances U1 and U2 are about the tem-
ple domain, but a speech recognition error oc-
curred in U2, and system control shifts to the hotel
domain. The user again says (U3), but this results
in the same recognition error. In this case, a do-
main that should ideally be selected is neither the
domain in the previous turn nor the domain deter-
mined based on the speech recognition results. If
this situation can be detected, the system should be
able to generate an appropriate response, like S3
(good), and prevent inappropriate responses based
? ?
U1: Tell me the address of Horin-ji (temple name).
(domain: temple)
S1: The address of Horin-ji is ...
U2: Then, what is the fee for Horin-ji?
(domain: temple)
misrecognized as ?the fee of Holiday Inn?.
(domain: hotel)
S2: The fee of Holiday Inn is ...
U3: The fee of Horin-ji. (domain: temple)
again misrecognized as ?the fee of Holiday Inn?.
(domain: hotel)
S3 (bad): The fee of Holiday Inn is ...
S3 (good): Are you asking about hotel information?
U4: No.
S4: Would you like to return to the temple information
service?
? ?
Figure 4: Example in which choice (III) should be
selected
on an incorrect domain determination. It is pos-
sible for the system to restart from two utterances
before (U1), after asking a confirmatory question
(S4) about whether to return to it or not. After that,
repetition of similar errors can also be avoided if
the system prohibits transition to the hotel domain.
4 Domain Selection using Dialogue
History
We constructed a classifier that selects the appro-
priate domains using various features, including
dialogue histories. The selected domain candi-
dates are based on: (I) the previous domain, (II)
the domain in which the speech recognition results
can be accepted with the highest recognition score,
or (III) other domains. Here, we describe the fea-
tures present in our domain selection method.
In order to not spoil the system?s extensibility,
an advantage of the distributed-type architecture,
the features used in the domain selection should
not depend on the specific domains. We categorize
the features used into three categories listed below:
? Features representing the confidence with
which the previous domain can be considered
correct (Table 1)
? Features about a user?s speech recognition re-
sult (Table 2)
12
Table 1: Features representing confidence in pre-
vious domain
P1: number of affirmatives after entering the domain
P2: number of negations after entering the domain
P3: whether tasks have been completed in the domain
(whether to enter ?requesting detailed information?
in database search task)
P4: whether the domain appeared before
P5: number of changed slots after entering the domain
P6: number of turns after entering the domain
P7: ratio of changed slots (= P5/P6)
P8: ratio of user?s negative answers (= P2/(P1 + P2))
P9: ratio of user?s negative answers in the domain (=
P2/P6)
P10: states in tasks
Table 2: Features of speech recognition results
R1: best posteriori probability of the N-best candidates
interpreted in the previous domain
R2: best posteriori probability for the speech recogni-
tion result interpreted in the domain, that is the do-
main with the highest score
R3: average of word?s confidence scores for the best
candidate of speech recognition results in the do-
main, that is, the domain with the highest score
R4: difference of acoustic scores between candidates
selected as (I) and (II)
R5: ratio of averages of words? confidence scores be-
tween candidates selected as (I) and (II)
? Features representing the situation after do-
main selection (Table 3)
We can take into account the possibility that a
current estimated domain might be erroneous, by
using features representing the confidence in the
previous domain. Each feature from P1 to P9 is
defined to represent the determination of whether
an estimated domain is reliable or not. Specifi-
cally, if there are many affirmative responses from
a user or many changes of slot values during in-
teractions in the domain, we regard the current do-
main as reliable. Conversely, the domain is not
reliable if there are many negative answers from a
user after entering the domain.
We also adopted the feature P10 to represent
the state of the task, because the likelihood that
a domain is changed depends on the state of the
task. We classified the tasks that we treat into two
categories using the following classifications first
made by Araki et al (1999). For a task catego-
rized as a ?slot-filling type?, we defined the di-
alogue states as one of the following two types:
?not completed?, if not all of the requisite slots
have been filled; and ?completed?, if all of the
Table 3: Features representing situations after do-
main selection
C1: dialogue state after the domain selection after se-
lecting previous domain
C2: whether the interpretation of the user?s utterance is
negative in previous domain
C3: number of changed slots after selecting previous
domain
C4: dialogue state after selecting the domain with the
highest speech recognition score
C5: whether the interpretation of the user?s utterance
is negative in the domain with the highest speech
recognition score
C6: number of changed slots after selecting the domain
with the highest speech recognition score
C7: number of common slots (name of place, here)
changed after selecting the domain with the high-
est speech recognition score
C8: whether the domain with the highest speech recog-
nition score has appeared before
requisite slots have been filled. For a task catego-
rized as a ?database search type?, we defined the
dialogue states as one of the following two types:
?specifying query conditions? and ?requesting de-
tailed information?, which were defined in (Ko-
matani et al, 2005a).
The features which represent the user?s speech
recognition result are listed in Table 2 and corre-
spond to those used in conventional studies. R1
considers the N-best candidates of speech recogni-
tion results that can be interpreted in the previous
domain. R2 and R3 represent information about a
domain with the highest speech recognition score.
R4 and R5 represent the comparisons between the
above-mentioned two groups.
The features that characterize the situations af-
ter domain selection correspond to the information
each expert returns to the central module after un-
derstanding the speech recognition results. These
are listed in Table 3. Features listed from C1 to
C3 represent a situation in which the previous do-
main (choice (I)) is selected. Those listed from
C4 to C8 represent a situation in which a domain
with the highest recognition score (choice (II)) is
selected.
Note that these features listed here have sur-
vived after feature selection. A feature survives
if the performance in the domain classification is
degradedwhen it is removed from a feature set one
by one. We had prepared 32 features for the initial
set.
13
Table 4: Specifications of each domain
Name of Class of # of vocab. # of
domain task in ASR slots
restaurant database search 1,562 10
hotel database search 741 9
temple database search 1,573 4
weather slot filling 87 3
bus slot filling 1,621 3
total - 7,373 -
5 Experimental Evaluation
5.1 Implementation
We implemented a Japanese multi-domain spoken
dialogue system with five domain experts: restau-
rant, hotel, temple, weather, and bus. Specifica-
tions of each expert are listed in Table 4. If there
is any overlapping slot between the vocabularies
of the domains, our architecture can treat it as a
common slot, whose value is shared among the
domains when interacting with the user. In our
system, place names are treated as a common slot.
We adopted Julian as the grammar-based
speech recognizer (Kawahara et al, 2004). The
grammar rules for the speech recognizer can be
automatically generated from those used in the
language understanding modules in each domain.
As a phonetic model, we adopted a 3000-states
PTM triphone model (Kawahara et al, 2004).
5.2 Collecting Dialogue Data
We collected dialogue data using a baseline sys-
tem from 10 subjects. First, the subjects used the
system by following a sample scenario, to get ac-
customed to the timing to speak. They, then, used
the system by following three scenarios, where at
least three domains were mentioned, but neither
an actual temple name nor domain was explicitly
mentioned. One of the scenarios is shown in Fig-
ure 5. Domain selection in the baseline system
was performed on the basis of the baseline method
that will be mentioned in Section 5.4, in which ?
was set to 40 after preliminary experiments.
In the experiments, we obtained 2,205 utter-
ances (221 per subject, 74 per dialogue). The
accuracy of the speech recognition was 63.3%,
which was rather low. This was because the sub-
jects tended to repeat similar utterances even after
misrecognition occurred due to out-of-grammar or
out-of-vocabulary utterances. Another reason was
that the dialogues for subjects with worse speech
recognition results got longer, which resulted in an
increase in the total number of misrecognition.
? ?
Tomorrow or the day after, you are planning a sightsee-
ing tour of Kyoto. Please find a shrine you want to visit
in the Arashiyama area, and determine, after consider-
ing the weather, on which day you will visit the shrine.
Please, ask for a temperature on the day of travel. Also
find out how to go to the shrine, whether you can take a
bus from the Kyoto station to there, when the shrine is
closing, and what the entrance fee is.
? ?
Figure 5: Example of scenarios
5.3 Construction of the Domain Classifier
We used the data containing 2,205 utterances col-
lected using the baseline system, to construct a do-
main classifier. We used C5.0 (Quinlan, 1993) as
a classifier. The features used were described in
Section 4. Reference labels were given by hand
for each utterance based on the domains the sys-
tem had selected and transcriptions of the user?s
utterances, as follows2.
Label (I): When the correct domain for a user?s
utterance is the same as the domain in which
the previous system?s response was made.
Label (II): Except for case (I), when the correct
domain for a user?s utterance is the domain
in which a speech recognition result in the N-
best candidates with the highest score can be
interpreted.
Label (III): Domains other than (I) and (II).
5.4 Evaluation of Domain Selection
We compared the performance of our domain se-
lection with that of the baseline method described
below.
Baseline method: A domain having an interpre-
tation with the highest score in the N-best
candidates of the speech recognition was se-
lected, after adding ? for the acoustic likeli-
hood of the speech recognizer if the domain
was the same as the previous one. We calcu-
lated the accuracies of domain selections for
various ?.
2Although only one of the authors assigned the labels,
they could be easily assigned without ambiguity, since the
labels were automatically defined as previously described.
Thus, the annotator only needs to judge whether a user?s re-
quest was about the same domain as the previous system?s re-
sponse or whether it was about a domain in the speech recog-
nition result.
14
0100
200
300
400
500
600
700
800
900
0 10 20 30 40 50 60
?
#
 
o
f
 
e
r
r
o
r
s
 
i
n
 
d
o
m
a
i
n
 
s
e
l
e
c
t
i
o
n
 total
 domain in previous utt.
 domain with highest score
 other domain
Figure 6: Accuracy of domain selection in the
baseline method
Our method: A domain was selected based on
our method. The performance was calculated
with a 10-fold cross validation, that is, one
tenth of the 2,205 utterances were used as test
data, and the remainder was used as training
data. The process was repeated 10 times, and
the average of the accuracies was computed.
Accuracies for domain selection were calculated
per utterance. When there were several domains
that had the same score after domain selection, one
domain was randomly selected among them as an
output.
Figure 6 shows the number of errors for do-
main selection in the baseline method, categorized
by their reference labels as ? changed. As ? in-
creases, so does the system desire to keep the pre-
vious domain. A condition where ? = 0 cor-
responds to a method in which domains are se-
lected based only on the speech recognition re-
sults, which implies that there are no constraints
on keeping the current domain. As we can see
in Figure 6, the number of errors whose refer-
ence labels are ?a domain in the previous response
(choice (I))? decreases as ? gets larger. This is be-
cause incorrect domain transitions due to speech
recognition errors were suppressed by the con-
straint to keep the domains. Conversely, we can
see an increase in errors whose labels are ?a do-
main with the highest speech recognition score
(choice (II))?. This is because there is too much
incentive for keeping the previous domain. The
smallest number of errors was 634 when ? = 35,
and the error rate of domain selection was 28.8%
(= 634/2205). There were 371 errors whose refer-
ence labels were neither ?a domain in the previous
response? nor ?a domain with the highest speech
recognition score?, which cannot be detected even
when ? is changed based on conventional frame-
works.
We also calculated the classification accuracy of
our method. Table 5 shows the results as a con-
fusion matrix. The left hand figure denotes the
number of outputs in the baseline method, while
the right hand figure denotes the number of out-
puts in our method. Correct outputs are in the
diagonal cells, while the domain selection errors
are in the off diagonal cells. Total accuracy in-
creased by 5.3%, from 71.2% to 76.5%, and the
number of errors in domain selection was reduced
from 634 to 518, so the error reduction rate was
18.3% (= 116/634). There was no output in the
baseline method for ?other domains (III)?, which is
in the third column, because conventional frame-
works have not taken this choice into considera-
tion. Our method was able to detect this kind of
error in 157 of 371 utterances, which allows us
to prevent further errors from continuing. More-
over, accuracies for (I) and (II) did not get worse.
Precision for (I) improved from 0.77 to 0.83, and
the F-measure for (I) also improved from 0.83 to
0.86. Although recall for (II) got worse, its preci-
sion improved from 0.52 to 0.62, and consequently
the F-measure for (II) improved slightly from 0.61
to 0.62. These results show that our method can
detect choice (III), which was newly introduced,
without degrading the existing classification accu-
racies.
The features that follow played an important
role in the decision tree. The features that repre-
sent confidence in the previous domain appeared
in the upper part of the tree, including ?the num-
ber of affirmatives after entering the domain (P1)?,
?the ratio of user?s negative answers in the do-
main (P9)?, ?the number of turns after entering the
domain (P6)?, and ?the number of changed slots
based on the user?s utterances after entering the
domain (P5)?. These were also ?whether a domain
with the highest score has appeared before (C8)?
and ?whether an interpretation of a current user?s
utterance is negative (C2)?.
6 Conclusion
We constructed a multi-domain spoken dialogue
system using an extensible framework. Domain
selection in conventional studies is based on ei-
ther the domain based on the speech recognition
15
Table 5: Confusion matrix in domain selection (baseline / our method)
reference label \ output in previous response (I) with highest score (II) others (III) # total label (recall)
in previous response (I) 1289 / 1291 162 / 85 0 / 75 1451 (0.89 / 0.89)
with highest score (II) 84 / 99 299? / 256? 0 / 28 383 (0.74 / 0.62)
others (III) 293 / 172 78 / 42 0 / 157 371 ( 0 / 0.42)
total 1666 / 1562 539 / 383 0 / 260 2205
(precision) (0.77) / (0.83) (0.52) / (0.62) ( - ) / (0.60) (0.712 / 0.765)
?: These include 17 errors because of random selection when there were several domains having the same highest scores.
results or the previous domain. However, we no-
ticed that these conventional frameworks cannot
cope with situations where neither of these do-
mains is correct. Detection of such situations
can prevent dialogues from staying in the incor-
rect domain, which allows our domain selection
method to be robust against speech recognition er-
rors. Furthermore, our domain selection method
is also extensible. Our method does not select the
domains directly, but, by categorizing them into
three classes, it can cope with an increase or de-
crease in the number of domains. Based on the re-
sults of an experimental evaluation using 10 sub-
jects, our method was able to reduce domain se-
lection errors by 18.3% compared to a baseline
method. This means our system is robust against
speech recognition errors.
There are still some issues that could make
our system more robust, and this is included in
future work. For example, in this study, we
adopted a grammar-based speech recognizer to
construct each domain expert easily. However,
other speech recognition methods could be used,
such as a statistical language model. As well,
multiple speech recognizers employing different
domain-dependent grammars could be run in par-
allel. Thus, we need to investigate how to integrate
these approaches into our framework, without de-
stroying the extensibility.
References
Masahiro Araki, Kazunori Komatani, Taishi Hirata,
and Shuji Doshita. 1999. A dialogue library for
task-oriented spoken dialogue systems. In Proc.
IJCAI Workshop on Knowledge and Reasoning in
Practical Dialogue Systems, pages 1?7.
Tatsuya Kawahara, Akinobu Lee, Kazuya Takeda, Kat-
sunobu Itou, and Kiyohiro Shikano. 2004. Re-
cent progress of open-source LVCSR engine Julius
and japanese model repository. In Proc. Int?l Conf.
Spoken Language Processing (ICSLP), pages 3069?
3072.
Kazunori Komatani, Naoyuki Kanda, Tetsuya Ogata,
and Hiroshi G. Okuno. 2005a. Contextual
constraints based on dialogue models in database
search task for spoken dialogue systems. In Proc.
European Conf. Speech Commun. & Tech. (EU-
ROSPEECH), pages 877?880, Sep.
Kazunori Komatani, Shinichi Ueno, Tatsuya Kawa-
hara, and Hiroshi G. Okuno. 2005b. User model-
ing in spoken dialogue systems to generate flexible
guidance. User Modeling and User-Adapted Inter-
action, 15(1):169?183.
Lori Lamel, Sophie Rosset, Jean-Luc Gauvain, and
Samir Bennacef. 1999. The LIMSI ARISE sys-
tem for train travel information. In IEEE Int?l Conf.
Acoust., Speech & Signal Processing (ICASSP),
pages 501?504, Phoenix, AZ.
Ian R. Lane and Tatsuya Kawahara. 2005. Utterance
verification incorporating in-domain confidence and
discourse coherence measures. In Proc. European
Conf. Speech Commun. & Tech. (EUROSPEECH),
pages 421?424.
E. Levin, S. Narayanan, R. Pieraccini, K. Biatov,
E. Bocchieri, G. Di Fabbrizio, W. Eckert, S. Lee,
A. Pokrovsky,M. Rahim, P. Ruscitti, andM.Walker.
2000. The AT&T-DARPA communicator mixed-
initiative spoken dialogue system. In Proc. Int?l
Conf. Spoken Language Processing (ICSLP).
Bor-shen Lin, Hsin-min Wang, and Lin-shan Lee.
2001. A distributed agent architecture for intelli-
gent multi-domain spoken dialogue systems. IEICE
Trans. on Information and Systems, E84-D(9):1217?
1230, Sept.
Mikio Nakano, Yuji Hasegawa, Kazuhiro Nakadai,
Takahiro Nakamura, Johane Takeuchi, Toyotaka
Torii, Hiroshi Tsujino, Naoyuki Kanda, and Hi-
roshi G. Okuno. 2005. A two-layer model for be-
havior and dialogue planning in conversational ser-
vice robots. In 2005 IEEE/RSJ International Con-
ference on Intelligent Robots and Systems (IROS),
pages 1542?1548.
Ian O?Neill, Philip Hanna, Xingkun Liu, and Michael
McTear. 2004. Cross domain dialogue modelling:
An object-based approach. In Proc. Int?l Conf. Spo-
ken Language Processing (ICSLP).
Botond Pakucs. 2003. Towards dynamic multi-
domain dialogue processing. In Proc. European
16
Conf. Speech Commun. & Tech. (EUROSPEECH),
pages 741?744.
Alexandros Potamianos and Hong-Kwang J. Kuo.
2000. Statistical recursive finite state machine pars-
ing for speech understanding. In Proc. Int?l Conf.
Spoken Language Processing (ICSLP), volume 3,
pages 510?513.
J. Ross Quinlan. 1993. C4.5: Programs for Ma-
chine Learning. Morgan Kaufmann, San Mateo,
CA. http://www.rulequest.com/see5-info.html.
Antoine Raux and Maxine Eskenazi. 2004. Non-
native users in the let?s go!! spoken dialogue sys-
tem: Dealing with linguistic mismatch. In Proc. of
HLT/NAACL.
Ruben San-Segundo, Bryan Pellom, Wayne Ward, and
Jose M. Pardo. 2000. Confidence measures for di-
alogue management in the CU communicator sys-
tem. In IEEE Int?l Conf. Acoust., Speech & Signal
Processing (ICASSP).
17
Proceedings of the 9th SIGdial Workshop on Discourse and Dialogue, pages 88?91,
Columbus, June 2008. c?2008 Association for Computational Linguistics
A Framework for Building Conversational Agents Based on a Multi-Expert
Model
Mikio Nakano, Kotaro Funakoshi, Yuji Hasegawa, Hiroshi Tsujino
Honda Research Institute Japan Co., Ltd.
8-1 Honcho, Wako, Saitama 351-0188, Japan
{nakano, funakoshi, yuji.hasegawa, tsujino}@jp.honda-ri.com
Abstract
This paper presents a novel framework for
building symbol-level control modules of an-
imated agents and robots having a spoken di-
alogue interface. It features distributed mod-
ules called experts each of which is special-
ized to perform certain kinds of tasks. A com-
mon interface that all experts must support is
specified, and any kind of expert can be incor-
porated if it has the interface. Several modules
running in parallel coordinate the experts by
accessing them through the interface, so that
the whole system can achieve flexible control,
such as interruption handling and parallel task
execution.
1 Introduction
As much attention is recently paid to autonomous
agents such as robots and animated agents, spoken
dialogue is expected to be a natural interface be-
tween users and such agents. Our objective is to es-
tablish a framework for developing the intelligence
module of such agents.
In establishing such a framework, we focus on
achieving the following features. (1) Multi-domain
dialogue: Since agents are usually expected to per-
form multiple kinds of tasks, they need to work in
multiple domains and switch domains according to
user utterances. (2) Interruption handling: It is cru-
cial for human-agent interaction to be able to handle
users? interrupting utterances while speaking or per-
forming tasks. (3) Parallel task execution: Agents,
especially robots that perform physical actions, are
expected to be able to execute multiple tasks in par-
allel when possible. For example, robots should be
able to engage in a dialogue while moving. (4) Ex-
tensibility: Since the agents can be used for a vari-
ety of tasks, various strategies for dialogue and task
planning should be able to be incorporated.
Although a number of models for conversational
agents have been proposed, no model has all of the
above properties. Several multi-domain dialogue
system models have been proposed and they are ex-
tensible, but it is not clear how they handle interrup-
tions to system utterances and actions (e.g., O?Neill
et al (2004), Lin et al (1999), and Hartikainen et al
(2004)). There are several spoken dialogue agents
and robots that can handle interruptions thanks to
their asynchronous control (Asoh et al, 1999; Boye
et al, 2000; Blaylock et al, 2002; Lemon et al,
2002), they do not focus on making it easy to add
new dialogue domains with a variety of dialogue
strategies.
This paper presents a framework called RIME
(Robot Intelligence based on Multiple Experts),
which employs modules called experts.1 Each ex-
pert is specialized for achieving certain kinds of
tasks by performing physical actions and engaging
in dialogues. It corresponds to the symbol-level con-
trol module of a system that can engage in tasks in
a single small domain, and it employs fixed con-
trol strategies. Only some of the experts take charge
in understanding user utterances and decide actions.
The basic idea behind RIME is to specify a com-
mon interface of experts for coordinating them and
to achieve flexible control. In RIME, several mod-
1RIME is an improved version of our previous model
(Nakano et al, 2005), whose interruption handling was too sim-
ple and which could not achieve parallel task execution.
88
ules run in parallel for coordinating experts. They
are understander, which is responsible for speech
understanding, action selector, which is responsible
for selecting actions, and task planner, which is re-
sponsible for deciding which expert should work to
achieve tasks.
RIME achieves the above mentioned features.
Multi-domain dialogues are possible by selecting an
appropriate expert which is specialized to dialogues
in a certain domain. Interruption handling is possi-
ble because each expert must have methods to de-
tect interruptions and decide actions to handle in-
terruptions, and coordinating modules can use these
methods. Parallel task execution is possible because
experts have methods for providing information to
decide which experts can take charge at the same
time, and the task planner utilizes that information.
Extensibility is achieved because any kind of expert
can be incorporated if it supports the common inter-
face. This makes it possible for agent developers to
build a variety of conversational agents.
2 Multi-Expert Model
This section explains RIME in detail. Fig. 1 depicts
its module architecture.
2.1 Experts
Each expert is a kind of object in the object-oriented
programming framework. In this paper, we call
tasks performed by one expert primitive tasks. Ex-
perts should be prepared for each primitive task type.
For example, if there is an expert for a primitive task
type ?telling someone?s extension number?, ?telling
person A?s extension number? is a primitive task.
By performing a series of primitive tasks, a com-
plicated task can be performed. For example, a mu-
seum guide robot can perform ?explaining object B?
by executing ?moving to B? and ?giving an explana-
tion on B?. Among the experts, a small number of
experts can perform tasks at one time. Such experts
are called being in charge.
Each expert holds information on the progress of
the primitive task. It includes task-type-independent
information, such as which action in this primitive
task is being performed and whether the previous
robot action finished, and task-type-dependent in-
formation such as the user intention understanding
understander
expert 1
expert 2
expert 3
expert n
action 
selector
task 
planner
global 
context
input 
processor
action 
executor
speech 
recognition
result
score
expert 
selection 
information
speech 
recognition
result
action
(from experts 
in charge)
action
execution
report
exec. report (to the expert 
that selected the action)
charge 
/discharge new task information
across tasks
.
.
.
.
.
microphone etc. agent & speech synthesizer
Figure 1: Architecture for RIME-Based Systems
results and dialogue history. The contents and the
data structure for the task-type-dependent informa-
tion for each expert can be designed by the system
developer.
Experts are classified into system-initiative task
experts and user-initiative task experts. In this pa-
per, the initiative of a task means who can initiate
the task. For example, the task ?understanding a
request for weather information? is a user-initiative
task, and the task ?providing weather information?
is a system-initiative task.
In RIME, executing multiple tasks in parallel be-
comes possible by making multiple experts take
charge. To check whether two experts can take
charge simultaneously, we currently use two fea-
tures verbal and physical. Two experts having the
same feature cannot take charge simultaneously.
The interface of experts consists of methods for
accessing its internal state. Below are some of the
task-type-dependent methods, which need to be im-
plemented by system developers.
The understand method updates the internal state
based on the user speech recognition results, us-
ing domain-dependent sentence patterns for utter-
ance understanding. This method returns a score
which indicates the plausibility the user utterance
should be dealt with by the expert. Domain selection
techniques in multi-domain spoken dialogue sys-
tems (Komatani et al, 2006) can be applied to obtain
the score. The select-action method outputs one ac-
tion based on the content of the internal state. Here,
an action is a multimodal command which includes
a text to speak and/or a physical action command.
89
The action can be an empty action, which means do-
ing nothing. The detect-interruption method returns
a Boolean value that indicates whether the previous
user utterance is an interruption to the action being
performed when this expert is being in charge. The
handle-interruption method returns the action to be
performed after an interruption is detected. For ex-
ample, an instruction to stop the utterance can be
returned.
In the definition of these methods, experts can
access a common database called global context to
store and utilize information across domains, such
as information on humans, information on the envi-
ronment, and past dialogue topics.
2.2 Modules Coordinating Experts
To exploit experts, three processes, namely the un-
derstander, the action selector, and the task planner,
work in parallel.
The understander receives output of an input pro-
cessor, which typically performs speech recogni-
tion. Each time the understander receives a user
speech recognition result from the input processor,
it performs the following process. First it dispatches
the speech recognition result to the experts in charge
and the user-initiative experts with their understand
methods, which then returns the scores mentioned
above. The expert that returns the highest score is
selected as the expert to take charge. If the selected
expert is not in charge, it tells the task planner that
the expert is selected as the user-initiative expert to
take charge. If the selected expert is in charge, it
calls the detect-interruption method of the expert. If
true is returned, it tells the action selector that an
interruption utterance is detected.
The action selector repeats the following process
for each expert being in charge in a short cycle.
When an interruption for the expert is detected, it
calls the expert?s handle-interruption method, and
it then sends the returned action to the action ex-
ecutor, which is assumed to execute multimodal ac-
tions by controlling agents, speech synthesizers, and
other modules. Otherwise, unless it is not waiting
for a user utterance, it calls the expert?s select-action
methods, and then sends the returned action to the
action executor. The returned action can be an empty
action. Note that it is assumed that the action execu-
tor can perform two or more actions in parallel when
verbalagentexplaining placesG
physicalagentmoving to show the way F
verbaluserunderstanding requests for guiding to placesE
verbalagentproviding extension numbersD
verbaluserunderstanding extension number requestsC
verbalagentproviding weather informationB
verbaluserunderstanding weather information requestsA 
featureinitiativetask typeID 
Table 1: Experts in the Example Robotic System
Human: "Where is the meeting 
room?"
Robot: "Would you like to know 
where the meeting room is?"
Human: "yes."
Human: "Tell me A's extension 
number."
Robot: "Please come this way."
(start moving)
Robot: "A's extension number is 
1234."
Robot: (stop moving)
Expert E
Expert G
Expert C
Expert D
understand request
to show the way
show the way
tell A's ext. 
number
understand 
request for A's 
ext. number
Robot: "The meeting room is over
there."
Utterances and physical actions Experts in charge and tasks
move to 
show the 
way
Expert F
Figure 2: Expert Selection in a Parallel Task Execution
Example
possible.
The task planner is responsible for deciding which
experts take charge and which experts do not. It
sometimes makes an expert take charge by setting
a primitive task, and sometimes it discharges an ex-
pert to cancel the execution of its primitive task. To
make such decisions, it receives several pieces of in-
formation from other modules. First it receives from
the understander information on which expert is se-
lected to understand a new utterance. It also receives
information on the finish of the primitive task from
an expert being in charge. In addition, it receives
new tasks from the experts that understand human
requests. The task planner also consults the global
context to access the information shared by the ex-
perts and the task planner. In this paper we do not
discuss the details of task planning algorithms, but
we have implemented a task planner with a simple
hierarchical planning mechanism.
There can be other processes whose output is
written in the global context. For example, a robot
and human localization process using image pro-
cessing and other sensor information processing can
be used.
90
3 Implementation as a Toolkit
The flexibility of designing experts increases the
amount of effort for programming in building ex-
perts. We therefore developed RIME-TK (RIME-
ToolKit), which provides libraries that facilitate
building systems based on RIME. It is implemented
in Java, and contains an abstract expert class hier-
archy. The system developers can create new ex-
perts by extending those abstract classes. Those ab-
stract classes have frequently used functions such
as WFST-based language understanding, template-
based language generation, and frame-based dia-
logue management. RIME-TK also contains the im-
plementations of the understander and the action se-
lector. In addition, it specifies the interfaces for the
input processor, the action executor, and the task
planner. Example implementations of these mod-
ules are also included in RIME-TK. Using RIME-
TK, conversational agents can be built by creating
experts, an input processor, an action executor, and
a task planner.
As an example, we have built a robotic system,
which is supposed to work at a reception, and can
perform several small tasks such as providing ex-
tension numbers of office members and guiding to
several places near the reception such as a meeting
room and a restroom. Some experts in the system
are listed in Table 1. Fig. 2 shows an example inter-
action between a human and the robotic system that
includes parallel task execution and how experts are
charged. The detailed explanation is omitted for the
lack of the space.
By developing several other robotic systems and
spoken dialogue systems (e.g., Komatani et al
(2006), Nakano et al (2006), and Nishimura et al
(2007)), we have confirmed that RIME and RIME-
TK are viable.
4 Concluding Remarks
This paper presented RIME, a framework for build-
ing conversational agents. It is different from pre-
vious frameworks in that it makes it possible to
build agents that can handle interruptions and exe-
cute multiple tasks in parallel by employing experts
which have a common interface. Although the cur-
rent implementation is useful for building various
kinds of systems, we believe that preparing more
kinds of expert templates and improving expert se-
lection for understanding utterances facilitate build-
ing a wider variety of systems.
Acknowledgments We would like to thank all
people who helped us to build RIME-TK and its ap-
plications.
References
H. Asoh, T. Matsui, J. Fry, F. Asano, and S. Hayamizu.
1999. A spoken dialog system for a mobile office
robot. In Proc. Eurospeech-99, pages 1139?1142.
N. Blaylock, J. Allen, and G. Ferguson. 2002. Synchro-
nization in an asynchronous agent-based architecture
for dialogue systems. In Proc. Third SIGdial Work-
shop, pages 1?10.
J. Boye, B. A. Hockey, and M. Rayner. 2000. Asyn-
chronous dialogue management: Two case-studies. In
Proc. Go?talog-2000.
M. Hartikainen, M. Turunen, J. Hakulinen, E.-P. Salo-
nen, and J. A. Funk. 2004. Flexible dialogue manage-
ment using distributed and dynamic dialogue control.
In Proc. Interspeech-2004, pages 197?200.
K. Komatani, N. Kanda, M. Nakano, K. Nakadai, H. Tsu-
jino, T. Ogata, and H. G. Okuno. 2006. Multi-domain
spoken dialogue system with extensibility and robust-
ness against speech recognition errors. In Proc. 7th
SIGdial Workshop, pages 9?17.
O. Lemon, A. Gruenstein, A. Battle, and S. Peters. 2002.
Multi-tasking and collaborative activities in dialogue
systems. In Proc. Third SIGdial Workshop, pages
113?124.
B. Lin, H. Wang, and L. Lee. 1999. Consistent dialogue
across concurrent topics based on an expert system
model. In Proc. Eurospeech-99, pages 1427?1430.
M. Nakano, Y. Hasegawa, K. Nakadai, T. Nakamura,
J. Takeuchi, T. Torii, H. Tsujino, N. Kanda, and H. G.
Okuno. 2005. A two-layer model for behavior and
dialogue planning in conversational service robots. In
Proc. 2005 IEEE/RSJ IROS, pages 1542?1547.
M. Nakano, A. Hoshino, J. Takeuchi, Y. Hasegawa,
T. Torii, K. Nakadai, K. Kato, and H. Tsujino. 2006.
A robot that can engage in both task-oriented and non-
task-oriented dialogues. In Proc. 2006 IEEE/RAS Hu-
manoids, pages 404?411.
Y. Nishimura, S. Minotsu, H. Dohi, M. Ishizuka,
M. Nakano, K. Funakoshi, J. Takeuchi, Y. Hasegawa,
and H. Tsujino. 2007. A markup language for describ-
ing interactive humanoid robot presentations. In Proc.
IUI-07.
I. O?Neill, P. Hanna, X. Liu, and M. McTear. 2004.
Cross domain dialogue modelling: an object-based ap-
proach. In Proc. Interspeech-2004, pages 205?208.
91
