XML and Multilingual Document Authoring: Convergent Trends 
Marc l )ymctman Veronika Lux  
Xerox  Research  Centre Europe 
6, chemin  de Maupertu is  
38240 Meylan,  France 
{ dymetman, lux  } @xrce .xerox .com 
Aarne Ranta  
Depar tment  of  Comput ing  Science 
Chahners  Univers i ty  of  Techno logy  
and GOteborg Univers i ty  
S-412 96 GOteborg,  Sweden 
aarne @ cs.chahners,  e 
Abstract 
Typical al)proaches to XML authoring view a XML doc- 
urnent as a mixture of structure (the tags) and surlhce 
(texl between the tags). We advoeale a radical approach 
where the surface disappears from lhe XML documenl 
altogether to be handled exclusively by rendering mech- 
anisms. This move is based on the view that the author's 
choices when authoring XML docutnciHs are best seen 
as language-i~eutral semantic decisions, that lhe SlftlC- 
lure can then be viewed as inlerlingual content, and that 
the textual oulpul  should be derived from this co)lien\[ by 
language-sl~ecific realization mechanisms, lhus assimi- 
lating XML aufllol'ing lo Mullilingual Document Amhof  
ing. However, slandard XMI, tools have imporlant lhni- 
tations when used for such a ptu'pose: (1) they are weak 
at propagating semanlic dependencies belween dil'ferenl 
parts of the st,'ucture, and, (2) current XMI. rendering 
tools are ill-suited for handling the grammatical combi- 
nation of lextual units. We present two relalcd proposals 
for overcoming these limitalions: one (GI:) origitmting 
in the Iradilion of malhemalical proof edilors and con- 
slruct ivc type lhcery,  the other  (IG), a special i?at ion o f  
l)elinite Clause (_\]ranllllars strongly inspired by (iF. 
1 Introduction 
The typical al3pl'oacll to XML authoring views an XML 
doctmlcnt as a mixture of wee-like strttctttre, expressed 
througll balanced labelled parentheses (tim lags), and 
of sul:face, expressed llu'ough free lexi interspersed be- 
tween lhe tags (PCI)ATA). A l)octunent Type l)elini- 
lion (DTD) is roughly similar to a coiitext-free gram- 
mar j with exactly one predelined terminal. It delines a 
set o1' well-formed structures, (hat is, a la,guage over 
trees, where each nonterminal node can dominate ither 
the empty string, or a sequence of occurrences of nonter- 
minal nodes and of 111o terminal node pcdata. The ter- 
minal pcdata  has a specM status: it can in turn dominate 
any characler string (subjecl to certain reslrictions on the 
characters allowed). Authoring is typically seen as a top- 
down interactive process of step-wise refinement of the 
root nonterminal (corresponding to the whole document) 
where the aulhor  ileratively chooses arule for expanding 
IBu( see (l'rescod, 1998) lbr an inleresfing discussion oflhe differ- 
enccs. 
a nonlerminal aheady present in the tree, 2 and where in 
addition the author can choose an arbitrary sequence of 
characters (roughly) for expanding lhe pcdata  node. 
One can observe the following trends in the XML 
world: 
A move towards more typing of the surface: 
Schemas (W3C, 1999a), which are an inlluemial 
proposal for the ieplacenlent of I)TD's, provide for 
types such as f loat ,  boolean, uri, etc., instead o\[" 
the single type pcdata; 
A move, aheady constitulive of the main lmlpose 
of XMl, its opposed l(1 HTML for instance, towards 
clearer separation between content and form, where 
the original XML document is responsible for con- 
lent, and powerful styling lnechanisms (e.g. XSI.T 
(W3C, 1999b)) are available for rendering 111o doc- 
tlll/en\[ \[o lhe end-user .  
We advocate an approach in which these two moves 
are radicali?cd in tile folk)wing ways: 
Strongly typed, surface-free XML documents. The 
whole content of the document is a trcc whore each node 
is labelled and typed. For inlernal nodes, lhe lype is just  
the usual nonierminal name (or category), and Ille label 
is a name for the expansion chosen for this nonlernfinal, 
lhat is, an identifier of which rule was chosen to expand 
ibis nonterminal. For leaves, lhe type is a semanlically 
specilic category such as Integer, Animal, etc., and lhe 
label is a specilic concept of this type, such as three or 
dog)  
Styling responsible for producing tim text itself. 
The styling mechanisnl is not only responsible for ren- 
dering the layout of the lext (typography, order and pre- 
sentation of lhe elements), but also for producing the text 
itse!ffrom 111o document content. 
What are (he motiw~tions behind this proposal? 
Autlmring choices carry language-independent 
meaning. First, let us note that lhe expansion choices 
2We arc ignoring here tl~e aspecls of lhis process relating to lhe 
regular ,mlure of Ihe righ(-halld sides of rules, but Ihese parliculars are 
uncssenlial lo the nlaill g:lfgtllllOnl. 
3Note Ihat lnlcgcr is of"logical type" e, whereas Animal is of log- 
ical lype (c, t): lhe,'c is no reslriction on lhe denotalional s alus of 
leaves. 
243 
<!ELEMENT R isk  (Caut ion  I Warn ing)  > r i sk - ru le l :  R i sk  --> Caut ion  
r i sk - ru le2 :  R i sk  --> Warn ing  
<!ELEMENT Caut ion  ( . . .  I . . .  I . . .  ) > caut ion - ru le l :  
caut ion - ru le2 :  
caut ion - ru le3 :  
Caut ion  --> .., 
Caut ion  --> ... 
Caut ion  --> ... 
Figure 1 : Context-flee rules (shown on the right) corresponding to the aircraft DTD (shown on the left); for illustration 
purposes, we have assumed that there are in turn three semantic varieties of cautious. The rule identitier on the left 
can be seen as a semantic label for each expansion choice (in practice, the rule identifiers are given mnemonic names 
directly related to their meauing). 
made during the authoring of an XML document gener- 
ally carry language-independent meaning. For instance, 
the DTD for an aircraft maintenance manual might be 
legally required to distinguish between risk instructions 
of two kinds: caut  ion (risk related to material damages) 
and warn ing (risk to the operator). Or a D~'I) describing 
a personal list of contacts might provide a choice of gen- 
der (male, female) ,  title (dr, p ro f ,  de fau l t ) ,  country 
(ger, fra,...), etc. Each such authoring choice, which 
formally consists in selecting among different rules for 
expanding the same nonterminal (see Figure 1), corre- 
sponds to a semantic decision which is independent of 
the language chosen for expressing the document. A 
given DTD has an associated expressive space of tree 
structures which fall under its explicit control, and the 
author is situating herself in this space through top-down 
expansion choices. There is then a tension between on 
the one hand these cxplicitely controlled choices, which 
should be rendered differently in different languages 
(thus ger  as Germany, Allemagne, Deutschland .... and 
Warning by a paragraph starting with Warnillg! ...; At- 
tention, Danger! ...; Achtung, Lebensgefahr! ...), and 
on the other hand the uncontrolled inclusion in the XML 
document of free PCDATA strings, which are written in 
a specific language. 
Surface-fi'ce XML documents. We propose to com- 
pletely remove these surface strings from the XML doc- 
ument, and replace them with explicit meaning labels. 4
The tree structure of the document then becomes the sole 
repository of content, and can be viewed as a kind of in- 
terlingua for describing a point in the expressive space 
of tile DTD (a strongly domain-dependent space); it is 
then the responsability of the language-specific rendering 
mechanisms to "display" such content in each individual 
language where the document is needed. 
XML and Multil ingual Document Authoring. In 
this conception, XML authoring has a strong connection 
to the enterprise of Multilingual Document Authoring in 
which the author is guided in the specilication of the 
document content, and where the system is responsible 
4There are autlmring situations in which it may be necessary for 
the user to introduce new selllalllic labels eorleSl)onding lo expres- 
sive needs not foreseen by lhe creator of the original I)TD. To handle 
such situations, it is useflfl to view the l)TI)'s as open-ended objecls 1o 
which new semantic labels and types can be added at authoring time. 
for generating from this content extual output in several 
languages imultaneously (see (Power and Scott, 1998; 
Hartley and Paris, 1997; Coch, 1996)). 
Now there are some obvious problems with this view, 
due to the current limitations of XML tools. 
Limitations of XML for multilingual document au- 
thoring. The first, possibly most serious, limitation 
originates in the fact that a standard DTD is severely re- 
stricted in the semantic dependencies it can express be- 
tween two subtrces in the document structure. Thus, if 
in the description of a contact, a city of residence is in- 
cluded, one may want to constrain such an information 
depending on the country of residence; or, in the air- 
craft maintenance manual example, one might want to 
automatically include some warning in case a dangerous 
chemical is mentioned somewhere lse in the document. 
Because DTD's are essentially ofcontcxt-fi'ce expressive 
power, the only communication between a subtree and its 
environment has to be mediated through the name of the 
nonterminal rooting this subtree (for instance the nonter- 
minal Country) ,  which presents a bottleneck to informa- 
tion ilow. 
The second limitation comes fi'om the fact that the cur- 
rent styling tools for rendering an XML document, such 
as CSS (Cascading Style Sheets), which arc a strictly 
layout-oriented language, or XSLT (XSL transformation 
language), which is a more generic tool for transforming 
an XML document into another one (such as a display- 
oriented HTML file) are poorly adapted to linguistic pro- 
cessing. In particulm, it seems difficult in such for- 
malisms to express uch basic grammatical facts as ntun- 
ber or gender agreement. But such problems become 
central as soon as semantic elements corresponding to 
textual units below the sentence level have to be com- 
bined and rendered linguistically. 
We will present two related proposals for overcom- 
ing these limitations. The first, the Grammatical Frame- 
work (GF)(Ranta, 2000), originates in constructive type- 
theory (Martin-L6f, 1984; Ranta, 1994) and in mathe- 
matical proof editors (Magnusson and Nordstr6m, 1994). 
The second, h~teraction Grammars (IG), is a specializa- 
tion of Definite Clause Grammars trongly inspired by 
GF. The two approaches present certain lk)rmal differ- 
ences that will not be examined in detail in this papeh 
244 
but they share a number of important assumptions: 
? The semantic representations are strrmgly O'ped 
trees, and rich dependencies between subtrees can 
be specilied; 
? The abstract tree is independe,lt of tile different ex- 
tual realization hmguages; 
? Tim surface realization in each language is obtained 
by a semalltics-driven compositional process; that 
is, the surface realizations are constructed by a 
bottom-up recursive process which associates ur- 
face realizations to abstract ree nodes by recur- 
sively combining the realizations of daugthcr nodes 
to obtain the realization of the mother node. 
? The grammars are revelwible, that is, can be used 
both for generation and for parsing; 
? The authoring process is an interactive process 
of repeatedly asking the author to further specify 
nodes in the absmlct ree of which only the type is 
known at the 1)oint of interacti(m (tyFe re/itlemeHt). 
This process is mediated througll text in the lan- 
guage of the author, showing the types t(5 be relined 
as specially highlighted textual units. 
2 GF  ~ the  Grammat ica l  F ramework  
The Grammatical Framework (GF; (Ranta, 2000)) is a 
special-purpose programming hmguage combining co~z- 
strttctive type thee O, with an annotation hmguage for 
concrete syntax. A grammar, in the sense of GF, delines, 
on one hand, an abstract s3,1ttax (a system of types and 
typed syntax trees), and on the other hand, a mapping {51 
tile abstract syntax into a co,icicle sy, tta.v. The abstract 
syntax has cotCtlot 3, declarations, uch as 
cat  Count ry  ; ca t  C i ty  ; 
and combinator (orfttnctiolO dechuations, uch as 
fun Get : Country ; fun Fra : Country ; 
fun Ham : C i ty  ; fun Par : C i ty  ; 
fun cap : Country -> C i ty  ; 
The type of a combinator can be either a basic type, such 
as the type C i ty  of the combinator Ham, or a function 
type, such as the type of the combinator cap. Syntax 
trees formed by combinators of functioll types are con> 
plex functional terlns, such as 
cap Fra 
of type City. 
"file concrete syntax part of a GF grammar gives lit~- 
earization rules, which assign strings (or, in general, 
more complex linguistic objects) to syntax trees. For the 
abstract syntax above, we may lmve 
fin Ger = "Germany" ; f in Fra = "France" ; 
l in Ham = "Hamburg" ; l in Par : "Paris" ; 
lin cap Co = "the capita l  of" ++ Co ; 
Thus tile linearization of cap Fra is 
the capital  of France 
2.1 GF inXMI ,  
Functional terms have a straightforward encoding in 
XML, l'el~resenting a term of tile forna 
.\[ (11  . . .  ( I ,~  
by the XML object 
<J'> ct', . . .  a',, < / f> 
where each e~ is tile encoding of a i. In this encoding, 
cap Fra is 
<cap> 
<Fra> 
</Fra> 
</cap> 
Tile simple encoding does not pay attention to the 
types (51' the objects, and has no interesting DTI). To 
express type distinctions, we will hence use a slightly 
more complicated representation, i  which the category 
and combinator declarations of GF are represented as 
DTDs in XML, so that GF type dlecking becomes equiv- 
alent ,a, itll XML validatiom The represelm~tion f the GF 
grallllllaf o1' tile previous ection is tile DTI) 
<!ELEMENT Country (Ger \[ Fra)  > 
<!ELEMENT Get EMPTY > 
<!ELEMENT Fra EMPTY > 
<!ELEMENT City (Ham I Par I (cap,Country))> 
<!ELEMENT Ham EMPTY > 
<!ELEMENT Par EMPTY > 
<!ELEMENT cap EMPTY > 
In this DTD, each category is represented as an EI,E- 
MENT dclinition, listing all combinators producing trees 
of that category. The combinators themselves are repre- 
sented as EMPTY elements. The XML representation f 
the capital (51' France is 
<City> 
<cap /> 
<Country> 
<Fra /> 
</Country> 
</City> 
which is a wdid XML object w.r.t, tile given DTD. 
The latter encoding of GF in XML enjoys two impor- 
tant properties: 
? All well-typed GF trees are represented by valid 
XML objects. 
? An XML represents a unique GF tree. 
The tirst property guarantees that type checking in the 
sense of GF (and type theory) can be used for validation 
of XML objects. The second property guarantees that GF 
objects can be stored in tim XML format. (The second 
property is already gt, aranteed by tile simpler encoding, 
which ignores types.) 
()ther prope,'ties one would desire are the followillg: 
245 
? All valid XML objects represent well-typed GF 
trees. 
? A DTD represents a unique GF abstract grammar. 
These properties cannot be satislied, in general. The rea- 
son is that GF grammars may contain dependent types, 
i.e. types depending on objects. We will retnrn to this 
notion shortly. But let us first consider the use of GF for 
nmltilingual generation. 
2.2 Multilingualgeneration i GF 
Multilingual generation i  GF is based on parallel gram- 
mars': two (or more) GF grammars are parallel, if they 
have the same abstract syntax. They may differ in con- 
crete syntax. A grammar parallel to the one above is de- 
fined by the concrete syntax 
param Case = hem \[ gen ; 
oper noml : Str -> Case => Str = 
ks -> tbl {{nom} => s, {gen} -> s+"n"} ; 
oper nom2 :S t r  -> Case => Str 
ks -> tbl 
{{nom} => s+"ki", {gen} -> s+"gin"} ; 
l incat Country = Case => Str ; 
l incat City = Case => St r ;  
lin Ger = noml "Saksa" ; 
lin Fra = noml "Ranska" ; 
lin Ham = noml "Hampuri" ; 
l in Par = noml "Pari isi" ; 
l in cap Co = 
tbl {c => Co!gen ++ 
nora2 "p~iikaupun" ! c} ; 
This grammar renders GF objects in Finnish. In addition 
to linearization rules, it has rules introducing parameters 
and operations, and rules detining the linearization O,pes" 
corresponding to basic types: the linearization type el' 
Country, for instance is not just string (Str), but a func- 
tion fl'om cases to strings. 
Not only the linearization rules proper, but also param- 
eters and linearization types wwy a lot fl'om one hmguage 
to another. In our example, we have the paralnetre of ease 
with two values (in larger granunars for Finnish, as many 
as 16 may be required!), and two patterns for inflecting 
Finnish nouns. The syntax tree cap Fra produces the 
strings 
Ranskan p~fikaupunki 
Ranskan p~kaupung in  
which are the nominative and the genitive form, respec- 
tively. 
2.3 Del)endent types 
DTDs in XML are capable of representing simple types, 
i.e. types without dependencies. Even a simple type sys- 
tem can contribute a lot to the semantic ontrol of doc- 
uments. For instance, the above grammar permits the 
formation of the English noun phrase 
the capital  of France 
but not of 
the capital  of Paris 
Both of these expressions would be well-formed w.r.t. 
an "ordinary" granunar, in which both France and Paris 
would be classitied simply as noun phrases. 
Dependent types are types depending on objects of 
other types. An example is the following alternative dec- 
laration of Country and City: 
cat Country ; cat City (Co:Country) ; 
Under tiffs definition, there are no objects of type City 
(which is no longer a well-formed type), but of types 
City Ger and City Fra. Tlms we define e.g. 
fun Ham : City Ger ; fun Par : City Fra ; 
fun cap : (Co:Country) -> City Co ; 
Observe the use of the variable Co in the type of the com- 
binator capital: the variable is bound to the argument 
type and then used in the value type. The capital of a 
country is by definition a city of the same country. This 
involves a generalization o1' function types with depen- 
dent types. 
Now consider a simplified format ()f postal addresses: 
an address is a pair of a country and a city. The GF rule 
is either 
fun addr : Country  -> C i ty  -> Address ; 
i i n  addr  Co C = C ++ " , "  ++ Co ; 
using simple types or 
fun addr : 
(Co:Country)  -> C?ty Co -> Address ; 
&in addr  Co C = C ++ " , "  ++ Co ; 
using dependent types. The invalid address 
Hamburg, France 
is well-typed by the former definition but not by the lat- 
ter. Using the laUer delinition gives a simple mechanism 
of semantic ontrol ot' addresses. The same idea can ob- 
viously be exlended to full addresses with street names 
and numbers. Such dependencies cannot, however, be 
expressed in DTDs: both of the address rules above cor- 
respond to one and the same ELEMENT definition, 
<!ELEMENT Address (addr, Country, City) > 
This example 
enoughlbr GF 
<Address> 
<addr /> 
<Country> 
<Fra /> 
</Country> 
<City> 
<Ham /> 
</City> 
</Address> 
also shows Illat XML validity is not 
well-formedness: the object 
246 
is valid w.r.t, the DTD, but the corresponding Ot-; object 
addr  Fra  ttam 
is not well-typed. 
2.4 Computation rules 
In addition to categories and cornbinators, GF grammars 
may contain definitions, uch as 
def  cap Fra  = Par ; 
Definitions belong to the abstract syntax. They define 
a normal form for syntax trees (recursively replace de- 
fienda by definientes), as well as a paraphrase relation 
(sameness of normal tbrm). These notions are, of course 
reflected in the concrete syntax: the addresses 
the capital of France, France 
Par i s ,  F rance  
are paraphrases, and the latter is the normal form of the 
former. 
= . . . .  - - , -  , - - -  1 
\[U"e m IE'~i ml~w ml?pu?i's ~lum= ~J II 
 Nll 
I\[ "''~ ~ ~ ~ I / l l  
I I ~h~1- ~ul~f  ~ / / 1 1  
I I  lt'~eore~. Fc? aH numbers ?, there e?ists a rtlOcer u ' such I / /11 
I I  ~hat ~.L~ ~,~n~ U~ ,,'. ~-o~f. C~-.id~. ~,~'bitr ,  a~u I / /  
11 nuliJer x. '?z3re<~? . Ik.nce, "for' a l l  r i J~2rs ~, there ex is ts  a I l l  II 
l i  ~-,4,c,r'e~. Pot  tous lore rBc~hoes ;4. i l  e~i~te ~.~mbre  ~: ' .~ \ [ / I1  
j \ [  x ,  ~ r~. ,  ~.111~\] (~  t~.: n~',-~, ~- ~ ~-ooql II//1/ 
I\[ m~oon L~,u:~oUil l  " " t~- (~-  n~, u =(~.'ql II j i l l  
I I  e t~oH lukux~ik4} l  . . . . . .  I . . . . . . . .  . v .  I I I l l / I t  
I \[ <Text > crh,ua~w,-o411 ~,~. (, ,:- \[~, r,, q I I I l l / I /  
I I <Pr*~> <E--:ist/> <0c~ll E~t , / i ' .  ~ -_ ~ , ,  ~-_ (~ =11 I I IM II 
</Prop> <~r'oo> </ @tEll _ . . 
I . . . .  ta ~ ~_l~m H 
, .................................... Ill.,,,  411Lt 
?~a ~ Proof (Exist  !lat (','..'>:' q l l?l . l  0:~s~ r,, s: ~" ~ ' ,~  tl I i i-\]1t 
-- ~iI1_:_'. ~ ,_ t%: t~:F??~) \ ] l l l~  
Figure 2: GF session for editing a mathematical proof 
text. 
2.5 GF editing tools 
An editing tool has been implemented for GF, using 
metavariables to represent yet undefined parts of expres- 
sions. The user can work on any metavariable, in various 
different ways, e.g. 
? by choosing a combinator f om a menu, 
? by entering a string that is parsed, 
? by reading a previously defined object from a file, 
? by using an automatic search of suitable instantia- 
tions. 
These functionalities and their metatheory have been 
used for about a decade in a number of syntax edi- 
tors for constructive type theory, usually known as proof 
editors (Magnusson and NordstrOm, 1994). From this 
point of view, the GF editor is essentially a proof edi- 
tor together with supplementary views, provided by the 
concrete syntax. The current implementation of GF 
is a plugin module of the proof editor Alfa (Hallgren, 
2000). The window dump in Figure 2 shows a GF ses- 
sion editing a mathematical proof. Five views are pro- 
vided: abstract syntax in type-theoretical notation, En- 
glish, French, Finnish, and XML. One metavariable is
seen, expecting the user to find a Proof  of the proposi- 
tion that there exists a number .r' such that a', is smaller 
than x', where x is an arbitrary number given in the con- 
text (for the sake of Universal Introduction). 
3 IG : Interaction Grammars 
We have just described an approach to solving the limita- 
tions of usual XML tools for multilingual document au- 
thoring which originates in the tradition of constructive 
type-theory and mathematical proof editors. We will now 
sketch an approach strongly inspired by GF but which 
formally is more in the tradition of logic-programming 
based unification grammars, and which is currently un-. 
der development at Xerox Research Centre Europe (see 
(Brun et al, 2000) for a more extended escription of 
this project). 
Definite Clause Grammars, or DCG's, (Pereira and 
Warren, 1980), are possibly the simplest unification- 
based extension of context-free grammars, and have 
good reversibility properties which make them adapted 
both to parsing and to generation. A typical view of what 
a DCG rule looks like is the following: 5
a(a l (B ,C  . . . .  )) ---> 
<text l> ,  
b(B), 
<text2>,  
e(c ) ,  
<text3>, 
{constraints (B,C,...)}. 
This rule expresses the fact that (1) some abstract 
structure a l  (B, C . . . .  ) is in category a if the structure 
B is in category b, the structure C in category c..... and 
furthermore a certain number of constraints are satisfied 
by the structures B, C .... ; (2) if the structures B, C .... can 
be "rendered" by character strings St r ingB,  Str ingC,  
.... then the structure a l (B ,C . . . .  ) can be rendered by 
the string obtained by concatenating the text <text:t> 
(that is, a certain constant sequence of terminals), then 
St r ingB,  then <text2>, then Str ingC,  etc. 
In this formalism, a grammar for generating English 
addresses (see preceding section) might look like: 
SReminder: according to the usual ogic programming conventions, 
lowercase letters denote predicates and functors, whereas uppercase 
letters denote metavariables that will be instantiated with terms. 
247 
address(addr(Co,C)) --> city(C), ",", 
country(Co). 
country(fra) --> "France". 
country(get) --> "Germany". 
city(par) --> "Paris" 
city(cap(Co)) --> "the capital of", 
country(Co). 
The analogies with the GF grammars of the previous 
section arc clear. What is traditionally called a cate- 
gory (or nonterminal, or predicate) in the logic program- 
ruing terminology, can also be seen as a type (address,  
country ,  c i ty )  and functors uch as get,  par,  addr, 
cap can be seen as combinators. 
If, in this DCG, we "forget" all the constant strings 
by replacing them with the empty string, we obtain the 
following "abstract grammar": 
address(addr(Co,C)) --> city(C), country(Co). 
country(fra) --> \[\]. 
country(ger) --> \[\]. 
city(par) --> \[\]. 
city(cap(Co)) --> country(Co). 
which is in fact equivalent to the definite clause pro- 
gram: 6 
address (addr (Co ,C) )  : -  c i ty (C) ,  count ry (Co) .  
count ry ( f ra ) .  
country(ger) . 
city(par) . 
city(cap(Co)) :- country(Co). 
This program is language-independent andrecursively 
dclines a set el' well-formed trees to which it assigns 
types (thus cap( f ra )  is a well-formed tree o1' type 
city). 
As they stand, such definite clause grammars and pro- 
grams, although suitable Ibr simple generation tasks, are 
not directly adapted for the process of interactive multi- 
lingual document authoring. In order to make them more 
appropriate for that task, we need to specialize and adapt 
DCGs in the way that we now describe. 
Parallel grammars.  The tirst move is to allow for 
parallel English, French ..... grammars, which all have 
the same underlying abstract gralnmar (program). So in 
addition to the Englisb grammar given above, we have 
tim French grammar: 
address(addr(Co,C)) --> city(C), ",", 
country(Co). 
country(fra) --> "la France". 
country(get) --> "l'Allemagne". 
city(par) --> "Paris". 
city(cap(Co)) --> "la capitale de", 
country(Co) . 
6hl the sense that rewriling the llOntCI'nlilull goal 
address  (addr (Co ,C) ) to the empty siring in lhe I)CG is equivalent 
|o proving the goal address  (addr (Co, C) ) in the program (l)cransart 
and Maluszynski, 1993). 
Dependent  Categor ies .  The grammars we have given 
arc delicient in one importaut respect: there is no de- 
pendency between the city and the country in the salne 
address. In order to remedy this problem, a stan- 
dard logic programming move would he to reformulate 
the abstract grammar (and similarly for the language- 
dependent ones) as: 
address (addr (Co ,C) )  - -> c i ty (C ,Co) ,  
count ry (Co) .  
count ry ( f ra )  - -> \ [ \ ] .  
count ry (ger )  - -> \ [ \ ] .  
c i ty (par , f ra )  - -> \ [ \ ] .  
c i ty (cap(Co) ,Co)  - -> count ry (Co) .  
The expression c i ty (C ,  Co) is usually read as the re- 
lation "C is a city of Co", which is line for computational 
purposes, but this reading obscures the notion that the 
object C is being typed as a c i ty ;  more precisely, it is 
being typed as a c i ty  of Co. In order to make this read- 
ing more apparent, we will write the grammar as: 
address(addr(Co,C)) --> cityc0(C), 
country(Co). 
country(fra) --> \[\]. 
country(ger) --> \[\]. 
cityf~(par) --> \[\]. 
cityco(cap(Co)) --> country(Co). 
That is, we allow the categories to be indexed by terms 
(a move which is a kind of "currying" ot' a relation into 
a type for its first argument). Dependent categories are 
similar to the dependent types of constructive type the- 
ory. 
Heterogeneous trees. Natural language authoring is 
different from natural language generation in one cru- 
cial respect. Whenever the abstract ree to be generated 
is incomplete (for instance the tree cap(Co)),  that is, 
has some leaves which are yet uninstantiated variables, 
the generation process should not proceed with noude- 
terministically enumerating texts for all the possible in- 
stantiations of the initial incomplete structure. Instead it 
should display to the author as much of the text as it can 
in its present "knowledge state", and enter into an inter- 
action with the author to allow her to further refine the 
incomplete structure, that is, to further instantiate some 
of the uninstantiated leaves. To this purpose, it is use- 
ful to introduce along with the usual combinators (addr, 
f ra ,  cap, etc.) new combinators of arity 0 called type- 
names, which are notated type, and are of type type.  
These combiuators are allowed to stand as leaves (e.g. in 
the tree cap(country) )  and the trees thus obtained are 
said to be heterogeneous. The typenames are treated by 
the text generation process as if they were standard se- 
mantic units, that is, they are associated with text trails 
which arc generated "at their proper place" in the gen- 
erated output. These text units are specially phrased and 
highlighted to indicate to the author that some choice has 
to be made to reline the underlying type (e.g. obtaining 
248 
the text "la capimle de PAYS"). This choice has the efl'ect 
of further instantiating the incomplete tree with "true" 
combinators, and the gmmration process is iterated. 
Extended senmntics-driven eompositionality. The 
simple DCG view presented at the beginning of this sec- 
tion sees the process of generating text from an abstract 
structure as basically a compositional process on strings, 
that is, a process where strings are recursively associated 
with subtrees and concatenated to l~roduce strings at the 
next subtree level. But such a direct process of construct- 
ing strings Ires well-known limitations when the seman- 
tic and syntactic levels do not have such a direct corre- 
spondence (simple example: ordering a list of modifiers 
around a noun). We are currently experimenting with a 
powerful extension of string compositionality where the 
objects compositionally associated with abstract subtrees 
are not strings, but syntactic representations with rich in- 
ternal structure. The text itself is obtained fiom the syn- 
tactic representation associated with the total tree by Siln- 
ply enumerating its leaves. 
The picture we get of an IG grammar is tinally the 
following: 
aD,. . (al(B,C . . . .  ) ) -Syn  - -> 
bE,...(B)-SynB, 
CF,...(C)-SynC, 
{const ra in ts (B ,C , . . . ,D ,E ,F , . . . )} ,  
{compose_engl ish(SynB,  SynC, Syn)}.  
The rule shown is a rule for English: the syntactic 
representations are hmguage dependent; Parallel rules 
for tim other hmguages are obtained by replacing the 
compose eng l ' i sh  constraint (which is tmique to this 
rule) by constraints appropriate to the other hmguages 
under consideration. 
4 Conclusion 
XML-based authoring tools are more and more widely 
used in the business community for supporting the pro- 
duction of technical documentation, controlling their 
quality and improving their reusability. In this paper, 
we have stressed the connections between these practices 
and current research in natural anguage genenttion and 
authoring. We have described two related fornmlisms 
which are proposals for removing some of the limitations 
of XML DTD's when used for tim production of multi- 
lingual texts. 
From a compt, tational inguist's point of view, there 
might be little which seems novel or exciting in XML 
representations. Still XML has a great potential as a lin- 
gua.franca and in driving a large community of users 
towards authoring practices where content is becoming 
more and more explicit. There may be a great opportu- 
nity here for researchers in natural hmguage generation 
to connect o a growing sot, rce of applications. 
Acknowledgements 
Thanks for contributions, discussions and comments to 
Ken Beesley, Caroline Brtm, Jean-Pierre Chanod, Marie- 
Hdl8ne Corrdard, Pierre Isabelle, Bengt Nordstr6m, Syl- 
vain Pogodalla nd Annie Zaenen. 
References 
C. Brun, M. l)ymetman, and V. Lux. 2000. l)ocument 
structure and multilinguat authoring. In Proceedings of 
First h~telwatiomd Natural lzmguage Generation Confer- 
ence (INLG '2000), Mitzpe P, amon, Israel, June. 
J. Coch. 1996. Evahmting and comparing three text production 
tech,fiqucs. In Proceedhtgs ofthe 16th huernational Confe.r- 
ettce on Conqmtational Linguistics. 
1: l)eransart and J. Maluszynski. 1993. A Gramntatical View 
of Logic Programming. MIT Press. 
Thonms llallgren. 2000. Alfa Home Page. Awfilable fi'om 
http ://wm~. cs. chalmers, se/~hallgren/Alfa/ 
A. ltartley and C. Paris. 1997. Multilingual document produc- 
tion: fiom support for translating to support for authoring. 
In Machine Translation, Special Issue on New 7bols.for Htt- 
man 7)'anslators, pages 109-128. 
L. Magnusson and B. NordslrOm. 1994. The ALF proof editor 
and its proof engine. In Lecture Notes in Conqmler Science 
806. SpringeL 
P. Martin-L6f. 1984. hmdlionistic 7\]ype 7heoo,. Bibliopolis, 
Naples. 
W. Pardi. 1999. XML in Action. Microsoft Press. 
Femando C. N. Pereira and David II. D. Warren. 1980. Deft- 
nite clause grammars for language analysis. Artificial huel- 
ligence, 13:231-278. 
P,. Power and D. Scott. 1998. Multilingual authoring using 
feedback texts. In ProceedhTgs of the 17th h~ternational 
Confelwnce on Comlmtatiom~l linguistics and 36th Annual 
Meeting of the Association for Computational Lhlguislics, 
pages 1053-1059. 
P. Prescod. 1998. Fornmlizing SGMI, and XML In- 
stances and Schemata with Forest Automata Theory. 
http : //m~w. prescod, net/f orest/shorttut/. 
A. Ranta. 1994. 7~vpe-Theorelical Grammar. Oxford Univer- 
sity Press. 
Aarne Ranm. 2000. GF Work Page. Awfilablc fi'om 
h'c t;p://m,m, cs.  chalmers, se/~aarne/(IF/ 
pub/work- index/ 
W3C, 1998. Exlensible Marktq~ Language (XML) 1.0, Febru- 
ary. W3C recommendation. 
W3C, 1999a. XML Schema - l'art h Strltctttres, Part 2 : 
Datatypes -, l)ecembe,. W3C Working draft. 
W3C, 1999b. XSL Transformations (XSLT), Novcmbe,; W3C 
recommendation. 
249 
Document Structure and Multilingual Authoring 
Carol ine Brun Marc Dymetman Veronika Lux  
Xerox  Research  Cent re  Europe  
6 chemin  de Mauper tu i s  
38240 Mey lan ,  F rance  
{brun ,  dymetman,  lux}?xrce ,  xerox ,  com 
Abst rac t  
The use of XML-based authoring tools is swiftly be- 
coming a standard in the world of technical docu- 
mentation. An XML document is a mixture of struc- 
ture (the tags) and surface (text between the tags). 
The structure reflects the choices made by the au- 
thor during the top-down stepwise refinement of the 
document under control of a DTD grammar. These 
choices are typically choices of meaning which are 
independent of the language in which the document 
is rendered, and can be seen as a kind of interlin- 
gua for the class of documents which is modeled by 
the DTD. Based on this remark, we advocate a rad- 
icalization of XML authoring, where the semantic 
content of the document is accounted for exclusively 
in terms of choice structures, and where appropri- 
ate rendering/realization mechanisms are responsi- 
ble for producing the surface, possibly in several lan- 
guages imultaneously. In this view, XML authoring 
has strong connections to natural language genera- 
tion and text authoring. We describe the IG (In- 
teraction Grammar) formalism, an extension of DT- 
D's which permits powerful inguistic manipulations, 
and show its application to the production of multi- 
lingual versions of a certain class of pharmaceutical 
documents. 
1 In t roduct ion  
The world of technical documentation is forcefully 
moving towards the use of authoring tools based 
on the XML markup language (W3C, 1998; Pardi, 
1999). This language is based on grammatical spec- 
ifications, called DTD's, which are roughly similar 
to context-free grammars 1 with an arbitrary num- 
ber of non-terminals and exactly one predefined ter- 
minal called pcdata. The pcdata  terminal has a 
special status: it can dominate any character st, ring 
(subject to certain restrictions on the characters al- 
lowed). Authoring is seen as a. top-down interactive 
process of step-wise refinement of the root nonter- 
minal (corresponding to the whole document) where 
the author iteratively selects a rule for expanding a
lBut see (Wood, 1995: Prescod, 1998) for discussions of 
the differences. 
nonterminal already present in the tree and where 
in addition s/he can choose an arbitrary sequence 
of characters (roughly) for expanding tile pcdata  
node. The resulting document is a mixture of tree- 
like structure (the context-free derivation tree cor- 
responding to the author's selections), represented 
through tags, and of surface, represented as free-text 
(PCDATA) between the tags. 
We see however a tension between the structure 
and surface aspects of an XML document: 
? While structural choices are under system con- 
trol (they have to be compatible with the DTD), 
surface choices are not. 2 
? Surface strings are treated as unanalysable 
chunks for the styling mechanisms that render 
the XML document o the reader. They can 
be displayed in a given font or moved around, 
but they lack the internal structure that would 
permit to "re-purpose" them for different ren- 
dering situations, such as displaying on mobile 
telephone screens, wording differently for a spe- 
cific audience, or producing prosodically ade- 
quate phonetic output. This situation stands 
in contrast with the underlying philosophy of 
XML, which emphasizes the separation between 
content specification and the multiple situations 
in which this content can be exploited. 
. Structural decisions tend t,o be associated wit, h 
choices of meaning which are independent of the 
language in which the document is rendered. 
Thus for instance the DTD for an aircraft main- 
tenance manual might distinguish between two 
kinds of risks: caut ion  (material damage risk) 
and warning (risk to the operator). By select- 
ing one of these options (a choice that will lead 
t,o further-t_owerdevel choices,), the::author takes 
a decision of a semantic nature, which is quite 
independent of the language in which the docu- 
ment is to be rendered, and which could be ex- 
ploited to produce multilingual versions of the 
2With  the emergenceof  schemas (W3C, 1999a), which per- 
mit some typing of the surface (float, boolean, string, etc.), 
some degree of control is becoming more feasible. 
24 
document. By contrast, a PCDATA string is 
language-specific.and ill-suited for multilingual 
applications. 
These remarks point to a possible radical view of 
XML authoring that advocates that surface strings 
be altogether eliminated from the document content, 
and that author choices be all under the explicit con- 
trol of the DTD and reflected in the document struc- 
ture. Such a view, which is argued for in a related 
paper (Dymetman et el., 2000), emphasizes the link 
application of MDA to a certain domain of pharma- 
ceutical documents. 
2 Our approach to Multilingual 
Document Authoring 
Our Multilingual Document Authoring system has 
the following main features: 
First, the authoring process is monolingual, but 
the results are multilingual. At each point of the pro- 
cess the author can view in his/her own language the 
..... . . . . . . . . . . .  between ~ML`d~cumeqt~a~a9ring`~aad;mu~ti~nguaL;~,~.~te~t:~s/h~hasa~u~h~rex~:~.~aa~a~d~rea~?where~he ..: 
text authoring/generation (Power and Scott, 1998; text still needs refinement are highlighted. Menus 
Hartley and Paris, 1997; Coch, 1996): the choices for selecting a refinement are also presented to the 
made by the author are treated as a kind of in- author is his/her own language. Thus, the author is 
terlingua (specific to the class of documents being always overtly working in the language s/he nows, 
modelled), and it is the responsibility of appropri- but is implicitly building a language-independent 
ate "rendering" mechanisms to produce actual text representation of the document content. From this 
from these choices ill tile different languages 3 under representation, the system builds multilingual texts 
consideration, in any of several anguages simultaneously. This ap- 
For such a program, existing XML tools suffer proach characterizes our system as belonging to an 
however from serious limitations. First, DTD's are emerging paradigm of"natural anguage authoring" 
too  poor in expressive power (they are close to (Power and Scott, 1998; Hartley and Paris, 1997), 
context-free grammars) for expressing dependencies which is distinguished from natural anguage gener- 
between different parts of the document, an aspect ation by the fact that the semantic input is provided 
which becomes central as soon as the document interactively by a person rather than by a program 
micro-structure (its fine-grained semantic structure) accessing digital knowledge representations. 
starts to play a prominent role, as opposed to simply Second, the system maintains strong control both 
its macro-structure (its organization i  large seman- over the semantics and the realizations of the docu- 
tic units, typically larger than a paragraph). Second, ment. At the semantic level, dependencies between 
current rendering mechanisms such as CSS (Cascad- different parts of the representation f the document 
ing Style Sheets) or XSLT (XLS transformation lan- content can be imposed: for instance the choice of 
guage) (W3C, 1999b) are ill-adapted for handling a certain chemical at a certain point in a mainte- 
even simple linguistic phenomena such as morpho- nance manual may lead to an obligatory warning 
logical variation or subject-verb agreement, at another point in the manual. At the realization 
In order to overcome these limitations, we are level, which is not directly manipulated by the au- 
using a formalism, Interaction Grammars (IG), a thor, the system can impose terminological choices 
specialization of Definite Clause Grammars (Pereira (e.g. company-specific nomenclature for a given con- 
and Warren, 1980) which originates in A. Ranta's cept) or stylistic choices (such as choosing between 
Grammatical Framework (GF) (Ranta; M~enp~igt using the infinitive or the imperative mode in French 
and Ranta, 1999; Dynaetman et el., 2000), a gram- to express an instruction to an operator). 
matical formalism based on Martin-LSf's Type The- Finally, and possibly most distinctively, the st- 
ory (Martin-L6f, 1984) and building on previous ex- mantle representation underlying the authoring pro- 
perience with interactive mathematical proof editors cess is strongly document-centric and geared towards 
(Magnusson and Nordstr6m, 1994). In this formal- directly expressing the choices which uniquely char- 
ism, the carrier of meaning is a choice tree (called aeterize a given document in an homoge~cous class 
"abstract ree" in GF), a strongly typed object in of documents belonging to the same domain. Our 
which dependencies between substructures can be view is document-centric in the sense that it takes 
easily stated using the notion of dependent types, as its point of departure the widespread practice of 
The remainder of this paper is organized as fol- using XML tools for authoring the macro-structure 
lows. In section 2,,,we give a'~,high.teveloverview .of ..... of doeuments,-oand--extends this-practice towards an 
the Multilingual Document Authoring (MDA) sys- account of their m.icro-structure. But the analysis 
tern that we have developed at XRCE. In section of the micro-structure is only pushed as far as is 
3, we present in some detail the formalism of In- necessary in order to account for the variability in- 
teraction Grammars. In section 4. we describe an side the class of documents considered, and not in 
terms of the ultimate meaning constituents of lan- 3The word "language" should be understood here in an 
extended sense tha! not only covers English. French. etc., but guage. This  nlicro-structure can in general be de- 
also different styles or modes of communication, ler ln iued by s tudy ing  a corpus of  documents  and by 
25 
exposing the structure of choices that distinguish a 
given document from other documents in this class. 
This structure of choices is represented in a choice 
tree, which is viewed as the semantic representation 
for the document. 4 One single choice may be asso- 
ciated with text realizations of drastically different 
granularities: while in a pharmaceutical document 
the choice of an ingredient may result in the produc- 
tion of a single word, the choice of a "responsability- 
waiver" may result in a long stereotypical paragraph 
of text, the further analysis of which would be totally 
.counter-productive. 
3 In teract ion  Grammars  
Let us now give some details about the formalism 
of Interaction Grammars. We start by explaining 
the notion of choice tree on the basis of a simple 
context-free grammar, analogous to a DTD. 
Context - f ree  grammars  and  choice trees 
Let's consider the following context-free grammar 
for describing simple "addresses" in English such as 
"Paris, France": s 
address --> city, " , " ,  
country. 
country --> "France". 
country --> "Germany". 
city --> "Paris". 
city --> "Hamburg". 
city --> "the capital of", 
country. 
What does it mean, remembering the XML anal- 
ogy, to author a "document" with such a CFG? It 
means that the author is iteratively presented with 
partial derivation trees relative to the grammar (par- 
tial in the sense that leaves can be terminals or non- 
terminals), and at each given authoring step both 
selects a certain nonterminal to "refine", and also a 
given rule to extend this non-terminal one step fur- 
ther: this action is repeated until the derivation tree 
is complete. 
If one conventionally uses the identifier 
nonterminal~ to name the i-th rule expanding 
the nonterminal nontermina l ,  then the collection 
of choices made by the author during a session can 
be represented by a choice tree labelled with rule 
identifiers, also called combinators. An example 
of such a tree is address l (c i ty2 ,count ry2)  
4This kind of semantic representation stands i-n contrast 
to some representations commonly used in NLP, which tend 
to emphasize the fine-grained predicate-argument structure of 
sentences independently of the productivity of such analyses 
.\[or a given class of documents. 
5For compatibil ity with the notacionsCo follow, we use low- 
ercase to denote nonlerminals, aml quoted strings to denote 
terminals,  ra ther  than  tile inore usna\[  ul)pot'case lowercase 
convent  ions. 
which corresponds to choices leading to the output 
"Hamburg, Germany". 6 In.practice, rather than 
using combinator names which strictly adhere to 
this numbering scheme, we prefer to use mnemonic 
names directly relating to the meaning of the 
choices. In the sequel we will use the names adr;  
f ra ,  ger ,  par ,  ham, cap for the six rules in the 
example grammar. The choice tree just described is 
thus written adr (ham,ger ) .  
Mak ing  choice t rees  exp l ic i t  As we have ar- 
gued previously, choices trees are in our view the cen- . 
tral repositoi-y of documentc0ntent and we Want to 
manipulate them explicitely. Definite Clause Gram- 
mars represent possibly the simplest extension of 
context-free grammars permitting such manipula- 
tion. Our context-free grammar can be extended 
straightforwardly into the DCG: 7 
address (adr (Co ,C) )  - -> c i ty (C) ,  " , "  
country(Co) .  
count ry ( f ra )  - -> "France" .  
count ry (ger )  - -> "Germany". 
city(par) --> "Paris". 
city(ham) --> "Hamburg". 
city(cap(Co)) --> "the capital of", 
country(Co). 
What these rules do is simply to construct choice 
trees recursively. Thus, the first rule says that if the 
author has described a city through the choice tree 
C and a country through the choice tree Co, then the 
choice tree adr(Co,C) represents the description of 
an address. 
If now, in this DCG, we "forget" all the terminals, 
which are language-specific, by replacing them with 
the empty string, we obtain the following "abstract 
gram mar' l :  
address(adr(Co,C)) --> city(C), country(Co). 
country(fra) --> \[\]. 
country(ger) --> \[\]. 
city(par) --> \[\]. 
city(ham) --> \[\]. 
city(cap(Co)) --> country(Co). 
which is in fact equivalent o the definite clause 
program: s
SSuch a choice tree can be projected into a derivation 
tree in a straightforward way, by mapping a combinator 
nonterminali into the monterminal name nontermin,:.l, and 
by 'introducing terminal material as required by the specific 
rules. 
7According to the usual logic programming conventions, 
lowercase letters denote predicates and functors, whereas up- 
percase letters denote metavariables that can be instauciated 
with terms. 
Sin the sense that rewriting the nonterminal goal 
address  (adr (Co ,C)) to the empty string in the DCG is equiv- 
alent to proving the goal address(adr (Co ,C) )  in the program, 
26 
address (adr (Co ,C) )  : -  c i ty (C) ,  count ry (Co) .  
count ry  ( f  ra ) .  
count ry  (ger ) .  
c i ty (par ) .  
city(ham). 
city(cap(Co)) :- country(Co). 
This abstract  g rammar  (or, equivalently, this logic 
program),  is language independent and recursively 
defines a set of well-formed choice trees of different 
categories, or types. Thus, the tree adr (ham,ger )  
is .well-formed "in".. the. :typ~/add.~:r~s, ,End the .lice 
cap( f ra )  well-formed in the type c i ty .  
Dependent  Types  In order to stress the type- 
related aspects of the previous tree specifications, 
we are actual ly using in our current implementa-  
tion the following notat ion for the previous abstract  
grammar :  
adr (Co ,C) : :address  - ->  C : :c i ty ,  
Co : : count ry .  
f ra :  : count ry  - -> \[\] . 
ger :  : count ry  - -> \[\] . 
par :  : c i ty  --> \[3 . 
ham: :city --> \[\]. 
cap(Co) : :c i ty  --> Co::country. 
The first rule is then read: "if C is a tree of 
type c i ty ,  and Co a tree of type count ry ,  then 
adr (Co ,C)  is a tree of type address" ,  and simi lar ly 
for the remaining rules. 
The grammars  we have given so far are deficient 
in one important  respect: there is no dependency 
between the city and the country in the same ad- 
dress, so that  the tree adr (ham, f ra )  is well-formed 
in the type address .  In order to remedy this prob- 
lena, dependent types (Ranta; Martin-L6f, 1984)can 
be used. From our point  of view, a dependent ype 
is s imply a type that can be parametr ized by objects 
of other types. We write: 
adr (Co ,C) : :address  - ->  C : :c i ty (Co) ,  
Co: : count ry .  
f ra :  : count ry  - -> \[\] . 
get :  : count ry  - -> \[\] .
par : : c i ty ( f ra )  - ->  \ [ \ ] .  
ham: :c i ty (ger )  - ->  \ [ \ ] .  
cap(Co) : : c i ty (Co)  - ->  Co: :count ry .  
in which the type c i ty  is now parametr ized by 
objects of type count ry ,  and where the notat ion 
par  : : c i ty ( f ra )  is read as " 'par is  at ree of the type: 
city of f ra ' .  9 
which is another way of stating the well-known duality be- 
tween the rewriting and the goal-proving approaches to the 
interpretation f Prolog. 
9In terms of the underlying Prolog implementation. "::" is 
simply an infix operator for a predicate ofarity 2 which relates 
an object and its type, and both simple and dependent types 
are handled st raighforwardly. 
Para l le l  Grammars  and  Semant ics -dr iven  
? Compos i t iona l i ty . fo r  . ;Text . ;Rea l izat6 ion We 
have just  explained how abstract  grammars  can be 
used for specifying well-formed typed trees repre- 
senting the content of a document.  
In order to produce actual  mult i l ingual documents  
from such specifications, a s imple approach is to al- 
low for parallel real ization English, French . . . . .  gram- 
mars, which all have the same underlying abstract. 
g rammar  (program),  but which introduce terminals  
specific, to ~the_ language -at. hand. Thus. the (ollow- 
ing French andEng l i sh  gi-annmkrs a/'e pai~allel to the ' : "  
previous abstract  g rammar : l ?  
adr(Co,C) : :address --> C::city(Co), ",", 
Co: :country. 
fra: :country --> "France". 
ger : : country --> "Germany". 
par: :c i ty(fra)  --> "Paris". 
ham: : city(ger) --> "Hamburg". 
cap(Co): :c i ty(Co) --> "the capital of", 
Co : : country. 
adr(Co,C): :address --> C::city(Co), ",", 
Co : : country. 
fra: : country --> "In France". 
ger : : country --> "i' Al lemagne". 
par: : city(fra) --> "Paris". 
ham: : city (get) -- > "Hambourg". 
cap(Co): :city(Co) --> "In capitale de", 
Co: :country. 
This view of real ization is essentially the one we 
have adopted in the prototype at the t ime of writ- 
ing, with some straighforward addit ions permit t ing  
the handl ing of agreement constraints and morpho- 
logical variants. This s imple approach has proven 
quite adequate for the class of documents we have 
been interested in. 
However, such an approach sees the activity of 
generat ing text from an abstract  structure as ba- 
sically a composit ional  process on strings, that  is, 
a process where strings are recursively associated 
with subtrees and concatenated to produce strings 
at the next subtree level. But such a direct proce- 
dure has well-known l imitat ions when the seinantic 
and syntact ic levels do not have a direct correspon- 
dence (simple example: ordering a list of modifiers 
around a noun). We are currently experimenting 
with.a, powerful extension~of.stri.ng compqsihonal i ty  - 
where tim objects  composit ional ly  associated with 
abstract  subtrees are not strings, but syntactic rep- 
resentations with rich internal structure. The text 
10Because the order of goals in the right-hand side of an ab- 
stract grammar rule is irrelevant, he goals on the right-hand 
sides of rule in two parallel realization grammars can appear 
in a different order, which permits certain reorganizations of 
the linguistic material (situation ot shown in the example). 
27 
itself is obtained from the syntactic representation 
associated with the .total tree .by simply enumerat- 
ing its leaves. 
In this extended view, realization grammars have 
rules of the following form: 
a l (B ,C  . . . .  ) : :a (D  . . . .  ) -Syn  - ->  
B: :b(E  . . . .  ) -SynB,  
C : :c (F , . . . ) -SynC,  
general public. Le VIDAL ? includes a collection of 
notices ,for .around? 5 5.00. dmgs..a~ailable .in France. 
As the publisher, OVP-t~ditions du Vidal has taken 
care of homogeneity across the notices, reformatting 
and reformulating source information. The main 
source are the New Drug Authorizations (Autori- 
sation de Mise sur le March~), regulatory docu- 
ments written by pharmaceutical laboratories and 
approved by legal authorities. 
Relative to multilingual document authoring, this 
{const ra in ts  (B, C . . . . .  D, E, F . . . .  ) }, corpus has three features whicli,~e, considered highly 
? ' {compose=engt.ish(~synB ;~.SynC, " :-;-.Syn.)~}-~.--:-desi-r~ble:;(l)-it-dea\[s.with ,a.res\[rlcted-~em~:tit d~2 
The rule shown is a rule for English: the syn- 
tactic representations are language dependent; par- 
allel rules for the other languages are obtained by 
replacing the compose_engl ish constraint (which is 
unique to this rule) by constraints appropriate to the 
other languages under consideration. 
Heterogeneous  Trees and  In teract iv i ty  Natu- 
ral language authoring is different from natural lan- 
guage generation i one crucial respect. Whenever 
the abstract ree to be generated is incomplete (for 
instance the tree cap(Co)), that is, has some leaves 
which are yet uninstanciated variables, the genera- 
tion process hould not proceed with nondeterminis- 
tically enumerating texts for all the possible instan- 
elations of the initial incomplete structure. Instead 
it should display to the author as much of the text as 
it can in its present "knowledge state", and enter into 
an interaction with the author to allow her to fur- 
thor refine the incomplete structure, that is, to fur- 
ther instanciate some of the uninstanciated leaves. 
To this purpose, it is useful to introduce along with 
the usual combinators (adr, fra, cap, etc.) new 
combinators of arity 0 called typenames, which are 
notated type,  and are of type "type. These combi- 
nators are allowed to stand as leaves (e.g. in the tree 
cap(count ry ) )  and the trees thus obtained are said 
to be heterogeneous. The typenames are treated by 
the text generation process as if they were standard 
semantic units, that is, they are associated with text 
units which are generated "at their proper place" in 
the generated output. These text units are specially 
phrased and highlighted to indicate to the author 
that some choice has to be made to refine the un- 
derlying type (e.g. obtaining the text "la capitale de 
PAYS"). This choice has the effect of further instan- 
elating the incomplete tree with "true" combinators, 
main (for which various terminological resources are 
available), (2) it is a homogeneous collection of docu- 
ments all complying to the same division in sections 
and sub-sections, (3) there is a strong trend in in- 
ternational bodies such as the EEC towards making 
drug package notices (which are similar to VIDAL 
notices) available in multilingual versions strictly 
aligned on a common model. 11 
4.2 Corpus  analys is  
An analysis of a large collection of notices from Le 
VIDAL ? de la famille, describing different drugs, 
from different laboratories was conducted in order 
to identify: 
* the structure of a notice, 
? the semantic dependencies between elements in 
the structure. 
For this task, all the recta-information available is 
useful, in particular: explanations provided by Le 
VIDAL ? de la famille and help of a domain expert. 
Corpus study was a necessary preliminary task be- 
fore modeling the notices in the IG formalism pre- 
sented in section 2. 
4.2.1 S t ructure  
Notices from Le VIDAL ? are all built on the same 
model, including a title (the name of the drug, plus 
some general information about it). followed by sec- 
tions describing the main characteristics of the cirug: 
general description, composition, indications, con- 
traindications, warnings, drug interactions, preg- 
nancy and breast-feeding, dosage and administra- 
tion, possible side effects. This initial knowledge 
? about the semantic ontent of the document is cap- 
tured with a first., simple context free rule, such as: 
and the generation process is iterated. 
4 An  App l i ca t ion  to  Pharmaceut ica l  
Documents  
4.1 Corpus  select ion 
Our corpus consists in drug notices extracted froln 
"'Le VIDAL?de la Famille" (Editions du Vidal. 
1998). a practical book about heahh made for the 
........ vidalNot.ice(T,D,C, I ,CI.~W,DI ~ PaBF,D~i-A,PSI) : :notice 
- ->  
T: :title, 
D: :description, 
C: :composition, 
I lA  similar but less extended corpus was previously built 
by the third author as the basis for a prototype ofmuhilingual 
ctocument authoring using G F. 
28 
I : : ind icat ions ,  
Cl::contraindications, 
W::warn ings ,  
D I : :d rugs In teract ion ,  
PaBF: :p regnancyAndBreastFeed ing ,  
DaA::dosageAndAdmin, 
PSI::possibleSideEffects. 
Each section is associated with context-bee rules 
that describe its internal structure: 
'vidalTitle(N,APi . . . ,  .~;>)~:-.:~d?1e-=:n ....... 
- ->  
N::name0fDrug, 
AP::activePrinciples . . . . .  
vidalDescription(N,PF,P...)::description 
- ->  
\['DESCRIPTION'\], 
N::nameOfDrug, 
PF::pharmaceutForm, 
P::package . . . . .  
vidalDosageAndAdmin(D,A)::dosageAndAdmin 
- ->  
\['DOSAGE AND ADMINISTRATION'\], 
D::dosage, 
A::administration. 
tablet::pharmaceutForm --> \['tablet'\]. 
eyeDrops:::pharmaceutForm --> \['eye drops'\]. 
At this point, we allow parallel realizations for 
French and English. So, in addition to the English 
grammar given above, we have the French grammar: 
vidalTitle(N, AP . . . . . . . .  )::title 
- ->  
N::name0fDrug, 
AP::activePrinciples, ... . 
vidalDescr(N,PF,P...)::description 
- ->  
\['PRESENTATION'\], 
N::nameOfDrug, 
PF::pharmaceutForm, 
P::package . . . . .  
vidalDosageAndAdmin(D,A)::dosageAndAdmin 
- ->  
\['MODE D'EMPLOI ET POSOLOGIE'\], 
D::dosage, 
A::administration. 
tab le t : :pharmaceutForm - -> \ [ ' compr im~' \ ] .  
eyeDrops : : :pharmaceutForm --> \ [ ' co l l y re ' \ ] .  
This first grammar is fully eq.ivalent o a XML 
I)TD that describes the structure of a notice, though 
it distinguishes finer-grained units 1hart traditional 
l)TI)s tends to do. 
4.2.2 Modeling dependencies 
, ,~ButHG :~ goes ?urt, her,:than XM-L DTDs ~it~h'regard 
to the semantic ontrol of documents: it enables us 
to express dependencies which may arise in differ- 
ent parts of a document, including tong-distance de- 
pendencies, through the use of dependent types pre: " 
sented in section 2. 
Identification of the dependencies to be modeled was 
done in a second stage of the corpus study. For ex- 
ample, we identified dependencies between: 
, ........ ,:.-.: ~-~ "the:--ghamaaeoa~tieal ,:forrrr;0t~ a :gi,#ed~dtfug :(.cbn:.- 
cept pharmaceutForm) and its packaging (con- 
cept package), 
? particular ingredients given in the section com- 
position and warning instructions given ill the 
section warnings, 
? categories of patients the drug is intended for in 
the section description and posology indicated 
for each category in the section indications. 
To illustrate the modeling task, we now give more 
details about one particular dependency identified. 
Intuitively, it appears that there is a strong link be- 
tween the pharmaceutical form of a given drug and 
the way it should be administered: tablets are swal- 
lowed, eye drops are put in the eyes, powder is di- 
luted in water etc. In our first grammar, the phar- 
maceutical form concept appears in the description 
section, since the administration way is described in 
the dosage and administration section. The use of 
dependent ypes permits to link these sections to- 
gether according to the pharmaceutical form. Tile 
parts of the (English) grammar involved become: 
vidalNotice(T,D,C,I,CI,W,DI,PaBF,DaA,PSI)::notice 
- ->  
T::title, 
D::description(PF), 
C::composition, 
I::indications, 
CI::contraindications, 
W::warnings, 
DI::drugslnteraction, 
PaBF::pregnancyAndBreastFeeding, 
DaA::dosageAndAdmin(PF), 
PSI::possibleSideEffects. 
vidalDescription(N,PF,P,...)::description(PF) 
- ->  
\['D~SCRIPTION'\], " ? 
N::nameOfDrug, 
PF::pharmaceutForm, 
P::package . . . . .  
vidalDosageAndAdmin(D,A)::dosageAndAdmin(PF) 
- ->  
\['DOSAGE AND ADMINISTRATION'\], 
D::dosage, 
29 
A : : administration (PF). 
The administration section should now be de-- .... 
scribed according to the pharmaceutical form it pre- 
supposes, several administration ways being compat- 
ible with each form: 
t ab le tsAdmin l  : : administrat  ion (Tablet) 
?O~I'~?-INDICAT%(~mS: ce ~id l?~ent  rm do|t  p~s ~tre ut~l~sb dlns les C~S sutvancs: 
----> a l le r~ le  au~ /~1SS nocu~ent t 'aset r lne  i 
\ [ 'Swal low the tab le ts  w i thout  "- l 
crunch ing  them. '\] . ar~n~: 
"'... -" . . . . .  _ . ~w=' ~ ' : "  : ~ ' , ' ~ . ~ ' % ' - ~ ~  -.-" . . . . . . . . . .  
? \[KTERACTZORS HI~DICAHENTEIJSES: Ce |~atc~ent  aeut tn ter lq t r  avec a'autres ~ed~ca~ents. tablet  sAdmin2 : :administrat ion (Tablet) ~,o~ .... ~ - ~-,~,. ,, .... t,,~ ,nt ,~n..,~to ,.~ .... t.,.,~ ,,~ 
augmentation des effets ~a~Is~r~bles. - le l t th tu~:  ~9uentat lon ~u taux de Hth iu |  
__> dam le sanq. 
\[ 'Let the tab le ts  mel t  under  c.oss~ss( ?TT AttAI~M~,T: 
the tongue. '\] . 
eyeDropsAdmin : :admin is t ra t ion(EyeDrops)  
- ->  
\ [~Pul l  the lower  eye l id  down wh i le  
look ing  up and squeeze  the eye drops,  
so that they fa l l  between the eye l id  
and the eyeba l l . ' \ ] .  
emacs: "prolo@ ? : 
I 
llOaOF?1t IbuDrofane 
P'R~\[NTATION: RUROFEN : ?ot~r|m~ C blanc ) : bQIte de Z? - ~ah &~ - 15.s F - 
? t@orat01 res Boots Healt.care 
?o,tposrrzoq: p cD 
Ibugrofene . . . . . . . . . . . . . .  20fl ig 
INDICATIONS: Ce |~d lcuent  est u,  gnc l - |n f lu la tO l?o  non stero~cHen {PISS). I \ ]  osc 
u t | l i s6  e, cas de aouIeurs diverses. 
.~OOE D'EHPtOI ET POSOLOCZE: i \ [~ l l l l l lm l lmlml  ~ . P~ologta 
Usuel t e: : ~ ?o.pr i mes . . . ,~ ;441 . i~   g/l 
The consequence of such a modeling is a better 
control of the semantic ontent of the document in 
the process of being authored: once the user chooses 
tablet as pharmaceutical form in the section descrip- 
tion, his choice is restricted between the two con- 
cepts tabletsAdminl and tabletsAdmin~ in the ad- 
ministration section. If he chooses eye drops as the 
pharmaceutical form, there is no choice left if the ad- 
ministration section: the text fragment correspond- 
ing to the concept eyeDropsAdmin will be generated 
automatically in the document. 
This example illustrates how dependencies are 
propagated into the macro-structure, but they can 
be propagated into the micro-structure as well: for 
example, in the description section, we can express 
that the packaging of the drugs is also dependent of 
their form: tablets are packaged in boxes, eye drops 
in flasks, powder in packets, etc.: 
v ida lDescr ip t ion(N ,P  . . . .  ) : :descr ipt ion(PF)  
- ->  
\ [ 'DESCRIPTIDN' \ ] ,  
N : :name0fDrug,  
PF : :pharmaceutForm,  
P : :package(PF)  . . . . .  
box:  :package(Tab le t )  . - ->  \ [ 'Box ' \ ] .  
f l ask : :package(EyeDrops)  - ->  \ [ ' F lask ' \ ] .  
This example shows that tile granularity degree of 
the linguistic realization cat\] vary from full text seg- 
ment (administration ways) to sing\[e words (forms 
like tablet, eye drops, powder, etc.). This is highly 
related to the reusability of the concept: references 
to specific forrns may appear it\] many parts of the 
Figure 1: A stage in the authoring of a notice, with 
French text shown. 
document, while the administration ways are more 
or less frozen segments. 12
The level of generality of dependencies encoded in 
the grammar needs to be paid attention to: one has 
to be sure that a given dependency is viable over a 
large collection of documents in the domain. If a 
choice made by the grammar writer is too specific, 
the risk is that it may be not relevant for other docu- 
ments. For this reason, an accurate knowledge of the 
corpus is necessary to ensure an adequate coverage 
of documents in the domain. 
4.3 An  Example  
Screen copies of the IG interface during an authoring 
process of a VIDAL notice are given on figures 1 and 
2. Figure 1 represents the notice authored in French 
at a given stage. The fields still to be refined by 
tile user appear ill dark. When the author wants to 
refine a given field, a pulldown menu presenting tile 
choices for this field appears on the screen. Here, the 
author chooses to refine the field avaler in the admin- 
istration (mode d'emploi et posologie ) section: the 
corresponding menu.proposes the list of.administra- 
tion ways corresponding to the pharmaceutical form 
tablet he has chosen before. Figure 2 shows the par- 
allel notice in English but one step further, i.e. once 
he has selected the administration way. 
12 For a discussion of some of the issues regarding the use of 
templates in nature\[ language generation systems, see (\[-leit er, 
1995). 
30 
I . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . .  ~ : ? - . . . .  aaa- . ;~o~}=:  . . . . . . . . . . . . . . . . . . .  . . 7~.  7 -~ i.. 
RUnOFE# I bupro fen  
OESERIPT|ON: HUROfEH : tab let  ( vh i te  ) ; box of 20 - G~ Rezab - X5.8 F - . Boots 
Real thcare Laborator ies 
?~?SFr IOH:  0 tb  
~buDrot en . . . . . . . . . . . . . .  200  i~ 
INDICATZC~S: This dru9 Is a ,on -~tero ld / I  anct - ln f lu la tc ry  (NSAIPS). I t  IS used to 
treat various pal~s 
COliTRA.\[KOIC&Tl~44S: This drug should not be used in  the fo l low ing  cases: a l l~rt ly  to 
NSAtOS l in  par t i cu la r  t~_~p_trtn i 
WA~I~INCS: . . . . . .  . ? 
~RU? I~TER~'I'ZONS: This clru9 can In teract  ~ l tb  other  drugs. In  ~art~cular:  - asp l r , ,  
aria the other non s tero ida l  ~t~- tn f l~ la tory  drugs: ~ncrea.se of side ef fec ts .  - 
Lithium: ~?reas l  of blood hth~ul  rate.  
I 
PRECNN(CV MD 8REAST-rE?DINC: 
VeDm~ 
DOSAGE AnD .~DMINISTRATI(~4: ~ tab le t  swallowed v i th  a lass of 
aye .  ~ . 
t 
PC~SIeLE SlO? EFFECTS: 
Figure 2: The parallel English notice one authoring 
step later. 
5 Conc lus ion  
XML-based authoring tools are more and more 
widely used in the business community for sup- 
porting the production of technical documentation, 
controlling their quality and improving their re- 
usability. In this paper, we have stressed the connec- 
tions between these practices and current research in 
natural anguage generation and authoring. We have 
described a formalism which removes ome of the 
limitations of DTD's when used for the production 
of multilingual texts and presented its application to 
a certain domain of pharmaceutical documents. 
Acknowledgements  Thanks to Jean-Pierre 
Chanod, Marie-H~_lb.ne Corr/mrd, Sylvain Pogodalla 
and Aarne Ranta for important contributions, 
discussions and comments. 
References  
a. Coch. 1996. Evaluating and comparing three text 
production techniques. In Proceedings of the 16th 
International Confe~vnce on Computational kin- 
guistics. 
OVP l~ditions du Vidal, editor. 1998. Le VIDAL de 
la famille. HACHETTE. 
M. Dymetman. V. Lux, and A. Ranta. 2000. XML 
and multilingual document authoring: Conver- 
gent trends. In Pro,'eedings Coling 2000, Saar- 
brficken. 
A. Hartley and ('. Paris. 1997. Muhilingual docu- 
ment production-: from supporl for translating to 
support for authoring. In Machine Translation, 
Special Issue. on New Tools for Huma n TranslaT,.. 
tots, pages 109-128. 
L. Magnusson and B. Nordstr6m. 1994. The ALF 
proofeditor and its proof engine. In Lecture Notes 
in Computer Science 806: Springer. 
P. Martin-L6f. 1984. Intuitionistic Type Theory. 
Bibliopolis, Naples. 
P. M/ienp/ii and A. Ranta. 1999. The type theory 
and type checker of GF. In Colloquium on Prin- 
ziples, .Logics, ..and Implementations .ofHigh-Level 
Progrdmm.ihg L~inTJages, Worl~shop: On-Logical 
Frameworks and Meta-languages, Paris, Septem- 
ber. Available at h t tp  : / /www. cs .  chalmers, se /  
~aarne/papers/Ifm 1999. ps. gz. 
W. Pardi. 1999. XML in Action. Microsoft Press. 
Fernando C. N. Pereira and David H. D. Warren. 
1980. Definite clause grammars for language anal- 
ysis. Artificial Intelligence, 13:231-278. 
R. Power and D. Scott. 1998. Multilingual au- 
thoring using feedback texts. In Proceedings of 
the 17th International Conference on Computa- 
tional Linguistics and 36th Annual Meeting of the 
Association for Computational Linguistics, pages 
1053-1059. 
P. Prescod. 1998. Formalizing SGML 
and XML instances and schemata 
with forest automata theory. 
http ://www. prescod, net/forest/shorttut/. 
A. Ranta. Grammatical Framework work 
page. h t tp  ://www. cs .  chalmers, se /  
aarne/GF/pub/work -  index/ index,  html. 
E. Reiter. 1995. NLG vs. templates. In Proceedings 
of the 5th European Workshop on Natural Lan- 
guage Generation (EWNLG '95), pages 95-106, 
Leiden. 
W3C, 1998. Extensible Markup Language (XML) 
1.0, February. W3C reconunendation. 
W3C, 1999a. XML Schema - Part 1: Structu~vs, 
Part 2 : Datatypes -, December. W3C Working 
draft. 
W3C, 1999b. XSL Transformations (XSLT), 
November. W3C recommendation. 
D. Wood. 1995. Standard Generalized Markup Lan- 
guage: Mathematical and philosophical issues. 
Lecture Notes in Computer Science. 1000:344-- 
365. 
31 
Generat ing a Controlled Language 
Laurence Danlos Guy Lapalme 
Universitd Paris 7 Ddpartement  d' informatique t RO 
TALANA UFR Linguist ique Universitd de Montrdal 
Case 7003-2, Place Jussieu C.P. 6128, Succ Centre-Vil le 
75251 Paris;' France- " Montreal ;  QuEbec, CCana~dai::~3C 337 
danlos?linguist, jussieu, fr lapalme@iro, umontreal, ca 
Veron ika  Lux  * 
Xerox Research Centre Europe 
6, chemin de Maupertu is  
38240 Meylan, France 
Veron ika .  Lux@xrce. xerox ,  com 
Abst rac t  
This paper argues for looking at Controlled Lan- 
guages (CL) from a Natural Language Genera- 
tion (NLG) perspective. We show that CLs are 
used in a normative nvironment in which dif- 
ferent textual modules can be identified, each 
having its own set of rules constraining the text. 
These rules can be used as a basis for natural 
language generation. These ideas were tested in 
a proof of concept generator for the domain of 
aircraft maintenance manuals. 
1 What  is a Cont ro l led  Language? 
Controlled Languages (CLs) result from a grow- 
ing concern about technical documentation 
quality and translation, be it human or auto- 
matic. A CL consists of a glossary and of writ- 
ing rules for the linguistic aspect of the doc- 
umentation. These rules are given as recom- 
mendations or prohibitions for both the lexicon 
and the grammar. Currently, most CLs are 
varieties of "controlled English" which derive 
froth the Caterpillar Tractor Company Funda- 
veloped for CL users, the best known being con- 
formity checkers/controllers such as AlethCL or 
SECC (CLA, 1996). 
A writer expects that the checking tool should 
not only detect errors but also propose a CL 
conformable xpression. A. Nasr (Nasr, 1996), 
who worked on the problem of CL refornmla- 
tion, underlines the difficulties of this task. Re- 
formulation cannot make any hypotheses about 
the conformity of the input sentences, and 
therefore must deal with a wider variety of 
lexico-syntactical constructions than those al- 
lowed in a CL. Some instances of noncompliance 
are relatively easy to detect but much more dif- 
ficult to correct: for example, sentences that are 
longer than the prescribed number of words. 
So there is little hope that human writers will 
ever produce documentation complying strictly 
with a CL even with the help of a conformity 
checker. We argue that it may be more promis- 
ing to use NLG technology for generating doc- 
.umentation in. CL instead of analyzing it af- 
terwards, as it is the case with a conformity 
checker. Few researchers have looked at CLs 
mental English tha t vi~..elab0rated.in the S~: ...... from-:a~-~generation p int  of view.. (Nasr, 1996; 
ties (Scheursand Adriaens, 1992). However CLs Hartley and Paris, 1996); but we think that 
are presently being defined for German, Swedish 
and French. 
Technical writers find it difficult to comply 
with the writing rules of a CL which are often 
hard to justify (CLA. 1996). For them, a CL is 
seen as an additional constraint on an already 
complex task. This is why tools have been de- 
" Work done while at the Adrospatiale Research Center 
there are very compelling reasons for taking a 
generation perspective, in addition to the ad- 
vantages of NLG for CLs that will be presented 
in section 3: 
* As CLs can be viewed as linguistic specifi- 
cations for human beings, it seems natural 
"to, .consider them 'a:s specifica'tkms for the 
linguistic component of an NLG system. 
141 
e CL writing specifications come on top of 
other writing norms which deal with docu- 
ment structuring. For example, in the aero- 
nautical industry, CLs such Simplified En- 
glish (SE) (AEC, 1995) and Fran~ais Ra- 
tionalisd (FR) (GIFAS, 1996) extend the 
ATA 100 norms (Bur, 1995) which describe 
the divisionof the document into chapl:ers, 
sections, subsections, etc. reflecting a tree- 
structured functional organization of the 
airplane: a chapter corresponds to a sys- 
tem (e.g. main rotor), a section to a sub- 
system (e.g. gear box), a subsection to a 
sub-sub-system (e.g. set of gears), and so 
on. Over this thematic structure is added a 
communicative structure to fulfill two main 
goals: describe all systems of the airplane 
and prescribe all maintenance instructions 
for the airplane. The norms of the ATA 
can be viewed as specifications for the text 
structuring component of an NLG system. 
? The thematic and communicative structur- 
ing of the document must also conform 
to a systematic non-linear page number- 
ing system and strict formatting rules us- 
ing SGML tags. These constraints can be 
viewed as specifications for the layout com- 
ponent of an NLG system. 
So we claim that CLs should not be con- 
sidered outside the context of the production 
of complex structured ocuments, which natu- 
rally raises the question of the automatic gen- 
eration of this documentation given some for- 
real representation. This claim led V. Lux (Lux, 
1998) to redefine the notion of a CL. Her study 
has shown that only a few syntactic constraints 
(e.g. coordination constraints) are applicable to 
the whole document. Most constraints are only 
valid for sub-parts of the document, identified 
as "textual modules". Each textual module has 
a particular communicative goal  and a precise 
theme according to the ATA 100 norms. It can 
be divided into smaller modules: for example, 
the Task module is divided into simpler Sub- 
Task modules which are themselves composed 
of simpler Instructions modules. From a lin- 
guistic point of view, a textual module uses only 
a controlled sublanguage. V. Lux thus extended 
FR to a new CL .called.:RREM (.Fr.aa~gais Ra- 
tionalise'. Etendu Modulaire) comprising many 
CLs, each having its own syntactic rules for 
a specific textual module. She also performed 
a corpus study showing that the same textual 
modules could be identified for both French and 
English. It should thus be possible to remodu- 
larize SE similarly to what has been done to 
FR with FREM. In this paper, we therefore 
in t roduce  the: not ion of aii Extei ided Modular 
Controlled Language (EMCL) which first de- 
fines some general rules and then some more 
specific ones for each textual module. We now 
look at the problem of automatical ly generat- 
ing technical documentation complying both to 
structuration orms such as ATA 100 and to the 
rules of an EMCL. 
2 How to  generate  techn ica l  
documentat ion?  
We assume that a generation system can be di- 
vided into a What to say and How to say it 
components, even though this may be consid- 
ered as a gross simplification. 
2.1 What  to say component  
The main difficulty for NLG in a real environ- 
ment lies in knowledge modeling. For aircraft 
maintenance manuals, existing ontologies could 
probably be reused, but even then the model- 
ing efforts required are huge. Nevertheless, we 
assume that it is possible to design forms which 
are sequentially presented to the user to be 
filled, as in Drafter (Paris et al, 1995), through 
which the technical writer provides the infor- 
mation to convey in an appropriate fornlalism. 
These forms can be derived directly fi'om the 
tree-like structure of the document given in the 
ATA norms. The goal is that, once the writer 
has finished filling in these forms, the technical 
docunmntation is already properly structured in 
an abstract language instead of a natural one. 
In a general text generation setting, using forms 
to describe What is to be said might seem like 
a difficult task; but in the context of techni- 
cal writing, the informational content is almost 
already prescribed and forms are thus a sin> 
ple way of complying with the rules of a CL. 
Indeed in the now comlnon web enviromnents, 
forms are frequently used for eliciting informa- 
tion from users. This input can then be pro- 
cessed by the "tIow to say it and layout compo- 
nents. 
142 
The writers who find it very difficult to com- 
ply with the rules of a CL have no problem 
complying with the ATA 100 norms, thereby 
producing documents with the right thematic 
and communicative structuration. This can be 
seen as an illustration of observations made in - 
However, many writing rules in a CL place 
particular syntactic constraints on the use of, 
a given lexical item, e.g. in FR a rule forbids 
the use of emp~cher (prevent) when followed by 
an infinitive clause. To handle such numerous 
lexically dependent syntactic rules, a formal- 
psycholinguistics. 
describes a model of the speaker's activity in 
which choices in the What to say component 
are conscious, while choices in the How to say it 
component are automatic. This model helps un- 
derstand some of the difficulties that CL users 
face. A CL forces the writer to become con- 
scious of behavioral mechanisms that are usu- 
ally automatic; The writer is thus distracted 
from choices made earlier in her/his writing 
task. So s/he often ends up writing it in the  
way  it has  to be written but does not write ex- 
actly what  had to be written, thus defeating 
the whole purpose of a CL which was meant to 
produce a better expression of the information. 
This model also explains why a human writer 
has less difficulties following the ATA norms: 
this part of the job corresponds to conscious 
choices. In the NLG scenario, this is replaced 
by filling in some information in the forms that 
are presented. 
To sum up, the What to say component re- 
quires a modelization of the domain model and 
the design of a series of forms to be filled. A 
human writer using the NLG system has to fill 
forms but on the other hand, s/he does not have 
to learn a CL, since compliance with the CL 
norms is taken care by the How to say it com- 
ponent which we now describe. 
2.2 How to say it component  
In this section, it is assumed that if a CL is 
in fact an EMCL such as FREM, a specific How 
to say it component is designed for each textual 
module, but always retaining the same formal- 
ism. 
The lexicon used in the How to s~zyit corn- . . . .  
ponent should be exactly the one enforced by 
the CL. Similarly, the syntactic constructions 
and the discourse structures of this component 
should correspond to the set of allowed con- 
structions / structures in the CL. This can sim- 
plify some lexical, syntactic and even discourse 
choices to be made within the generation sys- 
tern and thus ensure that .the gener~ed text 
complies with the rules of the CL. 
Levelt (Levelt , 1989, p. 9): ism based on a lexicalized grammax:is needed. 
We chose Lexicalized Tree Adjoining Grammar 
(LTAG) for the following reasons: 
* A text generation formalism inspired from 
LTAG, called G-TAG, has been designed, 
implemented and used in several applica- 
tions (Danlos and Meunier, 1996; Meunier, 
1997; Danlos, 1998; Meunier and Danlos, 
1998; Danlos, 2000). G-TAG takes as in- 
put an event graph which can be provided 
by the user  by filling in some forms which 
ensure that all the necessary information 
for generation is provided. 
o G-TAG deals with textual phenomena such 
as sentence connectors by extending LTAG 
to handle discourse comprised of more than 
one sentence. One of the major innovations 
of FREM compared to FR (and of EMCL 
compared to CL) is to implement rules for 
connecting sentences (clauses). The way to 
connect sentences has largely been ignored 
in CLs, although this linguistic issue raises 
ambiguities which can lead to maintenance 
errors. For example, simple juxtaposition 
of sentences i allowed in FR but disallowed 
in FREM because it is highly dangerous. A 
technician reading Nettoyer X.  Verser Y 
sur X.  (Clean X. Pour Y on X.) could in- 
terpret this to mean either "Clean X with 
Y" or "Clean X with Z, and next pour 
Y on X". Only one of these operations is 
right, the other one may lead to a mainte- 
nance error. On the other hand, traditional 
syntactical ambiguities uch as a preposi- 
.... tional attaehment...will-.not, usually lead to 
maintenance rrors because the technician 
can usually solve them on the basis of some 
domain knowledge. 
o The lexicalized grammar in G-TAG is com- 
piled from the recta-grammar designed and 
implemented by M.H. Candito (Candito. 
1996). This makes it easy to follow the 
evolution ofru les  of an (EM)CL. For ex- 
ample, if the rule to write an Instruction 
143 
changes from "Put a verb in the infini- 
tive" to "Insert an imperative", then this 
must be changed everywhere in the lexi- 
calized grammar. Using the metagrammar 
we can achieve this quite easily because of 
the hierarchical organization of a LTAG: 
with only one rule, an imperative can be 
allowed and an-infinitive ~disallowed ( in a 
main clause) for every verb, whatever its 
argument structure and syntactic onstruc- 
tion. 
G-TAG thus seems a good candidate for pro- 
ducing technical documentation complying with 
the constraints of an (EM)CL. A technical doc- 
umentation generator prototype in the aeronau- 
tical domain is described in Section 4. It is writ- 
ten in Flaubert, an implementation f G-TAG 
(Danlos and Meunier, 1996). The How to say 
it component would have to be completed by 
adding a layout component complying with the 
norms of ATA 100. We should also provide re- 
vision tools to allow the writer to fine tune the 
final text. 
So, automatically generating technical docu- 
mentation seems technically possible provided 
the technical writer is willing to fill forms which 
in principle should be less demanding than 
learning the rules of an (EM)CL. This approach 
also has other advantages, described in the next 
section. 
3 Advantages  o f  automat ic  
generat ion  o f  techn ica l  
documentat ion  
3.1 Mult i l ingual i ty  
One of tile major assets of NLG is its capacity 
to simultaneously generate texts in several lan- 
guages, and to regenerate updates as often as 
necessary, using a single input representation, 
thus ensuring coherence among the generated 
texts. 
Until now, CLs-have .dealt-withr muttitingual- 
ity by means of the translation hypothesis. It 
is for this reason that FR was developed by 
adapting SE, in order to ease the translation 
from French to English. FR authors try to en- 
sure that everything that can also be written 
in FR can be translated into SE. From this 
point of view, the definition of a source CLt, 
depends on the. defini.tion:.of, a tin:get CL2. De- 
velopers of CL1 are more likely to select struc- 
tures which can be easily or even literally trans- 
lated into CL2. What then happens if CLt and 
CL2 are structurally different? This can lead 
to a situation where CL1 imposes a cumber- 
some writing style that contravene conventions 
shared by native speakers of Li, thereby con- 
tradicting CLs' aim of enhancing understand- 
ability. Rules 0f-aii (EM)CL should be elabo- 
rated without such multilingual considerations. 
Their definition should principally pay atten- 
tion to the characteristics of one language, try- 
ing to avoid typical ambiguities. Such criteria 
are difficult enough to deal within a single lan- 
guage without taking translation problems into 
account. 
Now if we consider multilingual generation i
(EM)CLs, we find that there are major benefits 
from the multilingualism odeling proposed by 
NLG. In particular, defining a common repre- 
sentation is possible since the structure of the 
documentation is language independent. Recall 
from section 1 that the thematic structure of the 
documentation in the aeronautical domain must 
reflect the functional decomposition of the air- 
plane and that the same textual modules can be 
identified in many languages. Thus nothing has 
to be changed in the What to say component 
(Section 2.1) going from one language to the 
other. Only the How to say it component (Sec- 
tion 2.2) need be adapted to the target (EM)CL 
which should be monolingually defined. 
3.2 NLCI as an aid for test ing and 
developing a CL 
An NLG system can provide concrete assistance 
for the testing and for tile development of a CL. 
An NLG system that integrates the CL con- 
straints can help discover contradictions in the 
CL definition. As an illustration, a major dif- 
ficulty in CL definition concerns the coherence 
between the lexicon and the writing rules, as il- 
lustrated by (Emorine, 1994) with the following 
example: 
o Emp~cher l'oxyg~ne de s'accumuler (Pre- 
vent the oxygen from accumulating) does 
not conform to a FR lexically depen- 
dent syntactic rule, according to which 
empdcher (prevent) should not be followed 
by an infinitive clause. 
....... ~ .~ Emp~cher I ~uccumulation ' d.'~ozyg~ne ? (Pre- 
vent oxygen accumulat ion) does not con- 
144 
agent object 
U0 O5 
Titled sub-task 
title :Sub-Task  
DISPOSER 
lst-inst 
I 
Precond-Inst 
lst-order pre-cond 
I I 
DISPOSER ENLEVER 
agent object agent object 
I I I I 
Uo 04 Uo Ingo 
2nd-inst 
I 
Simul-Inst 
lst-order 2nd-order 
I I 
EXTRAIRE DEPOSER 
agent object agent object 
I I I I 
U0 O2 u0 Oa 
3rd-inst 
I 
Inst 
I 
lst-order 
I 
DEPOSER 
agent object tool 
I I I 
u0 o5 To 
Figure 1: Event graph given as input to Flaubert. In the prototype, this information is entered in 
textual form. 
form to FR lexicon, according to which the 
verb s'accumuler (accumulate) should be 
used instead of the noun accumulation (ac- 
cumulation) 
Emp~cher que l'oxyg~ne ne s'accumule 
(Prevent that the oxygen accumulates) 
does not conform to the writing rule that 
forbids the use of the subjunctive mode. 
So we come to a dead end if we want to use the " 
verb empdcher (prevent). This problem can be 
detected automatically by the NLG system.and 
an appropriate fix be made in the grammar. 
NLG can be used for checking a CL, which 
is helpful even if the CL is intended for a hu- 
man writer because it may avoid the discovery 
of various cases of incoherence by the writer. If 
tile writers can justify their writing difficulties 
by pointing out inconsistencies in the CL defini- 
tion, they won't be motivated to use what they 
will tend to consider'as an~-abmird invention, by .... 
people who understand nothing about the .job. 
NLG can also help strengthen CLs' claim to 
lead to more homogeneous texts, which is equiv- 
alent to forbidding certain paraphrases. NLG 
precisely deals with paraphrase as, for some in- 
puts, a NLG system will produce several texts. 
In this way, NLG helps identify which para- 
phrases till remain possible in the CL. In prac- 
tice, when an NLG system proposes several 
texts for one input, it raises the question for 
the CL developer: Should a constraint be added 
to the CL definition in order to forbid some of 
these texts ? 
4 P roo f  o f  concept  generator  
The previous ections have argued for the inter- 
est of dealing with CL from all NLG perspec- 
tive which to our knowledge had never been ex- 
amined ill such details. To further pursue, V. 
Lux (Lux, 1998) has developed a proof of con- 
cept generator using Flaubert (Meunier, 1997; 
Meunier-and "Danlos., :1998)" ~o"gee ? ?howthese "
theoretical concerns could be applied in prac- 
145 
Sous-t~che 60-007 
3.1 DEpose du segment d'arr~t (5) 
- Apr~s avoir enlev~ le mastic PR, d~poser le segment d'arr~t (4). 
- Extraire le porte joint (2) et d~poser le joint (3). 
- D@oser le segment d'arr~t (5) g l'aide de l'outillage (Z). 
: ..-~ I~igure~2:~::-Text~gffaera~ed~:by.~-Elu~aber~t.,-from.the~:input of~Figure-1 . . . . . . . . . .  
tice. The generator can produce text for about 
ten subtasks in FREM. These tasks comprise 
from two to eleven instructions, illustrating ten 
different instruction types such as: simple in- 
struction with a goal, simple instruction with a 
condition, complex instruction with simultane- 
ous actions, etc. They involve the use of various 
syntactical constructions uch as infinitive or 
sentential subordinates, nominalisation, nega- 
tion, etc. 
Input to the prototype are event graphs such 
as the one given in Figure 1. The output is a 
well formed French text such as the one in Fig- 
ure 2 which was generated from Figure 1. In 
Lux's prototype, the event graphs were hand 
coded, but now Flaubert has been rewritten 
in CLEF (Meunier, 1999; Meunier and Reyes, 
1999), which has a better graphical input mech- 
anism that would have eased the input process. 
The output text is a sub-task including a ti- 
tle and instructions of different ypes (only the 
first three instructions are given in the Figures) 
to be performed by the same person (e.g. U0). 
FREM defines which connector to use for each 
instruction type (e.g. conjunction et for an in- 
struction with simultaneous actions). 
The generation of noun groups for the ob- 
jects (Oi), ingredients ( Ingi)  and tools (Ti) re- 
lies on a mapping table between these labels 
and their denominations; this was a temporary 
solution for problems outside the scope of the 
prototype. We should have relied on existing 
nomenclatures for tools'andi'ngredients; and on  
the fact that objects are systematically repre- 
sented in drawings associated with various sub- 
tasks e.g. O5, called segment d'arr~t, is labeled 
(5) on the drawing associated with the exam- 
ple above. In a graphical interface nvironment, 
authors would select these objects linked to a 
controlled terminology data base. 
This proof of,concept ,ge~erator .ser-~ed :, well ..... 
our purpose of testing our theoretical ideas but 
unfortunately it could not be evaluated in a re- 
alistic CL text production environment. Our 
sponsors were very interested in the results we 
have produced but changes in their organisation 
made it impossible to carry further investiga- 
tions. We intend to further pursue our research 
and use the new implementation of Flaubert to 
generate controlled language in an other area 
of application while keeping the concept of an 
extended modular CL. 
5 Conc lus ion  
This paper has argued that linguistic norms im- 
posed by CLs should not be considered in iso- 
lation. They are only a part of a set of more 
comprehensive norms on the document struc- 
ture and layout. This insight led us to define a 
notion of textual modules, each with its own 
linguistic norms, and to envisage the genera- 
tion of technical documentation using an ex- 
tended modular controlled language (EMCL). 
Norms for document structure such as ATA100, 
its linguistic characteristics and its layout re- 
quirements may be seen to respectively define 
the text structuring, the linguistic and the lay- 
out components of an NLG system. 
We have also shown that a generation point of 
view can help refine tile definition of an EMCL. 
The EMCL can be defined monolingually, mul- 
tilinguality being obtained through NLG. These 
ideas were tested within a proof of concept ext 
generator, in thedomain  of' aircraftmaintenance 
manuals. 
Acknowledgment  
We thank our former colleagues at Aerospa- 
tiale Research Center and Frdd~ric Meunier 
who implemented Flaubert. We also thank EI- 
-liottqkffacMowitch,-who suggestedmany improve- " " 
ments to the paper. 
146 
References 
AECMA Document PSC-85-16598, 1995. Sim- 
plified English Standard, a guide for the 
preparation of Aircraft Maintenance Doc- 
umentation in the International Aerospace 
Maintenance Language. 
? Bureau de Normatisation :de l~,A~ronaufique 
et de l'Espace (BNAE), Issy-les-Moulineaux, 
1995. Spdcification ATA no 100, traduc- 
tion frangaise. Specification for Manufactur- 
er's Technical Data - ATA Specification 10, 
October. 
M.-H. Candito. 1996. A principle-based hierar- 
chical representation f LTAGs. In Proceed- 
ings of the 16th International Conference on 
Computational Linguistics, pages 194-199, 
Copenhagen. 
CLAW. 1996. Proceedings of the First Interna- 
tional Workshop on Controlled Language Ap- 
plications (CLAW), Leuven. 
L. Danlos and F. Meunier. 1996. G-TAG, 
un formalisme pour la gEnEration de texte : 
presentation et applications industrielles. In 
Actes du colloque Informatique t Langue Na- 
turelle, Nantes. 
L. Danlos. 1998. G-TAG: un formalisme lex- 
icalis~ de gdn~ration de textes inspire de 
TAG. Traitement Automatique des Langues 
- T.A.L., 39(2):4-32. 
L. Danlos, 2000. Tag Grammars, chapter G- 
TAG: A Lexicalized Formalism for Text Gen- 
eration inspired by Tree Adjoining Grammar. 
CSLI. 
M. Emorine. 1994. Projet de recherche sur la 
mod61isation des entr6es verbales du fran~ais 
rationalis6. Technical report, Universit6 de 
Clermont II. 
GIFAS. 1996. Guide du r6dacteur - partie 2: 
Fran~ais rationalis6. Technical report, GI- 
FAS, Paris. 
A. Hartley and C. Paris, 1996. Le tezte 
procddural : langage, action et cognition, 
chapter Une analyse fonctionnelle de textes 
proc6duraux : apport de la g6n6ration au- 
tomatique ~ la d6finition des langues ratio- 
nalis6es, pages 211-222. Toulouse. 
W. Levelt. 1989. Speaking -.h'om intention 
to articulation. MIT Press. Cambridge Mas- 
sachuset ts. 
V. Lux. 1998. Elaboration d'unffangais ratio- 
nalisd dtendu pour un manuel de maintenance 
adronautique, test en gdndration automatique. 
Th~se de doctorat en linguistique, Universitd 
Paris 7. 
F. Meunier and L. Danlos. 1998. FLAUBERT: 
an user-friendly system for multilingual text 
generation. In Proceedings of the 9th Interna- 
tianal. Workshop. on Natural Language Gener- 
ation (INLG'98), pages 284-287, Niagara-on- 
the-Lake. 
F. Meunier and R. Reyes. 1999. Plate-forme de 
ddveloppement de gdn~rateurs multilingues. 
In Actes de la confdrence de Gdndration Au- 
tomatique de Texte CAT'99, pages 145-155, 
Grenoble, France. 
F. Meunier. 1997. Impldmentation de G-TAG, 
formalisme pour la gdndration inspirde des 
grammaires d'arbres adjoints. Th~se de doc- 
torat en informatique, Universitd Paris 7. 
F. Meunier. 1999. Mod~lisation des ressources 
linguistiques d'une application industrielle. 
In TALN'99, pages 243-252, Carg~se, Corse, 
12-17 juillet. 
A. Nasr. 1996. Un module de reformulation au- 
tomatique fondd sur la thdorie Sens-Texte - 
application aux Langues Controldes. Ph.D. 
thesis, Universit~ Paris 7. 
C. Paris, K. Vander Linden, M. Fischer, 
A. Hartley, L. Pemberton, R. Power, and 
D. Scott. 1995. A support tool for writ- 
ing multilingaul instructions. In Proceedings 
of the 14th International Joint Conference 
on Artificial Intelligence (IJCAI'95), pages 
1398-1404, MontrEal. 
J. Scheurs and G. Adriaens, 1992. Comput- 
ers and writing - state of the art, chapter 
From cogram to alcogram : toward a con- 
trolled english grammar checker, pages 206- 
221. Kluwer Academic Publishers, London. 
147 
