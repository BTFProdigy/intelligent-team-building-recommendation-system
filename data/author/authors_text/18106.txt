Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 196?206,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
Fast and Robust Compressive Summarization
with Dual Decomposition and Multi-Task Learning
Miguel B. Almeida?? Andre? F. T. Martins??
?Priberam Labs, Alameda D. Afonso Henriques, 41, 2o, 1000-123 Lisboa, Portugal
?Instituto de Telecomunicac?o?es, Instituto Superior Te?cnico, 1049-001 Lisboa, Portugal
{mba,atm}@priberam.pt
Abstract
We present a dual decomposition frame-
work for multi-document summarization,
using a model that jointly extracts and
compresses sentences. Compared with
previous work based on integer linear pro-
gramming, our approach does not require
external solvers, is significantly faster, and
is modular in the three qualities a sum-
mary should have: conciseness, informa-
tiveness, and grammaticality. In addition,
we propose a multi-task learning frame-
work to take advantage of existing data
for extractive summarization and sentence
compression. Experiments in the TAC-
2008 dataset yield the highest published
ROUGE scores to date, with runtimes that
rival those of extractive summarizers.
1 Introduction
Automatic text summarization is a seminal prob-
lem in information retrieval and natural language
processing (Luhn, 1958; Baxendale, 1958; Ed-
mundson, 1969). Today, with the overwhelming
amount of information available on the Web, the
demand for fast, robust, and scalable summariza-
tion systems is stronger than ever.
Up to now, extractive systems have been the
most popular in multi-document summarization.
These systems produce a summary by extracting
a representative set of sentences from the origi-
nal documents (Kupiec et al, 1995; Carbonell and
Goldstein, 1998; Radev et al, 2000; Gillick et al,
2008). This approach has obvious advantages: it
reduces the search space by letting decisions be
made for each sentence as a whole (avoiding fine-
grained text generation), and it ensures a grammat-
ical summary, assuming the original sentences are
well-formed. The typical trade-offs in these mod-
els (maximizing relevance, and penalizing redun-
dancy) lead to submodular optimization problems
(Lin and Bilmes, 2010), which are NP-hard but ap-
proximable through greedy algorithms; learning is
possible with standard structured prediction algo-
rithms (Sipos et al, 2012; Lin and Bilmes, 2012).
Probabilistic models have also been proposed to
capture the problem structure, such as determinan-
tal point processes (Gillenwater et al, 2012).
However, extractive systems are rather limited
in the summaries they can produce. Long, partly
relevant sentences tend not to appear in the sum-
mary, or to block the inclusion of other sen-
tences. This has motivated research in compres-
sive summarization (Lin, 2003; Zajic et al, 2006;
Daume?, 2006), where summaries are formed by
compressed sentences (Knight and Marcu, 2000),
not necessarily extracts. While promising results
have been achieved by models that simultaneously
extract and compress (Martins and Smith, 2009;
Woodsend and Lapata, 2010; Berg-Kirkpatrick et
al., 2011), there are still obstacles that need to
be surmounted for these systems to enjoy wide
adoption. All approaches above are based on in-
teger linear programming (ILP), suffering from
slow runtimes, when compared to extractive sys-
tems. For example, Woodsend and Lapata (2012)
report 55 seconds on average to produce a sum-
mary; Berg-Kirkpatrick et al (2011) report sub-
stantially faster runtimes, but fewer compressions
are allowed. Having a compressive summarizer
which is both fast and expressive remains an open
problem. A second inconvenience of ILP-based
approaches is that they do not exploit the modu-
larity of the problem, since the declarative specifi-
cation required by ILP solvers discards important
structural information. For example, such solvers
are unable to take advantage of efficient dynamic
programming routines for sentence compression
(McDonald, 2006).
196
This paper makes progress in two fronts:
? We derive a dual decomposition framework for
extractive and compressive summarization (?2?
3). Not only is this framework orders of mag-
nitude more efficient than the ILP-based ap-
proaches, it also allows the three well-known
metrics of summaries?conciseness, informa-
tiveness, and grammaticality?to be treated sep-
arately in a modular fashion (see Figure 1). We
also contribute with a novel knapsack factor,
along with a linear-time algorithm for the corre-
sponding dual decomposition subproblem.
? We propose multi-task learning (?4) as a prin-
cipled way to train compressive summarizers,
using auxiliary data for extractive summariza-
tion and sentence compression. To this end,
we adapt the framework of Evgeniou and Pon-
til (2004) and Daume? (2007) to train structured
predictors that share some of their parts.
Experiments on TAC data (?5) yield state-of-the-
art results, with runtimes similar to that of extrac-
tive systems. To our best knowledge, this had
never been achieved by compressive summarizers.
2 Extractive Summarization
In extractive summarization, we are given a set
of sentences D := {s1, . . . , sN} belonging to one
or more documents, and the goal is to extract a
subset S ? D that conveys a good summary of D
and whose total number of words does not exceed
a prespecified budget B.
We use an indicator vector y := ?yn?Nn=1 to rep-
resent an extractive summary, where yn = 1 if
sn ? S, and yn = 0 otherwise. Let Ln be the
number of words of the nth sentence. By design-
ing a quality score function g : {0, 1}N ? R, this
can be cast as a global optimization problem with
a knapsack constraint:
maximize g(y)
w.r.t. y ? {0, 1}N
s.t.
?N
n=1 Lnyn ? B. (1)
Intuitively, a good summary is one which selects
sentences that individually convey ?relevant? in-
formation, while collectively having small ?re-
dundancy.? This trade-off was explicitly mod-
eled in early works through the notion of max-
imal marginal relevance (Carbonell and Gold-
stein, 1998; McDonald, 2007). An alternative
are coverage-based models (?2.1; Filatova and
Hatzivassiloglou, 2004; Yih et al, 2007; Gillick
et al, 2008), which seek a set of sentences that
covers as many diverse ?concepts? as possible; re-
dundancy is automatically penalized since redun-
dant sentences cover fewer concepts. Both models
can be framed under the framework of submodular
optimization (Lin and Bilmes, 2010), leading to
greedy algorithms that have approximation guar-
antees. However, extending these models to allow
for sentence compression (as will be detailed in
?3) breaks the diminishing returns property, mak-
ing submodular optimization no longer applicable.
2.1 Coverage-Based Summarization
Coverage-based extractive summarization can be
formalized as follows. Let C(D) := {c1, . . . , cM}
be a set of relevant concept types which are
present in the original documents D.1 Let ?m be a
relevance score assigned to the mth concept, and
let the set Im ? {1, . . . , N} contain the indices of
the sentences in which this concept occurs. Then,
the following quality score function is defined:
g(y) =
?M
m=1 ?mum(y), (2)
where um(y) := ?n?Im yn is a Boolean functionthat indicates whether the mth concept is present
in the summary. Plugging this into Eq. 1, one ob-
tains the following Boolean optimization problem:
maximize
?M
m=1 ?mum
w.r.t. y ? {0, 1}N , u ? {0, 1}M
s.t. um =
?
n?Im yn, ?m ? [M ]?N
n=1 Lnyn ? B, (3)
where we used the notation [M ] := {1, . . . ,M}.
This can be converted into an ILP and addressed
with off-the-shelf solvers (Gillick et al, 2008). A
drawback of this approach is that solving an ILP
exactly is NP-hard. Even though existing commer-
cial solvers can solve most instances with a mod-
erate speed, they still exhibit poor worst-case be-
haviour; this is exacerbated when there is the need
to combine an extractive component with other
modules, as in compressive summarization (?3).
1Previous work has modeled concepts as events (Filatova
and Hatzivassiloglou, 2004), salient words (Lin and Bilmes,
2010), and word bigrams (Gillick et al, 2008). In the sequel,
we assume concepts are word k-grams, but our model can
handle other representations, such as phrases or predicate-
argument structures.
197
2.2 A Dual Decomposition Formulation
We next describe how the problem in Eq. 3 can be
addressed with dual decomposition, a class of op-
timization techniques that tackle the dual of com-
binatorial problems in a modular, extensible, and
parallelizable manner (Komodakis et al, 2007;
Rush et al, 2010). In particular, we employ al-
ternating directions dual decomposition (AD3;
Martins et al, 2011a, 2012) for solving a linear re-
laxation of Eq. 3. AD3 resembles the subgradient-
based algorithm of Rush et al (2010), but it enjoys
a faster convergence rate. Both algorithms split
the original problem into several components,
and then iterate between solving independent lo-
cal subproblems at each component and adjusting
multipliers to promote an agreement.2 The differ-
ence between the two methods is that the AD3 lo-
cal subproblems, instead of requiring the compu-
tation of a locally optimal configuration, require
solving a local quadratic problem. Martins et al
(2011b) provided linear-time solutions for several
logic constraints, with applications to syntax and
frame-semantic parsing (Das et al, 2012). We will
see that AD3 can also handle budget and knapsack
constraints efficiently.
To tackle Eq. 3 with dual decomposition, we
split the coverage-based summarizer into the fol-
lowing M + 1 components (one per constraint):
1. For each of the M concepts in C(D), one
component for imposing the logic constraint
in Eq. 3. This corresponds to the OR-WITH-
OUTPUT factor described by Martins et al
(2011b); the AD3 subproblem for themth factor
can be solved in time O(|Im|).
2. Another component for the knapsack con-
straint. This corresponds to a (novel) KNAP-
SACK factor, whose AD3 subproblem is solv-
able in time O(N). The actual algorithm is de-
scribed in the appendix (Algorithm 1).3
3 Compressive Summarization
We now turn to compressive summarization,
which does not limit the summary sentences to be
verbatim extracts from the original documents; in-
2For details about dual decomposition and Lagrangian re-
laxation, see the recent tutorial by Rush and Collins (2012).
3The AD3 subproblem in this case corresponds to com-
puting an Euclidean projection onto the knapsack polytope
(Eq. 11). Others addressed the related, but much harder, inte-
ger quadratic knapsack problem (McDonald, 2007).
stead, it allows the extraction of compressed sen-
tences where some words can be deleted.
Formally, let us express each sentence of D
as a sequence of word tokens, sn := ?tn,`?Ln`=0,where tn,0 ? $ is a dummy symbol. We rep-
resent a compression of sn as an indicator vec-
tor zn := ?zn,`?Ln`=0, where zn,` = 1 if the `thword is included in the compression. By conven-
tion, the dummy symbol is included if and only if
the remaining compression is non-empty. A com-
pressive summary can then be represented by an
indicator vector z which is the concatenation of
N such vectors, z = ?z1, . . . ,zN ?; each position
in this indicator vector is indexed by a sentence
n ? [N ] and a word position ` ? {0} ? [Ln].
Models for compressive summarization were
proposed by Martins and Smith (2009) and Berg-
Kirkpatrick et al (2011) by combining extraction
and compression scores. Here, we follow the lat-
ter work, by combining a coverage score function
g with sentence-level compression score functions
h1, . . . , hN . This yields the decoding problem:
maximize g(z) +
?N
n=1 hn(zn)
w.r.t. zn ? {0, 1}Ln , ?n ? [N ]
s.t.
?N
n=1
?Ln
`=1 zn,` ? B. (4)
3.1 Coverage Model
We use a coverage function similar to Eq. 2, but
taking a compressive summary z as argument:
g(z) =
?M
m=1 ?mum(z), (5)
where we redefine um as follows. First, we
parametrize each occurrence of the mth concept
(assumed to be a k-gram) as a triple ?n, `s, `e?,
where n indexes a sentence, `s indexes a start po-
sition within the sentence, and `e indexes the end
position. We denote by Tm the set of triples repre-
senting all occurrences of the mth concept in the
original text, and we associate an indicator vari-
able zn,`s:`e to each member of this set. We then
define um(z) via the following logic constraints:
? A concept type is selected if some of its k-gram
tokens are selected:
um(y) :=
?
?n,`s,`e??Tm zn,`s:`e . (6)
? A k-gram concept token is selected if all its
words are selected:
zn,`s:`e :=
?`e
`=`s zn,`. (7)
198
Sentences $     The      leader    of   moderate  Kashmiri  separatists warned   Thursday   that ...
$     Talks    with   Kashmiri  separatists began    last       year ...
"Kashmiri separatists"
Budget
Concept tokens
Concept type
Figure 1: Components of our compressive summarizer. Factors depicted in blue belong to the compres-
sion model, and aim to enforce grammaticality. The logic factors in red form the coverage component.
Finally, the budget factor, in green, is connected to the word nodes; it ensures that the summary fits the
word limit. Shaded circles represent active variables while white circles represent inactive variables.
We set concept scores as ?m := w ? ?cov(D, cm),
where ?cov(D, cm) is a vector of features (de-
scribed in ?3.5) and w the corresponding weights.
3.2 Compression Model
For the compression score function, we follow
Martins and Smith (2009) and decompose it as a
sum of local score functions ?n,` defined on de-
pendency arcs:
hn(zn) :=
?Ln
`=1 ?n,`(zn,`, zn,pi(`)), (8)
where pi(`) denotes the index of the word which
is the parent of the `th word in the dependency
tree (by convention, the root of the tree is the
dummy symbol). To model the event that an
arc is ?cut? by disconnecting a child from its
head, we define arc-deletion scores ?n,`(0, 1) :=
w ? ?comp(sn, `, pi(`)), where ?comp is a feature
map, which is described in detail in ?3.5. We set
?n,`(0, 0) = ?n,`(1, 1) = 0, and ?n,`(1, 0) = ??,
to allow only the deletion of entire subtrees.
A crucial fact is that one can maximize Eq. 8
efficiently with dynamic programming (using the
Viterbi algorithm for trees); the total cost is linear
in Ln. We will exploit this fact in the dual decom-
position framework described next.4
3.3 A Dual Decomposition Formulation
In previous work, the optimization problem in
Eq. 4 was converted into an ILP and fed to an off-
the-shelf solver (Martins and Smith, 2009; Berg-
Kirkpatrick et al, 2011; Woodsend and Lapata,
2012). Here, we employ the AD3 algorithm, in a
4The same framework can be readily adapted to other
compression models that are efficiently decodable, such as
the semi-Markov model of McDonald (2006), which would
allow incorporating a language model for the compression.
similar manner as described in ?2, but with an ad-
ditional component for the sentence compressor,
and slight modifications in the other components.
We have the following N +M +?Mm=1 |Tm|+ 1
components in total, illustrated in Figure 1:
1. For each of the N sentences, one component
for the compression model. The AD3 quadratic
subproblem for this factor can be addressed by
solving a sequence of linear subproblems, as de-
scribed by Martins et al (2012). Each of these
subproblems corresponds to maximizing an ob-
jective function of the same form as Eq. 8; this
can be done in O(Ln) time with dynamic pro-
gramming, as discussed in ?3.2.
2. For each of the M concept types in C(D),
one OR-WITH-OUTPUT factor for the logic con-
straint in Eq. 6. This is analogous to the one
described for the extractive case.
3. For each k-gram concept token in Tm, one
AND-WITH-OUTPUT factor that imposes the
constraint in Eq. 7. This factor was described
by Martins et al (2011b) and its AD3 subprob-
lem can be solved in time linear in k.
4. Another component linked to all the words im-
posing that at most B words can be selected;
this is done via a BUDGET factor, a particular
case of KNAPSACK. The runtime of this AD3
subproblem is linear in the number of words.
In addition, we found it useful to add a second
BUDGET factor limiting the number of sentences
that can be selected to a prescribed value K. We
set K = 6 in our experiments.
199
3.4 Rounding Strategy
Recall that the problem in Eq. 4 is NP-hard, and
that AD3 is solving a linear relaxation. While
there are ways of wrapping AD3 in an exact search
algorithm (Das et al, 2012), such strategies work
best when the solution of the relaxation has few
fractional components, which is typical of pars-
ing and translation problems (Rush et al, 2010;
Chang and Collins, 2011), and attractive networks
(Taskar et al, 2004). Unfortunately, this is not the
case in summarization, where concepts ?compete?
with each other for inclusion in the summary, lead-
ing to frustrated cycles. We chose instead to adopt
a fast and simple rounding procedure for obtaining
a summary from a fractional solution.
The procedure works as follows. First, solve
the LP relaxation using AD3, as described above.
This yields a solution z?, where each component
lies in the unit interval [0, 1]. If these components
are all integer, then we have a certificate that this
is the optimal solution. Otherwise, we collect the
K sentences with the highest values of z?n,0 (?pos-
teriors? on sentences), and seek the feasible sum-
mary which is the closest (in Euclidean distance)
to z?, while only containing those sentences. This
can be computed exactly in timeO(B?Kk=1 Lnk),
through dynamic programming.5
3.5 Features and Hard Constraints
As Berg-Kirkpatrick et al (2011), we used
stemmed word bigrams as concepts, to which we
associate the following concept features (?cov):
indicators for document counts, features indicat-
ing if each of the words in the bigram is a stop-
word, the earliest position in a document each con-
cept occurs, as well as two and three-way conjunc-
tions of these features.
For the compression model, we include the fol-
lowing arc-deletion features (?comp):
? the dependency label of the arc being deleted, as
well as its conjunction with the part-of-speech
tag of the head, of the modifier, and of both;
? the dependency labels of the arc being deleted
and of its parent arc;
? the modifier tag, if the modifier is a function
word modifying a verb ;
5Briefly, if we link the roots of theK sentences to a super-
root node, the problem above can be transformed into that
of finding the best configuration in the resulting binary tree
subject to a budget constraint. We omit details for space.
? a feature indicating whether the modifier or any
of its descendants is a negation word;
? indicators of whether the modifier is a temporal
word (e.g., Friday) or a preposition pointing to
a temporal word (e.g., on Friday).
In addition, we included hard constraints to pre-
vent the deletion of certain arcs, following pre-
vious work in sentence compression (Clarke and
Lapata, 2008). We never delete arcs whose de-
pendency label is SUB, OBJ, PMOD, SBAR, VC, or
PRD (this makes sure we preserve subjects and ob-
jects of verbs, arcs departing from prepositions or
complementizers, and that we do not break verb
chains or predicative complements); arcs linking
to a conjunction word or siblings of such arcs (to
prevent inconsistencies in handling coordinative
conjunctions); arcs linking verbs to other verbs,
to adjectives (e.g., make available), to verb parti-
cles (e.g., settle down), to the word that (e.g., said
that), or to the word to if it is a leaf (e.g., allowed
to come); arcs pointing to negation words, cardinal
numbers, or determiners; and arcs connecting two
proper nouns or words within quotation marks.
4 Multi-Task Learning
We next turn to the problem of learning the model
from training data. Prior work in compressive
summarization has followed one of two strategies:
Martins and Smith (2009) and Woodsend and La-
pata (2012) learn the extraction and compression
models separately, and then post-combine them,
circumventing the lack of fully annotated data.
Berg-Kirkpatrick et al (2011) gathered a small
dataset of manually compressed summaries, and
trained with full supervision. While the latter
approach is statistically more principled, it has
the disadvantage of requiring fully annotated data,
which is difficult to obtain in large quantities. On
the other hand, there is plenty of data contain-
ing manually written abstracts (from the DUC and
TAC conferences) and user-generated text (from
Wikipedia) that may provide useful weak supervi-
sion.
With this in mind, we put together a multi-task
learning framework for compressive summariza-
tion (which we name task #1). The goal is to
take advantage of existing data for related tasks,
such as extractive summarization (task #2), and
sentence compression (task #3). The three tasks
are instances of structured predictors (Bak?r et
200
Tasks Features Decoder
Comp. summ. (#1) ?cov, ?comp AD3 (solve Eq. 4)
Extr. summ. (#2) ?cov AD3 (solve Eq. 3)
Sent. comp. (#3) ?comp dyn. prg. (max. Eq. 8)
Table 1: Features and decoders used for each task.
al., 2007), and for all of them we assume feature-
based models that decompose over ?parts?:
? For the compressive summarization task, the
parts correspond to concept features (?3.1) and
to arc-deletion features (?3.2).
? For the extractive summarization task, there are
parts for concept features only.
? For the sentence compression task, the parts
correspond to arc-deletion features only.
This is summarized in Table 1. Features for
the three tasks are populated into feature vectors
?1(x, y), ?2(x, y), and ?3(x, y), respectively,
where ?x, y? denotes a task-specific input-output
pair. We assume the feature vectors are all D di-
mensional, where we place zeros in entries cor-
responding to parts that are absent. Note that
this setting is very general and applies to arbi-
trary structured prediction problems (not just sum-
marization), the only assumption being that some
parts are shared between different tasks.
Next, we associate weight vectors v1,v2,v3 ?
RD to each task, along with a ?shared? vector w.
Each task makes predictions according to the rule:
y? := arg max
y
(w + vk) ? ?k(x, y), (9)
where k ? {1, 2, 3}. This setting is equiva-
lent to the approach of Daume? (2007) for domain
adaptation, which consists in splitting each fea-
ture into task-component features and a shared
feature; but here we do not duplicate features ex-
plicitly. To learn the weights, we regularize the
weight vectors separately, and assume that each
task has its own loss function Lk, so that the to-
tal loss L is a weighted sum L(w,v1,v2,v3) :=?3
k=1 ?kLk(w + vk). This yields the following
objective function to be minimized:
F (w,v1,v2,v3) =
?
2 ?w?
2 +
3?
k=1
?k
2 ?vk?
2
+ 1N
3?
k=1
?kLk(w + vk), (10)
where ? and the ?k?s are regularization constants,
andN is the total number of training instances.6 In
our experiments (?5), we let the Lk?s be structured
hinge losses (Taskar et al, 2003; Tsochantaridis et
al., 2004), where the corresponding cost functions
are concept recall (for task #2), precision of arc
deletions (for task #3), and a combination thereof
(for task #1).7 These losses were normalized, and
we set ?k = N/Nk, where Nk is the number of
training instances for the kth task. This ensures
all tasks are weighted evenly. We used the same
rationale to set ? = ?1 = ?2 = ?3, choosing this
value through cross-validation in the dev set.
We optimize Eq. 10 with stochastic subgradient
descent. This leads to update rules of the form
w ? (1? ?t?)w ? ?t?k??Lk(w + vk)
vj ? (1? ?t?j)vj ? ?t?jk?k??Lk(w + vk),
where ??Lk are stochastic subgradients for the kth
task, that take only a single instance into account,
and ?jk = 1 if and only if j = k. Stochastic sub-
gradients can be computed via cost-augmented de-
coding (see footnote 7).
Interestingly, Eq. 10 subsumes previous ap-
proaches to train compressive summarizers. The
limit ??? (keeping the ?k?s fixed) forces w ?
0, decoupling all the tasks. In this limit, inference
for task #1 (compressive summarization) is based
solely on the model learned from that task?s data,
recovering the approach of Berg-Kirkpatrick et al
(2011). In the other extreme, setting ?1 = 0 sim-
ply ignores task #1?s training data. As a result, the
optimal v1 will be a vector of zeros; since tasks
#2 and #3 have no parts in common, the objective
will decouple into a sum of two independent terms
6Note that, by substituting uk := w+vk and solving for
w, the problem in Eq. 10 becomes that of minimizing the sum
of the losses with a penalty for the (weighted) variance of the
vectors {0,u1,u2,u3}, regularizing the difference towards
their average, as in Evgeniou and Pontil (2004). This is sim-
ilar to the hierarchical joint learning approach of Finkel and
Manning (2010), except that our goal is to learn a new task
(compressive summarization) instead of combining tasks.
7Let Yk denote the output set for the kth task. Given
a task-specific cost function ?k : Yk ? Yk ? R,
and letting ?xt, yt?Tt=1 be the labeled dataset for this
task, the structured hinge loss takes the form Lk(uk) :=?
tmaxy??Yk(uk ? (?k(xt, y?)? ?k(xt, yt)) + ?k(y?, yt)).The inner maximization over y? is called the cost-augmented
decoding problem: it differs from Eq. 9 by the inclusion
of the cost term ?k(y?, yt). Our costs decompose over the
model?s factors, hence any decoder for Eq. 9 can be used
for the maximization above: for tasks #1?#2, we solve a
relaxation by running AD3 without rounding, and for task #3
we use dynamic programming; see Table 1.
201
involving v2 and v3, which is equivalent to train-
ing the two tasks separately and post-combining
the models, as Martins and Smith (2009) did.
5 Experiments
5.1 Experimental setup
We evaluated our compressive summarizers on
data from the Text Analysis Conference (TAC)
evaluations. We use the same splits as previ-
ous work (Berg-Kirkpatrick et al, 2011; Wood-
send and Lapata, 2012): the non-update portions
of TAC-2009 for training and TAC-2008 for test-
ing. In addition, we reserved TAC-2010 as a dev-
set. The test partition contains 48 multi-document
summarization problems; each provides 10 related
news articles as input, and asks for a summary
with up to 100 words, which is evaluated against
four manually written abstracts. We ignored all
the query information present in the TAC datasets.
Single-Task Learning. In the single-task exper-
iments, we trained a compressive summarizer on
the dataset disclosed by Berg-Kirkpatrick et al
(2011), which contains manual compressive sum-
maries for the TAC-2009 data. We trained a struc-
tured SVM with stochastic subgradient descent;
the cost-augmented inference problems are re-
laxed and solved with AD3, as described in ?3.3.8
We followed the procedure described in Berg-
Kirkpatrick et al (2011) to reduce the number of
candidate sentences: scores were defined for each
sentence (the sum of the scores of the concepts
they cover), and the best-scored sentences were
greedily selected up to a limit of 1,000 words. We
then tagged and parsed the selected sentences with
TurboParser.9 Our choice of a dependency parser
was motivated by our will for a fast system; in par-
ticular, TurboParser attains top accuracies at a rate
of 1,200 words per second, keeping parsing times
below 1 second for each summarization problem.
Multi-Task Learning. For the multi-task ex-
periments, we also used the dataset of Berg-
Kirkpatrick et al (2011), but we augmented the
training data with extractive summarization and
sentence compression datasets, to help train the
8We use the AD3 implementation in http://www.
ark.cs.cmu.edu/AD3, setting the maximum number of
iterations to 200 at training time and 1000 at test time. We
extended the code to handle the knapsack and budget factors;
the modified code will be part of the next release (AD3 2.1).
9http://www.ark.cs.cmu.edu/TurboParser
compressive summarizer. For extractive sum-
marization, we used the DUC 2003 and 2004
datasets (a total of 80 multi-document summariza-
tion problems). We generated oracle extracts by
maximizing bigram recall with respect to the man-
ual abstracts, as described in Berg-Kirkpatrick et
al. (2011). For sentence compression, we adapted
the Simple English Wikipedia dataset of Wood-
send and Lapata (2011), containing aligned sen-
tences for 15,000 articles from the English and
Simple English Wikipedias. We kept only the
4,481 sentence pairs corresponding to deletion-
based compressions.
5.2 Results
Table 2 shows the results. The top rows refer
to three strong baselines: the ICSI-1 extractive
coverage-based system of Gillick et al (2008),
which achieved the best ROUGE scores in the
TAC-2008 evaluation; the compressive summa-
rizer of Berg-Kirkpatrick et al (2011), denoted
BGK?11; and the multi-aspect compressive sum-
marizer of Woodsend and Lapata (2012), denoted
WL?12. All these systems require ILP solvers.
The bottom rows show the results achieved by
our implementation of a pure extractive system
(similar to the learned extractive summarizer of
Berg-Kirkpatrick et al, 2011); a system that post-
combines extraction and compression components
trained separately, as in Martins and Smith (2009);
and our compressive summarizer trained as a sin-
gle task, and in the multi-task setting.
The ROUGE and Pyramid scores show that the
compressive summarizers (when properly trained)
yield considerable benefits in content coverage
over extractive systems, confirming the results of
Berg-Kirkpatrick et al (2011). Comparing the
two bottom rows, we see a clear benefit by train-
ing in the multi-task setting, with a consistent
gain in both coverage and linguistic quality. Our
ROUGE-2 score (12.30%) is, to our knowledge,
the highest reported on the TAC-2008 dataset,
with little harm in grammaticality with respect to
an extractive system that preserves the original
sentences. Figure 2 shows an example summary.
5.3 Runtimes
We conducted another set of experiments to com-
pare the runtime of our compressive summarizer
based on AD3 with the runtimes achieved by
GLPK, the ILP solver used by Berg-Kirkpatrick et
al. (2011). We varied the maximum number of it-
202
System R-2 R-SU4 Pyr LQ
ICSI-1 11.03 13.96 34.5? ?
BGK?11 11.71 14.47 41.3? ?
WL?12 11.37 14.47 ? ?
Extractive 11.16 14.07 36.0 4.6
Post-comb. 11.07 13.85 38.4 4.1
Single-task 11.88 14.86 41.0 3.8
Multi-task 12.30 15.18 42.6 4.2
Table 2: Results for compressive summarization.
Shown are the ROUGE-2 and ROUGE SU-4 re-
calls with the default options from the ROUGE
toolkit (Lin, 2004); Pyramid scores (Nenkova and
Passonneau, 2004); and linguistic quality scores,
scored between 1 (very bad) to 5 (very good). For
Pyramid, the evaluation was performed by two
annotators, each evaluating half of the problems;
scores marked with ? were computed by different
annotators and are not directly comparable. Lin-
guistic quality was evaluated by two linguists; we
show the average of the reported scores.
Solver Runtime (sec.) ROUGE-2
ILP Exact 10.394 12.40
LP-Relax. 2.265 12.38
AD3-5000 0.952 12.38
AD3-1000 0.406 12.30
AD3-200 0.159 12.15
Extractive (ILP) 0.265 11.16
Table 3: Runtimes of several decoders on a Intel
Core i7 processor @2.8 GHz, with 8GB RAM. For
each decoder, we show the average time taken to
solve a summarization problem in TAC-2008. The
reported runtimes of AD3 and LP-Relax include
the time taken to round the solution (?3.4), which
is 0.029 seconds on average.
erations of AD3 in {200, 1000, 5000}, and clocked
the time spent by GLPK to solve the exact ILPs
and their relaxations. Table 3 depicts the results.10
We see that our proposed configuration (AD3-
1000) is orders of magnitude faster than the ILP
solver, and 5 times faster than its relaxed variant,
while keeping similar accuracy levels.11 The gain
when the number of iterations in AD3 is increased
to 5000 is small, given that the runtime is more
10Within dual decomposition algorithms, we verified ex-
perimentally that AD3 is substantially faster than the subgra-
dient algorithm, which is consistent with previous findings
(Martins et al, 2011b).
11The runtimes obtained with the exact ILP solver seem
slower than those reported by Berg-Kirkpatrick et al (2011).
(around 1.5 sec. on average, according to their Fig. 3). We
conjecture that this difference is due to the restricted set of
subtrees that can be deleted by Berg-Kirkpatrick et al (2011),
which greatly reduces their search space.
Japan dispatched four military ships to help Russia res-
cue seven crew members aboard a small submarine
trapped on the seabed in the Far East. The Russian
Pacific Fleet said the crew had 120 hours of oxygen
reserves on board when the submarine submerged at
midday Thursday (2300 GMT Wednesday) off the Kam-
chatka peninsula, the stretch of Far Eastern Russia fac-
ing the Bering Sea. The submarine, used in rescue,
research and intelligence-gathering missions, became
stuck at the bottom of the Bay of Berezovaya off Rus-
sia?s Far East coast when its propeller was caught in a
fishing net. The Russian submarine had been tending
an underwater antenna mounted to the sea floor when it
became snagged on a wire helping to stabilize a ventila-
tion cable attached to the antenna. Rescue crews low-
ered a British remote-controlled underwater vehicle to a
Russian mini-submarine trapped deep under the Pacific
Ocean, hoping to free the vessel and its seven trapped
crewmen before their air supply ran out.
Figure 2: Example summary from our compres-
sive system. Removed text is grayed out.
than doubled; accuracy starts to suffer, however, if
the number of iterations is reduced too much. In
practice, we observed that the final rounding pro-
cedure was crucial, as only 2 out of the 48 test
problems had integral solutions (arguably because
of the ?repulsive? nature of the network, as hinted
in ?3.4). For comparison, we also report in the bot-
tom row the average runtime of the learned extrac-
tive baseline. We can see that our system?s runtime
is competitive with this baseline. To our knowl-
edge, this is the first time a compressive sum-
marizer achieves such a favorable accuracy/speed
tradeoff.
6 Conclusions
We presented a multi-task learning framework for
compressive summarization, leveraging data for
related tasks in a principled manner. We decode
with AD3, a fast and modular dual decomposition
algorithm which is orders of magnitude faster than
ILP-based approaches. Results show that the state
of the art is improved in automatic and manual
metrics, with speeds close to extractive systems.
Our approach is modular and easy to extend.
For example, a different compression model could
incorporate rewriting rules to enable compres-
sions that go beyond word deletion, as in Cohn
and Lapata (2008). Other aspects may be added
as additional components in our dual decom-
position framework, such as query information
(Schilder and Kondadadi, 2008), discourse con-
203
straints (Clarke and Lapata, 2007), or lexical pref-
erences (Woodsend and Lapata, 2012). Our multi-
task approach may be used to jointly learn pa-
rameters for these aspects; the dual decomposi-
tion algorithm ensures that optimization remains
tractable even with many components.
A Projection Onto Knapsack
This section describes a linear-time algorithm (Al-
gorithm 1) for solving the following problem:
minimize ?z ? a?2
w.r.t. zn ? [0, 1], ?n ? [N ],
s.t.
?N
n=1 Lnzn ? B, (11)
where a ? RN and Ln ? 0,?n ? [N ]. This in-
cludes as special cases the problems of projecting
onto a budget constraint (Ln = 1,?n) and onto
the simplex (same, plus B = 1).
Let clip(t) := max{0,min{1, t}}. Algorithm 1
starts by clipping a to the unit interval; if that
yields a z satisfying ?Nn=1 Lnzn ? B, we are
done. Otherwise, the solution of Eq. 11 must sat-
isfy ?Nn=1 Lnzn = B. It can be shown from the
KKT conditions that the solution is of the form
z?n := clip(an+ ??Ln) for a constant ?? lying in a
particular interval of split-points (line 11). To seek
this constant, we use an algorithm due to Pardalos
and Kovoor (1990) which iteratively shrinks this
interval. The algorithm requires computing medi-
ans as a subroutine, which can be done in linear
time (Blum et al, 1973). The overall complexity
in O(N) (Pardalos and Kovoor, 1990).
Acknowledgments
We thank all reviewers for their insightful com-
ments; Trevor Cohn for helpful discussions about
multi-task learning; Taylor Berg-Kirkpatrick for
answering questions about their summarizer and
for providing code; and Helena Figueira and Pedro
Mendes for helping with manual evaluation. This
work was partially supported by the EU/FEDER
programme, QREN/POR Lisboa (Portugal), under
the Discooperio project (contract 2011/18501),
and by a FCT grant PTDC/EEI-SII/2312/2012.
References
G. Bak?r, T. Hofmann, B. Scho?lkopf, A. Smola,
B. Taskar, and S. Vishwanathan. 2007. Predicting
Structured Data. The MIT Press.
Algorithm 1 Projection Onto Knapsack.
1: input: a := ?an?Nn=1, costs ?Ln?Nn=1, maximum cost B
2:
3: {Try to clip into unit interval:}
4: Set zn ? clip(an) for n ? [N ]
5: if?Nn=1 Lnzn ? B then6: Return z and stop.
7: end if
8:
9: {Run Pardalos and Kovoor (1990)?s algorithm:}
10: Initialize working set W? {1, . . . ,K}
11: Initialize set of split points:
P? {?an/Ln, (1? an)/Ln}Nn=1 ? {??}
12: Initialize ?L ? ??, ?R ??, stight ? 0, ? ? 0.
13: while W 6= ? do
14: Compute ? ? Median(P)
15: Set s? stight + ?? +?n?W Lnclip(an + ?Ln)16: If s ? B, set ?L ? ? ; if s ? B, set ?R ? ?
17: Reduce set of split points: P? P ? [?L, ?R]
18: Define the sets:
WL := {n ?W | (1? an)/Ln < ?L}
WR := {n ?W | ? an/Ln > ?R}
WM :=
{
n ?W
???? ?
an
Ln
? ?L ? 1? anLn
? ?R
}
19: Update working set: W?W \ (WL ?WR ?WM)
20: Update tight-sum:
stight ? stight+
?
n?WL Ln(1?an)?
?
n?WR Lnan
21: Update slack-sum: ? ? ? +?n?WM L2n22: end while
23: Define ?? ? (B ??Ni=1 Liai ? stight)/?24: Set zn ? clip(an + ??Ln), ?n ? [N ]
25: output: z := ?zn?Nn=1.
P. B. Baxendale. 1958. Machine-made index for tech-
nical literature?an experiment. IBM Journal of Re-
search Development, 2(4):354?361.
Taylor Berg-Kirkpatrick, Dan Gillick, and Dan Klein.
2011. Jointly learning to extract and compress. In
Proc. of Annual Meeting of the Association for Com-
putational Linguistics.
Manuel Blum, Robert W Floyd, Vaughan Pratt,
Ronald L Rivest, and Robert E Tarjan. 1973. Time
bounds for selection. Journal of Computer and Sys-
tem Sciences, 7(4):448?461.
J. Carbonell and J. Goldstein. 1998. The use of MMR,
diversity-based reranking for reordering documents
and producing summaries. In SIGIR.
Y.-W. Chang and M. Collins. 2011. Exact decoding of
phrase-based translation models through lagrangian
relaxation. In Proc. of Empirical Methods for Natu-
ral Language Processing.
James Clarke and Mirella Lapata. 2007. Modelling
compression with discourse constraints. In Proc. of
Empirical Methods in Natural Language Process-
ing.
J. Clarke and M. Lapata. 2008. Global Inference for
Sentence Compression An Integer Linear Program-
204
ming Approach. Journal of Artificial Intelligence
Research, 31:399?429.
T. Cohn and M. Lapata. 2008. Sentence compression
beyond word deletion. In Proc. COLING.
D. Das, A. F. T. Martins, and N. A. Smith. 2012. An
Exact Dual Decomposition Algorithm for Shallow
Semantic Parsing with Constraints. In Proc. of First
Joint Conference on Lexical and Computational Se-
mantics (*SEM).
H. Daume?. 2006. Practical Structured Learning Tech-
niques for Natural Language Processing. Ph.D. the-
sis, University of Southern California.
H. Daume?. 2007. Frustratingly easy domain adapta-
tion. In Proc. of Annual Meeting of the Association
for Computational Linguistics.
H. P. Edmundson. 1969. New methods in automatic
extracting. Journal of the ACM, 16(2):264?285.
T. Evgeniou and M. Pontil. 2004. Regularized multi?
task learning. In Proc. of ACM SIGKDD Inter-
national Conference on Knowledge Discovery and
Data Mining, pages 109?117. ACM.
Elena Filatova and Vasileios Hatzivassiloglou. 2004.
A formal model for information selection in multi-
sentence text extraction. In Proc. of International
Conference on Computational Linguistics.
J.R. Finkel and C.D. Manning. 2010. Hierarchical
joint learning: Improving joint parsing and named
entity recognition with non-jointly labeled data. In
Proc. of Annual Meeting of the Association for Com-
putational Linguistics.
J. Gillenwater, A. Kulesza, and B. Taskar. 2012. Dis-
covering diverse and salient threads in document
collections. In Proc. of Empirical Methods in Natu-
ral Language Processing.
Dan Gillick, Benoit Favre, and Dilek Hakkani-Tur.
2008. The icsi summarization system at tac 2008.
In Proc. of Text Understanding Conference.
K. Knight and D. Marcu. 2000. Statistics-based
summarization?step one: Sentence compression.
In AAAI/IAAI.
N. Komodakis, N. Paragios, and G. Tziritas. 2007.
MRF optimization via dual decomposition:
Message-passing revisited. In Proc. of International
Conference on Computer Vision.
J. Kupiec, J. Pedersen, and F. Chen. 1995. A trainable
document summarizer. In SIGIR.
H. Lin and J. Bilmes. 2010. Multi-document summa-
rization via budgeted maximization of submodular
functions. In Proc. of Annual Meeting of the North
American chapter of the Association for Computa-
tional Linguistics.
H. Lin and J. Bilmes. 2012. Learning mixtures of sub-
modular shells with application to document sum-
marization. In Proc. of Uncertainty in Artificial In-
telligence.
C.-Y. Lin. 2003. Improving summarization perfor-
mance by sentence compression-a pilot study. In the
Int. Workshop on Inf. Ret. with Asian Languages.
Chin-Yew Lin. 2004. Rouge: A package for auto-
matic evaluation of summaries. In Stan Szpakowicz
Marie-Francine Moens, editor, Text Summarization
Branches Out: Proceedings of the ACL-04 Work-
shop, pages 74?81, Barcelona, Spain, July.
H. P. Luhn. 1958. The automatic creation of literature
abstracts. IBM Journal of Research Development,
2(2):159?165.
A. F. T. Martins and N. A. Smith. 2009. Summariza-
tion with a Joint Model for Sentence Extraction and
Compression. In North American Chapter of the As-
sociation for Computational Linguistics: Workshop
on Integer Linear Programming for NLP.
A. F. T. Martins, M. A. T. Figueiredo, P. M. Q. Aguiar,
N. A. Smith, and E. P. Xing. 2011a. An Aug-
mented Lagrangian Approach to Constrained MAP
Inference. In Proc. of International Conference on
Machine Learning.
A. F. T. Martins, N. A. Smith, P. M. Q. Aguiar, and
M. A. T. Figueiredo. 2011b. Dual Decomposition
with Many Overlapping Components. In Proc. of
Empirical Methods for Natural Language Process-
ing.
Andre F. T. Martins, Mario A. T. Figueiredo, Pedro
M. Q. Aguiar, Noah A. Smith, and Eric P. Xing.
2012. Alternating Directions Dual Decomposition.
Arxiv preprint arXiv:1212.6550.
R. McDonald. 2006. Discriminative sentence com-
pression with soft syntactic constraints. In Proc. of
Annual Meeting of the European Chapter of the As-
sociation for Computational Linguistics.
R. McDonald. 2007. A study of global inference algo-
rithms in multi-document summarization. In ECIR.
A. Nenkova and R. Passonneau. 2004. Evaluating
content selection in summarization: The pyramid
method. In Proceedings of NAACL, pages 145?152.
Panos M. Pardalos and Naina Kovoor. 1990. An al-
gorithm for a singly constrained class of quadratic
programs subject to upper and lower bounds. Math-
ematical Programming, 46(1):321?328.
D. R. Radev, H. Jing, and M. Budzikowska. 2000.
Centroid-based summarization of multiple docu-
ments: sentence extraction, utility-based evaluation,
and user studies. In the NAACL-ANLP Workshop on
Automatic Summarization.
205
A.M. Rush and M. Collins. 2012. A Tutorial on Dual
Decomposition and Lagrangian Relaxation for In-
ference in Natural Language Processing. Journal of
Artificial Intelligence Research, 45:305?362.
A. Rush, D. Sontag, M. Collins, and T. Jaakkola. 2010.
On dual decomposition and linear programming re-
laxations for natural language processing. In Proc.
of Empirical Methods for Natural Language Pro-
cessing.
Frank Schilder and Ravikumar Kondadadi. 2008. Fast-
sum: Fast and accurate query-based multi-document
summarization. In Proc. of Annual Meeting of the
Association for Computational Linguistics.
R. Sipos, P. Shivaswamy, and T. Joachims. 2012.
Large-margin learning of submodular summariza-
tion models.
B. Taskar, C. Guestrin, and D. Koller. 2003. Max-
margin Markov networks. In Proc. of Neural Infor-
mation Processing Systems.
B. Taskar, V. Chatalbashev, and D. Koller. 2004.
Learning associative Markov networks. In Proc. of
International Conference of Machine Learning.
I. Tsochantaridis, T. Hofmann, T. Joachims, and Y. Al-
tun. 2004. Support vector machine learning for in-
terdependent and structured output spaces. In Proc.
of International Conference of Machine Learning.
K. Woodsend and M. Lapata. 2010. Automatic gener-
ation of story highlights. In Proc. of Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 565?574.
Kristian Woodsend and Mirella Lapata. 2011. Learn-
ing to simplify sentences with quasi-synchronous
grammar and integer programming. In Proc. of Em-
pirical Methods in Natural Language Processing.
Kristian Woodsend and Mirella Lapata. 2012. Mul-
tiple aspect summarization using integer linear pro-
gramming. In Proc. of Empirical Methods in Natu-
ral Language Processing.
Wen-tau Yih, Joshua Goodman, Lucy Vanderwende,
and Hisami Suzuki. 2007. Multi-document summa-
rization by maximizing informative content-words.
In Proc. of International Joint Conference on Artifi-
cal Intelligence.
D. Zajic, B. Dorr, J. Lin, and R. Schwartz. 2006.
Sentence compression as a component of a multi-
document summarization system. In the ACL DUC
Workshop.
206
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 617?622,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
Turning on the Turbo: Fast Third-Order Non-Projective Turbo Parsers
Andre? F. T. Martins?? Miguel B. Almeida?? Noah A. Smith#
?Priberam Labs, Alameda D. Afonso Henriques, 41, 2o, 1000-123 Lisboa, Portugal
?Instituto de Telecomunicac?o?es, Instituto Superior Te?cnico, 1049-001 Lisboa, Portugal
#School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA
{atm,mba}@priberam.pt, nasmith@cs.cmu.edu
Abstract
We present fast, accurate, direct non-
projective dependency parsers with third-
order features. Our approach uses AD3,
an accelerated dual decomposition algo-
rithm which we extend to handle special-
ized head automata and sequential head
bigram models. Experiments in fourteen
languages yield parsing speeds competi-
tive to projective parsers, with state-of-
the-art accuracies for the largest datasets
(English, Czech, and German).
1 Introduction
Dependency parsing has become a prominent ap-
proach to syntax in the last few years, with in-
creasingly fast and accurate models being devised
(Ku?bler et al, 2009; Huang and Sagae, 2010;
Zhang and Nivre, 2011; Rush and Petrov, 2012).
In projective parsing, the arcs in the dependency
tree are constrained to be nested, and the problem
of finding the best tree can be addressed with dy-
namic programming. This results in cubic-time
decoders for arc-factored and sibling second-order
models (Eisner, 1996; McDonald and Pereira,
2006), and quartic-time for grandparent models
(Carreras, 2007) and third-order models (Koo and
Collins, 2010). Recently, Rush and Petrov (2012)
trained third-order parsers with vine pruning cas-
cades, achieving runtimes only a small factor
slower than first-order systems. Third-order fea-
tures have also been included in transition systems
(Zhang and Nivre, 2011) and graph-based parsers
with cube-pruning (Zhang and McDonald, 2012).
Unfortunately, non-projective dependency
parsers (appropriate for languages with a more
flexible word order, such as Czech, Dutch, and
German) lag behind these recent advances. The
main obstacle is that non-projective parsing is
NP-hard beyond arc-factored models (McDonald
and Satta, 2007). Approximate parsers have there-
fore been introduced, based on belief propagation
(Smith and Eisner, 2008), dual decomposition
(Koo et al, 2010), or multi-commodity flows
(Martins et al, 2009, 2011). These are all in-
stances of turbo parsers, as shown by Martins et
al. (2010): the underlying approximations come
from the fact that they run global inference in
factor graphs ignoring loop effects. While this
line of research has led to accuracy gains, none of
these parsers use third-order contexts, and their
speeds are well behind those of projective parsers.
This paper bridges the gap above by presenting
the following contributions:
? We apply the third-order feature models of Koo
and Collins (2010) to non-projective parsing.
? This extension is non-trivial since exact dy-
namic programming is not applicable. Instead,
we adapt AD3, the dual decomposition algo-
rithm proposed by Martins et al (2011), to han-
dle third-order features, by introducing special-
ized head automata.
? We make our parser substantially faster than the
many-components approach of Martins et al
(2011). While AD3 requires solving quadratic
subproblems as an intermediate step, recent re-
sults (Martins et al, 2012) show that they can be
addressed with the same oracles used in the sub-
gradient method (Koo et al, 2010). This enables
AD3 to exploit combinatorial subproblems like
the the head automata above.
Along with this paper, we provide a free distribu-
tion of our parsers, including training code.1
2 Dependency Parsing with AD3
Dual decomposition is a class of optimization
techniques that tackle the dual of combinatorial
1Released as TurboParser 2.1, and publicly available at
http://www.ark.cs.cmu.edu/TurboParser.
617
Figure 1: Parts considered in this paper. First-
order models factor over arcs (Eisner, 1996; Mc-
Donald et al, 2005), and second-order models in-
clude also consecutive siblings and grandparents
(Carreras, 2007). Our parsers add also arbitrary
siblings (not necessarily consecutive) and head bi-
grams, as in Martins et al (2011), in addition
to third-order features for grand- and tri-siblings
(Koo and Collins, 2010).
problems in a modular and extensible manner (Ko-
modakis et al, 2007; Rush et al, 2010). In this
paper, we employ alternating directions dual de-
composition (AD3; Martins et al, 2011). Like
the subgradient algorithm of Rush et al (2010),
AD3 splits the original problem into local sub-
problems, and seeks an agreement on the over-
lapping variables. The difference is that the AD3
subproblems have an additional quadratic term to
accelerate consensus. Recent analysis (Martins et
al., 2012) has shown that: (i) AD3 converges at
a faster rate,2 and (ii) the quadratic subproblems
can be solved using the same combinatorial ma-
chinery that is used in the subgradient algorithm.
This opens the door for larger subproblems (such
as the combination of trees and head automata in
Koo et al, 2010) instead of a many-components
approach (Martins et al, 2011), while still enjoy-
ing faster convergence.
2.1 Our Setup
Given a sentence with L words, to which we
prepend a root symbol $, let A := {?h,m? | h ?
{0, . . . , L}, m ? {1, . . . , L}, h 6= m} be the
set of possible dependency arcs. We parame-
terize a dependency tree via an indicator vector
u := ?ua?a?A, where ua is 1 if the arc a is in the
tree, and 0 otherwise, and we denote by Y ? R|A|
the set of such vectors that are indicators of well-
2Concretely, AD3 needs O(1/) iterations to converge to
a -accurate solution, while subgradient needs O(1/2).
formed trees. Let {As}Ss=1 be a cover of A, where
each As ? A. We assume that the score of a parse
tree u ? Y decomposes as f(u) :=?Ss=1 fs(zs),
where each zs := ?zs,a?a?As is a ?partial view? of
u, and each local score function fs comes from a
feature-based linear model.
Past work in dependency parsing considered ei-
ther (i) a few ?large? components, such as trees
and head automata (Smith and Eisner, 2008; Koo
et al, 2010), or (ii) many ?small? components,
coming from a multi-commodity flow formulation
(Martins et al, 2009, 2011). Let Ys ? R|As| de-
note the set of feasible realizations of zs, i.e., those
that are partial views of an actual parse tree. A tu-
ple of views ?z1, . . . ,zS? ??Ss=1 Ys is said to be
globally consistent if zs,a = zs?,a holds for every
a, s and s? such that a ? As?As? . We assume each
parse u ? Y corresponds uniquely to a globally
consistent tuple of views, and vice-versa. Follow-
ing Martins et al (2011), the problem of obtaining
the best-scored tree can be written as follows:
maximize ?Ss=1 fs(zs)
w.r.t. u ? R|A|, zs ? Ys, ?s
s.t. zs,a = ua, ?s, ?a ? As, (1)
where the equality constraint ensures that the par-
tial views ?glue? together to form a coherent parse
tree.3
2.2 Dual Decomposition and AD3
Dual decomposition methods dualize out the
equality constraint in Eq. 1 by introducing La-
grange multipliers ?s,a. In doing so, they solve a
relaxation where the combinatorial sets Ys are re-
placed by their convex hulls Zs := conv(Ys).4 All
that is necessary is the following assumption:
Assumption 1 (Local-Max Oracle). Every s ?
{1, . . . , S} has an oracle that solves efficiently any
instance of the following subproblem:
maximize fs(zs) +
?
a?As ?s,azs,a
w.r.t. zs ? Ys. (2)
Typically, Assumption 1 is met whenever the max-
imization of fs over Ys is tractable, since the ob-
jective in Eq. 2 just adds a linear function to fs.
3Note that any tuple ?z1, . . . , zS? ? ?Ss=1 Ys satisfyingthe equality constraints will be globally consistent; this fact,
due the assumptions above, will imply u ? Y.
4Let ?|Ys| := {? ? R|Ys| |? ? 0, ?ys?Ys ?ys = 1}be the probability simplex. The convex hull of Ys is the set
conv(Ys) := {
?
ys?Ys ?ysys | ? ? ?
|Ys|}. Its members
represent marginal probabilities over the arcs in As.
618
The AD3 algorithm (Martins et al, 2011) alter-
nates among the following iterative updates:
? z-updates, which decouple over s = 1, . . . , S,
and solve a penalized version of Eq. 2:
z(t+1)s := argmax
zs?Zs
fs(zs) +
?
a?As ?
(t)
s,azs,a
??2
?
a?As(zs,a ? u
(t)
a )2. (3)
Above, ? is a constant and the quadratic term
penalizes deviations from the current global so-
lution (stored in u(t)).5 We will see (Prop. 2)
that this problem can be solved iteratively using
only the Local-Max Oracle (Eq. 2).
? u-updates, a simple averaging operation:
u(t+1)a := 1|{s : a?As}|
?
s : a?As z
(t+1)
s,a . (4)
? ?-updates, where the Lagrange multipliers are
adjusted to penalize disagreements:
?(t+1)s,a := ?(t)s,a ? ?(z(t+1)s,a ? u(t+1)a ). (5)
In sum, the only difference between AD3 and
the subgradient method is in the z-updates, which
in AD3 require solving a quadratic problem.
While closed-form solutions have been developed
for some specialized components (Martins et al,
2011), this problem is in general more difficult
than the one arising in the subgradient algorithm.
However, the following result, proved in Martins
et al (2012), allows to expand the scope of AD3
to any problem which satisfies Assumption 1.
Proposition 2. The problem in Eq. 3 admits a
solution z?s which is spanned by a sparse basis
W ? Ys with cardinality at most |W| ? O(|As|).
In other words, there is a distribution ? with sup-
port in W such that z?s =
?
ys?W ?ysys.6
Prop. 2 has motivated an active set alorithm
(Martins et al, 2012) that maintains an estimate
of W by iteratively adding and removing elements
computed through the oracle in Eq. 2.7 Typically,
very few iterations are necessary and great speed-
ups are achieved by warm-starting W with the ac-
tive set computed in the previous AD3 iteration.
This has a huge impact in practice and is crucial to
obtain the fast runtimes in ?4 (see Fig. 2).
5In our experiments (?4), we set ? = 0.05.
6Note that |Ys| = O(2|As|) in general. What Prop. 2
tells us is that the solution of Eq. 3 can be represented as a
distribution over Ys with a very sparse support.
7The algorithm is a specialization of Nocedal and Wright
(1999), ?16.4, which effectively exploits the sparse represen-
tation of z?s . For details, see Martins et al (2012).
0 10 20 30 40 50sentence length (words)0.00
0.10
0.20
avera
geru
ntime
(sec.) AD3Subgrad.
Figure 2: Comparison between AD3 and subgra-
dient. We show averaged runtimes in PTB ?22 as
a function of the sentence length. For subgradi-
ent, we chose for each sentence the most favorable
stepsize in {0.001, 0.01, 0.1, 1}.
3 Solving the Subproblems
We next describe the actual components used in
our third-order parsers.
Tree component. We use an arc-factored score
function (McDonald et al, 2005): f TREE(z) =?L
m=1 ?ARC(pi(m),m), where pi(m) is the parent
of the mth word according to the parse tree z,
and ?ARC(h,m) is the score of an individual arc.
The parse tree that maximizes this function can be
found in time O(L3) via the Chu-Liu-Edmonds?
algorithm (Chu and Liu, 1965; Edmonds, 1967).8
Grand-sibling head automata. Let Ainh and
Aouth denote respectively the sets of incoming and
outgoing candidate arcs for the hth word, where
the latter subdivides into arcs pointing to the right,
Aouth,?, and to the left, Aouth,?. Define the sets
AGSIBh,? = Ainh ?Aouth,? andAGSIBh,? = Ainh ?Aouth,?. We
describe right-side grand-sibling head automata;
their left-side counterparts are analogous. For
each head word h in the parse tree z, define
g := pi(h), and let ?m0,m1, . . . ,mp+1? be the se-
quence of right modifiers of h, with m0 = START
and mp+1 = END. Then, we have the following
grand-sibling component:
fGSIBh,? (z|AGSIBh,?) =
?p+1
k=1
(
?SIB(h,mk?1,mk)
?GP(g, h,mk) + ?GSIB(g, h,mk?1,mk)
)
,
where we use the shorthand z|B to denote the
subvector of z indexed by the arcs in B ? A.
Note that this score function absorbs grandparent
and consecutive sibling scores, in addition to the
grand-sibling scores.9 For each h, fGSIBh,? can be
8In fact, there is an asymptotically fasterO(L2) algorithm
(Tarjan, 1977). Moreover, if the set of possible arcs is reduced
to a subset B ? A (via pruning), then the fastest known al-
gorithm (Gabow et al, 1986) runs in O(|B|+L logL) time.
9Koo et al (2010) used an identical automaton for their
second-order model, but leaving out the grand-sibling scores.
619
No pruning |Ainm| ? K same, + |Aouth | ? J
TREE O(L2) O(KL+ L logL) O(KL+ L logL)
GSIB O(L4) O(K2L2) O(JK2L)
TSIB O(L4) O(KL3) O(J2KL)
SEQ O(L3) O(K2L) O(K2L)
ASIB O(L3) O(KL2) O(JKL)
Table 1: Theoretical runtimes of each subproblem
without pruning, limiting the number of candidate
heads, and limiting (in addition) the number of
modifiers. Note the O(L logL) total runtime per
AD3 iteration in the latter case.
maximized in time O(L3) with dynamic program-
ming, yielding O(L4) total runtime.
Tri-sibling head automata. In addition, we de-
fine left and right-side tri-sibling head automata
that remember the previous two modifiers of a
head word. This corresponds to the following
component function (for the right-side case):
f TSIBh,? (z|Aouth,?) =
?p+1
k=2 ?TSIB(h,mk?2,mk?1,mk).
Again, each of these functions can be maximized
in time O(L3), yielding O(L4) runtime.
Sequential head bigram model. Head bigrams
can be captured with a simple sequence model:
f SEQ(z) =
?L
m=2 ?HB(m,pi(m), pi(m? 1)).
Each score ?HB(m,h, h?) is obtained via features
that look at the heads of consecutive words (as in
Martins et al (2011)). This function can be maxi-
mized in time O(L3) with the Viterbi algorithm.
Arbitrary siblings. We handle arbitrary siblings
as in Martins et al (2011), definingO(L3) compo-
nent functions of the form fASIBh,m,s(z?h,m?, z?h,s?) =
?ASIB(h,m, s). In this case, the quadratic problem
in Eq. 3 can be solved directly in constant time.
Tab. 1 details the time complexities of each sub-
problem. Without pruning, each iteration of AD3
has O(L4) runtime. With a simple strategy that
limits the number of candidate heads per word to
a constant K, this drops to cubic time.10 Further
speed-ups are possible with more pruning: by lim-
iting the number of possible modifiers to a con-
stant J , the runtime would reduce to O(L logL).
10In our experiments, we employed this strategy withK =
10, by pruning with a first-order probabilistic model. Fol-
lowing Koo and Collins (2010), for each word m, we also
pruned away incoming arcs ?h,m? with posterior probability
less than 0.0001 times the probability of the most likely head.
UAS Tok/sec
PTB-YM ?22, 1st ord 91.38 4,063
PTB-YM ?22, 2nd ord 93.15 1,338
PTB-YM ?22, 2nd ord, +ASIB, +HB 93.28 1,018
PTB-YM ?22, 3rd ord 93.29 709
PTB-YM ?22, 3rd ord, gold tags 94.01 722
This work (PTB-YM ?23, 3rd ord) 93.07 735
Koo et al (2010) 92.46 112?
Huang and Sagae (2010) 92.1? 587?
Zhang and Nivre (2011) 92.9? 680?
Martins et al (2011) 92.53 66?
Zhang and McDonald (2012) 93.06 220
This work (PTB-S ?23, 3rd ord) 92.82 604
Rush and Petrov (2012) 92.7? 4,460
Table 2: Results for the projective English dataset.
We report unlabeled attachment scores (UAS) ig-
noring punctuation, and parsing speeds in tokens
per second. Our speeds include the time necessary
for pruning, evaluating features, and decoding, as
measured on a Intel Core i7 processor @3.4 GHz.
The others are speeds reported in the cited papers;
those marked with ? were converted from times per
sentence.
4 Experiments
We first evaluated our non-projective parser in a
projective English dataset, to see how its speed and
accuracy compares with recent projective parsers,
which can take advantage of dynamic program-
ming. To this end, we converted the Penn Tree-
bank to dependencies through (i) the head rules
of Yamada and Matsumoto (2003) (PTB-YM) and
(ii) basic dependencies from the Stanford parser
2.0.5 (PTB-S).11 We trained by running 10 epochs
of cost-augmented MIRA (Crammer et al, 2006).
To ensure valid parse trees at test time, we rounded
fractional solutions as in Martins et al (2009)?
yet, solutions were integral ? 95% of the time.
Tab. 2 shows the results in the dev-set (top
block) and in the test-set (two bottom blocks). In
the dev-set, we see consistent gains when more ex-
pressive features are added, the best accuracies be-
ing achieved with the full third-order model; this
comes at the cost of a 6-fold drop in runtime com-
pared with a first-order model. By looking at the
two bottom blocks, we observe that our parser
has slightly better accuracies than recent projec-
tive parsers, with comparable speed levels (with
the exception of the highly optimized vine cascade
approach of Rush and Petrov, 2012).
11We train on sections ?02?21, use ?22 as validation data,
and test on ?23. We trained a simple 2nd-order tagger with
10-fold jackknifing to obtain automatic part-of-speech tags
for ?22?23, with accuracies 97.2% and 96.9%, respectively.
620
First Ord. Sec. Ord. Third Ord. Best published UAS RP12 ZM12
UAS Tok/sec UAS Tok/sec UAS Tok/sec UAS Tok/sec UAS Tok/sec UAS
Arabic 77.23 2,481 78.50 388 79.64 197 81.12 - Ma11 - - -
Bulgarian 91.76 5,678 92.82 2,049 93.10 1,273 93.50 - Ma11 91.9 3,980 93.08
Chinese 88.49 18,094 90.14 4,284 89.98 2,592 91.89 - Ma10 90.9 7,800 -
Czech 87.66 1,840 90.00 751 90.32 501 89.46 - Ma11 - - -
Danish 89.42 4,110 91.20 1,053 91.48 650 91.86 - Ma11 - -
Dutch 83.61 3,884 86.37 1,294 86.19 599 85.81 121 Ko10 - - -
German 90.52 5,331 91.85 1,788 92.41 965 91.89 - Ma11 90.8 2,880 91.35
English 91.21 3,127 93.03 1,317 93.22 785 92.68 - Ma11 - - -
Japanese 92.78 23,895 93.14 5,660 93.52 2,996 93.72 - Ma11 92.3 8,600 93.24
Portuguese 91.14 4,273 92.71 1,316 92.69 740 93.03 79 Ko10 91.5 2,900 91.69
Slovene 82.81 4,315 85.21 722 86.01 366 86.95 - Ma11 - - -
Spanish 83.61 4,347 84.97 623 85.59 318 87.48 - ZM12 - - 87.48
Swedish 89.36 5,622 90.98 1,387 91.14 684 91.44 - ZM12 90.1 5,320 91.44
Turkish 75.98 6,418 76.50 1,721 76.90 793 77.55 258 Ko10 - - -
Table 3: Results for the CoNLL-2006 datasets and the non-projective English dataset of CoNLL-2008.
?Best Published UAS? includes the most accurate parsers among Nivre et al (2006), McDonald et al
(2006), Martins et al (2010, 2011), Koo et al (2010), Rush and Petrov (2012), Zhang and McDonald
(2012). The last two are shown separately in the rightmost columns.
In our second experiment (Tab. 3), we used 14
datasets, most of which are non-projective, from
the CoNLL 2006 and 2008 shared tasks (Buch-
holz and Marsi, 2006; Surdeanu et al, 2008).
Our third-order model achieved the best reported
scores for English, Czech, German, and Dutch?
which includes the three largest datasets and the
ones with the most non-projective dependencies?
and is on par with the state of the art for the
remaining languages. To our knowledge, the
speeds are the highest reported among higher-
order non-projective parsers, and only about 3?
4 times slower than the vine parser of Rush and
Petrov (2012), which has lower accuracies.
5 Conclusions
We presented new third-order non-projective
parsers which are both fast and accurate. We de-
coded with AD3, an accelerated dual decomposi-
tion algorithm which we adapted to handle large
components, including specialized head automata
for the third-order features, and a sequence model
for head bigrams. Results are above the state of
the art for large datasets and non-projective lan-
guages. In the hope that other researchers may find
our implementation useful or are willing to con-
tribute with further improvements, we made our
parsers publicly available as open source software.
Acknowledgments
We thank all reviewers for their insightful com-
ments and Lingpeng Kong for help in converting
the Penn Treebank to Stanford dependencies. This
work was partially supported by the EU/FEDER
programme, QREN/POR Lisboa (Portugal), under
the Intelligo project (contract 2012/24803), by a
FCT grant PTDC/EEI-SII/2312/2012, and by NSF
grant IIS-1054319.
References
S. Buchholz and E. Marsi. 2006. CoNLL-X shared
task on multilingual dependency parsing. In Inter-
national Conference on Natural Language Learn-
ing.
X. Carreras. 2007. Experiments with a higher-order
projective dependency parser. In International Con-
ference on Natural Language Learning.
Y. J. Chu and T. H. Liu. 1965. On the shortest arbores-
cence of a directed graph. Science Sinica, 14:1396?
1400.
K. Crammer, O. Dekel, J. Keshet, S. Shalev-Shwartz,
and Y. Singer. 2006. Online passive-aggressive al-
gorithms. Journal of Machine Learning Research,
7:551?585.
J. Edmonds. 1967. Optimum branchings. Journal
of Research of the National Bureau of Standards,
71B:233?240.
J. M. Eisner. 1996. Three new probabilistic models
for dependency parsing: An exploration. In Proc.
of International Conference on Computational Lin-
guistics, pages 340?345.
H. N. Gabow, Z. Galil, T. Spencer, and R. E. Tarjan.
1986. Efficient algorithms for finding minimum
spanning trees in undirected and directed graphs.
Combinatorica, 6(2):109?122.
621
L. Huang and K. Sagae. 2010. Dynamic programming
for linear-time incremental parsing. In Proc. of An-
nual Meeting of the Association for Computational
Linguistics, pages 1077?1086.
N. Komodakis, N. Paragios, and G. Tziritas. 2007.
MRF optimization via dual decomposition:
Message-passing revisited. In Proc. of International
Conference on Computer Vision.
T. Koo and M. Collins. 2010. Efficient third-order de-
pendency parsers. In Proc. of Annual Meeting of the
Association for Computational Linguistics, pages 1?
11.
T. Koo, A. M. Rush, M. Collins, T. Jaakkola, and
D. Sontag. 2010. Dual decomposition for parsing
with non-projective head automata. In Proc. of Em-
pirical Methods for Natural Language Processing.
S. Ku?bler, R. McDonald, and J. Nivre. 2009. Depen-
dency parsing. Morgan & Claypool Publishers.
A. F. T. Martins, N. A. Smith, and E. P. Xing. 2009.
Concise integer linear programming formulations
for dependency parsing. In Proc. of Annual Meeting
of the Association for Computational Linguistics.
A. F. T. Martins, N. A. Smith, E. P. Xing, M. A. T.
Figueiredo, and P. M. Q. Aguiar. 2010. Turbo
parsers: Dependency parsing by approximate vari-
ational inference. In Proc. of Empirical Methods for
Natural Language Processing.
A. F. T. Martins, N. A. Smith, P. M. Q. Aguiar, and
M. A. T. Figueiredo. 2011. Dual decomposition
with many overlapping components. In Proc. of Em-
pirical Methods for Natural Language Processing.
A. F. T. Martins, M. A. T. Figueiredo, P. M. Q. Aguiar,
N. A. Smith, and E. P. Xing. 2012. Alternat-
ing directions dual decomposition. Arxiv preprint
arXiv:1212.6550.
R. T. McDonald and F. C. N. Pereira. 2006. Online
learning of approximate dependency parsing algo-
rithms. In Proc. of Annual Meeting of the European
Chapter of the Association for Computational Lin-
guistics.
R. McDonald and G. Satta. 2007. On the complex-
ity of non-projective data-driven dependency pars-
ing. In Proc. of International Conference on Parsing
Technologies.
R. T. McDonald, F. Pereira, K. Ribarov, and J. Ha-
jic. 2005. Non-projective dependency parsing us-
ing spanning tree algorithms. In Proc. of Empirical
Methods for Natural Language Processing.
R. McDonald, K. Lerman, and F. Pereira. 2006. Mul-
tilingual dependency analysis with a two-stage dis-
criminative parser. In Proc. of International Confer-
ence on Natural Language Learning.
J. Nivre, J. Hall, J. Nilsson, G. Eryig?it, and S. Marinov.
2006. Labeled pseudo-projective dependency pars-
ing with support vector machines. In Procs. of In-
ternational Conference on Natural Language Learn-
ing.
J. Nocedal and S. J. Wright. 1999. Numerical opti-
mization. Springer-Verlag.
Alexander M Rush and Slav Petrov. 2012. Vine prun-
ing for efficient multi-pass dependency parsing. In
Proc. of Conference of the North American Chapter
of the Association for Computational Linguistics.
A. Rush, D. Sontag, M. Collins, and T. Jaakkola. 2010.
On dual decomposition and linear programming re-
laxations for natural language processing. In Proc.
of Empirical Methods for Natural Language Pro-
cessing.
D. Smith and J. Eisner. 2008. Dependency parsing by
belief propagation. In Proc. of Empirical Methods
for Natural Language Processing.
M. Surdeanu, R. Johansson, A. Meyers, L. Ma`rquez,
and J. Nivre. 2008. The CoNLL-2008 shared task
on joint parsing of syntactic and semantic dependen-
cies. Proc. of International Conference on Natural
Language Learning.
R.E. Tarjan. 1977. Finding optimum branchings. Net-
works, 7(1):25?36.
H. Yamada and Y. Matsumoto. 2003. Statistical de-
pendency analysis with support vector machines. In
Proc. of International Conference on Parsing Tech-
nologies.
H. Zhang and R. McDonald. 2012. Generalized
higher-order dependency parsing with cube pruning.
In Proc. of Empirical Methods in Natural Language
Processing.
Y. Zhang and J. Nivre. 2011. Transition-based depen-
dency parsing with rich non-local features. In Proc.
of the Annual Meeting of the Association for Com-
putational Linguistics.
622
