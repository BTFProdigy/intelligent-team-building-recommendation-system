Software Engineering, Testing, and Quality Assurance for Natural Language Processing, pages 68?76,
Columbus, Ohio, USA, June 2008. c?2008 Association for Computational Linguistics
Reengineering a domain-independent framework
for Spoken Dialogue Systems
Filipe M. Martins, Ana Mendes, Ma?rcio Viveiros, Joana Paulo Pardal,
Pedro Arez, Nuno J. Mamede and Joa?o Paulo Neto
Spoken Language Systems Laboratory, L2F ? INESC-ID
Department of Computer Science and Engineering,
Instituto Superior Te?cnico, Technical University of Lisbon
R. Alves Redol, 9 - 2? ? 1000-029 Lisboa, Portugal
{fmfm,acbm,mviveiros,joana,pedro,njm,jpn}@l2f.inesc-id.pt
http://www.l2f.inesc-id.pt
Abstract
Our work in this area started as a re-
search project but when L2F joined TecnoVoz,
a Portuguese national consortium including
Academia and Industry partners, our focus
shifted to real-time professional solutions.
The integration of our domain-independent
Spoken Dialogue System (SDS) framework
into commercial products led to a major
reengineering process.
This paper describes the changes that the
framework went through and that deeply af-
fected its entire architecture. The communi-
cation core was enhanced, the modules inter-
faces were redefined for an easier integration,
the SDS deployment process was optimized
and the framework robustness was improved.
The work was done according to software en-
gineering guidelines and making use of design
patterns.
1 Introduction
Our SDS framework was created back in
2000 (Moura?o et al, 2004), as the result of
three graduation theses (Cassaca and Maia, 2002;
Moura?o et al, 2002; Viveiros, 2004), one of which
evolved into a masters thesis (Moura?o, 2005).
The framework is highly inspired on the TRIPS
architecture (Allen et al, 2000): it is a frame-based
domain-independent framework that can be used
to build domain-specific dialogue systems. Every
domain is described by a frame, composed by
domain slots that are filled with user requests.
When a set of domain slots is filled, a service is
executed. In order to do so, the dialogue system
interacts with the user until enough information is
provided.
From the initial version of the framework two
systems were created for two different domains: a
bus ticket vending system, which provides an in-
terface to access bus timetables; and a digital vir-
tual butler named Ambro?sio that controls home de-
vices, such as TVs (volume and channel), acclima-
tization systems, and lights (switch on/off and in-
tensity) through the X10 electrical protocol and the
IrDA (Infrared Data Association) standard. Since
2003, Ambro?sio is publicly available in the ?House
of the Future?1, on the Portuguese Telecommunica-
tions Museum2.
As proof of concept, we have also built a pro-
totype system that helps the user while performing
some task. This was tested for the cooking domain
and the automobile reparation domain.
After the successful deployment of the mentioned
systems, we began developing two new automatic
telephone-based systems: a home banking system
and a personal assistant. These are part of a project
of the TecnoVoz3 consortium technology migration
to enterprises. To answer to the challenges that the
creation of those new systems brought to light, the
focus of the framework shifted from academic issues
to interactive use, real-time response and real users.
Since our goal was to integrate our SDS framework
into enterprise products, we started the development
of a commercial solution. Nevertheless, despite this
1http://www.casadofuturo.org/
2http://www.fpc.pt/
3http://www.tecnovoz.pt/
68
new focus, we wanted to maintain the research fea-
tures of the framework. This situation led to deep
changes in the framework development process: as
more robust techniques needed to be used to ensure
that new systems could easily be created to respond
to client requests. From this point of view, the goal
of the reengineering process was to create a frame-
work that provides means of rapid prototyping simi-
lar to those of Nuance4, Loquendo5 or Artificial So-
lutions6.
Also, the new systems we wanted to built carried
a significant change on the paradigm of the frame-
work: while in the first systems the effects of users?
actions were visible (as they could watch the lights
turning on and off, for instance) and a virtual agent
face provided feedback, in the new scenarios com-
munication is established only through a phone and,
being so, voice is the only feedback.
The new paradigm was the trigger to this pro-
cess and whenever a new issue needed to be solved
the best practices in similar successful systems were
studied. Not all can be mentioned. The most rele-
vant are described in what follows.
As it was previously mentioned, TRIPS was
the main inspiration for this framework. It is a
well known and stable architecture that has proven
its merits in accommodating a range of different
tasks (Allen et al, 2007; Jung et al, 2007). The
main modules of the system interact through a
Facilitator (Ferguson et al, 1996), similar to the
Galaxy HUB7 (Polifroni and Seneff, 2000) with
KQML (Labrou and Finin, 1997) messages. How-
ever, in TRIPS, the routing task is decentralized
since the sender modules decide where to send its
messages. At the same time, any module can sub-
scribe to selected messages through the Facilitator
according to the sender, the type of message or its
contents. This mechanism makes it easier to inte-
grate new modules that subscribe the relevant mes-
sages without the senders? acknowledgment.
Like our framework, the CMU Olympus is a clas-
sical pipeline dialog system architecture (Bohus et
4http://www.nuance.com/
5http://www.loquendo.com/
6http://www.artificial-solutions.com/
7The Galaxy Hub maintains connections to modules (parser,
speech recognizer, back-end, etc.), and routes messages among
them. See http://communicator.sourceforge.net/
al., 2007) where the modules are connected via a
Galaxy HUB that uses a central hub and a set of
rules for relaying messages from one component to
the other. It has the three usual main blocks: Lan-
guage Understanding, through Phoenix parser and
Helios confidence-based annotation module, Dia-
logue Management, through RavenClaw (Raux et
al., 2005; Bohus, 2004), and Language Generation,
through Rosetta. Recognition is made with Sphinx
and synthesis with Theta. The back-end applications
are directly connected to the HUB through an in-
cluded stub.
Some of our recent developments are also inspired
in Voice XML8, in an effort to simplify the frame-
work parameterization and development, required in
the enterprise context. Voice XML provides stan-
dard means of declarative configuration of new sys-
tems reducing the need of coding to the related de-
vices implementation (Nyberg et al, 2002).
Our reengineering work aimed at: i) making the
framework more robust and flexible, enhancing the
creation of new systems for different domains; ii)
simplifying the system?s development, debug and
deployment processes through common techniques
from software engineering areas, such as design pat-
terns (Gamma et al, 1994; Freeman et al, 2004).
By doing this, we are trying to promote the de-
velopment and deployment of new dialogue systems
with our framework.
This paper is organized as follows: Section 2
presents the initial version of the framework; Sec-
tion 3 describes its problems and limitations, as well
as the techniques we adopted to solve them; Sec-
tion 4 describes a brief empirical evaluation of the
reengineering work; finally, Section 5 closes the pa-
per with conclusions and some remarks about future
work directions.
2 Framework description
This section briefly presents our architecture, at its
initial stage, before the reengineering process. We
also introduce some problems of the initial architec-
ture, as they will be later explained in the next sec-
tion.
8http://www.w3.org/Voice/
69
2.1 Domain Model
The domain model that characterizes our framework
is composed by the following entities:
Domain, which includes a frame realization and
generalizes the information about several de-
vices;
Frame, which states the subset of slots to fill for a
given domain;
Device, which represents a real device with several
states and services. Only one active state exists,
at each time, for each device;
State, which includes a subset of services that are
active when the state is active;
Service, which instantiates a defined frame and
specifies a set of slots type of data and restric-
tions for that service.
When developing a new domain all these entities
have to be defined and instantiated.
2.2 Framework architecture
Our initial framework came into existence as the re-
sult of the integration of three main modules:
Input/Output Manager, that controls an Automatic
Speech Recognition (ASR) module (Meinedo,
2008), a Text-To-Speech (TTS) module (Paulo
et al, 2008) and provides a virtual agent
face (Viveiros, 2004);
Dialogue Manager, that interprets the user inten-
tions and generates output messages (Moura?o
et al, 2002; Moura?o, 2005);
Service Manager, that provides a dialogue man-
ager interface to execute the requested services,
and an external application interface through
the device concept (Cassaca and Maia, 2002).
2.3 Input/Output Manager
The Input/Output Manager (IOManager) controls an
ASR module and a TTS module. It also integrates
a virtual agent face, providing a more realistic in-
teraction with the user. The synchronization be-
tween the TTS output and the animated face is done
by an audio?face synchronization manager, which
generates the visemes9 for the corresponding TTS
phonemes information. The provided virtual agent
face is based on a state machine that informs, among
others, when the system is ?thinking? or when what
the user said was not understood.
Besides, a Graphical User Interface (GUI) exists
for text interactions between the user and the system.
Although this input interface is usually only used for
test and debug proposes (as it skips the ASR mod-
ule), it could be used in combination with speech,
if requested by any specific multi-modal system im-
plementation.
The IOManager provides an interface to the Di-
alogue Manager that only includes text input and
output functions. However, the Dialogue Manager
needs to rely on other information, such as the in-
stant the user starts to speak or the moment a syn-
thesized sentence ends. These events are useful, for
instance, to set and trigger for user input timeouts.
2.4 Dialogue Manager
The architecture of the Dialogue Manager (Figure 1)
has seven main modules: a Parser, an Interpretation
Manager, a Task Manager, a Behavior Agent, a Gen-
eration Manager, a Surface Generation and a Dis-
course Context.
HUB
Surface
Generation
[16, 19]
Generation
Manager
[13, 15]
Discourse
Context
[4, 14]
Input/
Output
Manager
[1, 20]
Service
Manager
[7,10,18]
Behavior
Agent
[12]
Parser
[2]
Interpretation 
Manager
[3, 5, 8, 11]
Task
Manager
[6, 9, 17]
External
Applications
Figure 1: Dialogue Manager architecture through the
central HUB. Numbers show the execution sequence.
9A viseme is the visual representation of a phoneme and is
usually associated with muscles positioned near the region of
the mouth (Neto et al, 2006).
70
These modules have specific code from the im-
plementations of the two first systems (the bus ticket
vending system and the butler). When building a
generic dialogue framework, this situation turns out
to be a problem since domain-dependent code was
being used that was not appropriate in new systems.
Also, the modules have many code for HUBmessag-
ing, which makes debug and development harder.
2.5 Service Manager
The Service Manager (Figure 2) was initially devel-
oped to handle all domain specific information. It
has the following components:
Service Manager Galaxy Server, that works like a
HUB stub, managing the interface with the de-
vices and the Dialogue Manager;
Device Manager, that stores information related to
all devices. This information is used by the Di-
alogue Manager to find the service that should
be executed after an interaction;
Access Manager, that controls the user access to
some devices registered in the system;
Domain Manager, that stores all the information
about the domains. This information is used to
build interpretations and for the language gen-
eration process;
Object Recognition Manager, that recognizes the
discourse objects associated with a device;
Device Proxy, abstracts all communication with
the Device Core and device specific informa-
tion protocol. This is done through the Virtual
Proxy design pattern
Device Core, that implements the other part of the
communication protocol with the Service Man-
ager and the Dialogue Manager.
Since the Service Manager interface is shared by
the Dialogue Manager and all devices, a device can
execute a service that belongs to another device or
even access to internal Dialogue Manager informa-
tion.
External
Application
HUB
Database
Service
Manager
Galaxy
Server
Domain
Manager
Device
Manager
Access
Manager
Object
Recognition
Manager
Device
Proxy
Device Core
Device
specific
Implementation
Figure 2: Service Manager architecture.
3 Reengineering a framework
When the challenge of building two new SDSs on
our framework appeared, some of the mentioned ar-
chitectural problems were highlighted. A reengi-
neering process was critical. A starting point for the
reengineering process was needed, even though that
decision was not clear.
By observing the framework?s data and control
flow, we noticed that part of the code in the different
modules was related with HUB messaging, namely
the creation of messages to send, and the conversion
of received messages into internal structures (mar-
shalling). A considerable amount of time was spent
in this task that was repeated across the framework.
Based on that, we decided that the first step should
be the analysis of the Galaxy HUB communication
flow and the XML structures used to encode those
messages, replacing them with more appropriate and
efficient protocols.
3.1 Galaxy HUB and XML
The Galaxy HUB protocol is based in generic XML
messages. That allows new modules to be easily
plugged into the framework, written in any program-
ming language, without modifying any line of code.
However, we needed to improve the development
and debugging processes of the existing modules,
71
and having a time consuming task that was repeated
whenever two modules needed to communicate was
a serious drawback.
Considering this, we decided to remove the
Galaxy HUB. This decision was enforced by the
fact that all the framework modules were written
in the Java programming language, which already
provides direct invocations and objects serialization
through Java Remote Method Invocation (RMI).
The major advantage associated with the use of
this protocol, was the possibility of removing all the
XML-based messaging that repeatedly forced the
creation and interpretation of generic messages in
execution time. With the use of RMI, these struc-
tures were replaced by Java objects that are inter-
changed between modules transparently. Not only
RMI is native to Java.
This was not a simple task, as the team that was
responsible for this process was not the team who
originally developed the framework. Because of
this, the new team lacked familiarity with the overall
code structure. In order to reduce the complexity of
the process, it was necessary to create a proper in-
terface for each module removing the several entry
points that each one had. To better understand the
real flow and to minimize the introduction of new
bugs while refactoring the code we made the infor-
mation flow temporarily synchronous.
The internal structure of each module was re-
designed and every block of code with unknown
functionality was commented out.
This substitution improved the code quality and
both the development and the debugging processes.
We believe that it also improved the runtime effi-
ciency of the system, even though no evaluation of
the performance was made. Empirically, we can say
that in the new version of the system less time is
needed to complete a task since no explicit conver-
sion of the objects into generic messages is made.
3.2 Domain dependent code
The code of the Parser, the Interpretation Manager
and the Surface Generation modules had domain de-
pendent code and it was necessary to clean it out.
Since we were modifying the Galaxy HUB code,
we took the opportunity and redesigned that code in
the aforementioned modules to make it more generic
(and, consequently less domain dependent). Being
so, the code cleaning process took place while the
Galaxy HUB was being replaced.
We were unable to redesign the domain dependent
code. Cases like hard-coded word replacement, used
both to provide a richer interpretation of the user ut-
terances and to allow giving a natural response to the
user. In such cases, we either isolated the domain
specific portions of the code or deleted them, even if
the interpretation or generation processes were de-
graded. It can be recovered in the future by includ-
ing the domain specific knowledge in the dynamic
configuration of the Interpretation and Generation
managers as suggested by Paulo Pardal (2007)
An example of this process is the split-
ting of the parser specific code into several
parsers: some domain-dependent, some domain-
independent, while creating a mechanism to com-
bine them in a configurable chain (through a pipes
and filters architecture). This allows the building
of smaller data-type specific parsers that the Inter-
pretation Manager selects to achieve the best pars-
ing result, according to the expectations of the sys-
tem (Martins et al, 2008). These expectations are
created according to the assumption that the user
will follow the mixed-initiative dialogue flow that
the system ?suggests? during its turn in the interac-
tion. The strategy also handles those cases were the
user does not keep up with those expectations.
3.3 Dialogue Manager Interface
The enhancements introduced at the IOManager
level augmented the amount of the information in-
terchanged between this module and the Dialogue
Manager, as it could deal with more data coming
from the ASR, TTS and the virtual agent face.
However, the Dialogue Manager Interface was
continuously evolving and changing. This lack of
stability made it harder to maintain the successive
versions completely functional during the process.
Following the software engineering practices, and
using the Template Method design pattern, we
started with the definition of modules interfaces and
only after that the implementation code of the meth-
ods was written. This allows the simultaneous de-
velopment of different modules that interact. Only
when some conflict is reported, the parallel develop-
ment processes need to be synchronized resulting in
the possible revision of the interfaces. Even when
72
an interface was not fully supported by the Dialogue
Manager, it was useful since it lead the IOManager
continuous improvements and allowed simultaneous
developments in the Dialogue Manager.
In order to ease the creation of this interface,
an Input/Output adapter was created. This adapter
makes the conversion of the information sent by the
IOManager to the Dialogue Manager specific for-
mat. Having this, when the information exchanged
with the Dialogue Manager changes, the Dialogue
Manager Interface does not need any transforma-
tion. In addition, the Dialogue Manager is able to
interact with other Input/Output platforms without
the need of internal changes.
This solution for the interfaces follows the Facade
design pattern, which provides an unique interface
for several internal modules.
3.4 File system reorganization
When the different dialogue systems were fully im-
plemented in the new version of the framework, we
wanted to keep providing simultaneous access to the
several available domains during the same execution
of the system.
In fact, in our initial framework it was already
possible to have several different domains running in
parallel. When an interaction is domain ambiguous,
the system tries to solve the ambiguity by asking the
user which domain is being referred.
User: Ligar
System: O que deseja fazer:
ligar um electrodome?stico
ou fazer um telefonema?
Figure 3: Example of a domain ambiguous interaction
while running with two different running domains. In
Portuguese ?ligar? means ?switch on? and ?call?
Consider the example on Figure 3: an user inter-
action with two different running domains, the but-
ler and the personal digital assistant. In Portuguese,
the verb ?ligar? means ?to switch something on? or
?to make a phone call?. Since there are two running
domains, and the user utterance is domain ambigu-
ous, the systems requests for a disambiguation in its
next turn (O que deseja fazer), by asking if the user
wants to switch on a home device (ligar um elec-
trodome?stico) or make a phone call (fazer um tele-
fonema).
While using this feature, it came to our attention
that it was necessary to reorganize the file system:
the system folder held the code of all domains, and
every time we needed to change a specific domain
property, we had hundreds of properties files to look
at. This situation was even harder for novice frame-
work developers, since it was difficult to find ex-
actly which files needed to be modified in that dense
file system structure. Moreover, the ASR, TTS and
virtual agent configurations were shared by all do-
mains.
To solve this problem we applied the concept
of system?instance. A system?instance has one or
more domains. When the system starts, it receives
a parameter that specifies which instance we want
to run. The configuration of the existing instances
is split across different folders. A library folder
was created and organized in external libraries (li-
braries from an external source), internal libraries
(library developed internally at our laboratory) and
instance specific libraries (specific libraries of a
system?instance).
With this organization we improved the version-
ing management and updates. The conflicting con-
figuration was removed since each system?instance
has now its own configuration. The configuration
files are organized and whenever we need to deliver
a new version of a system?instance, we simply need
to select the files related with it.
3.5 Service Manager redesign
The Service Manager code had too many dependen-
cies with different modules. The Service Manager
design was based on the Virtual Proxy design pat-
tern. However, it was not possible to develop new
devices without creating dependencies on all of the
Service Manager code, as the Device Core code re-
lied heavily on some classes of the Service Manager.
This situation created difficulties in the SDSs de-
velopment process and affected new developments
since the Service Manager code needed to be copied
whenever a Device Core was running in another
computer or in a web container. This is a known
bad practice in software engineering, since the code
is scattered, making it harder to maintain updated
code in all the relevant locations.
It was necessary to split the Service Manager code
73
for the communication protocol between communi-
cation itself and the device specific code.
Also, the Service Manager class10 interface was
shared by the DialogueManager and all devices. Be-
ing so, it was possible that a device requested the
execution of a service in other device, as well as to
access the internal information exchanged between
the Service Manager and the Dialogue Manager.
Example Device
Device Core
Device
specific
Implementation
Dialogue
Manager
Service Manager
Dialogue
Manager
Interface
Devices
Interface
Service
Manager
Class
Access
Manager
Device
Manager
Figure 4: Service Manager architecture.
Like we did with the Dialogue Manager, we spec-
ified a coherent interface for the different Service
Manager modules, removing the unwanted entry
points. The Service Manager class interface was
split and the Device Manager is now the interface
between the Service Manager and the devices (Fig-
ure 4). Also, the Service Manager class interface is
only accessed by the Dialogue Manager. The classes
between the Service Manager and the Device imple-
mentation were organized in a small library, contain-
ing the classes and the Device Core code. This li-
brary is all what is needed to create a new device
and to connect it to both the Service Manager and
the Dialogue Manager.
Finally, we changed the Access Manager to con-
trol not only user access to registered devices, but
also the registry of devices in the system. This
prevents a device which is running on a specific
system?instance to be registered in some other run-
ning system?instance. This module changed its po-
sition in the framework architecture: now it is be-
10The Service Manager Galaxy Server was renamed to Ser-
vice Manager. However, we decided to call it here by Service
Manager class so it will not be mistaken with the Service Man-
ager module.
tween the Service Manager class and the Device
Manager.
3.6 Event Manager
In the initial stage, when the Galaxy HUB was
removed, all the communication was made syn-
chronous. After that, to enhance the framework and
allowmixed initiative interactions, a mechanism that
provides asynchronous communication was needed.
Also, it was necessary to propagate information be-
tween the ASR, TTS, GUI and the Dialogue System,
crucial for the error handling and recovery tasks.
We came to the conclusion that most of the frame-
works deal with these problems by using event man-
agement dedicated modules. Although TRIPS, the
framework that initially inspired ours, has an Event
Manager, that was not available in ours. The ASR
and TTS modules provided already an event-based
information propagation, and we needed to imple-
ment a dedicated module to make the access to this
sort of information simpler. This decision was en-
forced by the existence of a requirement on han-
dling events originated by an external Private Branch
eXchange (PBX) system, like incoming call and
closed call events. The PBX system was integrated
with the personal assistant that is available through
a phone connection. SDS.
We decided to create an Event Manager in the
IOManager. The Dialogue Manager implements an
event handler that receives events from the Event
Manager and knows where to deliver them. Quickly
we understood that the event handler needed to be
dependent of the system?instance since the events
and their handling are different across systems (like
a telephone system and kiosk system). With this in
mind, we implemented the event handler module,
following the Simple Factory design pattern, by del-
egating the events handling to the specific system-
instance handler. If this specific system?instance
event handler is not specified, the system will use
a default event handler with ?generic? behavior.
This developments were responsible for the con-
tinuous developments in the IOManager, referred in
section 3.3, and occurred at the same time.
With this approach, we can propagate and handle
all the ASR events, the TTS events, GUI events and
external applications events.
The Event Manager has evolved to a decentral-
74
ized HUB. Through this, the sender can set identi-
fiers in some events. These identifiers are used by
other modules to identify messages relevant to them.
In TRIPS a similar service is provided by the Facil-
itator, that routes messages according to the recipi-
ents specified by the sender, and following the sub-
scriptions that modules can do by informing the Fa-
cilitator. This approach eases the integration of new
modules without changing the existing ones, just by
subscribing the relevant type of messages.
3.7 Dialogue Manager distribution
Currently, there are some clients interested in our
framework to create their own SDS. However, since
the code is completely written in Java, distributions
are made available through jar files that can be eas-
ily decoded, giving access to the source of our code.
To avoid this we need to obfuscate the code.
Even though obfuscation is an interesting solu-
tion, our code used Java?s reflexion in several points.
This technique enables dynamic retrieval of classes
and data structures by name. By doing so, it needs to
know the specific name of the classes being reflected
so that the Java class loader knows where to find
them. Obfuscation, among other things, changes
class names and locations, preventing the Java class
loader from finding them.
To cope with this additional challenge, the code
that makes use of reflexion was replaced using the
Simple Factory design pattern. This change allows
the translation of the hard-coded names to the new
obfuscated names in obfuscation time. After that,
when some class needs to instantiate one of those
classes that used reflection, that instance can be cre-
ated through the proper factory.
4 Evaluation
Although a SDS was successfully deployed in our
initial framework, which is publicly available at a
Museum since 2003, no formal evaluation was made
at that initial time. Due to this, effective or numeric
comparison between the framework as it was before
the reengineering work and as it is now, is not possi-
ble. Previous performance parameters are not avail-
able. However, some empirical evaluation is pos-
sible, based on generic principles of Software (re)
Engineering.
In the baseline framework, each improvement,
like modifications in the dialogue flow or at the
parser level, was a process that took more than two
weeks of work, of two software engineers. With the
new version, similar changes are done in less than
one week, by the same team. This includes internal
improvements, and external developments made by
entities using the system. The system is more stable
and reliable now: in the beginning, the system had
an incorrect behavior after some hours of running
time; currently with a similar load, it runs for more
than one month without needing to be restarted.
This is one great step for the adoption of our
framework. This stability, reliability and develop-
ment speed convinced our partners to create their
Spoken Dialogue Systems with our framework.
5 Conclusions and Future Work
Currently, our efforts are concentrated on interpreta-
tion improvement and on error handling and recov-
ery (Harris et al, 2004).
Currently, we are working on representing emo-
tions within the SDS framework. We want to test
the integration, and how people will react to a sys-
tem with desires and moods.
The next big step will be the inclusion of an ef-
ficient morpho-syntactic parser which generates and
provides more information (based on speech acts) to
the Interpretation Manager.
Another step we have in mind is to investigate
how the events and probabilistic information that the
ASR module injects in the system can be used to re-
cover recognition errors.
The integration of a Question-Answering (QA)
system (Mendes et al, 2007) in this framework is
also in our horizon. This might require architectural
changes in order to bring together the interpretation
and disambiguation features from the SDS with the
Information Retrieval (IR) features of QA systems.
This would provide information-providing systems
through voice interaction (Mendes, 2008).
Another ongoing work is the study of whether
ontologies can enrich a SDS. Namely, if they can
be used to abstract knowledge sources allowing the
system to focus only on dialogue phenomena rather
than architecture adaptation, when including new
domains (Paulo Pardal, 2007).
75
Acknowledgments
This work was partially funded by TECNOVOZ,
PRIME National Project number 03/165.
It was also partially funded by DIGA, project
POSI/PLP/14319/2001 of Fundac?a?o para a
Cie?ncia e Tecnologia (FCT).
Joana Paulo Pardal is supported by a PhD fellow-
ship from FCT (SFRH/BD/30791/2006).
References
James Allen, Donna Byron, Myroslava Dzikovska,
George Ferguson, Lucian Galescu, and Amanda Stent.
2000. An architecture for a generic dialogue shell.
Natural Language Engineering, Cambridge Univer-
sity Press, 6.
James Allen, Nathanael Chambers, George Ferguson,
Lucian Galescu, Hyuckchul Jung, Mary Swift, and
William Taysom. 2007. Plow: A collaborative task
learning agent. In Proc. 22th AAAI Conf. AAAI Press.
Dan Bohus, Antoine Raux, Thomas Harris, Maxine Es-
kenazi, and Alexander Rudnicky. 2007. Olympus:
an open-source framework for conversational spoken
language interface research. In Workshop on Bridging
the Gap: Academic and Industrial Research in Dialog
Technology, HLT-NAACL.
Dan Bohus. 2004. Building spoken dialog systems with
the RavenClaw/Communicator architecture. Presenta-
tion at Sphinx Lunch Talk, CMU, Fall.
Renato Cassaca and Rui Maia. 2002. Assistente electro?-
nica. Instituto Superior Te?cnico (IST), Universidade
Te?cnica de Lisboa (UTL), Graduation Thesis.
George Ferguson, James Allen, Brad Miller, and Eric
Ringger. 1996. The design and implementation of
the TRAINS-96 system: A prototype mixed-initiative
planning assistant. Technical Report TN96-5.
Elisabeth Freeman, Eric Freeman, Bert Bates, and Kathy
Sierra. 2004. Head First Design Patterns. O?Reilly.
Erich Gamma, Richard Helm, Ralph Johnson, and John
Vlissides. 1994. Design Patterns: Elements of
Reusable Object-Oriented Software. Addison-Wesley
Professional Computing Series.
Thomas Harris, Satanjeev Banerjee, Alexander Rud-
nicky, June Sison, Kerry Bodine, and Alan Black.
2004. A research platform for multi-agent dialogue
dynamics. In 13th IEEE Intl. Workshop on Robot and
Human Interactive Communication (ROMAN).
Hyuckchul Jung, James Allen, Nathanael Chambers, Lu-
cian Galescu, Mary Swift, and William Taysom. 2007.
Utilizing natural language for one-shot task learning.
Journal of Logic and Computation.
Yannis Labrou and Tim Finin. 1997. A proposal for a
new KQML specification. Technical Report CS-97-
03, Computer Science and Electrical Engineering De-
partment, Univ. of Maryland Baltimore County.
Filipe M. Martins, Ana Mendes, Joana Paulo Pardal,
Nuno J. Mamede, and Joa?o Paulo Neto. 2008. Us-
ing system expectations to manage user interactions.
In Proc. PROPOR 2008 (to appear), LNCS. Springer.
Hugo Meinedo. 2008. Audio Pre-processing and Speech
Recognition for Broadcast News. Ph.D. thesis, IST,
UTL.
Ana Mendes, Lu??sa Coheur, Nuno J. Mamede, Lu??s
Roma?o, Joa?o Loureiro, Ricardo Daniel Ribeiro, Fer-
nando Batista, and David Martins de Matos. 2007.
QA@L2F@QA@CLEF. In Cross Language Evalua-
tion Forum: Working Notes - CLEF 2007 Workshop.
Ana Mendes. 2008. Introducing dialogue in a QA sys-
tem. In Doctoral Symposium of 13th Intl. Conf. Apps.
Nat. Lang. to Information Systems, NLDB (to appear).
Ma?rcio Moura?o, Pedro Madeira, and Miguel Rodrigues.
2002. Dialog manager. IST, UTL, Graduation Thesis.
Ma?rcio Moura?o, Renato Cassaca, and Nuno J. Mamede.
2004. An independent domain dialogue system
through a service manager. In EsTAL, volume 3230
of LNCS. Springer.
Ma?rcio Moura?o. 2005. Gesta?o e representac?a?o de do-
m??nios em sistemas de dia?logo. Master?s thesis, IST,
UTL.
Joa?o Paulo Neto, Renato Cassaca, Ma?rcio Viveiros, and
Ma?rcio Moura?o. 2006. Design of a Multimodal Input
Interface for a Dialogue System. In Proc. PROPOR
2006, volume 3960 of LNCS. Springer.
Eric Nyberg, Teruko Mitamura, and Nobuo Hataoka.
2002. DialogXML: extending Voice XML for dy-
namic dialog management. In Proc. 2th Int. Conf.
on Human Language Technology Research. Morgan
Kaufmann Publishers Inc.
Se?rgio Paulo, Lu??s C. Oliveira, Carlos Mendes, Lu??s
Figueira, Renato Cassaca, Ce?u Viana, and Helena Mo-
niz. 2008. DIXI - A Generic Text-to-Speech System
for European Portuguese. In Proc. PROPOR 2008 (to
appear), LNCS. Springer.
Joana Paulo Pardal. 2007. Dynamic use of ontologies in
dialogue systems. In NAACL-HLT Doctoral Consor-
tium.
Joseph Polifroni and Stephanie Seneff. 2000. GALAXY-
II as an architecture for spoken dialogue evaluation. In
Proc. 2nd Int. Conf. Language Resources and Evalua-
tion (LREC).
Antoine Raux, Brian Langner, Dan Bohus, Alan Black,
and Maxine Eskenazi. 2005. Let?s go public! tak-
ing a spoken dialog system to the real world. In Proc.
INTERSPEECH.
Ma?rcio Viveiros. 2004. Cara falante ? uma interface vi-
sual para um sistema de dia?logo falado. IST, UTL,
Graduation Thesis.
76
From a Surface Analysis to a Dependency Structure
Lu??sa Coheur
L2F INESC-ID / GRIL
Lisboa, Portugal
Luisa.Coheur@l2f.inesc-id.pt
Nuno Mamede
L2F INESC-ID / IST
Lisboa, Portugal
Nuno.Mamede@inesc-id.pt
Gabriel G. Be`s
GRIL / Univ. Blaise-Pascal
Clermont-Ferrand, France
BesGabriel@yahoo.fr
Abstract
This paper describes how we use the arrows
properties from the 5P Paradigm to generate
a dependency structure from a surface analy-
sis. Besides the arrows properties, two mod-
ules, Algas and Ogre, are presented. Moreover,
we show how we express linguistic descriptions
away from parsing decisions.
1 Introduction
Following the 5P Paradigm (Be`s, 1999; Hage`ge,
2000; Be`s and Hage`ge, 2001) we build a
syntactic-semantic interface which obtains a
graph from the analysis of input text. The
graph express a dependency structure, which is
the domain of a function that will obtain as out-
put a logic semantic interpretation.
The whole syntactic-semantic interface is in-
tegrated by four modules: Susana in charge
of surface analysis, Algas and Ogre, defining
the graph, and ASdeCopas, that obtains the
logic semantic representation. In this paper
we present the first three modules, focussing
mainly on Algas and Ogre.
5P argues for a carefully separation between
linguistic descriptions and algorithms. The first
ones are expressed by Properties and the last
ones by Processes. Futhermore, linguistic mod-
elised and formalised descriptions (i.e. Prop-
erties, P2 of 5P) are not designed to be the
declarative source of algorithms, but rather as
a repository of information (Hage`ge and Be`s,
2002) that one should be able to re-use (to-
tally or partially) in each task. Following and
completing this, we assume that the parsing is-
sue can be viewed from at least three different
points of view: (i) modelised and formalised
linguistic observation; (ii) computational effec-
tive procedures; (iii) useful computational con-
straints. These three aspects of the same issue
are distinctly tackled in the proposed syntactic-
semantic interface, but they converge in the ob-
tention of results.
There are three different kinds of Properties
(P2) in 5P: existence, linearity and arrow prop-
erties. The first two underly the Susana module
(3.1). They express which are the possible mor-
phological categories of some expression and the
possible order between them. The third ones
arrow properties specify arrow pairs, which for-
mally are directed arcs of a graph. Arrow prop-
erties underly the Algas (3.2) and Ogre (3.3)
modules. At the level of Projections (i.e. P3
of 5P) the balanced parentheses structure un-
derlying sentences is exploited (2). Computa-
tional useful constraints improve Algas perfor-
mance (5).
2 Arrow properties
The motivation behind an arrow property is to
connect two elements, because the established
relation is needed to reach the desired semantic
representation (Be`s, 1999). Notice that this for-
malism can be applied to establish dependencies
either between words, chunks or phrases. Nev-
ertheless, arrows can be seen as dependencies
but, contrary to the main dependency theories,
an arrow is not labeled and go from dependents
to the head (Hage`ge, 2000).
Let C be the set of category labels available,
M the set of chunk labels, P a set of phrase
labels and I a set of indexes.
Arrow Property: An arrow property is a
tuple (X, n, Z, Y, m, R+, R?) noted by:
Xn ?Z Ym,
+R+
-R?
where:
? X, Y ? M ? C (X is said to be the source
and Y the target of the arrow);
? Z ? M ? P (the segment labeled Z contains
X and Y);
? R+, R? are sets of constraints over the ar-
rows (respectively, the set of constraints
that Z must verify, either positive ones
(R+) on symbols which must be attested or
negative ones (R?) on symbols which must
not occur);
? n, m ? I.
Both R+, R? impose simple constraints over
the arrows, such as symbols that should or
should not occur within Z or linear order re-
lations that should be satisfied between its con-
stituents. As an example, the following ar-
row property says that within an interroga-
tive phrase (Pint), an interrogative chunk (IntC)
with an interrogative pronoun inside (pint) ar-
rows a nominal chunk (NC) on its right (i ?
k), as long as there is no other nominal chunk
between them (i ? j ? k).
IntCi({pint}/) ?Pint NCk
-{NCj}
A more complex type of constraint is the
?stack? constraint (Coheur, 2004). This con-
straint is based on the linguistically motivated
work over balanced parentheses of (Be`s and
Dahl, 2003; Be`s et al, 2003). Briefly, the
idea behind that work is the following: given
a sentence, if we introduce a left parentheses
everytime we find a word such as que(that),
se(if ), ...) ? the introducers ? and a right
parentheses everytime we find an inflected
verbal form1, at the end of the sentence, the
number of left parentheses is equal to the
number of right ones, and at any point of it,
the number of left ones is equal or greater
that the number of right ones (Be`s and Dahl,
2003). In (Be`s and Dahl, 2003), they use this
natural language evidence in order to identify
the main phrase, relatives, coordinations, etc.
Within our work, we use it to precise arrowing
relations. For example, consider the sentence
Quais os hote?is que te?m piscina? (Which are
the hotels that have a swimming pool? ). The
surface analysis of this statement results in the
following (where VC stands for verbal chunk):
(Quais)IntC (os hote?is)NC (que)RelC
(te?m)V C (piscina)NC
Typically the NC os hote?is arrows the main
VC, but in this situation, as there is no main VC
we want it to arrow itself. Nevertheless, there is
an arrow property saying that an NC can arrow
a VC, which applied to this particular situation
1See (Be`s and Dahl, 2003) for details about how to
deal with coordination.
would establish a wrong dependency (Figure 1).
Figure 1: Wrong dependency
Roughly, we use the stack constraint that says
that an NC arrows a VC if the stack of introduc-
ers and flexioned verbs is empty between them2:
NCi ?S VCk
+{stackj = [ ]}
As a result, if we consider again the example
Quais os hote?is que te?m piscina, the NC hote?is
will not arrow the VC te?m, because the stack
constraint is not verified between them (there
is only the introducer que).
3 Reaching the dependency
structure
3.1 Surface analysis
From existence and linearity properties (P2
of 5P) specifiyng chunks, it can be deduced
what categories can or must start a chunk,
and which ones can or must be the last one.
Drawing on this linguistic information, chunks
are detected in a surface analysis made by
Susana (Batista and Mamede, 2002). As an
example, consider the question Qual a maior
praia do Algarve? (Which is the biggest beach
in Algarve? ). Susana outputs the following
surface analysis (where PC stands for preposi-
tional chunk):
(Qual)IntC (a maior praia)NC (do Al-
garve)PC (? )Ponct
3.2 Algas
Algas is the C++ program responsible for con-
necting chunks and the elements inside them,
taking as input a structure that contains infor-
mation from arrow properties and also informa-
tion that can limit the search space (see section
4 from details about this). Additionally, as in-
side the majority of the chunks all the elements
arrow the last element (the head), the user can
declare which are the chunks that verify this
property. As a result, no calculus need to be
made in order to compute dependencies inside
these chunks: all its elements arrow the last one.
This possibility is computational very usefull.
2In fact, this restriction is a little more complicated
than this.
Continuing with our example, after Algas ex-
ecution, we have the output from Figure 2.
Both the IntC and the PC chunks arrow the
NC and inside them, all the elements arrow the
head.
Figure 2: Algas?s output.
Algas is able to skip unalyzable parts of a
sentence, but (for the moment) some constraints
are made to its output:
(1) There is at most an element arrowing itself,
inside each chunk;
(2) Cycles are not allowed;
(3) Arrow crossing is not allowed (projectiv-
ity);
(4) An element cannot be the target of an ar-
row if it is not the source of any arrow.
Notice that these constraints are made inside
the program. Notice that, in particular the pro-
jectivity requirement is not imposed by 5P. We
impose it, due to the fact that ? for the moment
? we are only dealing with written Portuguese,
that typically respects this property.
3.3 Ogre
After Algas, the text is processed by Ogre, a
pipeline of Perl and XSLT scripts, that gener-
ates a graph from the arrowed structures pro-
duced by Algas3. This process is based on the
following: if a chunk arrows another chunk, the
head of the first chunk will arrow the head of
the second chunk, and the chunk label can be
omitted.
Continuing with our example, after Ogre we
have the graph of Figure 3 (a dependency struc-
ture). Basically, IntC and PC head ? respec-
tively qual and Algarve ? arrow now the NC
head.
Figure 3: Ogre?s output.
3Arrowed structures produced by Algas can also be
seen as a graph, having nodes containing graphs.
It might seem that we are keeping away infor-
mation in this step, but the new arrowing rela-
tion between chunk heads keeps the lost struc-
tures. Beside, as information about the direc-
tion of the arrows is kept, and the position of
each word is also kept in the graph, we are
still able to distinguish behaviours dependent
on word order for the following semantic task.
That is, both semantic relations and word order
are kept within our graph.
Ogre?s motivation is to converge different
structures into the same graph. For example,
after Ogre?s execution O Ritz e? onde?, E? onde
o Ritz? and Onde e? o Ritz?, they all share the
same graph (appart from positions).
4 From descriptions to the
algorithm input structures
In order to keep descriptions apart from pro-
cessing, arrow properties and Algas input struc-
tures are developed in parallel. Then, arrow
properties are formally mapped into Algas in-
put structures (see (Coheur, 2004) for details).
This decision allowed us to add computational
constraints to Algas input structures, leaving
descriptions untouchable.
In fact, in order to reduce the search space,
Algas has the option of letting the user control
the distance between the source and the target
of an arrow. This is particularly very usefull
to control PP attachments (in this case PC
attachments). Thus, if we want a PC to arrow
an NC that is at most n positions away, we
simply say:
PC ?S NC [{NC <n PC}/]
Notice that we could make an extension over
the arrow properties formalism in order to al-
low this kind of information. Nevertheless, it
is well know that in natural language there is
no fix distance between two elements. Adding a
distance constraint over arrow properties would
add procedural information to a repository re-
sulting from natural language observations.
5 Applications
Both Algas and Ogre are part of a syntactic-
semantic interface, where the module responsi-
ble for the generation of logical forms is called
AsdeCopas (Coheur et al, 2003). This interface
has been applied in a semantic disambiguation
task of a set of quantifiers and also in question
interpretation.
Notice that, although arrows are not labeled,
the fact that we know its source, target and
direction, give us enough information to find
(or at least guess) a label for it. In fact, we
could add a label to the majority of the ar-
rows. For example, using the link-types from
the Link Grammar (Sleator and Temperley,
1993; Sleator, 1998), if an adverb connects an
adjective, this connection would be labeled EA,
if an adverb connects another adverb, the la-
bel would be EE. AsdeCopas can be used to
add this information to the graph. Neverthe-
less, the fact that we are using an unlabelled
connection serves languages as Portuguese par-
ticularly well. In Portuguese, it is not 100% sure
that we are able to identify the subject. For
example, we can say ?O Toma?s come a sopa.?,
?Come a sopa o Toma?s.?, or even ?A sopa come
o Toma?s.? having all the same (most probable)
interpretation: Thomas eats the soup. That is,
there is no misleading interpretation due to our
knowledge of the world: a man can eat a soup,
but a soup cannot eat a man. As so, arrow prop-
erties simply establish relations, and we leave to
semantic analysis the task of deciding what is
the nature of these relations.
6 Conclusions
We presented two modules ? Algas and Ogre
? that build a dependency graph from a sur-
face analysis. Algas uses information from a
formalism called arrows properties. Neverthe-
less this formalism is independent from Algas
input structures, that can be enriched with in-
formation that limits the relations to establish.
In the future we want the user to be able to
control the constraints over Algas output. That
is, the user will have the option to chose if out-
put may contain arrows crossing or not.
For the moment the Susana-Algas-Ogre mod-
ules of the syntactic-semantic interface behave
without problems in the domain of question
interpretation. They apply successfully to an
elicited corpus of questions produced by N por-
tuguese speakers which were asked to produce
them simulating effective and natural questions.
Our next step is to try to use them incremen-
tally (A??t-Mokhtar et al, 2002).
Also, another improvement will be over arrow
properties, as we want to organise them in a
hierarchy.
7 Acknowledgements
This paper was supported by FCT (Fundac?a?o
para a Cie?ncia e Tecnologia) and by Project
POSI/PLP/41319/2001 (FEDER).
References
Salah A??t-Mokhtar, Jean-Pierre Chanod, and
Claude Roux. 2002. Robustness beyound
shallowness: incremental deep parsing. Nat-
ural Language Engineering, pages 121?144.
Fernando Batista and Nuno Mamede. 2002.
SuSAna: Mo?dulo multifuncional da ana?lise
sinta?ctica de superf??cie. In Julio Gonzalo,
Anselmo Pen?as, and Antonio Ferra?ndez, ed-
itors, Proc. Multilingual Information Access
and Natural Language Processing Workshop
(IBERAMIA 2002), pages 29?37, Sevilla,
Spain, November.
Gabriel G. Be`s and Veronica Dahl. 2003. Bal-
anced parentheses in nl texts: a useful cue
in the syntax/semantics interface. In Nacy
Workshop on Prospects and Advances in the
Syntax/Semantics Interface.
Gabriel G. Be`s and Caroline Hage`ge. 2001.
Properties in 5P. Technical report, GRIL,
Universite? Blaise-Pascal, Clermont-Ferrand,
France, November.
Gabriel G. Be`s, Veronica Dahl, Daniel Guil-
lot, Lionel Lamadon, Ioana Milutinovici, and
Joana Paulo. 2003. A parsing system for bal-
anced parentheses in nl texts. In CLIN?2003.
Gabriel G. Be`s. 1999. La phrase verbal noyau
en franc?ais. In in Recherches sur le franc?ais
parle?, volume 15, pages 273?358. Universite?
de Provence, France.
Lu??sa Coheur, Nuno Mamede, and Gabriel G.
Be?s. 2003. ASdeCopas: a syntactic-semantic
interface. In Epia, Beja, Portugal, Dezembro.
Springer-Verlag.
Lu??sa Coheur. 2004. A interface entre a sin-
taxe e a sema?ntica no quadro das l??nguas
naturais. Ph.D. thesis, Instituto Superior
Te?cnico, Universidade Te?cnica de Lisboa,
Portugal, Universite? Blaise-Pascal, France.
work in progress.
Caroline Hage`ge and Gabriel G. Be`s. 2002. En-
coding and reusing linguistic information ex-
pressed by linguistic properties. In Proceed-
ings of COLING?2002, Taipei.
Caroline Hage`ge. 2000. Analyse Syntatic
Automatique du Portugais. Ph.D. thesis,
Universite? Blaise Pascal, Clermont-Ferrand,
France.
Daniel Sleator and Davy Temperley. 1993.
Parsing english with a link grammar. In Pro-
ceedings of the Third International Workshop
on Parsing Technologies.
Daniel Sleator. 1998. Summary of link types.
A step towards incremental generation of logical forms
Lu??sa Coheur
L2F INESC-ID / GRIL
Lisboa, Portugal
Luisa.Coheur@l2f.inesc-id.pt
Nuno Mamede
L2F INESC-ID / IST
Lisboa, Portugal
Nuno.Mamede@inesc-id.pt
Gabriel G. Be`s
GRIL / Univ. Blaise-Pascal
Clermont-Ferrand, France
Gabriel.Bes@univ-bpclermont.fr
Abstract
This paper presents AsdeCopas, a module de-
signed to interface syntax and semantics. Asde-
Copas is based on hierarchically organised se-
mantic rules, that output formulas in a flat lan-
guage. In this paper, we show how this system
can be used in the following applications: a) se-
mantic disambiguation; b) logical formulas con-
struction (in Minimal Recursion Semantics); c)
question interpretation.
1 Introduction
We present AsdeCopas, a syntax-semantic in-
terface based on hierarchically organised rules.
AsdeCopas is integrated in a system where
the input text is first transformed into a graph
and then passed to AsdeCopas. AsdeCopas can
be used in several ways.
It can be used to enrich the graph (Figure 1),
for example, by labeling its arrows.
          	 

 


 
    
  
 
Figure 1: Enriching the graph
It can be used in a desambiguation process
and to generate logical formulas. In this paper
we show how AsdeCopas can be used to choose
between several semantic values of some quan-
tifiers and also how it can generate underspec-
ified formulas in Minimal Recursion Semantics
(MRS) (Copestake et al, 2001). Additionally,
it can be used to add constraints to these under-
specified formulas. As AsdeCopas makes a con-
troled generation of variables, these new formu-
las can be simply added to the previous under-
specified MRS formulas and the rules respon-
sible for generating MRS underspecified struc-
tures remain unchangeable.
       Proceedings of ACL-08: HLT, Short Papers (Companion Volume), pages 1?4,
Columbus, Ohio, USA, June 2008. c?2008 Association for Computational Linguistics
Language Dynamics and Capitalization using Maximum Entropy
Fernando Batistaa,b, Nuno Mamedea,c and Isabel Trancosoa,c
a L2F ? Spoken Language Systems Laboratory - INESC ID Lisboa
R. Alves Redol, 9, 1000-029 Lisboa, Portugal
http://www.l2f.inesc-id.pt/
b ISCTE ? Instituto de Ci?ncias do Trabalho e da Empresa, Portugal
c IST ? Instituto Superior T?cnico, Portugal.
{fmmb,njm,imt}@l2f.inesc-id.pt
Abstract
This paper studies the impact of written lan-
guage variations and the way it affects the cap-
italization task over time. A discriminative
approach, based on maximum entropy mod-
els, is proposed to perform capitalization, tak-
ing the language changes into consideration.
The proposed method makes it possible to use
large corpora for training. The evaluation is
performed over newspaper corpora using dif-
ferent testing periods. The achieved results
reveal a strong relation between the capital-
ization performance and the elapsed time be-
tween the training and testing data periods.
1 Introduction
The capitalization task, also known as truecasing
(Lita et al, 2003), consists of rewriting each word
of an input text with its proper case information.
The capitalization of a word sometimes depends on
its current context, and the intelligibility of texts is
strongly influenced by this information. Different
practical applications benefit from automatic capi-
talization as a preprocessing step: when applied to
speech recognition output, which usually consists
of raw text, automatic capitalization provides rele-
vant information for automatic content extraction,
named entity recognition, and machine translation;
many computer applications, such as word process-
ing and e-mail clients, perform automatic capital-
ization along with spell corrections and grammar
check.
The capitalization problem can be seen as a se-
quence tagging problem (Chelba and Acero, 2004;
Lita et al, 2003; Kim and Woodland, 2004), where
each lower-case word is associated to a tag that de-
scribes its capitalization form. (Chelba and Acero,
2004) study the impact of using increasing amounts
of training data as well as a small amount of adap-
tation. This work uses a Maximum Entropy Markov
Model (MEMM) based approach, which allows to
combine different features. A large written news-
paper corpora is used for training and the test data
consists of Broadcast News (BN) data. (Lita et al,
2003) builds a trigram language model (LM) with
pairs (word, tag), estimated from a corpus with case
information, and then uses dynamic programming to
disambiguate over all possible tag assignments on a
sentence. Other related work includes a bilingual
capitalization model for capitalizing machine trans-
lation (MT) outputs, using conditional random fields
(CRFs) reported by (Wang et al, 2006). This work
exploits case information both from source and tar-
get sentences of the MT system, producing better
performance than a baseline capitalizer using a tri-
gram language model. A preparatory study on the
capitalization of Portuguese BN has been performed
by (Batista et al, 2007).
One important aspect related with capitalization
concerns the language dynamics: new words are in-
troduced everyday in our vocabularies and the usage
of some other words decays with time. Concerning
this subject, (Mota, 2008) shows that, as the time
gap between training and test data increases, the per-
formance of a named tagger based on co-training
(Collins and Singer, 1999) decreases.
This paper studies and evaluates the effects of lan-
guage dynamics in the capitalization of newspaper
1
corpora. Section 2 describes the corpus and presents
a short analysis on the lexicon variation. Section 3
presents experiments concerning the capitalization
task, either using isolated training sets or by retrain-
ing with different training sets. Section 4 concludes
and presents future plans.
2 Newspaper Corpus
Experiments here described use the RecPub news-
paper corpus, which consists of collected editions
of the Portuguese ?P?blico? newspaper. The corpus
was collected from 1999 to 2004 and contains about
148Million words. The corpus was split into 59 sub-
sets of about 2.5 Million words each (between 9 to
11 per year). The last subset is only used for testing,
nevertheless, most of the experiments here described
use different training and test subsets for better un-
derstanding the time effects on capitalization. Each
subset corresponds to about five weeks of data.
2.1 Data Analysis
The number of unique words in each subset is
around 86K but only about 50K occur more than
once. In order to assess the relation between the
word usage and the time gap, we created a number
of vocabularies with the 30K more frequent words
appearing in each training set (roughly corresponds
to a freq > 3). Then, the first and last corpora subsets
were checked against each one of the vocabularies.
Figure 1 shows the correspondent results, revealing
that the number of OOVs (Out of VocabularyWords)
decreases as the time gap between the train and test
periods gets smaller.
??
??
???
???
???
???
???
???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????
??
????? ?????
???? ????
Figure 1: Number of OOVs using a 30K vocabulary.
3 Capitalization
The present study explores only three ways of
writing a word: lower-case, all-upper, and first-
capitalized, not covering mixed-case words such as
?McLaren? and ?SuSE?. In fact, mixed-case words
are also being treated by means of a small lexicon,
but they are not evaluated in the scope of this paper.
The following experiments assume that the capi-
talization of the first word of each sentence is per-
formed in a separated processing stage (after punc-
tuation for instance), since its correct graphical form
depends on its position in the sentence. Evaluation
results may be influenced when taking such words
into account (Kim and Woodland, 2004).
The evaluation is performed using the met-
rics: Precision, Recall and SER (Slot Error Rate)
(Makhoul et al, 1999). Only capitalized words (not
lowercase) are considered as slots and used by these
metrics. For example: Precision is calculated by di-
viding the number of correct capitalized words by
the number of capitalized words in the testing data.
The modeling approach here described is discrim-
inative, and is based on maximum entropy (ME)
models, firstly applied to natural language problems
in (Berger et al, 1996). An ME model estimates
the conditional probability of the events given the
corresponding features. Therefore, all the infor-
mation must be expressed in terms of features in
a pre-processing step. Experiments here described
only use features comprising word unigrams and bi-
grams: wi (current word), ?wi?1, wi? and ?wi, wi+1?
(bigrams). Only words occurring more than once
were included for training, thus reducing the number
of misspelled words. All the experiments used the
MegaM tool (Daum? III, 2004), which uses conju-
gate gradient and a limited memory optimization of
logistic regression. The following subsections de-
scribe the achieved results.
3.1 Isolated Training
In order to assess how time affects the capitalization
performance, the first experiments consist of pro-
ducing six isolated language models, one for each
year of training data. For each year, the first 8 sub-
sets were used for training and the last one was used
for evaluation. Table 1 shows the corresponding
capitalization results for the first and last testing sub-
2
Train 1999-12 test set 2004-12 test set
Prec Rec SER Prec Rec SER
1999 94% 81% 0.240 92% 76% 0.296
2000 94% 81% 0.242 92% 77% 0.291
2001 94% 79% 0.262 93% 76% 0.291
2002 93% 79% 0.265 93% 78% 0.277
2003 94% 77% 0.276 93% 78% 0.273
2004 93% 77% 0.285 93% 80% 0.264
Table 1: Using 8 subsets of each year for training.
???
???
???
???
???
??? ??? ??? ??? ??? ???
??
?????????
????????? ?????????
Figure 2: Performance for different training periods.
sets, revealing that performance is affected by the
time lapse between the training and testing periods.
The best results were always produced with nearby
the testing data. A similar behavior was observed on
the other four testing subsets, corresponding to the
last subset of each year. Results also reveal a degra-
dation of performance when the training data is from
a time period after the evaluation data.
Results from previous experiment are still worse
than results achieved by other work on the area
(Batista et al, 2007) (about 94% precision and 88%
recall), specially in terms of recall. This is caused
by a low coverage of the training data, thus reveal-
ing that each training set (20Million words) does not
provide sufficient data for the capitalization task.
One important problem related with this discrim-
inative approach concerns memory limitations. The
memory required increases with the size of the cor-
pus (number of observations), preventing the use
of large corpora, such as RecPub for training, with
Evaluation Set Prec Rec SER
2004-12 test set 93% 82% 0.233
Table 2: Training with all RecPub training data.
Checkpoint LM #lines Prec Rec SER
1999-12 1.27 Million 92% 77% 0.290
2000-12 1.86 Million 93% 79% 0.266
2001-12 2.36 Million 93% 80% 0.257
2002-12 2.78 Million 93% 81% 0.247
2003-12 3.10 Million 93% 82% 0.236
2004-08 3.36 Million 93% 83% 0.225
Table 3: Retraining from Jan. 1999 to Sep. 2004.
available computers. For example, four million
events require about 8GB of RAM to process. This
problem can be minimized using a modified train-
ing strategy, based on the fact that scaling the event
by the number of occurrences is equivalent to multi-
ple occurrences of that event. Accordingly to this,
our strategy to use large training corpora consists
of counting all n-gram occurrences in the training
data and then use such counts to produce the cor-
responding input features. This strategy allows us
to use much larger corpora and also to remove less
frequent n-grams if desired. Table 2 shows the per-
formance achieved by following this strategy with
all the RecPub training data. Only word frequen-
cies greater than 4 were considered, minimizing the
effects of misspelled words and reducing memory
limitations. Results reveal the expected increase of
performance, specially in terms of recall. However,
these results can not be directly compared with pre-
vious work on this subject, because of the different
corpora used.
3.2 Retraining
Results presented so far use isolated training. A new
approach is now proposed, which consists of train-
ing with new data, but starting with previously cal-
culated models. In other words, previously trained
models provide initialized models for the new train.
As the training is still performed with the new data,
the old models are iteratively adjusted to the new
data. This approach is a very clean framework for
language dynamics adaptation, offering a number of
advantages: (1) new events are automatically con-
sidered in the new models; (2) with time, unused
events slowly decrease in weight; (3) by sorting the
trained models by their relevance, the amount of data
used in next training stage can be limited without
much impact in the results. Table 3 shows the re-
3
???
???
???
???
???
???
???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????
??
?????????
??????????? ???????????
Figure 3: Training forward and backwards
sults achieved with this approach, revealing higher
performance as more training data is available.
The next experiment shows that the training or-
der is important. In fact, from previous results, the
increase of performance may be related only with
the number of events seen so far. For this reason,
another experiment have been performed, using the
same training data, but retraining backwards. Corre-
sponding results are illustrated in Figure 3, revealing
that: the backwards training results are worse than
forward training results, and that backward training
results do not allways increase, rather stabilize af-
ter a certain amount of data. Despite the fact that
both training use all training data, in the case of for-
ward training the time gap between the training and
testing data gets smaller for each iteration, while in
the backwards training is grows. From these results
we can conclude that a strategy based on retraining
is suitable for using large amounts of data and for
language adaptation.
4 Conclusions and Future Work
This paper shows that maximum entropy models
can be used to perform the capitalization task, spe-
cially when dealing with language dynamics. This
approach provides a clean framework for learning
with new data, while slowly discarding unused data.
The performance achieved is almost as good as us-
ing generative approaches, found in related work.
This approach also allows to combine different data
sources and to explore different features. In terms
of language changes, our proposal states that differ-
ent capitalization models should be used for differ-
ent time periods.
Future plans include the application of this work
to BN data, automatically produced by our speech
recognition system. In fact, subtitling of BN has led
us into using a baseline vocabulary of 100K words
combined with a daily modification of the vocabu-
lary (Martins et al, 2007) and a re-estimation of the
language model. This dynamic vocabulary provides
an interesting scenario for our experiments.
Acknowledgments
This work was funded by PRIME National Project
TECNOVOZ number 03/165, and FCT project
CMU-PT/0005/2007.
References
F. Batista, N. J. Mamede, D. Caseiro, and I. Trancoso.
2007. A lightweight on-the-fly capitalization system
for automatic speech recognition. In Proc. of the
RANLP 2007, Borovets, Bulgaria, September.
A. L. Berger, S. A. Della Pietra, and V. J. Della
Pietra. 1996. A maximum entropy approach to nat-
ural language processing. Computational Linguistics,
22(1):39?71.
C. Chelba and A. Acero. 2004. Adaptation of maxi-
mum entropy capitalizer: Little data can help a lot.
EMNLP04.
M. Collins and Y. Singer. 1999. Unsupervised models
for named entity classification. In Proc. of the Joint
SIGDAT Conference on EMNLP.
H. Daum? III. 2004. Notes on CG and LM-BFGS opti-
mization of logistic regression.
J. Kim and P. C. Woodland. 2004. Automatic capitalisa-
tion generation for speech input. Computer Speech &
Language, 18(1):67?90.
L. V. Lita, A. Ittycheriah, S. Roukos, and N. Kambhatla.
2003. tRuEcasIng. In Proc. of the 41st annual meet-
ing on ACL, pages 152?159, Morristown, NJ, USA.
J. Makhoul, F. Kubala, R. Schwartz, and R. Weischedel.
1999. Performance measures for information extrac-
tion. In Proceedings of the DARPA Broadcast News
Workshop, Herndon, VA, Feb.
C. Martins, A. Teixeira, and J. P. Neto. 2007. Dynamic
language modeling for a daily broadcast news tran-
scription system. In ASRU 2007, December.
Cristina Mota. 2008. How to keep up with language
dynamics? A case study on Named Entity Recognition.
Ph.D. thesis, IST / UTL.
Wei Wang, Kevin Knight, and Daniel Marcu. 2006. Cap-
italizing machine translation. In HLT-NAACL, pages
1?8, Morristown, NJ, USA. ACL.
4
Proceedings of the Workshop on Lexical and Grammatical Resources for Language Processing, pages 92?101,
Coling 2014, Dublin, Ireland, August 24 2014.
The fuzzy boundaries of operator verb and support verb constructions
with dar ?give? and ter ?have? in Brazilian Portuguese
Amanda Rassi
1,2,3
, Cristina Santos-Turati
1,2,3
, Jorge Baptista
2,3
, Nuno Mamede
3
, Oto Vale
1
{aprassi,mcturati,jbaptis}@ualg.pt, nuno.mamede@inesc-id.pt, otovale@ufscar.br
1
UFSCar, Rodovia Washington Lu??s, km 235 - SP-310 S?ao Carlos-SP, Brazil
2
UAlg/CECL, Campus de Gambelas, 8005-139 Faro, Portugal
3
INESC-ID Lisboa/L2F, Rua Alves Redol, n.
o
9, 1000-029 Lisboa, Portugal
Abstract
This paper describes the fuzzy boundaries between support verb constructions (SVC) with ter
?have? and dar ?give? and causative operator verb (VopC) constructions involving these same
verbs, in Brazilian Portuguese (BP), which form a complex set of relations: (i) both verbs are
the support verb of the same noun (SVC); (ii) dar is the standard (active-like) SVC while ter
is a converse (passive-like) SVC; and (iii) dar is a VopC, operating on a ter SVC. In this paper
we have systematically studied these complex relations involving SVC and VopC for BP, which
constitute a challenge to Natural Language Processing (NLP) systems, and have been often ig-
nored in related work. The paper proposes a lexically-based strategy to implement SVC in a
fully-fledged, rule-based parsing system, yielding an adequate semantic structure of the events
(predicates) denoted by predicative nouns in SVC.
1 Introduction: basic concepts and a little history
The notion of support verb has been in use for a long time, under many different theoretical perspectives
and various terminologies. In this paper, we adopt the Zellig S. Harris?s (1991) transformational operator
grammar framework. As early as 1964, Harris (1964, p.216-7) proposed the concept and named this
particular type of construction as ?U operator? nominalizations, linking sentences such as He studies
eclipes = He makes studies of eclipses. It was, however, M. Gross (1981) who first provided the definition
of support verb we will rely upon here. The support verb make (in the example above) can be seen as
a sort of an auxiliary of the predicative noun studies, in charge of carrying the grammatical values of
tense and person-number agreement that the noun is morphologically unable to express. In many cases,
support verbs are practically devoid of meaning. For lack of space, we cannot detail further the properties
of SVC, and only the briefest outline is provided here; a good overview can be found in (Gross, 1996;
Gross, 1998; Lamiroy, 1998).
One of the most important theoretical contribution of the notion of support verb came from the fact
that it provides a natural framework to adequately include in the kernel sentences of the language the
large number of ?abstract? nouns, which do not have neither a verbal nor an adjectival counterpart; that
is, they are isolated or autonomous nouns, lacking any nominalizations (in a synchronic perspective,
at least). This phenomenon is particularly evident in Romance languages (French, Italian, Portuguese,
Romanian and Spanish): FR: Jean a fait gr`eve ?Jean did strike?; IT: Giovanni ha fatto sciopero ?id.?;
PT: O Jo?ao fez greve ?id.?; RU: Ioan a f?acut grev?a ?id.?; SP: Joan hizo huelga ?id.?; cp. EN: *John did
strike, John was on strike).
Finally, nominal constructions are unlike any other predicative part-of-speech by the fact that predica-
tive nouns can present more than one construction with different support verbs, while still expressing the
same semantic predicate. Hence, for example, greve ?strike? can have a SVC with both fazer ?to make?
(as above) and estar em ?to be in?: O Jo?ao est?a em greve ?Jo
?ao is on strike? (Ranchhod, 1990). Each
SVC has its own specific properties, e.g. only SVC with fazer can undergo passive, while the general
predicate remains the same.
This work is licenced under a Creative Commons Attribution 4.0 International License. Page numbers and proceedings
footer are added by the organizers. License details: http://creativecommons.org/licenses/by/4.0/
92
In this paper, we also consider the concept of operator verb (VopC), introduced in the same paper
(Gross, 1981, p. 23-39); two relatively clear situations were distinguished:
? a causative operator verb (VopC), which adds a new element to an elementary sentence; this ele-
ment has an easily identifiable meaning: CAUSE; distributionally, this element suffers very loose
constraints (and we define this as a distributionally non constraint position (Nnr)); if the base sen-
tence under the operator is a support verb construction 1, the VopC may ?absorb? the support verb
and it may also introduce some formal changes in that sentence 1;
(1) Isso d?a # Max tem (fome + medo + sede).
1
?This gives # Max has (hungry + fear + thirst).?
(2) Isso d?a (fome + medo + sede) em Max. ?This gives Max (hungry + fear + thirst).?
In (2), the support verb ter is absorbed under the operator dar and its subject becomes a dative, indirect
complement, though the semantic roles of subject of dar (CAUSE) and of the subject of the predicative
noun (EXPERIENCER), after this restructuring, remain the same.
? a linking operator-verb (VopL), which hardly modifies the meaning of the underlying sentence; it
also adds an argument to the base sentence 1, but this is not a new one since it is bounded linked to
a noun complement of the base sentence 1 (Ranchhod, 1990).
(3) Max tem # Ana est?a sob o controle do Max. ?Max has # Ana is under Max?s control.?
(4) = Max
i
tem Ana sob o (seu
i
+ *meu + *teu) controle. ?Max
i
has Ana under (his
i
+ *my + *your)
control.?
This paper reports an ongoing research to systematically classify the predicative nouns built with the
support verbs dar and ter in Brazilian Portuguese (Rassi and Vale, 2013; Santos-Turati, 2012). Similar
work has already been developed for the European variety (Vaza, 1988; Ranchhod, 1990; Baptista, 1997;
Baptista, 2005). For many languages, including Portuguese, the studies on support verb constructions
and causative constructions use a lexical approach, aiming at building dictionaries or lists of predicative
nouns or at identifying those constructions (semi)automatically, e.g. for Portuguese (Hendrickx et al.,
2010; Duran et al., 2011), for English (Grefenstette and Teufel, 1995), for German (Hanks et al., 2006;
Storrer, 2007) and many other languages. As far as we could ascertain, no implementation of these SVC
constructions has been made yet in NLP systems, particularly in parsers. Most systems considering these
constructions just treat them as multiword expressions, ignoring their internal syntactic structure.
In this paper, we will show the complex set of relations involved in these SVC, where these verbs
can function not only as support but also as operator verbs, thus rendering their description remarkably
complex, particularly in view of Natural Language Processing. We aim at capturing the syntactic de-
pendencies involved in these expressions, not as multiword, fixed strings, but as analyzable syntactic
structures.
The paper is structured as follows: Next, Section 2 presents the current state of the collection and
classification if these SVC in Brazilian Portuguese; Section 3 illustrates the syntactic-semantic relations
between different constructions of ter and dar; Section 4 proposes a strategy for implementing the data in
a rule-based parsing system; and, finally, Section 5 presents some concluding remarks and perspectives
on future work.
2 Support verb constructions with ter ?have? and dar ?give?
The predicative nouns in this paper select the support verbs dar ?give? and ter ?have?, and were retrieved
from previous lists of predicative nouns in European Portuguese (Vaza, 1988; Baptista, 1997) and from
the PLN.BR Full corpus (Bruckschein et al., 2008). This corpus contains 103,080 texts, with 29 million
tokens, consisting of news pieces from Folha de S?ao Paulo, a Brazilian newspaper (from 1994 to 2005).
All these constructions were validated in real data, and in some cases also ressourcing to the web.
1
In the examples, elements between brackets and separated by the ?+? sign can all appear in that given syntactic slot. The
symbol ?#? delimits clauses, while the ?*? mark signals the sentence as unacceptable. Correferent elements are linked by
correference indexes
i
. For clarity, all support verbs will be shown without italics in the examples. An approximate translation
of Portuguese examples is provided, but its acceptability is irrelevant for the paper.
93
2.1 Nominal predicates with support verb ter ?have?
We adopted several criteria that allowed us to constitute lexical-syntactic, relatively homogeneous,
classes. These criteria were inspired in those taken from previous classifications, developed in the
Lexicon-grammar framework of Maurice Gross (1975; 1988; 1996), for both Portuguese and other lan-
guages. The main classification criteria can be summarized as follows: (i) the number of arguments,
considering constructions with a subject and one or two essential complements as arguments; (ii) the
possibility of a noun admitting a sentential construction (in subject or complement position); (iii) the
distributional nature of the arguments: if they are obligatorily human or allow for non-human nouns; (iv)
the property of symmetry
2
between the arguments.
Following these criteria, we have so far classified around 1,000 nominal constructions from a list with
3,000 candidates of predicative nouns censed in the corpus (Santos-Turati, 2012). The already classified
nominal predicates that select the support verb ter ?have? in Brazilian Portuguese were divided into 9
classes (Table 1)
3
.
Class Structure Example/Gloss Count
TH1 Nhum
0
ter Npred Ana tem uma beleza impressionante 465
?Ana has an amazing beauty?
TNH1 N-hum
0
ter Npred A tinta tem um tom escuro 138
?The paint has a dark tone?
TR1 N?hum
0
ter Npred (Ana + a m?usica) tem um ritmo contagiante 139
?(Ana + the music) has a contagious rhythm?
TH2 Nhum
0
ter Npred Prep Nhum
1
Ana tem respeito por Max 111
?Ana has respect for Max?
TNH2 N-hum
0
ter Npred Prep Nhum
1
O bombom tem gosto de avel?a 6
?The bonbon has taste like hazelnut?
TR2 N?hum
0
ter Npred Prep N-hum
1
(O carro + a cidade) tem um alto consumo de ?agua 22
?(The car + the city) has a high consumption of water?
TS2 Nhum
0
ter Npred Prep Nhum
1
O patr?ao tem um acordo com o empregado 38
(Simetry) ?The boss has an agreement with the employee?
TQF1 QueF
0
ter Npred Prep N
1
Esse fato tem uma grande import?ancia para Ana 6
?This fact has a great importance for Ana?
TQF2 N
0
ter Npred Prep QueF
1
Ana tem medo de dirigir na estrada 80
?Ana has fear to drive on the road?
TOTAL 1,005
Table 1: SVC with support verb ter (Santos-Turati, 2012)
2.2 Nominal predicates with support verb dar ?give?
The same criteria were also adopted for SVC with verb dar ?give? (Rassi and Vale, 2013), though
two differences were considered: (i) the constructions with a body-part noun (Npc) as argument were
distinguished as a special class for their particular properties; and (ii), no symmetric constructions were
found. We classified 900 support verb constructions with verb dar ?give? in Brazilian Portuguese into
11 classes (Table 2).
3 Relations between ter ?have? and dar ?give?
First of all, it is necessary to distinguish three different kinds of relations established between verb dar
and verb ter constructions. The first type of relation considers the verbs dar ?give? and ter ?have? as
synonymous and classified as standard support verb constructions. The verb dar can replace the verb ter
without any changes in the meaning of the sentence or in the selection restrictions of the arguments:
2
The notion of symmetry in verbal constructions was initially presented by Borillo (1971) for French verbs - Paul rencontre
son fr`ere ?Paul meets his brother? / Paul et son fr`ere se rencontrent ?Paul and his brother meet?. In the case of the Portuguese
nominal constructions, symmetry was presented in Ranchhod (1990) and Baptista (2005), who described the nominal predicates
with the support verbs estar com and ser de, respectively.
3
In Table 1 and Table 2, the left column shows the conventional codes for designating each class; and the second column
represents its syntactic structure, indicated as follows: Nhum and N-hum for human and non-human noun respectively; N?hum
for both human or non-human noun; Npc for body-part noun; the indexes ?
0
? and ?
1
? indicate the subject and the complement
position, respectively; Npred stand for the predicative noun; Prep for preposition; QueF for completive.
94
Class Structure Example/Gloss Count
DH1 Nhum
0
dar Npred Ana deu uma pirueta 133
?Ana gave a pirouette?
DNH1 N-hum
0
dar Npred O bal?ao deu um estouro 20
?The baloon gave a burst?
DR1 N? hum
0
dar Npred (Max + O clima) deu uma refrescada 51
?(Max +The weather) gave a refreshed?
DH2 Nhum
0
dar Npred Prep Nhum
1
Max deu um castigo para a Ana 217
?Max gave a punishment to Ana?
DNH2 Nhum dar Npred Prep N-hum
1
Ana deu uma cozida nos legumes 137
?Ana gave a cooked in the vegetables?
DPC2 Nhum
0
dar Npred Prep Npc
1
Max deu um tapa na cara da Ana 114
?Max gave a slap in Ana?s face?
DQF2 Nhum
0
dar Npred Prep QueF
1
Max deu um jeito de consertar o carro 52
?Max gave a way to fix the car?
DHR2 Nhum
0
dar Npred Prep N? hum
1
Ana deu destaque ao (Max + problema) 60
?Ana gave emphasis to (Max + the problem)?
DRH2 N? hum
0
dar Npred Prep Nhum
1
(Ana + O telhado) deu protec??ao ao Max 32
?(Ana + The roof) gave protection to Max?
DR2 N? hum
0
dar Npred Prep N-hum
1
(Ana+A lei) deu embasamento `a teoria 25
?(Ana+The law) gave basis to the theory?
D3 N
0
dar Npred Prep N
1
Prep N
2
Ana deu um apelido de macaco ao Max 59
?Ana gave the nickname monkey to Max?
TOTAL 900
Table 2: SVC with support verb dar (Rassi and Vale, 2013)
(5) Ana (deu + teve) um + um(a) (birra + chilique + pirepaque + tremelique + troc?o).
?Ana (gave + had) (a + an) (tantrum + hissy fit + outburst + shiver + thing).?
The second type of relation concerns the transformation named Conversion by G. Gross (1982; 1989),
in which the predicative noun is maintained and their arguments change their relative position, without,
however, changing their semantic roles. In these constructions, the sentence with AGENT subject is
called the standard construction, while its equivalent sentence with the reversed argument order is called
the converse construction. Usually, the support verbs of the standard and the converse construction are
different, as it is also the preposition introducing the converse complement:
(6) Ana deu algum apoio ao Max. ?Ana gave some support to Max.?
[Conv.] = Max teve algum apoio da Ana. ?Max had some support from Ana.?
The third kind of relation linking the sentences with the verb ter and the verb dar is the causative
operator construction (already mentioned in ?1):
(7) Isso deu # Ana tem coragem. ?This gave # Ana has courage.?
= Isso deu coragem `a Ana. ?This gave courage to Ana.?
These three types of relations are presented in the table below, with an example and the respective
number of constructions in each type. From the intersection between the list of predicative nouns con-
structed with verb ter ?have? and those with verb dar ?give?, we found 693 predicative nouns, distributed
as shown in Table 3.
dar ?give? ter ?have? Example/Gloss Count
SVCstandard SVCstandard Ana deu um chilique ?Ana gave a hissy fit?
Ana teve um chilique ?Ana had a hissy fit? 35
SVCstandard SVCconverse O policial deu uma multa ao Max ?The officer gave Max a fine?
Max teve uma multa ?Max had a fine? 72
VopCausative SVCstandard A flor deu alergia a Ana ?The flower gave allergy to Ana?
(VopC) Ana tem alergia `a flor ?Ana has an allergy? 586
Table 3: Comparative table with syntactic relations
95
3.1 Verbs dar and ter in standard SVC
Around 4.8% of the predicative nouns (35 constructions) accept both support verbs dar and ter in stan-
dard constructions, such as:
(8) A empresa (d?a + tem) atenc??ao ao cliente. ?The company (gives + has) attention to the client.?
(9) O rem?edio (d
?a + tem) um efeito positivo no organismo. ?The medicine (gives + has) a positive effect
on human body.?
(10) O resultado (deu + teve) um impacto significativo para o time. ?The result (gave + had) a significant
impact to the team.?
In Brazilian Portuguese, around 35 predicative nouns, such as febre ?fever? and dengue ?dengue?,
besides having both dar and ter as their support verb also allow dar as a causative operator on them
(examples taken from the web):
[VopC]: [Sua lic??ao de casa:] ?agua parada d
?a dengue. ?[...] still water gives (= causes) dengue.?
[CVS dar]: Inclusive, a vizinha tamb?em deu dengue. ?Inclusive, the neighbour gave (= had) dengue.?
[CVS ter]: O meu esposo j?a teve dengue. ?My husband already had dengue.?
A few nouns (around 10), such as amor ?love?, confianc?a ?trust? and respeito ?respect?, besides
admitting the two support verbs in their basic construction, also admit ter in a converse construction:
(11) O filho d?a respeito `a m?ae. ?The son gives respect to the mother.?
= O filho tem respeito pela m?ae. ?The son has respect for the mother.?
[conv.] = A m?ae tem o respeito do filho. ?The mother has respect from her son.?
3.2 Verb dar as standard SVC and ter as converse SVC
Around 10.4% of the predicative nouns (72 constructions) admit the verb dar in the standard construction
and the verb ter in a converse construction, but not ter as a standard support. In Brazilian Portuguese,
predicative nouns constructed with the support verb dar in a standard construction accept other converse
verbs beyond the verb ter ?have?, such as receber ?receive?, ganhar ?gain?, levar ?get? and tomar
?take?
4
.
(12) Ana deu protec??ao ao Max. ?Ana gave protection to Max.?
= Max (teve + recebeu) a protec??ao da Ana. ?Max (had + received) the protection from Ana.?
(13) Ana deu uma ajuda ao Max. ?Ana gave a help to Max.?
= Max (teve + ganhou) uma ajuda da Ana. ?Max (had + gained) a help from Ana.?
(14) Ana deu uma resposta no Max. ?Ana gave an answer to Max.?
= Max (teve + levou) uma resposta da Ana. ?Max (had + got) an answer from Ana.?
(15) O policial deu uma multa ao Max. ?The officer gave a fine to Max.?
= Max (teve + tomou) uma multa do policial. ?Max (had + took) a fine from the officer.?
3.3 Verb dar as VopC and ter as SVC
Around 84.8% (586 predicative nouns) of the elementary constructions with the support verb ter ?have?
also allow the causative operator verb dar ?give?; some of these nouns constitute relatively homogenous
semantic sets, e.g. the predicative nouns that express <feeling>, <sensation>, <emotion> or those that
indicate <disease> (this semantic classification is just approximative):
4
For European Portuguese equivalent converse constructions, see Baptista (1997); for a comparison between the two lan-
guage variants, see Rassi et al. (2014).
96
(16) Ana tem alegria. ?Ana has happiness.?
(Z?e + A vinda do Z?e + O fato de Z?e ter voltado + Isso) deu alegria `a Ana.
?(Z?e + Z?e?s coming + The fact of Z?e has came + That) gave happiness to Ana.?
(17) Ana tem c?olica. ?Ana has colic.?
(O chocolate + O fato de ter comido chocolate + Isso) deu c?olica na Ana.
?(The chocolat + The fact of she has eaten chocolat + That) gave a colic in Ana.?
These predicative nouns allow a particular (impersonal?) construction with dar, in which the argument
in subject position is not explicit, so the CAUSE element is also absent, and the sentence has the same
overall meaning of the SVC with verb ter standard, but with an inchoative aspect; notice that the verb
dar must be in the 3
rd
person singular, and it does not agree with the predicative noun:
(18) (Deu + *Deram) (uma) (alegria + c?olica) na Ana. ?Gives/gave (a) (hapiness + colic) in Ana.?
= Ana teve (uma) (alegria + c?olica). ?Ana had (a) (hapiness + colic).?
(19) (Deu + ?*Deram) umas (palpitac??oes + c?olicas) na Ana. ?Gives/gave some (palpitations + colics) in
Ana.?
= Ana teve umas (palpitac??oes + c?olicas). ?Ana had some (palpitations + colics).?
3.4 Formalization into the Lexicon-Grammar
Because of the complex relations and the different syntactic status that the verbs dar and ter may show,
these constructions are essentially determined by the lexicon, i.e., they depend on the specific predicative
noun. It is only natural that a lexically-based approach be taken in order to describe this properties, partic-
ularly in view of the implementation of such type of expressions in NLP systems. The Lexicon-Grammar
framework constitutes such a methodological setting, as it presupposes the extensive and systematical
survey and formal representation of the lexicon properties.
In the Lexicon-Grammar, a systematic description of linguistic phenomena is usually presented in
the form of binary matrices: the lines contain the lexical entries while the columns represent syntactic-
semantic properties of each entry. For example, for each predicative noun, distributional constraints
on the arguments are represented; the elementary support verb and the main variants of this verb are
encoded; the possibility of accepting conversion and the converse support verbs are explicitly provided;
and all these syntactic-semantic informations are specified for each predicative noun. Besides its intrinsic
linguistic interest, the main purpose for this formalization requirements is the application of the data in
NLP. In the next section, we present a preliminary proposal for the implementation problems of these
type of SVC in a rule-based parsing system of Portuguese.
4 Towards the implementation of SVC in a NLP system
Besides its linguistic interest, one of the goals of the formal representation of the lexical properties of
predicative nouns and SVC into a Lexicon-Grammar such as described above (?3.4) is to allow for the
implementation of these data in NLP systems. In this section an outline of the strategy adopted for
its implementation specifically into a rule-based system, namely STRING (Mamede et al., 2012)
5
, is
presented. This is still an on-going work, so in the next lines we briefly sketch the system?s architecture
(?4.1.) and then (?4.2.) we present the strategy that we intend to implement for the adequate parsing of
SVC with ter and dar, having in mind the complex structures and relations mentioned in ?3.
4.1 STRING architecture
STRING is an NLP chain with a modular structure that executes all the basic processing tasks, namely:
tokenization and text segmentation, part-of-speeh tagging, morphosyntactic disambiguation, shallow
parsing (chuking) and deep parsing (dependency extraction). The parsing stage is performed by the
rule-based parser XIP (Xerox Incremental Parser) (Mokhtar et al., 2002). XIP identifies the elementary
5
http://string.l2f.inesc-id.pt/
97
constituents of a sentence, such as noun phrases (NP) or prepositional phrases (PP), and then these are
structured by binary dependencies between them, corresponding to the syntactic relations, such as sub-
ject (SUBJ), direct complement (CDIR) or modifier (MOD). STRING also extracts Named Entities,
performs time expressions identification and normalization, Anaphora Resolution and some Word-Sense
disambiguation (WSD).
At the final stages of parsing, the system extracts the text events (or predicates) and their participants
(arguments). The system currently extracts the EVENT structure for all full verbs and predicative nouns.
In the case of verbs, it associates the events to their participants and circumstances, identifying their
corresponding semantic roles (Talhadas, 2014), based on the sentence parse and the information available
on the Portuguese full verbs Lexicon-Grammar (Baptista, 2012)
6
. Hence, for a sentence such as (20),
the system parser extracts the event structure by way of the following dependencies:
(20) Max costuma ler o jornal no caf?e `as sextas-feiras. ?Max uses to read the newspaper at the caff
?ee on
Fridays.?
EVENT AGENT(ler,Max)
EVENT OBJECT(ler,jornal)
EVENT LOC-PLACE(ler,caf?e)
EVENT TIME-FREQUENCY(ler,a as sextas-feiras)
4.2 Strategy
In the case of a predicative noun in a SVC, one would want the predicative noun also to be captured as an
EVENT, but not the support verb, since its role is basically that of an auxiliary of the noun. However, since
the support verb conveys several important grammatical information, particularly the standard/converse
orientation of the predicate
7
, a SUPPORT dependency is first extracted, so in sentences such as in (21)
one would get the dependency shown below:
(21) Max deu um beijo na Ana. ?Max gave a kiss in Ana.?
SUPPORT STANDARD(beijo,deu)
To do so, one needs to provide the system with the information that dar is the (basic) standard support
verb of the predicative noun beijo ?kiss?. It is also necessary to know that in this construction, the
predicative noun is the direct complement (CDIR) of the support verb and that the dative complement
can be introduced, in Brazilian Portuguese, by preposition em ?in/on?. The following rules illustrate (in
a simplified way
8
) the functioning of the rule-based system:
if (CDIR(#1[lemma:dar],#2[lemma:beijo]) & ?SUPPORT(#2,#?))
SUPPORT[vsup-standard](#1,#2)
if (SUPPORT(#1,?))
EVENT[OTHER=+](#1).
if (SUPPORT[vsup-standard](#1[lemma:beijo],#2) &
EVENT[other](#1) & SUBJ(#2,#3))
EVENT[agent-generic=+](#1,#3).
if (SUPPORT[vsup-standard](#1[lemma:beijo],#2) & EVENT[other](#1) &
?MOD(#2,#3) & PREPD(#3,?[lemma:em]) )
COMPL(#1,#3),
EVENT[patient=+](#1,#3).
6
This semantic role information is still not available for the predicative nouns, but it is currently being encoded.
7
The support verb can convey aspectual, modal and even stylistic values, which are encoded in the lexicon and remain
available in the system?s output, even if not necessarily visible in the EVENT representation.
8
The rule system should also take into account the distributional constraints on the argument slots, but, for simplicity, we
dismissed it in this paper.
98
if (SUPPORT[vsup-standard](#1[lemma:beijo],#2) & EVENT[other](#1) &
(?MOD[dat](#2,#3) || ?CLITIC(#2,#3[dat]) ) )
CINDIR[dat=?](#1,#3),
EVENT[patient=+](#1,#3).
The rules read as follows: First, a SUPPORT dependency with the feature VSUP-STANDARD is
extracted when the noun beijo ?kiss? is the direct complement of the verb dar ?give? (and no other
support verb was extracted yet for that noun); based on this dependency, an EVENT (unary) dependency
is extracted for the predicative noun; then, the subject of the standard support verb is assigned the
agent semantic role (agent-generic in STRING?s terminology); next, the prepositional phrase
modifying (MOD) the support verb and introduced by preposition em ?in? is converted into a complement
(COMPL) of the predicative noun and assigned a semantic role of patient; a similar procedure is
used for the dative complement, when reduced to a dative pronominal form, but in this case, instead
of COMPL the CINDIR (indirect complement) dependency is used. All these rules are automatically
produced for each predicative noun, from the information in the Lexicon-Grammar. The corresponding
EVENT structure is represented below:
SUPPORT VSUP-STANDARD(beijo,deu)
EVENT AGENT(beijo,Max)
EVENT PATIENT(beijo,Ana)
For the converse construction 4.2, while the EVENT structure remains the same, the SUPPORT depen-
dency is:
(22) Ana ganhou um beijo do Max. ?Ana got a kiss from Max.?
SUPPORT VSUP-CONVERSE(beijo,ganhou)
The converse construction entails the ?swapping? of the arguments? syntactic function, while keeping
their respective semantic roles. The detection of the converse construction triggers a set of rules that
also swap the semantic roles associated to the predicative noun?s syntactic slots. In the case where the
same verb is both the standard and the converse support of a predicative noun, they are both extracted, at
first, and then the presence of prepositional complements or the determiner of the noun can be used for
disambiguation. This will be part of future work as, for the moment, whenever this happens, the converse
construction is discarded. The assigning of semantic roles to the predicative noun?s arguments is then
made only once, and by general rules, both in the standard and in the converse constructions.
The situation is somewhat similar in the case of a causative-operator verb 4.2:
(23) Essa not??cia deu estresse no Max. ?This news gave stress in Max.?
In this case, since the Lexicon-Grammar has encoded that the verb dar can be an operator on ter,
and since the predicative noun estresse ?stress? does not allow for dar to be its support, a general rule
can apply, extracting the CAUSE relation expressed by the VopC, in a similar way as for the SUPPORT
dependency. The EVENT structure is thus construed as shown below:
VOPC(estresse,deu)
EVENT(estresse,other)
EVENT EXPERIENCER(estresse,Max)
EVENT CAUSE(estresse,not??cia)
However, when the same verb can be both a support and an operator verb, in the absence of tell-tale
prepositional complements or other syntactic evidence, the detection of the adequate structure can not be
done at this stage. We found only 35 predicative nouns which can be associated to the verb dar ?give?
with both categories, i.e. as a support and a VopC. It is also possible that both dependencies SUPPORT
and CAUSE be extracted in order to disambiguate them at a later stage.
99
5 Conclusions and future work
In the near future, we intend to use the data encoded in the Lexicon-Grammar of these predicative nouns
and build a SVC identification module for STRING. For the moment, the identification of all the syn-
tactic phenomena, constituting as many different parsing cases as possible, is underway, in order to
fully automatize the processing of converting the Lexicon-Grammar tables into the STRING, with XIP-
compliant rules, in a similar way as it has already been done for the verbs (Baptista, 2012; Travanca,
2013; Talhadas, 2014). After implementing all the data in STRING we also intend to evaluate the system
in order to check the extraction of the dependencies involving the support verbs and predicative nouns.
An important task ahead is the systematic comparison of the structures and properties here described
against those of European Portuguese. First of all, the set of nouns available in each variant is not exactly
the same, even if the concepts are shared; for example, carona in BP corresponds to the EP boleia ?ride?;
in other cases, the choice of the nominalization suffixes differ: in BP one uses the term parada card??aca,
while its equivalent in EP is paragem card??aca ?cardiac arrest?. False-friends are also common: in BP,
chamada ?rebuke? is unrelated to EP chamada ?phone call? (but, in this sense, it is also used in BP);
the set of support verbs for each noun are different: as a synonym of rebuke we find the pair dar-levar
(only in BP), while as equivalent to phone call the basic support verbs are fazer-receber (the same in
BP and EP). Naturally, much in both variants is quite similar, though some patterns begin to emerge:
the different choice of prepositions for the complement, mostly the alternation between em ?in? in BP
and a ?to? in EP (both as dative complements); the choice of support verbs, with some being used for
these predicative noun exclusively in BP (ganhar ?gain? and tomar ?take?) or in EP (pregar ?throw? and
apanhar ?take?).
Acknowledgements
The authors would like to acknowledge the financial supports from Capes/PDSE under Processes BEX
12751/13-8 and BEX 6561/13-6 and also national funds through FCT ? Fundac??ao para a Ci?encia e a
Tecnologia, under project PEst-OE/EEI/LA0021/2013. We would like to thank the comments of the
anonymous reviewers, which helped to improve this paper.
References
Jorge Baptista. 1997. Serm?ao, tareia e facada. Uma classificac?
?ao das construc??oes conversas dar-levar. In
Semin?arios de Lingu??stica, volume 1, pages 5?37, Faro. Universidade do Algarve.
Jorge Baptista. 2005. Sintaxe dos predicados nominais com SER DE. Fundac??ao Calouste Gulbenkian/Fundac??ao
para a Ci?encia e Tecnologia, Lisboa.
Jorge Baptista. 2012. A Lexicon-grammar of European Portuguese Verbs. In Jan Radimsky, editor, Proceedings of
the 31st International Conference on Lexis and Grammar, volume 31, pages 10?16, Czech Republic, September.
Universit`a degli Studi di Salerno and University of South Bohemia in Nov?e Hrady.
Andr?ee Borillo. 1971. Remarques sur les verbes sym?etriques. Langue Franc?aise, (11):17?31.
M??rian Bruckschein, Fernando Muniz, Jos?e Guilherme Camargo Souza, Juliana Thiesen Fuchs, Kleber Infante,
Marcelo Muniz, Patr??cia Nunes Gonc?alvez, Renata Vieira, and Sandra Maria Aluisio. 2008. Anotac??ao
lingu??stica em XML do corpus PLN-BR. S?erie de relat?orios do NILC, NILC- ICMC - USP.
Magali Sanches Duran, Carlos Ramisch, Sandra Maria Alu??sio, and Aline Villavicencio. 2011. Identifying and
analyzing Brazilian Portuguese complex predicates. In Proceedings of the Workshop on Multiword Expressions:
from Parsing and Generation to the Real World, pages 74?82, Portland, USA.
Gregory Grefenstette and Simone Teufel. 1995. Corpus-based Method for Automatic Identification of Support
Verbs for Nominalizations. CoRR, cmp-lg/9503010.
Maurice Gross. 1975. M?ethodes en syntaxe. Hermann, Paris.
Maurice Gross. 1981. Les bases empiriques de la notion de pr?edicat s?emantique. Langages, 63(3):7?52.
Gaston Gross. 1982. Un cas des constructions inverses: donner et recevoir. Lingvisticae Investigationes, 2:1?44.
100
Maurice Gross. 1988. Methods and tactics in the construction of a Lexicon-grammar. In The linguistic Society of
Korea, editor, Linguistics in the Morning Calm 2. Selected papers from SICOL-1986, pages 177?197, Seoul.
Hanshin Publishing Company.
Gaston Gross. 1989. Les constructions converses du franc?ais. Droz, Genebra.
Maurice Gross. 1996. Lexicon grammar. In K. Brown and J. Miller, editors, Concise Encyclopedia of Syntactic
Theories, pages 244?259. Pergamon, Cambridge.
Maurice Gross. 1998. La fonction s?emantique des verbes supports. In B?eatrice Lamiroy, editor, Travaux de
Linguistique, number 37, pages 25?46.
Patrick Hanks, Anne Urbschat, and Elke Gehweiler. 2006. German light verb constructions in corpora and dictio-
naries. International Journal of Lexicography, 19(4):439?457.
Zellig Harris. 1964. The Elementary Transformations. Transformations and Discourse Analysis Papers, (54):211?
235.
Zellig Harris. 1991. A Theory of Language and Information: A Mathematical Approach. Clarendon Press, New
York.
Iris Hendrickx, Am?alia Mendes, S??lvia Pereira, Anabela Gonc?alves, and In?es Duarte. 2010. Complex predicates
annotation in a corpus of Portuguese. in: Proceedings of the 4th ACL. In Proceedings of the 4th ACL Linguistic
Annotation Workshop, pages 100?108, Uppsala, Sweden.
B?eatrice Lamiroy. 1998. Le Lexique-grammaire: Essai de synth`ese. In B?eatrice Lamiroy, editor, Travaux de
Linguistique, volume 37, pages 7?23.
Nuno Mamede, Jorge Baptista, Vera Cabarr?ao, and Cl?audio Diniz. 2012. STRING: An hybrid statistical and
rule-based natural language processing chain for Portuguese. In International Conference on Computational
Processing of Portuguese (Propor 2012), volume Demo Session, Coimbra, Portugal, April.
Salah Ait Mokhtar, Jean-Pierre Chanod, and Claude Roux. 2002. Robustness beyond shalowness: Incremental
dependency parsing. Natural Language Engineering, pages 121?144.
Elisabete Ranchhod. 1990. Sintaxe dos predicados nominais com Estar. INIC - Instituto Nacional de Investigac??ao
Cient??fica, Lisboa.
Amanda Rassi and Oto Vale. 2013. Predicative Nouns Suffixation associated to the verb dar (give) in Brazilian
Portuguese. In Jorge Baptista and Mario Monteleone, editors, Proceedings of the 32nd International Conference
on Lexis and Grammar, volume 32, pages 151?158, Faro, September. UAlg.
Amanda Rassi, Nathalia Perussi, Jorge Baptista, and Oto Vale. 2014. Estudo contrastivo sobre as construc??oes
conversas em PB e PE. In Cristina Fargetti, Odair Silva, Clotilde Murakawa, and Anise Ferreira, editors,
Anais do I CINELI - Congresso Internacional Estudos do L?exico e suas Interfaces, volume 1, page (no prelo),
Araraquara-SP, Maio. Universidade Estadual Paulista - UNESP.
Maria Cristina Andrade Santos-Turati. 2012. Descric??ao da estrutura argumental dos predicados nominais com
o verbo-suporte ter. In Semin?ario do GEL, number 60, pages 20?21, S
?ao Paulo, Brasil. Grupo de Estudos
Lingu??sticos do Estado de S?ao Paulo - GEL.
Angelika Storrer. 2007. Corpus-based investigations on german support verb constructions. In Christiane Fell-
baum, editor, Collocations and Idioms: Linguistic, Lexicographic, and Computational Aspects, pages 164?188.
Continuum Press, London.
Rui Talhadas. 2014. Automatic Semantic Role Labeling for European Portuguese. Master?s thesis, Universidade
do Algarve, Faro.
Tiago Travanca. 2013. Verb Sense Disambiguation. Master?s thesis, Instituto Superior T?ecnico, Universidade de
Lisboa, June.
Aldina Vaza. 1988. Estruturas com nomes predicativos e o verbo-suporte dar. Master?s thesis, Faculdade de
Letras - Universidade de Lisboa.
101
