A Lexico-semantic Approach to the Structuring of Terminology 
Marie-Claude L?HOMME 
OLST ? Universit? de Montr?al 
C.P. 6128, succ. Centre-ville 
Montr?al (Qu?bec), Canada H3C 3J7 
Marie-Claude.L?Homme@umontreal.ca 
http://www.olst.umontreal.ca 
 
Abstract 
This paper discusses a number of implications 
of using either a conceptual approach or a 
lexico-semantic approach to terminology 
structuring, especially for interpreting data 
supplied by corpora for the purpose of 
building specialized dictionaries. A simple 
example, i.e., program, will serve as a basis 
for showing how relationships between terms 
are captured in both approaches. My aim is to 
demonstrate that truly conceptual approaches 
do not allow a flexible integration of terms 
and relationships between terms and that 
lexico-semantic approaches are more 
compatible with data gathered from corpora. I 
will also discuss some of the implications 
these approaches have for computational 
terminology and other corpus-based 
terminological endeavours. 
 
1 Introduction 
Recent literature in terminology circles 
constantly reminds us that methods and practices 
have changed drastically due mostly to the 
extensive use of electronic corpora and computer 
applications. What might appear as normal and 
standard in computational circles has had profound 
consequences for terminologists; this has led many 
to criticize traditional theoretical principles and 
some to propose new approaches (Bourigault and 
Slodzian 1999; Cabr?, 2003, among others; see 
L?Homme et al , 2003 for a review). 
One of the issues at the centre of this debate is 
that of diverging views on the relationship between 
the term and the abstract entity it is supposed to 
represent (a ?concept? or a ?meaning?). Differing 
views will inevitably lead to very different ways of 
envisaging terms and methods of structuring them. 
Some might be compatible with a given 
application, while others are much more difficult to 
accommodate. 
In this paper, I will try to demonstrate some of 
the methodological consequences of adopting a 
conceptual approach or a lexico-semantic approach 
to terminology structuring. These observations are 
drawn from my experience in compiling 
specialized dictionaries using corpora as primary 
sources and computer applications to exploit them.  
Even though the application I am familiar with is 
very specific and obviously influences my view on 
the structuring of terms, I believe this topic is also 
relevant for other terminology-related applications. 
For example, in computational terminology, there 
is an increasing interest for structuring extracted 
terms (articles in Daille et al, 2004 and in 
Nazarenko and Hamon, 2002, among others). 
Automatic term structuration is carried out by 
considering morphological variants (Daille, 2001; 
Grabar and Zweigenbaum, 2004), performing 
distributional analysis to build classes of 
semantically related terms (Nazarenko et al, 2001, 
among others), or acquiring other types of 
linguistic units, such as collocations or verbal 
phrases, from specialized corpora. 
These questions will be addressed from a 
linguistic point of view, but many have been dealt 
with directly or indirectly by computational 
terminologists and, in fact, are often raised by their 
work on specialized corpora. I will also try to 
demonstrate that the problems dealt with in this 
paper are by no means a reflection of a tendency 
often attributed to linguists to make things more 
complicated than they actually are. I would like to 
show that they are a reflection of the functioning of 
terms in running text. 
2 Two different approaches to terminology 
The conceptual approach I describe is the one 
advocated by the Vienna School of terminology 
that has been and is still applied to work carried 
out by terminologists. The results of its analyses is 
encoded in term records in term banks or in articles 
in terminological dictionaries.  
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 7
The lexico-semantic approach on which my 
discussion is based is the Explanatory and 
Combinatorial Lexicology (ECL) (Mel??uk et al, 
1995; Mel??uk et al 1984-1999) which is the 
lexicological component of the Meaning-text 
Theory (MTT). As will be seen further, ECL 
provides an apparatus, namely lexical functions 
(LFs), that can capture a wide variety of semantic 
relations between lexical units. ECL descriptions 
are encoded in an Explanatory and Combinatorial 
Dictionary (ECD) (Mel??uk et al 1984-1999). 
In order to illustrate the methodological 
consequences of the two approaches under 
consideration, I will use a basic term in the field of 
computing, i.e., program. This term was chosen 
because no one will question its status in 
computing no matter what his or her view is on 
terms and terminology.  
In addition, like many basic terms, program is 
polysemic, ambiguous in some contexts, and 
semantically related to several other terms. It will 
be very useful to show the variety of semantic 
relationships in which terminological units 
participate. Finally, program does not refer to a 
concrete object. Hence, its analysis will pose 
problems different from those raised by terms like 
printer or computer. 
I will also frequently refer to a corpus from 
which my observations are derived. This corpus 
contains over 53 different texts and amounts to 
600,000 words. It was compiled by the 
terminology team within the group Observatoire 
de linguistique Sens-Texte (OLST) in Montreal. 
Since I am not an expert in computer science, I 
must rely ? like other terminologists ? on 
information provided in a corpus and not on 
previous knowledge to analyze the meaning of 
program and the other terms to which it is related. 
2.1 A conceptual approach to the processing 
of the term program 
When considering a unit such a program, 
terminologists who adhere to a conceptual 
approach will define its place within a conceptual 
structure. This is done by considering  its 
characteristics (in fact, often by deciding which 
ones are relevant), and by analyzing classical 
relationships, such as hyperonymy (or, rather, 
generic-specific) and meronymy (or whole-part). 
In order to achieve this, terminologists usually 
gather information from reliable corpora. 
The corpus first informs us that ?program? can 
be subdivided into in one of the following 
categories; 1. ?operating system?; 2. ?application 
software?, i.e., ?word processor?, ?spreadsheet?, 
?desktop publishing software?, ?browser?, etc.; 
and 3. ?utility program?. It also tells us that there 
are different types of ?programs?: 1. ?shareware 
programs?, ?freeware programs?; ?educational 
programs?; and ?commercial programs?; 2. 
?command-driven programs? and ?menu-driven 
programs?. 
One possible representation of these 
relationships has been reproduced in Figure 1. Of 
course, my interpretation of the data listed above is 
simplified, since it does not take into account all 
the relationships that can be inferred from it (e.g., 
the fact that software programs or educational 
programs can be menu-driven). Also, part-whole 
relationships for some of these subdivisions can be 
identifed (e.g., the fact that programs ? classified 
according to the interface ? have parts such as 
menus, windows, buttons, options, etc.).  
 
program 
 
according to the task or tasks to perform   
 
  operating system 
 
  application software 
 
   word processor 
   spreadsheet 
   desktop publishing software 
   browser 
 
  utility program 
 
 according to the  interface 
 
  command-driven program 
  menu-driven program 
 
 according to the market 
  
  shareware program 
  freeware program 
  commercial program 
  educational program 
Figure 1: Representation of the relationships 
between ?program? and related concepts 
For the time being, I will assume that I have 
solved the problems related to the relations 
between ?program? and other relevant concepts 
(which, in fact, is not the case, as we will see 
below). 
The corpus also allows me to observe that the 
concept I am currently dealing with, has different 
names: program and software program. This will 
normally be dealt with in conceptual 
CompuTerm 2004  -  3rd International Workshop on Computational Terminology8
representations by taking for granted that all these 
different linguistic forms refer to the same concept, 
and thus are true synonyms. In my representation, 
they will be attached to the same node as 
?program? (see Figure 2).1 
Furthermore, since concepts and conceptual 
representations are considered to be language-
independent, their description and representation 
should be valid for all languages. Hence, my 
representation system should apply to French (and 
to true synonyms in French) and other languages 
(see Figure 2). 
 
 program (program; software program) 
      (Fr. logiciel) 
 
  according to the task or tasks to perform   
 
    application software (application 
                          software; application) 
                         (Fr. logiciel d?application; 
                         application) 
 
                        ? 
 
Figure 2: Synonyms in conceptual 
representations 
Regarding this last issue, a choice must often be 
made between several potential synonyms in order 
to select a single identifier for a concept. This 
choice can simply be functional (allowing the 
labelling of a node in a representation such as that 
in Figure 1) or result from standardizing efforts. 
The choice of a unique identifier is central in 
conceptual analyses, since relationships are defined 
first and foremost between concepts and are 
considered to be valid for the linguistic forms that 
label them. 
2.2 Other issues related to the analysis of 
program  
In my discussion on the processing of program, I 
deliberately avoided other important issues 
revealed by the data contained in the corpus. We 
will look at some of these issues in this section. 
First, ?programs? can be further classified 
according to the language used create them (?C 
programs?, ?C++ programs?, ?Java programs?), or 
according to the hardware device they manage 
                                                 
1Large-scale ontologies represent concepts and 
lexical forms using a similar strategy. For example, the 
Unified Medical Language System (UMLS) (National 
Library of Medicine, 2004) makes a clear separation 
between a Semantic Network and a Lexicon. 
(?BIOS program?, ?boot program?). Incidentally, 
in French, the first subdivision (the one represented 
in section 2.1) corresponds to logiciel. The ones we 
just introduced are named programme. 
This obviously has consequences for the 
representation of program produced above. The 
problem can be solved in conceptual approaches 
by: 
a. Considering that program refers to a single 
concept, and trying to account for the 
different ways of organizing its relationships 
with other concepts with new conceptual 
subdivisions. This will produce a very 
complex, yet possible, graphical 
representation; 
b. Focussing on a single organization of the 
concept ?program? (for example, the one 
chosen in section 2.1.) and defining the 
others as being related to vague or improper 
uses of program; or, finally,  
c. Saying that program is associated with two 
or three different concepts, and possibly 
classifying them into three different 
subfields of computing, i.e., concept1 = 
micro-computing; concept2 = programming; 
concept3 = hardware. If the description is 
carried out in a multilingual context, the 
subdivision will be necessary to account for 
the fact that, in French, for instance, 
program can be translated by logiciel or 
programme. This latter choice is the one that 
is closest to the distinctions made with the 
lexico-semantic approach dealt with in the 
following section. 
 Secondly, program shares with other lexical 
units many other different semantic relationships 
other than the taxonomic and meronymic relations 
previously considered. All the relationships listed 
below have been found in the corpus.2  
o Relationships that involve activities and that 
are expressed linguistically mostly by 
collocates of program: 
Function: a program performs tasks  
Creation: development, creation of a 
program, programming 
Actions that can be carried out on programs: 
configuration, installation, running, 
aborting, etc. 
                                                 
2Some of these have been listed in Sager (1990) who 
argued that a large variety of conceptual relationships 
could be found in specialized subject fields. 
 
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 9
o Relationships that involve properties and that 
are also expressed linguistically by 
collocates of program: 
powerful program, user-friendly program; 
feature of a program  
o Argument or circumstantial relationships: 
Agent: user of a program; programmer  
Instrument: create a program with a 
language 
Location: install the program on the hard 
disk, on the computer  
o Other relationships expressed by 
morphological derivatives terms that include 
the meaning of program; 
programming, programmable, 
reprogrammable 
 
 Most relationships listed above are non-
hierarchical and may be expressed by parts of 
speech other than nouns. Consider, for example, 
actions that can be performed on a program 
(configuration, configure; install; installation, 
etc.). 3 Some will be very difficult to account for in 
terms of conceptual representations. Of course, 
conceptual-approach advocates might argue that 
these relationships are not relevant for 
terminology. 
Thirdly, in my discussion of the fact that 
concepts could have different names, I mentioned 
only a synonym, but concepts are expressed in a 
variety of forms in corpora. Many of these will not 
take the form of nouns. 
2.3 A lexico-semantic approach 
In this section, I repeat my analysis of program 
this time using a lexico-semantic approach. This 
approach is also based on data gathered from 
corpora. The discussion presented in this section is 
summarized in Table 1. 
First, the analysis of program in the corpus 
reveals that it has three different meanings. 
Program can be defined as: 1) a set of instructions 
written by a programmer in a given programming 
language in order to solve a problem (this meaning 
is also conveyed by computer program); 2) a set of 
programs (in sense 1) a user installs and runs on 
his computer to perform a number of tasks (this 
meaning being also conveyed by software 
program); and 3) a small set of instructions 
designed to run a specific piece of hardware. 
                                                 
3 Another non-hierarchical relationship has received a 
lot of attention recently, that of cause-effect. 
This sense distinction is validated by the fact that 
program can be related to different series of lexical 
units.  
For example, a program1 is something that 
someone, called a programmer, writes, executes, 
compiles and debugs. It can be machine-readable 
or human-readable. It can also end or terminate.  
Program can be modified by names given to 
languages, i.e., C program, C++ program, Java 
program. Finally, it can also have parts such as 
modules, routines, and instructions. 
 
Program1  
Explanation Set of instructions written by a 
programmer in a programming 
language to solve a specific problem 
Collocates write ~; compile ~, execute ~; create 
~; machine-readable ~; human-
readable ~; ~ ends, ~ terminates, 
debug ~; powerful ~ 
Hyponyms C ~, C++  ~, Java ~ 
Other 
related 
terms 
to program; programming, 
programmer; routine, instruction; 
module; page; segment; language; 
line 
Program2  
Explanation Set of programs1 installed and run on 
the computer by a user to perform a 
specific task or a set of related tasks. 
Hyponyms operating system; application 
software; word processor, 
spreadsheet 
Collocates active ~, running of ~; download ~; 
develop ~; run ~, install ~; uninstall 
~; add/remove ~;  user-friendly; quit 
~; exit ~; load ~; launch ~ 
Other 
related 
terms 
user, hard disk;  
application  
software 
Program3  
Explanation Short set of specific instructions 
designed to run a hardware device 
Other 
related 
terms 
boot, BIOS, to program, reprogram, 
programmable, reprogrammable, 
programming 
Table 1: Semantic distinctions for program 
A program2 is something a user installs on his 
computer, loads into the memory, runs, and 
sometimes uninstalls.  Different sorts of programs 
can be identified, such as operating systems, 
applications, and utilities. Programs can have parts 
such as windows, menus, options, etc. Finally, a 
program2 can be user-friendly. 
CompuTerm 2004  -  3rd International Workshop on Computational Terminology10
A program3 consists of a few code lines written 
in order to specify the behaviour of a specific 
hardware device, such as a memory. The device is 
then said to be programmable and/or 
reprogrammable. It can be programmed and 
reprogrammed.  
In this lexico-semantic approach, the 
relationships observed between program and other 
terms are attached to its specific meanings. This 
distinction allows us to relate other terms to 
specific senses. For example, program1 is related 
to other senses as follows: 
Synonym: computer ~ 
Types of programs: C ~, Java ~ 
Parts of programs: instruction, page, segment, 
line, routine 
Creation of a program: write ~, create ~, to 
program, programming 
Agent: programmer 
Cause a program to function: execute ~ 
The program stops functioning: ~ ends, ~ 
terminates 
etc. 
Since most semantic relationships are non-
hierarchical, they can be represented in a relational 
model. In ECL, paradigmatic and syntagmatic 
semantic relations are represented by means of a 
single formalism, i.e., lexical functions (LFs). LFs 
are used to capture abstract and general senses that 
remain valid for a large number of lexical units. 
The relationships listed above could be formalized 
as follows: 4  
synonym: Syn(program1) = computer ~ 
agent of a program: S1(program1) = programmer 
create a program: CausFunc0(program1) = 
create [DET ~], write [DET ~] 
Cause a program to function:                                                
CausFact0(program1) = execute [DET ~] 
The program stops functioning: 
FinFact0(program1) = [DET ~] ends, [DET ~] 
terminates 
                                                 
4Meronymic and hyperonymic relationships can also 
can also be captured by means of lexical functions. 
Authors have proposed LFs especially designed to 
represent these relations (Spec, for hyponymy; and 
Part; for meronymy). However, ECL will prefer 
accounting for these relationships with non-standard 
lexical functions in order to explain the specific nature 
of the relationships between a lexical unit and its 
meronym. 
3 General comments on the analyses of terms 
These two brief analyses of program reveal the 
following about terms: 
? Terms can convey multiple meanings. This 
is not an accidental property that only affects 
program. Numerous examples can be found 
in corpora and have been dealt with in recent 
literature. This, of course, has important 
consequences for both conceptual and 
lexico-semantic approaches.  
? Terms can enter into a large variety of 
relationships with other terms, and not only 
taxonomic or meronymic relationships. The 
understanding of these relationships is 
necessary to capture sense distinctions; in 
addition, relationships are valid for a specific 
meaning. 
? Some of the relationships observed between 
terms are hierarchical: hyperonymy and 
meronymy. 
? Most semantic relationships are non-
hierarchical: e.g., actions carried out by 
terms, properties, cause-effect. 
? Some relationships involve lexical units 
other than nouns: e.g., actions and creation 
are often expressed linguistically by means 
of verbs; properties are expressed by 
adjectives. 
? Most relationships involve terms considered 
as linguistics units rather than labels for 
concepts: e.g., morphological derivatives. 
In fact, what these observations tend to show is 
that terms behave like other lexical units and must 
be dealt with accordingly. Terms will acquire their 
specificity through a given application with set 
objectives, but as units occurring in corpora, terms 
cannot be differentiated from other lexical units. 
4 Implications for computational 
terminology and other corpus-based work 
The previous discussion has a number of 
implications for computational terminology (as 
well as other corpus-based terminology-related 
applications). I will examine a few in this section. 
First, both approaches will focus on different 
types of units when selecting terms in corpora. In 
conceptual approaches, a selection is made among 
linguistic units that can refer to a concept. The 
focus is on nouns and noun phrases. Even though 
concepts can be expressed in a variety of linguistic 
forms, synonyms considered will invariably be 
nouns of noun phrases. Work on terminological 
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 11
variation (Daille, 2003; Jacquemin, 2001) has 
shown the variety of forms that terms can take in 
corpora (morphological derivation, insertion, 
elision, anaphora, etc.), but these are taken into 
account only if they can be associated with an 
admitted term.  
In a lexico-semantic approach as that presented 
in section 2.3, units considered will be those that 
convey a meaning that can be related to the field of 
computing (the subject field is delimited prior to 
the selection). Lexical units selected can pertain to 
different parts of speech as long as their meaning 
can be related to the field under examination: 
nouns (program, byte); verbs (debug, to program), 
adjectives (user-friendly, programmable). Even 
adverbs can convey a specialized meaning (e.g., 
digitally, dynamically). 
Secondly, any terminological work based on 
corpora will run into polysemy, even though it 
focuses on a small set of terms. The manner in 
which the distinctions between senses are made 
has important consequences on way terms will be 
processed afterwards.  
Polysemy can be dealt with using a conceptual 
approach, which considers this property to be an 
accidental problem. Hence, distinctions depend on 
decisions made during the classification process or 
the construction of conceptual representations.  
In lexico-semantic approaches, polysemy is 
viewed as a natural property of lexical units. 
Senses are delimited prior to the representation of 
semantic relationships and this delimitation is 
based on the observations of interactions between 
the term under examination and other lexical units. 
Sense delimitation and distinction is a necessary 
step before anything else can be done. 
Thirdly, regarding terminology structuring, 
conceptual methods, such as the one discussed in 
section 2.1, are useful as far as classification is 
concerned. Hence, they can be used for describing 
concepts that correspond to entities (concrete 
objects, substances, artefacts, animates, etc.). 
Moreover, the focus is on hierarchical relations 
(hyperonymy and meronymy) which is again valid 
for entities, and, as far as part-whole relations are 
concerned, more specifically concrete objects. 
Many non-hierarchical relationships, such as those 
listed in section 2.3 are disregarded, either because 
they involve units that do not refer to entities, or 
because they are relationships between lexical 
units and not concepts.  
Also, relationships between synonyms are 
considered from the point of view of true 
synonymy. Choosing a unique linguistic identifier 
for a concept and considering competing linguistic 
forms as true synonyms has implications for the 
variety of relationships that can be considered. 
Some relationships can be valid for one synonym 
but not for another. 
In lexico-semantic approaches, semantic 
relationships are attached to senses that have been  
distinguished previously. In addition, a wide 
variety of semantic relationships can be taken into 
account. These relationships can apply to terms 
that designate entities, as well as activities, and 
properties. Hypernymy and meronymy represent 
only a small part of the semantic relationships 
terms can share with other terms. Other 
relationships, such as argument relations, entity-
activity relations, can be expressed by different 
parts of speech.  
Fourthly, conceptual approaches lead to 
representations that distance themselves from data 
collected in corpora. Many decisions are made 
during the construction of the representation. On 
the one hand, many meanings that would appear to 
be relevant in other approaches are not considered. 
On the other hand, things are added in order to 
build the representation. Consider, for example, 
Figure 1. Some subdivisions are created but do not 
correspond to lexical units (e.g., according to the 
interface); this sort of classification of units will 
result in considering several complex sequences 
that have a compositional meaning (hence, that are 
not true lexical units). 
Terminology structuring in conceptual 
approaches is often carried out in order to represent 
knowledge and not linguistic units. Problems arise 
when this work is done using corpora as a starting 
point, since linguistic units (such as terms) do not 
behave in a way that reflects perfectly a given 
knowledge structure. When analyzing terms, 
considerations regarding knowledge structure will 
constantly interfere with factors related to the 
behaviour of linguistic units in text. 
On the other hand, lexico-semantic approaches 
are much more compatible with data gathered from 
corpora. Of course, terminologists will make 
decisions since they must interpret data and 
synthesize their findings, but these are based on the 
observation of interactions between lexical units 
that appear in corpora. 
5 Concluding remarks 
The point in my discussion, is not to say that an 
approach is much better than the other for 
terminology, regardless of the application at hand. 
This topic has been dealt with extensively by 
authors and even placed in a theoretical 
CompuTerm 2004  -  3rd International Workshop on Computational Terminology12
perspective. Rather, I wanted to demonstrate that 
an approach is probably better suited that the other 
as far as terms considered in corpora are 
concerned. I also wanted to point out the 
methodological consequences of choosing an 
approach over another. 
Conceptual approaches will  account for 
consensual representations of knowledge, based on 
a predefined set of hierarchical relationships. 
However, in must be kept in mind that resulting 
representations distance themselves from corpus 
data and necessitate a lot of hand-crafted changes. 
Often, the ideal knowledge structure is formulated  
beforehand entirely or partly, and the difficulty 
consists in trying to find lexical units that fit into it. 
Lexico-semantic approaches will provide 
terminologists with a framework for interpreting 
data related to terms and the contexts in which they 
appear. However, one must accept, when using this 
kind of approach, that terminological structures are 
discovered gradually through semantic relations 
and that some of these relations will even 
contradict assumed knowledge structures.  
6 Acknowledgements 
I would like to thank Elizabeth Marshman for 
her comments on a preliminary version of this 
article. 
References  
D. Bourigault and M. Slodzian. 1999. Pour une 
terminologie textuelle. Terminologies nouvelles, 
19:29-32. 
M.T. Cabr?. 2003. Theories of Terminology. Their 
Description, Prescription and Explanation. 
Terminology 9(2):163-199. 
A. Condamines. 1995. ?Terminology. New needs, 
new perspectives.? Terminology 2(2): 219-238. 
D.A. Cruse. 1986. Lexical Semantics, Cambridge: 
Cambridge University Press. 
B. Daille. 2002. Qualitative term extraction. In  D. 
Bourigault, C. Jacquemin and M.C. L?Homme 
(eds.), Recent Advances in Computational 
Terminology, 149-166, Amsterdam / 
Philadelphia: John Benjamins. 
B. Daille. 2003. Terminology Mining. In M.T. 
Pazienza (ed.), Information Extraction in the 
Web Era, Lectures Notes in Artificial 
Intelligence. 29-44. Springer. 
B. Daille, K. Kageura, H. Nakagawa and L.-F. 
Chien (eds.). 2004. Recent Trends in 
Computational Terminology. Special Issue of 
Terminology, 10(1). 
N. Grabar and P. Zweigenbaum. 2004, 
forthcoming. Lexically-based terminology 
structuring. Terminology, 10(1). 
Jacquemin. C. 2001. Spotting and Discovering 
Terms through Natural Language Processing 
Techniques, Cambridge: MIT Press. 
M.C. L?Homme, U. Heid and J.C. Sager. 2003. 
Terminology during the past decade (1994-
2004). An Editorial Statement. Terminology, 
9(2):151-161. 
I. Mel??uk, A. Clas and A. Polgu?re. 1995. 
Introduction ? la lexicologie explicative et 
combinatoire, Louvain-la-Neuve (Belgique): 
Duculot. 
I. Mel??uk et al 1984-1999. Dictionnaire explicatif 
et combinatoire du fran?ais contemporain. 
Recherches lexico-s?mantiques I-IV, Montr?al : 
Les Presses de l?Universit? de Montr?al.  
National Library of Medicine. 2004. UMLS 
Knowledge Sources  
 (http://www.nlm.nih.gov/research/umls/) 
A. Nazarenko and T. Hamon. (eds.). 2002. 
Structuration de terminologie. Special issue of 
Traitement automatique des langues. TAL, 43(1). 
A. Nazarenko, P. Zweigenbaum, B. Habert and J. 
Bouaud. 2001. Corpus-based extension of a 
terminological semantic lexicon. In  D. 
Bourigault, C. Jacquemin and M.C. L?Homme 
(eds.), Recent Advances in Computational 
Terminology, 327-351, Amsterdam / 
Philadelphia: John Benjamins. 
J.C. Sager. 1990. A Practical Course in 
Terminology Processing. Amsterdam / 
Philadelphia: John Benjamins. 
E. W?ster. 2004, forthcoming. The structure of the 
linguistic world of concepts and its 
representation in dictionaries [translated by J.C. 
Sager]. Terminology, 10(2). 
 
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 13
Discovering Specific Semantic Relationships between Nouns and
Verbs in a Specialized French Corpus
Vincent CLAVEAU and Marie-Claude L'HOMME
OLST - University of Montreal
C.P. 6128, succ. Centre-Ville
Montr?al, QC, H3C 3J7
Canada
{Vincent.Claveau,Marie-Claude.L'Homme}@umontreal.ca
Abstract
Recent literature in computational termi-
nology has shown an increasing interest in
identifying various semantic relationships
between terms. In this paper, we pro-
pose an original strategy to find specific
noun-verb combinations in a specialized cor-
pus. We focus on verbs that convey a
meaning of realization. To acquire these
noun-verb pairs, we use asares, a machine
learning technique that automatically in-
fers extraction patterns from examples and
counter-examples of realization noun-verb
pairs. The patterns are then applied to the
corpus to retrieve new pairs. Results, mea-
sured with a large test set, show that our
acquisition technique outperforms classical
statistical methods used for collocation ac-
quisition. Moreover, the inferred patterns
yield interesting clues on which structures
are more likely to convey the target seman-
tic link.
1 Introduction
Recent literature in computational terminology
has shown an increasing interest in identifying
various semantic relationships between terms.
Different strategies have been developed in or-
der to identify pairs of terms that share a spe-
cific semantic relationship (such as hyperonymy
or meronymy) or to build classes of terms.
However, most strategies are based on in-
ternal or external methods (Grabar and
Zweigenbaum, 2002), i.e. methods that rely on
the form of terms or on the information gathered
from contexts. (In some cases, an additional
resource, such as a dictionary or a thesaurus,
is used during the identification process.) The
work reported here infers specific semantic rela-
tionships based on sets of examples and counter-
examples.
In this paper, the method is applied to a
French corpus on computing to find noun-verb
combinations in which verbs convey a meaning
of realization. The work is carried out in order
to assist terminographers in the enrichment of a
dictionary on computing that includes colloca-
tional information (L'Homme, 2004).
Even though this work is carried out for ter-
minographical and lexicographical purposes, it
can certainly be of use in other applications,
namely information retrieval. Indeed, such rich
semantic links can be used to extend indices
or reformulate queries (similar to the work by
Voorhees (1994) with WordNet relations).
2 Objectives
The noun-verb combinations we aim to identify
have the following characteristics. They share:
? A syntactic relationship : nouns can be
subjects (e.g., ordinateur tourne; com-
puter runs); direct objects (e.g., configurer
l'application; configure the application); or
second complement (e.g., charger x dans la
m?moire;  load x into memory);
? A valid semantic relationship. The follow-
ing semantic relationships are sought:
1. verbs that refer to activities carried out
by the nouns (e.g., serveur d?marre;
server starts);
2. verbs that refer to uses of the nouns
(e.g., activer une option; activate an
option or naviguer sur Internet; surf
the Internet);
3. verbs that refer to activities carried out
by means of the nouns (e.g., activer
l'option au moyen de cette commande;
activate this option with this com-
mand ); and, finally,
4. verbs that refer to the processes by
which nouns are prepared fur use (e.g.,
 installer un logiciel; install an applica-
tion).
These noun-verb combinations will hereafter be
called valid N-V pairs.
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 39
The semantic relationships listed above cor-
respond to a set of lexical functions (LFs) de-
fined in (Mel'?uk et al, 1984 1999), i.e. LFs
used to represent realization (e.g., Facti, Reali,
Labrealij) and to represent the process by which
something is prepared (Prepar)1. (Both of
these types of LFs can be combined with oth-
ers [to create complex lexical functions].) These
LFs are opposed to support verbs represented
by the LFs Funci, Operi, Laborij (e.g., cr?er un
fichier; create a file; definir une variable; de-
fine a variable).).
Realization verbs (and verbs denoting the
preparation of nouns) were chosen since they
are believed to be frequent in technical corpora,
such as the corpus of computing used in this ex-
periment. However, this is seen as a first step
in order to validate an acquisition process for
semantically-related V-N pairs. Other semantic
relationships could be sought in the future.
3 Related work
A number of applications have relied on distri-
butional analysis (Harris, 1971) in order to build
classes of semantically related terms. This ap-
proach, which uses words that appear in the con-
text of terms to formulate hypotheses on their
semantic relatedness (Habert et al, 1996, for ex-
ample), does not specify the relationship itself.
Hence, synonyms, co-hyponyms, hyperonyms,
etc. are not differentiated.
More recent work on terminology structuring
has focussed on formal similarity to develop hy-
potheses on the semantic relationships between
terms: Daille (2003) uses derivational morphol-
ogy; Grabar and Zweigenbaum (2002) use, as a
starting point, a number of identical characters.
Up to now, the focus has been on nouns
and adjectives, since these structuring methods
have been applied to lists of extracted candidate
terms (Habert et al, 1996; Daille, 2003) or to
lists of admitted terms (Grabar and Zweigen-
baum, 2002). As a consequence, relationships
considered have been mostly synonymic or tax-
onomic, or defined as term variations.
On the other hand, other work has been car-
ried out in order to acquire collocations. Most of
these endeavours have focused on purely statis-
tical acquisition techniques (Church and Hanks,
1
However, our interpretation of LFs in this work is
much looser, since we admitted verbs that would not be
considered to be members of true collocations as Mel'?uk
et al (1984 1999) define them, i.e. groups of lexical units
that share a restricted cooccurrence relationship.
1990), on linguisitic acquisition (by the use of
Part-of-Speech filters hand-crafted by a linguist)
(Oueslati, 1999) or, more frequently, on a combi-
nation of the two (Smadja, 1993; Kilgarriff and
Tugwell, 2001, for example). It is worth noting
that although these techniques are able to iden-
tify N-V pairs, they do not specify the relation-
ship between N and V, nor are they capable of
focusing on a subset of N-V pairs. The original
acquisition methodology we present in the next
section will allow us to overcome this limitation.
4 Methodology for finding valid
noun-verb pairs
This section is devoted to the description of the
methodology and the data we use to acquire
semantically related noun-verb pairs. We first
describe the specialized corpus used in this ex-
periment. Then, we briefly present asares, a
pattern inference tool, on which our acquisition
strategy relies. Finally, we explain the different
steps of the acquisition process.
4.1 Computer science corpus
The French corpus used in our experiments is
composed of more than 50 articles from books
or web sites specialized in computer science; all
of them were published between 1988 and 2003.
It covers different computer science sub-domains
(networking, managing Unix computers, web-
cams...) and comprises 600,000 words.
Segmentation, morpho-syntactic tagging and
lemmatization have been carried out using the
tool cordial
2
. Each word is accompanied by
its lemma and Part-of-Speech tag (noun, verb,
adjective). Also, the tool indicates inflection
(gender and number for nouns, tense and per-
son for verbs) and gives syntactic information
(head-modifier) for noun phrases.
4.2 Overview of asares
The method used for the acquisition of N-V
pairs relies mainly on asares, a pattern in-
ference tool. Asares is presented in detail in
(Claveau et al, 2003). We simply give a short
account of its basic principles herein.
Asares is based on a Machine Learning
technique, Inductive Logic Programming (ILP)
(Muggleton and De-Raedt, 1994), which infers
general morpho-syntactic patterns from a set
of examples (this set is noted E+ hereafter)
and counter-examples (E?) of the elements one
2
Cordial is a commercial product of Synapse-
D?veloppement.
CompuTerm 2004  -  3rd International Workshop on Computational Terminology40
wants to acquire and their context. The con-
textual patterns produced can then be applied
to the corpus in order to retrieve new elements.
The acquisition process can be summarized in 3
steps:
1. construction of the sets of examples (and
counter-examples);
2. inference of extraction patterns with
asares; and
3. extraction of N-V pairs from the corpus
with the inferred patterns.
Asares has been previously applied to the ac-
quisition of word pairs sharing semantic rela-
tions defined in the Generative Lexicon frame-
work (Pustejovsky, 1995) and called qualia rela-
tions (Bouillon et al, 2001). Here, we propose
to use asares in a quite similar way to retrieve
our valid N-V pairs. However, the N-V combi-
nations sought are more specific than those that
were identified in these previous experiments.
Formally, ILP aims at inferring logic pro-
grams (sets of Horn clauses, notedH) from a set
of facts (examples and counter-examples of the
concept to be learnt) and background knowledge
(B), such that the program H logically entails
the examples with respect to the background
knowledge and rejects (most of) the counter-
examples. This is transcribed by the two logical
formulae B ?H |= E+, B ?H 6|= E?, which set
the aim of an ILP algorithm.
In this framework, asares infers clauses ex-
pressing morpho-syntactic patterns that gener-
alize the structures of sentences containing the
target element (examples) but not the structures
of the sentences containing counter-examples.
The background knowledge encodes information
about each word occurring in the example or
counter-example, namely the meaning of its tag
(e.g., adjective in plural form, infinitive verb).
The main benefits of this acquisition tech-
nique lie in the inferred patterns. Indeed, con-
trary to the more classical statistical methods
(Mutual Information, Loglike..., see below) used
for collocation acquisition (see (Pearce, 2002)
for a review), these patterns allow:
1. understanding of the results, that is, why a
specific element has been retrieved or not;
2. highlighting of the corpus-specific struc-
tures conveying the target element.
In addition to its explanatory capacity, this sym-
bolic acquisition technique has obtained good
results for other acquisition tasks when com-
pared to existing statistical techniques (Bouillon
et al, 2002).
4.3 Acquisition process
To infer extraction patterns, asares needs a set
of examples (E+) and a set of counter-examples
(E?) of the elements we want to retrieve. In
our case, E+ must thus be composed of (POS-
tagged) sentences containing valid N-V pairs;
conversely, E? must be composed of sentences
containing non-valid N-V pairs. While this step
is tedious and usually carried out manually, the
originality of our work lies in the fact that E+
and E? are obtained automatically.
To produce the positive examples, we use the
existing entries of a terminological database we
are currently developing. These entries are thus
a kind of bootstrap in our acquisition process.
More precisely, every N-V pair in which V is de-
fined in the database as a realization verb for N
is included. Then, all sentences in our corpus
containing this N-V pair are considered as ex-
amples and added to E+. Note that we do not
check if each occurrence of the N-V pair actually
shares the target semantic link or even a syn-
tactic link in the sentences that are extracted.
Some of the examples in E+ might be incorrect,
but asares tolerates a certain amount of noise.
A totally different technique is needed to pro-
duce the E? set, since no information concern-
ing verbs that are not semantically related is
available in the terminological database. To ob-
tain a list of invalid N-V pairs, we acquire them
from our corpus using a statistical technique.
This produces a list of all N-V pairs that ap-
pear in the same sentence, and assigns each a
score. Many statistical coefficients exist (Man-
ning and Sch?tze, 1999); most of them can be
easily expressed with the help of a contingency
table similar to that reproduced in Table 1 and
by noting S = a + b + c + d. For example, the
Vj Vk, k 6= j
Ni a b
Nl, l 6= i c d
Table 1: Contingency table for the pair Ni-Vj
Mutual Information coefficient is defined as:
MI = log2 a(a+ b)(a+ c)
and the loglike coefficient (Dunning, 1993) as:
Log = a log a + b log b + c log c + d log d ? (a +
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 41
b) log(a+ b)? (a+ c) log(a+ c)? (b+ d) log(b+
d)? (c+ d) log(c+ d) + S log S.
In the work presented here, we have adopted
the Loglike coefficient. From the N-V pair list
produced with this method, we have chosen the
pairs that obtained the lower Loglike scores. As
for the positive examples, we consider that each
sentence containing one of the pairs is a counter-
example and is added to E?.
Finally, asares is launched with these E+
and E? sets; each containing about 2600 sen-
tences. About 80 patterns are then produced;
some of them are presented and discussed in sec-
tion 5.1. These patterns can now be applied to
the corpus in order to retrieve valid N-V pairs.
5 Performance evaluation
5.1 Inferred patterns
The inferred patterns give some interesting in-
formation about the way the target semantic re-
lationships are expressed in our corpus. While
some structures are general, others seem very
specific to our corpus.
First of all, proximity is an important factor
in valid relationships between nouns and verbs;
it can be observed in numerous patterns. For
example, the inferred Horn clause:
realization(N,V) :- common_noun(N), contigu-
ous(N,V), N 6=V. transcribes the fact that a noun
and a verb may be a valid N-V pair if N is
a common noun (common_noun(N)) and V is
contiguous to N (contiguous(N,V). (Determiners
are not taken into account.) This pattern
covers the case in which N precedes V, such as
 les utilisateurs lancent tour-?-tour leurs programmes
(users launch in turn their programs) or
in which V precedes N, such as  il est donc
n?cessaire d'ex?cuter la commande depmod  (thus,
it is necessary to run the depmod command .
A quite similar clue is given in the following
pattern:
realization(N,V) :- near_verb(N,V), suc(V,C),
suc(C,N), noun(N), V 6=C, N 6=C, N 6=V. The
near_verb(N,V) predicate means that no verb
occurs between N and V, and suc(X,Y) that
the word X is followed by Y. This clause can
be expressed in a more classical way as V +
(anything but a verb) + N and retrieves pairs like
C'est un service qui vous permet de vous connecter
? Internet (This is a service that allows you to
connect to the Internet).
Another frequent clue in the patterns pro-
duced is, unsurprisingly, that N must be the
head of a noun phrase. For example, realiza-
tion(N,V) :- near_word(N,V), near_verb(N,V), pre-
cedes(V,N), noun_ph_head(N), pred(N,C), preposi-
tion(C), V 6=C, N 6=C, N 6=V. This pattern means
V + (anything but a verb)? + (preposition) + N
head of a noun phrase and retrieves pairs such as:
 les dispositifs d'impression n'?taient pas contr?l?s par
ordinateur (the printing devices were not con-
trolled by computer ).
Prepositions also play an important part
and appear frequently in the patterns: re-
alization(N,V) :- near_verb(N,V), pred(N,C),
lemma(C,sur), V 6=C, N 6=C, N 6=V. (that is V +
(anything but a verb)* + sur + N) covers for
example un terminal (...) permet de travailler sur
l'ordinateur (a terminal (...) allows [one/the
user] to work on the computer ).
The pattern realization realization(N,V)
:- near_verb(N,V), precedes(V,N), pred(N,C),
lemma(C,?), V 6=C, N 6=C, N 6=V., that is V +
(anything but a verb)* + ? + N, covers comment
vous connecter ? Internet (How to connect to the
Internet).
realization(N,V) :- near_verb(N,V), precedes(N,V),
pred(V,C), lemma(C,?), common_noun(N), V 6=C,
N 6=C, N 6=V., that is N + (anything but a verb)* +
? + V , covers (...) mode de traitement des don-
n?es suivant lequel les programmes ? ex?cuter (...)
(...mode of data processing in which the pro-
grams to execute...).
A certain number of patterns express struc-
tures more specific to our corpus. For example,
the clause:
realization(N,V) :- near_verb(N,V), precedes(V,N),
suc(N,C), proper_noun(C), common_noun(N), V 6=C,
N 6=C, N 6=V. (that is, V + (anything but a verb)* +
common noun N + (proper noun)) is very specific to
structures including a proper noun, such as the
sentence: (...) Internet utilise le protocole TCP/IP
(...) (the Internet uses the TCP/IP protocol).
5.2 Methodology for evaluation
In order to evaluate the quality of the extracted
N-V pairs, we are interested in two different
measures. The first one expresses the complete-
ness of the set of retrieved N-V pairs, that is,
how many valid pairs are found with respect
to the total number of pairs which should have
been found; this is the recall rate. The second
measure indicates the reliability of the set of re-
trieved N-V pairs, that is, how many valid pairs
are found with respect to the total number of re-
trieved pairs; this is the precision rate (defined
below). These two rates were evaluated using a
test sample containing all this information.
CompuTerm 2004  -  3rd International Workshop on Computational Terminology42
To construct this test set, we have focused
our attention on ten domain-specific terms: com-
mande (command), configuration, fichier (file), In-
ternet, logiciel (software), option, ordinateur (com-
puter), serveur (server), syst?me (system), utilisa-
teur (user). The terms have been identified as
the most specific to our corpus by a program
developed by Drouin (2003) and called Termo-
Stat. The ten most specific nouns have been
produced by comparing our corpus of comput-
ing to the French corpus Le Monde, composed
of newspaper articles (Lemay et al, 2004). Note
that to prevent any bias in the results, none of
these terms were used as positive examples dur-
ing the pattern inference step. (They were re-
moved from the example set.)
For each of these 10 nouns, a manual identifi-
cation of valid and invalid pairs was carried out.
Linguists were asked to analyze the sentences
and decide whether the highlighted pairs were
valid N-V pairs. Examples of the sentences pro-
duced are given in Table 2 for the term utilisateur
(user). A pair is considered as valid if at least
one of its occurrences has the desired semantic
(and syntactic) relationship (cf. section 2).
Finally, 603 of the N-V pairs examined are
valid and 4446 are considered not to be valid.
The results for each noun are detailed in Table 3.
valid non-valid total
commande 114 346 460
configuration 4 361 365
fichier 21 604 625
option 69 324 393
syst?me 82 605 687
Internet 9 535 544
ordinateur 85 432 517
utilisateur 96 435 531
logiciel 64 440 504
serveur 59 364 423
Total 603 4446 5049
Table 3: Summary of the test set
5.3 Results
To compare the results obtained by our tech-
nique with the analysis carried out manually,
we use the traditional precision/recall approach.
Thus we applied the patterns to the corpus and
kept all the pairs retrieved when N is one of the
ten specific nouns. The results of the compari-
son are summarized with the help of confusion
matrices like the one presented in Table 4
3
.
actual actual
valid non-valid Total
predicated
valid TP FP PrP
predicated
non-valid FN TN PrN
Total AP AN S
Table 4: Confusion matrix
It is important to note here that the values in
this confusion matrix depend on a parameter: a
detection threshold. Indeed, a single occurrence
of a N-V pair with the patterns is not sufficient
for a pair to be considered as valid. The thresh-
old, called s, represents the minimal number of
occurrences to be detected to consider a pair as
valid. The recall and precision rates (respec-
tively R and P ), measured on our test set, are
thus defined according to s.
In order to represent every possible value of R
and P according to s, we draw a recall-precision
graph in which each value of P is related to
its corresponding value of R. Figure 1 gives
the graph obtained when applying the inferred
patterns to the test set. For comparison pur-
poses, Figure 1 also indicates the recall-precision
graphs obtained by two common statistical tech-
niques for collocation acquisition (the Loglike
et Mutual Information coefficients presented in
section 4.3). As a baseline, this graph also gives
the density, computed as AP/S, which repre-
sents the precision that would be obtained by
a system deciding randomly if a pair is valid or
not.
The recall-precision graph shows that our
symbolic technique outperforms the two statis-
tical ones; for a fixed recall, the precision gain
is up to 45% with respect to the Loglike results
and is even higher with respect the MI coeffi-
cient. Thus, our acquisition technique meets the
objective of offering assistance to the terminog-
rapher, since it provides many reliable N-V pair
candidates. However, results show that invalid
pairs are also retrieved; thus a manual analysis
remains unavoidable.
5.4 Discussion of the results
When examining the retrieved pairs, it appears
that most invalid N-V pairs can be classified in
3
The meaning of the variables is given by the combi-
nation of the letters: A means actual, Pr predicated, T
true, F false, P positive and N negative.
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 43
Examples Comment
utilisateur___ex?cuter 162.823 13.907792621292
* MemCheckBoxInRunDlg Autorise les utilisateurs#N# ? ex?cuter#V# un
programme 16 bits dans un processus VDM ( Virtual DOS Machine ) d?di?
( non partag? ) .
Valid syntactic and seman-
tic relationship: "user runs
a program"
utilisateur___formater 162.823 0.27168791461736
* AllocateDasd D?termine quels utilisateurs#N# peuvent formater#V# et
?jecter les disques_durs amovibles .
Valid syntactic and seman-
tic relationship: "user for-
mats a hard disk"
utilisateur___lancer 162.823 17.9010990569368
* Il utilise donc le num?ro de l_ utilisateur#N# r?el qui a lanc?#V#
la commande pour savoir si c_ est bien l_ utilisateur#N# root qui l_
a lanc?#V# .
Valid syntactic and se-
mantic relationship: "user
launches a command"
Counter-examples Comment
utilisateur___accepter 162.823 0.0059043737128377
* Ces commandes sont absolument essentielles pour pouvoir
utiliser le syst?me , mais elles sont assez r?barbatives et peu_d_
utilisateurs#N# acceptent#V# de s_ en contenter .
Syntactic relationship is
valid; Semantic relation-
ship is not valid
utilisateur___entourer 162.823 0.41335402801632
* Mais , c?t? utilisateur#N# , plus on a entour?#V# ou rempli
son Macintosh de p?riph?riques , plus grands sont les risques de
rencontrer des blocages ou des sautes_d_humeur .
Syntactic relationship is
not valid
Table 2: Positive and negative examples with utilisateur (Engl. user)
 0
 0.2
 0.4
 0.6
 0.8
 1
 0  0.2  0.4  0.6  0.8  1
Pr
ec
is
io
n
Recall
ASARES
Density
Mutual Information
Loglike
Figure 1: Recall-Precision graph
one of the four following categories.
First, some errors are due to tagging mistakes.
For example, in the sentence  la premi?re solution
est d'utiliser la commande date  (the first solution
is to use the date command ) the noun date
was incorrectly tagged as a verb, and the N-V
pair commande-dater was retrieved by one of the
inferred patterns. Even if this kind of error does
not come directly from our acquisition technique
and does not call into question our approach, it
is still a factor that should be taken into ac-
count, especially when considering the choice of
CompuTerm 2004  -  3rd International Workshop on Computational Terminology44
the tagger and the quality of the texts compos-
ing our corpus.
Secondly, in a few cases, there is no syn-
tactic link between N and V, as is the
case with logiciel-garantir (software-guarantee) in
cette phase garantit la v?rification du logiciel (this
step guarantees the software verification). Even
if these errors are rare in the retrieved pairs ex-
amined, our symbolic extraction system could
certainly be enhanced with information about
the syntactic function of nouns (subject, direct
object...). The learning algorithm could then
incorporate this information and produce more
relevant patterns.
Thirdly, some N-V pairs are retrieved, al-
though there is no semantic link between N and
V, or at least, not a semantic link that would
be encoded by a terminographer in a dictionary.
This is the case for ordinateur-savoir (computer-
know) in  l'ordinateur ne sait pas o? chercher (the
computer does not know where to look ). Again,
morpho-syntactic information is not always suf-
ficient to distinguish between semantically re-
lated pairs and non-semantically (but syntacti-
cally) related ones.
Finally, other very frequent errors are caused
by the fact that there actually is an interesting
semantic link between N and V in a retrieved
pair, but not the realization link we are looking
for. Indeed, some nouns belonging to specific
semantic classes will often cooccur with verbs
expressing realization meanings (and thus often
appear in valid N-V pairs) while others do not.
For example, nouns like ordinateur (computer)
and utilisateur (user) often appear in valid N-V
pairs. On the other hand, other nouns clearly
do not appear in combinations with realization
verbs (e.g., configuration; Internet, refer to Table
3).
These last two kinds of error clearly illustrate
the limitations of our symbolic approach (but
are also very frequent errors in statistical ap-
proaches since cooccurrence is not enough to
capture subtle semantic distinctions). In fact,
they tend to show that our method could be
enhanced if it could incorporate richer linguis-
tic information. Indeed, morpho-syntactic infor-
mation is not always sufficient to operate fine-
grained sense distinctions. For example, the
two sentences below have the same combina-
tion of Part-of-Speech tags: vous pouvez utiliser la
commande exit (you can use the exit command)
and vous devez choisir l'option 64MB (you must
choose the 64MB option); in the first one the
underlined N-V pair is valid whereas this is not
the case in the second one. Realization verbs
for option would be valider (validate) and activer
(activate), for example. Here again, these subtle
distinctions could be handled by our symbolic
method provided that some semantic informa-
tion is given on nouns This could be supplied
by a semantic tagger.
6 Concluding remarks and future
work
We have presented an original acquisition pro-
cess for noun-verb pairs in which verbs convey a
realization meaning. These noun-verb pairs are
acquired from a domain-specific corpus of com-
puting. Our acquisition method, which relies
on asares, a extraction pattern inference tech-
nique, produces results that are quite good and
could improve manual terminographical work.
In particular, our method outperforms classical
statistical techniques often used for collocation
acquisition. Moreover, the inferred patterns give
interesting clues about the structures that are
likely to convey the target semantic link.
Many possibilities for future work are sug-
gested by this experiment. Concerning our ac-
quisition process, some adaptations could cer-
tainly improve the results, currently limited
by the sole use of Part-of-Speech tags and
noun-phrase information. As was previously
mentioned, syntactic and semantic information
could be added to the corpus through a tag-
ging and parsing process. These two enrich-
ments could help to overcome some limitations
of our symbolic approach to capture the nature
of N-V relationships. In terms of applications, it
would be interesting to use a similar technique
for the acquisition of other more specific seman-
tic links between nouns and verbs and even be-
tween nouns and nouns or other categories of
words. These semantic relationships would al-
low us to complete the description of the ter-
minological units contained in our dictionary of
computing. The comparison of the acquisition
results and of the inferred patterns could lead
to interesting insights.
Aknowlegements
The authors would like to thank Sahara Iveth
Carre?o Cruz and L?onie Demers-Dion for their
help in analyzing the data and Elizabeth Marsh-
man for her comments on a previous version of
this paper.
CompuTerm 2004  -  3rd International Workshop on Computational Terminology 45
References
Pierrette Bouillon, Vincent Claveau, C?cile
Fabre, and Pascale S?billot. 2001. Using
Part-of-Speech and Semantic Tagging for the
Corpus-Based Learning of Qualia Structure
Elements. In First International Workshop
on Generative Approaches to the Lexicon,
GL'2001, Geneva, Switzerland.
Pierrette Bouillon, Vincent Claveau, C?cile
Fabre, and Pascale S?billot. 2002. Acqui-
sition of Qualia Elements from Corpora 
Evaluation of a Symbolic Learning Method.
In 3rd International Conference on Language
Resources and Evaluation, LREC 02, Las Pal-
mas de Gran Canaria, Spain.
Kenneth W. Church and Patrick Hanks. 1990.
Word Association Norms, Mutual Informa-
tion, and Lexicography. Computational Lin-
guistics, 16(1):2229.
Vincent Claveau, Pascale S?billot, C?cile Fabre,
and Pierrette Bouillon. 2003. Learning Se-
mantic Lexicons from a Part-of-Speech and
Semantically Tagged Corpus using Induc-
tive Logic Programming. Journal of Ma-
chine Learning Research, special issue on ILP,
4:493525.
B?atrice Daille. 2003. Conceptual structuring
through term variation. InWorkshop on Mul-
tiword Expressions. Analysis, Acquisition and
Treatment. Proceedings of the ACL'03, Sap-
poro, Japan.
Patrick Drouin. 2003. Term-extraction using
non-technical corpora as a point of leverage.
Terminology, 9(1):99115.
Ted E. Dunning. 1993. Accurate methods for
the statistics of surprise and coincidence.
Computational Linguistics, 19(1):6174.
Natalia Grabar and Pierre Zweigenbaum.
2002. Lexically-based terminology structur-
ing. some inherent limits. In Second Work-
shop on Computational Terminology, Com-
puterm 2002. Coling 2002, Taipei, Taiwan.
Beno?t Habert, Ellie Naulleau, and Adeline
Nazarenko. 1996. Symbolic word clustering
for medium-sized corpora. In Proceedings of
the 16th Conference on Computational Lin-
guistics, Coling'96, Copenhagen, Denmark.
Zellig Harris. 1971. Structures math?matiques
du langage. Paris: Dunod.
Adam Kilgarriff and David Tugwell. 2001.
Word-Sketch: Extraction and Display of
Significant Collocations for Lexicography. In
Workshop on Collocation: Computational
Extraction, Analysis and Exploitation, 39th
ACL and 10th EACL Conference, Toulouse,
France.
Chantal Lemay, Marie-Claude L'Homme, and
Patrick Drouin. 2004. Two methods for ex-
tracting "specific" single-word terms from
specialized corpora. Forthcoming.
Marie-Claude L'Homme. 2004. S?lection de ter-
mes dans un dictionnaire d'informatique :
Comparaison de corpus et crit?res lexico-
s?mantiques. In Euralex 2004. Proceedings,
Lorient, France. Forthcoming.
Christopher D. Manning and Hinrich Sch?tze.
1999. Foundations of Statistical Natural Lan-
guage Processing. The MIT Press, Cam-
bridge, MA, USA.
Igor Mel'?uk, Nadia Arbatchewsky-Jumarie,
L?o Elnitsky, Lidija Iordanskaja, Ad?le Les-
sard, Louise Dagenais, Marie-No?lle Lefeb-
vre, Suzanne Mantha, and Alain Polgu?re.
19841999. Dictionnaire explicatif et combi-
natoire du fran?ais contemporain, Recherches
lexico-s?mantiques, volumes I-IV. Les Presses
de l'Universit? de Montr?al, Montr?al, QC,
Canada.
Stephen Muggleton and Luc De-Raedt. 1994.
Inductive Logic Programming: Theory and
Methods. Journal of Logic Programming, 19-
20:629679.
Rochdi Oueslati. 1999. Aide ? l'acquisition
de connaissances ? partir de corpus. Ph.D.
thesis, Univesit? Louis Pasteur, Strasbourg,
France.
Darren Pearce. 2002. A Comparative Evalu-
ation of Collocation Extraction Techniques.
In 3rd International Conference on Language
Resources and Evaluation, LREC 02, Las Pal-
mas de Gran Canaria, Spain.
James Pustejovsky. 1995. The Generative Lexi-
con. The MIT Press, Cambridge, MA, USA.
Frank Smadja. 1993. Retrieving Collocations
from Text: Xtract. Computational Linguis-
tics, 19(1):143178.
Ellen M. Voorhees. 1994. Query Expansion Us-
ing Lexical-Semantic Relations. In Proceed-
ings of ACM SIGIR'94, Dublin, Ireland.
CompuTerm 2004  -  3rd International Workshop on Computational Terminology46
