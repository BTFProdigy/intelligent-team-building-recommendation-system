On Underspecif ied Processing of Dynamic Semantics 
Alexander Keller, Joachim Niehren 
University of the Saarland, Saarbriicken, Germany 
{koller@coli I niehren@ps}, uni-sb, de 
Abstract  
We propose a new inference system which oper- 
ales on underspecified semantic representations 
of scope and anaphora. This system exploits 
anaphoric accessibility conditions from dynamic 
selnantics to disambiguate scope ambiguities if
possible. The main feature of the system is 
that it deals with underspecified descriptions di- 
rectly, i.e. without enumeratlng readings. 
1 Introduction 
A particularly appealing aspect of lmdersl)eci- 
fication (van Deemter and Peters, 1996; Reyle, 
1993; Muskens, 1995; Pinkal, 1996; Bos, 1996) 
is that it can in principle deal very efficiently 
with local ambiguit ies - ambiguities which are 
only due to lack of inibrmation at an interme- 
diate stage of processing and go away by the 
end of the analysis. An example for this effect 
is (1): The scope ambiguity that is perceived 
alter processing the first sentence is no longer 
present after the second one. This effect can 
be explained in a framework of dynamic selnan- 
tics (Groelmndijk and Stokhof, 1991; Kamp and 
Reyle, 1993) by the fact that a wide-scope uni- 
versal quantifier would make the indefinite inac- 
cessible for anaphoric reference from the second 
sei/tence. 
(1) Every man loves a woman. 
Her nanle is Mary. 
In this paper, we show how this particular 
type of local ambiguity can be processed effi- 
ciently. The approach we propose mploys de- 
terministic inference rules that can exclude the 
readings which violate anaphoric accessibility 
conditions without enlnnerating them. These 
rules operate directly on underspecified descrip- 
tions and fully maintain underspecifiedness. We
also show how this behaviour Call be captured 
by constraint propagation i an existing imple- 
mentation of tree descriptions using finite set 
constraints (Duchier and Niehren, 2000; Keller 
and Niehren, 2000; Duchier and Gardent, 1999). 
More specifically, we introduce DPL struc- 
tuT"cs~ extended trce structures that encode for- 
mulas of dynamic predicate logic (DPL) in much 
the same way as Egg et al's (1998) lambda 
structnres encode A-terms. Then we define a 
constraint language tbr the description of DPL 
structures, called CL(DPL), in analogy to Egg 
et al's constraint langague for lambda struc- 
tures (CLLS). We characterize those DPL struc- 
tures in which all restrictions oil anaphoric ac- 
cessibility are obeyed by talking directly about 
the syntactic structure of a DPL formula. This 
is ill contrast o the standard procedure in dy- 
nanfic semantics, where the dynamic behaviour 
is produced by the semantics of the logic; we do 
not need to (and do not) talk about interpreta- 
tion of DPL structures and model accessibility 
by purely "static" means. 
The paper is structured as follows. In Sec- 
tion 2, we introduce DPL structures and tree 
descrit)tions in the language CL(DPL). In Sec- 
tion 3, we add syntactic restrictions on admis- 
sible variable bindings to DPL structures and 
present axioms that characterize these restric- 
tions. In Section 4:, we turn these axioms into 
deterministic nfhrence rules and combine them 
with deterministic inference rules known from 
an existing ilfference algorithm for dominance 
constraints. We obtain a procedure that can do 
the kind of underspccified reasoning described 
above without enmncrating readings. In Section 
5, we sketch all imtflelnentation f our inf'erence 
system based on finite set constraint prograln- 
ming. This implementation can be obtained by 
adapting an existing ilnI)lelnentation f a solver 
for dominance constraints. Finally, we conclude 
and point to further work in Section 6. 
2 Tree Descr ipt ions 
In this section, we define the Constraint Lan- 
guage tbr DPL structures, CL(DPL), a lan- 
guage of tree descriptions which conserw~tively 
extends donfinance constraints (Marcus et al, 
1983; Rainbow et al, 1995; Keller et al, 2000) 
by variable binding constraints. CL(DPL) is 
a close relative of the Constraint Language for 
460 
Lamb(la Structures (CLLS), 1)resented in (Egg 
et al, 1998). It; is interl)reted over DPL struc- 
tures - trees extended by a variable 1)inding 
function which can be used to encode tbrmulas 
of dynamic (or static) predicate logic. We will 
define DPL structures in two steps and then the 
language to talk al)out them. 
2.1 Tree St ruetures  
For the definitions below, we assulne a signature 
Y\] = {(~12, varl0,Vl~,~ll,Al.z, manll , likel2,... } of  
node labels, each of which is equipped with a 
fixed arity n _> 0. The labels A,_~,_V,... are the. 
tirst-order commctives. Node lal)els are. ranged 
over by f, g, a, b, and the arity of a lal)el f is 
denoted by ar(./'); i.e. if J'l,~ C E then ar(f) = n. 
Let N l)e the set; of natural numbers ~. > 1. 
As usual, we write N* tbr the set of words over 
N, C for the elnl)ty word, and 7r~-' for the con- 
catellatioll of two words 7r, 7r t C N*. A wor(t 7t is 
a prefiz of 7c' (written rc _< re') if there is a word 
7r u such  that  7rTr tt = 7r t. 
A node of a tree is the word rr E N* which 
addresses the node. The empty word e C N* 
is called the root node. A tree domain A is a 
nonempty, t)refixed-closed subset of N* which is 
closed under the left-sil)ling relation. 
Def in i t ion  2.1 A t ree s t r l l c t i l re  iS a t'a\])l(: 
(A,  c,) consisting of a finite, tree dmn, ain A and 
a total labeling t'unction co ? : A -+ E s'ach th, al, 
for all rr 6 A and i G N: 
c A 1 < i < 
We say that the nodes r 6 rcl , . . . ,  7c~ m'e in the 
labeling ,'elationsh/ip 7c: J' On , . . . ,  7r,~) ill! a (Tr) = J' 
and tbr each 1 < i < n, ~-i = ~-i. Similarly, we 
say that a node ~c properly dom, inatcs a node 
7c' and write 7r<\]+rc ' iffrr is a proper prefix of 
7c'. We take Ir and It' to be disjoint (~r J_ ~r') if 
ttley are different and neither node dominates 
the other. So any two nodes in a tree structure 
are in one of the four relations = (equality), <1 +, 
~>+ (the inverse of <1+), or _L. We shall ~lso t)e 
interested the coml)inations of these l"elatiolls by 
set operators: intersection, coml)lementation , 
union, and inversion. For instance, the dom- 
inance relation <~* is detined as the union of 
node equality and proper dominance = U<1 +. 
Finally, we detine the ternary non-intervention 
relation ~(Tr<l*Td<Frc") to hold ifl' it is not the 
case that 1)oth ~r < ~r' and ~r' < re". 
.' ~r 
var  a ~ 
ma0 \lo  
var  ? var  t r  var - .  
Figm'e 1: I)PL structure tbr the meaning of (1). 
2.2 DPL  s t ruc tures  
Now we extend tree structures by variable 
binding and obtain DPL structures. To this 
end, we I)artition E into three sets: connee- 
tive.s Econ = {V_,A,_%...}, predicate symbols 
Epred = {man, likes,...}, and tcr'm symbols 
Ere,., .  = {var, peter, mother_of,...} which sub- 
stone, the variable symbol var and fimction sym- 
1)ols. 
Def in i t ion  2.2 A DPL structure is a triple 
(A,c&A) con.~isting of a trcc structure. (A,c,) 
and a partial varial)le t)inding flmction A : A 
A which sati.sfies for all % ~r t ~ A:  
1. the .  < r.co,, u .fo,. 
all 7ci C A;  
2. < the,,,, fo,. 
all 7ci ~ A;  
I)PL structures can be used to re, present ibr- 
mulas of first-order predicate logic. For in- 
stance, the DPL structure in Fig. 1 represents 
the (unique) meaning of (1). So far, however, 
variables bound by a quantifier do not need to 
be in any special position in a DPL structure; in 
particular, not in its scope. To entbrce seeping 
as in static predicate logic, we could simpy add 
the condition ~c'<~*~r in condition 3 of Definition 
2.2. We will define an appropriate counterpart 
\]'or DPL in Section 3 (properness). 
Modeling variable binding with an explicit 
binding flmction instead of variable nmnes was 
first proposed in (Egg et al ,  1998) .  There, bind- 
ing flmctions heJp to avoid a capturing problem 
in the context of scope underspecitication which 
t)ecomes most ~q)l)arent in the presence of ellip- 
sis. Her(; the 1)inding flmction mainly gives us a 
different t)erspective on variable binding which 
461 
R : :=  <+1>+1 = I?  
I -* 
::= X: f (X \ ] , . . . ,X , , )  (fin C E) 
I xRz  
I 
I 
\[ ~A~'.  
Figure 2: Syntax of CL(DPL) 
is useflfl for defining properness of DPL struc- 
tures. 
2.3 The Constraint Language CL(DPL) 
The syntax of CL(DPL) is defined in Fig- 
ure 2. It provides constraints tbr all the 
relations discussed above. There are label- 
ing constraints X: . f (X~,. . . ,Xr~),  expressive 
combinations XRY of dominance constraints 
'with set operators (Dtu:hier and Niehren, 
200(}; Cornell, 1994), non-intervention con- 
straints ~( X <1* Y <~* Z), and binding constraints 
a(X)=Z.  
CL(DPL) is interpreted over DPL structures. 
A variable assignment into a DPL structure 54 
is a total flmction fi'om the set of variables of a 
constraint o the domain of 54. A pair (54, oz) 
of a DPL structure 54 and a variable assign- 
ment (t into 54 satisfies a constraint qo ifl' it 
satisfies all of its atomic constraints; that is, if 
the relation with the same sylnbol holds of the 
nodes assigned to their arguments. We also call 
the pair (54, oz) a solution and Ad a model of ~o. 
Only some of the atonfic constraints in 
CL(DPL) are used in mlderspecified escrip- 
tions in t)articular, labeling, dominance, and 
binding constraints; the other constraints are 
helpful in processing the others. These three 
types of constraints can be transparently dis- 
played in constraint graphs. For instance, the 
constraint graph ill Fig. 3 represents a con- 
straint describing the readings of example (1) 
including the scope ambiguity. The nodes of 
the graph stand for variables in tile constraint; 
labels and solid edges represent labeling COl> 
straints, dotted edges, donlinance constraints, 
and dashed arrows, binding constraints, hi ad- 
dition, the constraint graph represents an in- 
equality constraint X-~=Y between each two 
variables whose nodes carry a label. A con- 
straint with the latter property is called overlap- 
free. The intuition is that the solid-edge tree 
fragments in the constraint graph must never 
overlap properly in a solution. 
3 Dynamic Semantics in CL(DPL)  
The semantics of DPL is built in a way that 
allows quantifiers to bind only variables in cer- 
tain positions: inside their scopes and, if it is an 
existential quantifier, from the left-hand sides 
of conjunctions and implications into the right- 
hand sides. In CL(DPL), we model this as a 
purely syntactic restriction on the accessibility 
of binders which we define as a structural prop- 
erty of DPL structures. DPL structures which 
have this property will be called proper. 
A useflll auxiliary concept tbr the definition 
is that of an infimum of two nodes with respect 
to the dominance relation q*, which constitutes 
a lower senfilattice because of the underlying 
treeness of DPL structures. Furthermore, we 
will use the standard DPL notions of internally 
v@" = {A,~} and ex- dynamic COlUlectives ~con
te rna lh  d, static connect ives ~con'~stat = {2, V, __=::k, _V}. 
The semantics definition of DPL gives these two 
groups special relevance tbr variable binding. 
Now we can define pTvper \])PL structures as 
tbllows. 
Def in i t ion 3.1 A DPL structure 54 is called 
proper '~f or each, node ~r of 54 on which ~ is 
defined, one of th, e following cases holds true 
wh, ere p, is the i'nfimum of rc and A(TC). 
1.  ff = ;~(~), or 
2. )@r) is labeled 'with ~_, ttl<l*.~(Tr), p,2q*% I t 
is labeled with art internally dynamic con- 
nective, and no node between ttl and A(Tc), 
inclusively, is labeled with an externally 
static connective. 
Intuitively, the first branch of the definitiou 
corresponds to usual binding of variables inside 
tile scope of a quanfifer. In the second branch, 
the positions of the variable and the (existen- 
tial) quantifier in the DPL structure are dis- 
.joint, and the quantifier is dominated by tile 
left child of the infimum. Then the infimum 
must be labeled with an internally dynamic on- 
nective, and there must be no externally static 
connective between this node and the quantifier. 
This restriction is what we are going to exploit 
462 
, . . - ' '  
r ,  
/ 
? / 
womb2',1% ..)...':'- 
\ , , '  
\ 
vat 
Figure 3: Constraint graph for (1). 
to capture the influence 055 scope. There is 51o 
such restriction for the lmth 1)etwcen the inti- 
mmn and the w~riM)le. 
Sohll;ions of & constraint hnt violate the (ly- 
nmnie accessibility conditions are now excluded 
silnply by restricting the, class of ~utmissible so- 
lutions to i)roper ones. As exl)ected from the 
linguistic intuition, only one sohd;ion of the nm- 
ning exmnple (1) is proper: the one where "a 
woman" is assigned wide scope (Fig. 1). Tit(; 
other solution is not prot)er because the path 
Kern the infimum ((lellol;cd by Z0 in Fig. 3) to 
the antecedent contains ;~ mfiversal qu~mtiticl". 
Prot )erness  o f  ;~ I)PI, sl;ruct;u5"(' ('t~sl I)(; ~tx io ln-  
atized synta,ctically: A \])PL sl;rucl;urc is 1)rot)er 
iff the CI~(I)I'I~)~xioms ( l )y , , \ ] ) to  ( l )yn4) in  
Fig. 4 ~re, wflid over it. The rule (Dynl) threes 
universM qmmtifiers to bind only variM)les in 
their scopes, and the rules (l)yn2) to (Dyn4) 
enforce properness of binding when a wtrial)le 
is not in the scope of its binder. 
4 Underspec i f ied  Reason ing  
We next present a procedure for mMorspeci- 
tied reasoning with dynmnic semmltics. Th(' 
goal is to narrow an mMerst)ecified (les(;rit)tion 
such that improi)er DPL-structure, s are removed 
flom the solution set. Narrowing should apply 
as soon as possible, so unde, rspeciliedness (:~m be 
5naintmned and readings need not t)e enmner- 
ated. We present ml intb, rence procedure tlmt 
can do this and go through two exmnples. 
4.1 In fe rence  Procedure  
This infi;rence procedure ,s'atuvatt,.s a,constrMnt 
ttccording to the rules in Figures 4 and 5; that 
is, whenever a constraint conttdns the lefl;-hmM 
side of a rule,, i t  adds il;s right-hand side, until 
no new conjuncts ca, n 1)e ndded. Fig. 4 contains 
simply the prot)erness axioms from the, l)revi- 
ous sections, turned into deterministic proof 
rules. The rules in Pig. 5 are t)ropagation rules 
t'ronl Algorithm DO in (Duchier and Niehren, 
2000), plus new rules for non-intervention con- 
strainl;s. Algorithm DO contains some ~Mdi- 
tional rules, in I)ari;iculm' distribution rules that 
perform case distinctions, because DO is a com- 
plete solver tbr dominance constraints with set 
operators, wlfich improves on (Duchier and Oar- 
dent, 1999; Keller et M., 1998). We have omit- 
ted the (listril)ution rules here l)e,(;ause we do 
'not wmlt to perform case distinctions; l)y ndding 
1;\]1(;115 ~tg~l, i l~ WC COll\]d ellll511era, I;e all proper so- 
lutions, ~:ls Schiehlen (1997) does tbr UDI1T. 
The new rules (NonI1) ~md (NonI2) Mlow 
to derive dominan(:e infbrmation from non- 
intervention constraints. As we will see, the 
most interesting rule in Fig. 4 is (l)yn2), 
which derives explicit non-intervention i t'orma- 
lion fi'om the structurM t)roperLies of dynamic 
1)inding. Note that while the rules in Fig. 5 
are sound over ;my DPL strucl;ure, those in Fig. 
4 are only serum eve5" proper DPL structures. 
This is intended: Application of a prot)erness 
rule is s'upposcd to exclude (improper) solutions. 
4.2 Examples  
The inii;rence rules go a long w:ty towards mak- 
ink tile eft'cot of dynamic seminal;its on scope 
e, xt)lieit. Let us consider |;15(; running example 
in Figure 3 to see how this works; we show how 
to derive Y3<I*X, which specifies the relative 
quantifier scope. 
First of all, we need to make the information 
463 
(Dynl) 
(Dyn2) 
(Dyn3) 
(Dyn4) 
a(x)=Y A Y:V(z') Y<*X 
Z(X)=Y A Z:f(Zl, Z2) A ZI<1*Y A Z2<\]*X A W:g(W1,..., Wn) 
~dyn ~st~tt ( fe  or,, e 
~(X)=Y A Z:f (Z1, . . . ,  Zn) A Zi<:1*X A Zj<:\]*Y --+ false 
A(X)=Y A Z:f (Z1, . . . ,Zn)  A Zi<l*X A &<1*Y -~ false 
Figure 4: Properness axioms. 
(Trans) 
(Lab.Dom) 
(NegDisj) 
(Lab.Disj) 
(Inter) 
(Inv) 
(Child.down) 
(NegDom) 
(NonI1) 
(NonI2) 
X <a* Y A Y <q* Z -+ X <1* Z 
x: f ( . . . ,z , . . . )  x<+y 
X <1* Z A Y <F Z --+ X~ -L Y 
,xs,...) 
XR1Y A XR2Y -+ XRY 
XRY -+ YR-1X 
-+ -~(Z~ <*W<a*Y) 
v~dY'1 i ? j) (.fl,, ~ Econ - ,-,co,,, 
(.fl,, e E, i < j) 
Xi ? Xj where i < j 
if RINR2 C R 
X<:\]+Y A X:f(Xl,... ,Xn) A 
X-~ ? Y A X J_Z -+ Z-~<a*Y 
-~(X<*Y<1*Z) A X<*Y  --+ Y~<*Z 
~(X<\]*Y<I*Z) A Y<*Z --," X-~<1*Y 
---> X i <F Y 
Figure 5: Propagation rules for dominance and non-intervention constr~dnts. 
Z2<1*Za explicit by application of (Lab.Dom) 
and (Inter). In this instance, (Inter) is used as 
a rule of weakening. 
(Lab.Dom) Zg:A(Za, Z4) -~ Z,~<1+ Za 
(Inter) Z.~<Y'- Za --+ Z2<F Z3 
Now we can apply the rule (Dyn2) to the vari- 
able binding constraint A(Za) = Y (drawn in 
boldface in the graph) and the V labeling con- 
straint to derive a non-intervention constraint. 
(Dyn2) Z0:A(Z:j, Z2) A ZI<1*X1 A X:V_(X1) 
A Z2<q*Za A A(Z3) = 1/ 
All that is left to do is to make the positive 
dominance intbrmation contained in the new 
non-intervention constraint explicit. As the 
constraint also contains Zo<1*X, we can apply 
(NonI1) on the new non-intervention constraint 
and derive X~<FY. 
(NonIl) =(Zo<1*X<1*Y) A Zo<1*X --+ X~<1*Y 
On the other hand, we can derive non- 
disjointness of X and Y because (Trans), 
(Lab.Dom), and (Inter) allow the deriw~tion of 
X<FW and Y<1*W: 
(NegDisj) X<*W A Y<I*W ~ X= ? Y 
We can now combiue all of our constraints tbr 
X and Y with the intersection rule and obtain 
Y<1*X, which basically determines the order of 
the two quantifiers: 
(Inter) X~<*Y A X-~ ? Y ~ Y<*X 
By exploiting the fact that the constraint is 
overlap-ti'ee (i.e. contains an inequality cost- 
straint for each two labeled variables), we (:an 
even derive Y3<I*X by repeated application of 
the rules (Child.down), (Lab.Disj), (NegDisj), 
and (NegDom). This means that we have flflly 
disambiguated the scope ambiguity by saturn- 
tion with deterministic nference rules. 
Now let us consider a more complicated ex- 
ample. Fig. 6 is the underspecified description 
of the semantics of 
(2) Every visitor of a company saw one of its 
departments. 
The constraint graph has five solntions, three 
of which are proper. Unfortunately, the con- 
straint language is not expressive nough to 
describe these three solutions ill a single con- 
straint: Both X and Z can be either above or 
below Y, even in a proper solution, but if X is 
below Y, Z must be too, and i fX  is above Y, Z 
must be anywhere below X (but; may be above 
464 
? IX  V ,, Y " " " - -  q ,,,Z 
company ." " - 
x " .  ." i ". , "  " 
var " researcher i ". / o f~- - - -~  depar.tmen-gh'~ ; , 
"~". var \~! .." ' Var ~ var'~ .""" var ~"." ? i .." " 
", ".  L" i . " / 
v a r ' ~  vat ~ . . . . . . .  
Figure 6: Constraint graph for (2). 
YI). In other words, this constraint is an exam- 
pie where the inference procedure is not strong 
enough to narrow the description. In this case, 
we must still resort to pertbrming nondetermin- 
istic case distinctions; at worst, the rules will 
apply on solved forms of CL(1)PL) constraints. 
constraints over these set variables; examples 
for set constraints are V C V' and V = 
V~ U V.2. The new non-intervention constraint 
~(X<1*Y<1*Z) can be encoded as 
Y e <+(x)  u _L(Z) u >+(Z). 
5 Process ing  w i th  F in i te  Set  
Const ra in ts  
This inferen('e procedure fits nicely with all im- 
ph;mentation of (lominance constraints t)ased on 
constraint programming (Marriott and Stuckey, 
1.998; Koller and Niehren, 2000) with tinite 
set constraints (Miiller, 1999). Constraint pro- 
gramlning is a technology for solving combina- 
toric puzzles eificiently. The main idea is to 
replace "generate and test" by "propagate and 
distrilmt(f'. Constraint prot~agation t)eribrms 
deterministic nferences which prune the search 
space, whereas distribution tmrfonns (nondeter- 
rain|st|c) case distinctions. 
Duchier and Niehren (2000) show how to 
implenmnt a (lominance constraint solver by 
encoding donfinance constraints as finite set 
constraints and disjunctive propagators. This 
solver does not handle non-intervention con- 
strain|s, lint we show here that they can tm 
added very naturally. The (Dyn) rules still have 
to be implemented as saturation rules. 
The idea of this implementation is to encode 
a solution (Ad, ~) of a donfinance constraints by 
introducing for each variable X in the constraint 
and each relation symbol R C {<1 +, t> +, =, J_ } 
a finite set variable R(X). This w~riable is sup- 
posed to denote the set of all variables denoting 
nodes that are in tile relation R to ~(X): 
l~,(X) = {Y  e W(~o)I (M,  ~) b- YI~.X} 
Dominance constr~fints can now be stated as 
The bull| in t)rot)agation tbr set constraints au- 
tomatically implenmnts the rules (NonI1) and 
(NonI2). For instance, assume that X<1*Y t)e- 
longs to ~; then there will 1)e a set constraint 
Y ? <1 +(X), so set constraint propagation will 
derive Y ~ ~_(Z) U t>+(Z). This is the |mined|- 
at(; encoding of Y_L U t>+Z, which is equiwdent 
to Y~<1* Z. 
6 Conc lus ion  
In this paper, we have shown how a sl)ecific type 
of local anti)|gully, which is produced by the in- 
teraction of intersentential naphora nd scope 
ambiguities, can l)e processed ell|clearly ill the 
framework of underspecification. We h~ve de- 
fined \])PL structures, which can be used to 
model fonmflas of DPL, and proper DPL struc- 
tures, ill which w~riable binding must obey the 
accessibility conditions of DPL. Finally, we have 
shown how an underspecified description can be 
narrowed to a description of its proper solutions, 
sometimes without even partial enumeration of
readings, and integrated this operation into all 
implelnentation f dominance constraints which 
is based on tin|re set constraints. 
Se, en from the perspective of DPL, our defini- 
tion of tlrot)ern(;ss i tmrely syntactic and tech- 
nically has nothing to do with dynamic seman- 
tics. We could state such a definition t/ecause 
the expli(;it variable binding flmctions gave us a 
structure-in(let)endear h ndle on variable bind- 
ing that excluded all tbnns of capturing. This 
deviates from the standard perspective of indef- 
465 
inites changing the context, but has the advan- 
tage of being extremely modular in that the ac- 
cessibility conditions are factorized out explic- 
itly. For instance, it is simple to represent he 
meaning of "Bach-Peters entences" by relaxing 
these conditions; it should also be easy to adapt 
our tbrmalism to other frameworks of dynamic 
semantics. Of course, the question of how to 
interpret a DPL structure remains open. 
Another open question is how the approach 
presented here can be extended to higher-order 
systems of dynamic semantics (e.g. Dynanfic 
Lambda Calculus (Kuschert, 1999)). In this 
context, it could be worthwhile to restore tim 
distinction of variable binding and anaphoric 
linking from CLLS. 
Finally, it should be interesting to find other 
classes of local ambiguity that lend themselves 
to a treatment as presented here. So far, there 
are not many related examples; one is lexical 
ambiguity in parsing of dependency grammar, 
as presented in (Duchier, 1999). However, we 
believe that the work presented here provides 
further illustration that underspecified process- 
ing can go a long way towards efficient process- 
ing of local ambiguities. 
Acknowledgments .  This work was sup- 
ported by the l)eutsche Forschungsgemeinschaft 
in the SFB 378. As always, we thank all mem- 
bers of the SFB 378 project CHORUS at the 
University of the Saarland. We are also grateful 
to the participants at the Dagstuhl workshop on 
Dynamic Semantics in February 1999 for com- 
ments and discussions on an earlier version of 
this paper. 
References  
Johan Bos. 1996. Predicate logic unplugged. In 
Proceedings of the lOth Amsterdam Colloquium, 
pages 133-143. 
Thomas Cornell. 1994. On determining the consis- 
tency of partial descriptions of trees. In Proceed- 
ings of ACL. 
Denys Duchier and Claire Gardent. 1999. A 
constraint-based treatment of descriptions. In 2 d 
Int. Workshop on Comp. Semantics, pages 71-85. 
Denys Dnchier and Joachim Niehren. 2000. Domi- 
nance constraints with set operators. In 1st Int. 
Conf. on Computational Logic, LNCS, July. 
Denys Duchier. 1999. Axiomatizing dependency 
parsing using set constraints. In Prw:. of the 6 TM 
M. on Mathematics of Language, pages 115 126. 
Markus Egg, Joachim Niehren, Peter Ruhrberg, 
and t;'eiyn Xu. 1998. Constraints over lambda- 
strnctures in semantic umlerspecification. I  joint 
17 th Int. Conf. on Comp. Ling. and 3# t' Ann. 
Meet. of the ACL., pages 353 359. 
Jeroen Oroenendijk and Martin Stokhof. 1.991. Dy- 
namic predicate logic. Linguistics ~ Philosophy, 
14:39-100. 
Hans Kmnp and Uwe Reyle. 1993. From Discourse 
to Logic. Kluwer, Dordrecht. 
Alexander Koller and Joachim Niehren. 2000. Con- 
straint progrmnming in computational linguistics. 
In Proe. of the 8 th CSLI Workshop on Logic, Lan- 
guage, and Computation. CSLI Press. To appear. 
Alexander Koller, Joachim Niehren, and Ralf 
Treinen. 1998. Dominance constraints: Algo- 
rithms and complexity. In 2 d Conf. on Logical 
Asp. of Comp. Ling. To appear as LNCS in 2000. 
Alexander Koller, Kurt Mehlhorn, and Joachim 
Niehren. 2000. A polynomial-time fragment of 
dominance constraints. In P~vccedings of th, c 38th 
A CL. To appear. 
Susanna Kusclmrt. 1999. Dynamic Meaning and 
Accomodation. Ph.D. thesis, Dept. of Computer 
Science, University of the Saarland. 
Mitchell P. Marcus, Donald Hindle, and Mar- 
garet M. Fleck. 1983. D-theory: Talking about 
talking about trees. In 21 st Ann. Meet. of the 
ACL, pages 129 136. 
Kim Marriott and Peter ,l. Stuckey. 1998. Program- 
ruing with, Constraints: An Introduction. MIT 
Press. 
Tobias Mfiller. 1999. Problem solving with filfite set 
constraints in Oz. A Tutorial. Documentation of
the Mozart system of Oz. www.mozart-oz, org. 
R.A. Muskens. 1995. Order-Independence and Un- 
derspecification. In J. Oroenendijk, editor, Ellip- 
sis, Underspccification, Events and Morv in Dy- 
namic Semantics. DYANA Deliverable R.2.2.C. 
Manfred Pinkal. 1996. Radical underspeeification. 
In Prveeedings of the lOth Amsterdam Collo- 
quium, pages 587-606. 
Owen Rainbow, K. Vijay-Shanker, and David Weir. 
1995. D-Tree Grmnmars. In Proceedings of 
A CL '95. 
Uwe Reyle. 1993. Dealing with ambiguities by 
underspecification: construction, representation, 
and deduction. ,Iournal of Semantics, 10:123-179. 
Michael Schiehlen. 1997. Disambiguation of under- 
specified iscourse repesentation strnctnres Ul~(ter 
anaphoric onstraints. In 2 ~'d Int. Workshop. on 
Computational Semantics, Tilburg. 
Kees van Deemter and Stmfley Peters. 1996. Se- 
mantic Ambiguity and Underspecification. CSLI 
Press. 
466 
195
196
197
198
199
200
201
202
115
116
117
118
119
120
121
122
A Polynomial-Time Fragment of Dominance Constraints
Alexander Koller Kurt Mehlhorn? Joachim Niehren
koller@coli.uni-sb.de mehlhorn@mpi-sb.mpg.de niehren@ps.uni-sb.de
University of the Saarland / ?Max-Planck-Institute for Computer Science
Saarbru?cken, Germany
Abstract
Dominance constraints are logical
descriptions of trees that are widely
used in computational linguistics.
Their general satisfiability problem
is known to be NP-complete. Here
we identify the natural fragment of
normal dominance constraints and
show that its satisfiability problem
is in deterministic polynomial time.
1 Introduction
Dominance constraints are used as partial
descriptions of trees in problems through-
out computational linguistics. They have
been applied to incremental parsing (Mar-
cus et al, 1983), grammar formalisms (Vijay-
Shanker, 1992; Rambow et al, 1995; Duchier
and Thater, 1999; Perrier, 2000), discourse
(Gardent and Webber, 1998), and scope un-
derspecification (Muskens, 1995; Egg et al,
1998).
Logical properties of dominance constraints
have been studied e.g. in (Backofen et al,
1995), and computational properties have
been addressed in (Rogers and Vijay-Shanker,
1994; Duchier and Gardent, 1999). Here, the
two most important operations are satisfia-
bility testing ? does the constraint describe a
tree? ? and enumerating solutions, i.e. the
described trees. Unfortunately, even the sat-
isfiability problem has been shown to be NP-
complete (Koller et al, 1998). This has shed
doubt on their practical usefulness.
In this paper, we define normal domi-
nance constraints, a natural fragment of dom-
inance constraints whose restrictions should
be unproblematic for many applications. We
present a graph algorithm that decides sat-
isfiability of normal dominance constraints
in polynomial time. Then we show how to
use this algorithm to enumerate solutions ef-
ficiently.
An example for an application of normal
dominance constraints is scope underspecifi-
cation: Constraints as in Fig. 1 can serve
as underspecified descriptions of the semantic
readings of sentences such as (1), considered
as the structural trees of the first-order rep-
resentations. The dotted lines signify domi-
nance relations, which require the upper node
to be an ancestor of the lower one in any tree
that fits the description.
(1) Some representative of every
department in all companies saw a
sample of each product.
The sentence has 42 readings (Hobbs and
Shieber, 1987), and it is easy to imagine
how the number of readings grows exponen-
tially (or worse) in the length of the sen-
tence. Efficient enumeration of readings from
the description is a longstanding problem in
scope underspecification. Our polynomial
algorithm solves this problem. Moreover,
the investigation of graph problems that are
closely related to normal constraints allows us
to prove that many other underspecification
formalisms ? e.g. Minimal Recursion Seman-
tics (Copestake et al, 1997) and Hole Seman-
tics (Bos, 1996) ? have NP-hard satisfiability
problems. Our algorithm can still be used as
a preprocessing step for these approaches; in
fact, experience shows that it seems to solve
all encodings of descriptions in Hole Seman-
tics that actually occur.
?u ?
? ?
comp ?
u ?
?
?w ?
? ?
? ?
? dept ?
w ?
?
?x ?
? ?
? ?
? repr ?
x ?
?
?y ?
? ?
? ? ?
spl ?
y ?
?
?z ?
? ?
prod ?
z ?
?
in ?
w ? u ?
of ?
x ? w ?
see ?
x ? y ?
of ?
y ? z ?
Fig. 1: A dominance constraint (from scope underspecification).
2 Dominance Constraints
In this section, we define the syntax and se-
mantics of dominance constraints. The vari-
ant of dominance constraints we employ de-
scribes constructor trees ? ground terms over
a signature of function symbols ? rather than
feature trees.
f ?
g ?
a ? a ?
Fig. 2: f(g(a, a))
So we assume a signa-
ture ? function symbols
ranged over by f, g, . . .,
each of which is equipped
with an arity ar(f) ?
0. Constants ? function
symbols of arity 0 ? are ranged over by a, b.
We assume that ? contains at least one con-
stant and one symbol of arity at least 2.
Finally, let Vars be an infinite set of vari-
ables ranged over by X,Y,Z. The variables
will denote nodes of a constructor tree. We
will consider constructor trees as directed la-
beled graphs; for instance, the ground term
f(g(a, a)) can be seen as the graph in Fig. 2.
We define an (unlabeled) tree to be a fi-
nite directed graph (V,E). V is a finite set of
nodes ranged over by u, v, w, and E ? V ? V
is a set of edges denoted by e. The indegree of
each node is at most 1; each tree has exactly
one root, i.e. a node with indegree 0. We call
the nodes with outdegree 0 the leaves of the
tree.
A (finite) constructor tree ? is a pair (T,L)
consisting of a tree T = (V,E), a node labeling
L : V ? ?, and an edge labeling L : E ?
N, such that for each node u ? V and each
1 ? k ? ar(L(u)), there is exactly one edge
(u, v) ? E with L((u, v)) = k.1 We draw
1The symbol L is overloaded to serve both as a
node and an edge labeling.
constructor trees as in Fig. 2, by annotating
nodes with their labels and ordering the edges
along their labels from left to right. If ? =
((V,E), L), we write V? = V , E? = E, L? =
L. Now we are ready to define tree structures,
the models of dominance constraints:
Definition 2.1. The tree structure M? of
a constructor tree ? is a first-order structure
with domain V? which provides the dominance
relation ?? and a labeling relation for each
function symbol f ? ?.
Let u, v, v1, . . . vn ? V? be nodes of ? . The
dominance relationship u??v holds iff there
is a path from u to v in E? ; the labeling rela-
tionship u:f ? (v1, . . . , vn) holds iff u is labeled
by the n-ary symbol f and has the children
v1, . . . , vn in this order; that is, L? (u) = f ,
ar(f) = n, {(u, v1), . . . , (u, vn)} ? E? , and
L? ((u, vi)) = i for all 1 ? i ? n.
A dominance constraint ? is a conjunction
of dominance, inequality, and labeling literals
of the following form where ar(f) = n:
? ::= ? ? ?? | X?Y | X 6=Y
| X:f(X1, . . . , Xn)
X 1 X 2
Y
X f
Fig. 3: An unsat-
isfiable constraint
Let Var(?) be the set of
variables of ?. A pair of
a tree structure M? and
a variable assignment ? :
Var(?) ? V? satisfies ?
iff it satisfies each literal
in the obvious way. We
say that (M? , ?) is a solution of ? in this
case; ? is satisfiable if it has a solution.
We usually draw dominance constraints as
constraint graphs. For instance, the con-
straint graph for X:f(X1, X2) ? X1?Y ?
X2?Y is shown in Fig. 3. As for trees, we
annotate node labels to nodes and order tree
edges from left to right; dominance edges are
drawn dotted. The example happens to be
unsatisfiable because trees cannot branch up-
wards.
Definition 2.2. Let ? be a dominance con-
straint that does not contain two labeling con-
straints for the same variable.2 Then the con-
straint graph for ? is a directed labeled graph
G(?) = (Var(?), E, L). It contains a (par-
tial) node labeling L : Var(?)  ? and an
edge labeling L : E ? N ? {?}.
The sets of edges E and labels L of
the graph G(?) are defined in dependence
of the literals in ?: The labeling literal
X:f(X1, . . . , Xn) belongs to ? iff L(X) = f
and for each 1 ? i ? n, (X,Xi) ? E and
L((X,Xi)) = i. The dominance literal X?Y
is in ? iff (X,Y ) ? E and L((X,Y )) = ?.
Note that inequalities in constraints are not
represented by the corresponding constraint
graph. We define (solid) fragments of a con-
straint graph to be maximal sets of nodes that
are connected over tree edges.
3 Normal Dominance Constraints
Satisfiability of dominance constraints can be
decided easily in non-deterministic polyno-
mial time; in fact, it is NP-complete (Koller
et al, 1998).
X 1 X 2
f
Y f
Y 1 Y 2
X
Fig. 4: Overlap
The NP-hardness
proof relies on the
fact that solid frag-
ments can ?overlap?
properly. For illustra-
tion, consider the con-
straint X:f(X1, X2) ?
Y :f(Y1, Y2) ? Y ?X ? X?Y1, whose con-
straint graph is shown in Fig. 4. In a solu-
tion of this constraint, either Y or Y1 must be
mapped to the same node as X; if X = Y ,
the two fragments overlap properly. In the
applications in computational linguistics, we
typically don?t want proper overlap; X should
2Every constraint can be brought into this form by
introducing auxiliary variables and expressing X=Y
as X?Y ? Y ?X.
never be identified with Y , only with Y1. The
subclass of dominance constraints that ex-
cludes proper overlap (and fixes some minor
inconveniences) is the class of normal domi-
nance constraints.
Definition 3.1. A dominance constraint ?
is called normal iff for all variables X,Y,Z ?
Var(?),
1. X 6= Y in ? iff both X:f(. . .) and
Y :g(. . .) in ?, where f and g may be
equal (no overlap);3
2. X only appears once as a parent and
once as a child in a labeling literal (tree-
shaped fragments);
3. if X?Y in ?, neither X:f(. . .) nor
Z:f(. . . Y . . .) are (dominances go from
holes to roots);
4. if X?Y in ?, then there are Z, f such
that Z:f(. . . X . . .) in ? (no empty frag-
ments).
Fragments of normal constraints are tree-
shaped, so they have a unique root and leaves.
We call unlabeled leaves holes. If X is a vari-
able, we can define R?(X) to be the root of
the fragment containing X. Note that by
Condition 1 of the definition, the constraint
graph specifies all the inequality literals in a
normal constraint. All constraint graphs in
the rest of the paper will represent normal
constraints.
The main result of this paper, which we
prove in Section 4, is that the restriction to
normal constraints indeed makes satisfiability
polynomial:
Theorem 3.2. Satisfiability of normal domi-
nance constraints is O((k+1)3n2 log n), where
n is the number of variables in the constraint,
and k is the maximum number of dominance
edges into the same node in the constraint
graph.
In the applications, k will be small ? in
scope underspecification, for instance, it is
3Allowing more inequality literals does not make
satisfiability harder, but the pathological case X 6= X
invalidates the simple graph-theoretical characteriza-
tions below.
bounded by the maximum number of argu-
ments a verb can take in the language if we
disregard VP modification. So we can say
that satisfiability of the linguistically relevant
dominance constraints is O(n2 log n).
4 A Polynomial Satisfiability Test
Now we derive the satisfiability algorithm
that proves Theorem 3.2 and prove it correct.
In Section 5, we embed it into an enumera-
tion algorithm. An alternative proof of The-
orem 3.2 is by reduction to a graph problem
discussed in (Althaus et al, 2000); this more
indirect approach is sketched in Section 6.
Throughout this section and the next, we
will employ the following non-deterministic
choice rule (Distr), where X,Y are different
variables.
(Distr) ? ? X?Z ? Y ?Z
? ? ?X?R?(Y ) ? Y ?Z
? ? ? Y ?R?(X) ? X?Z
In each application, we can pick one of the
disjuncts on the right-hand side. For instance,
we get Fig. 5b by choosing the second disjunct
in a rule application to Fig. 5a.
The rule is sound if the left-hand side is nor-
mal: X?Z ? Y ?Z entails X?Y ? Y ?X,
which entails the right-hand side disjunction
because of conditions 1, 2, 4 of normality and
X 6= Y . Furthermore, it preserves normality:
If the left-hand side is normal, so are both
possible results.
Definition 4.1. A normal dominance con-
straint ? is in solved form iff (Distr) is not
applicable to ? and G(?) is cycle-free.
Constraints in solved form are satisfiable.
4.1 Characterizing Satisfiability
In a first step, we characterize the unsatisfia-
bility of a normal constraint by the existence
of certain cycles in the undirected version of
its graph (Proposition 4.4). Recall that a cy-
cle in a graph is simple if it does not contain
the same node twice.
Definition 4.2. A cycle in an undirected
constraint graph is called hypernormal if it
does not contain two adjacent dominance
edges that emanate from the same node.
f ?
? X
g ?
? Y ?
a ? Z b ?
g ?
? Y
f ?
? X
?
a ? Z b ?
(a) (b)
Fig. 5: (a) A constraint that entails X?Y ,
and (b) the result of trying to arrange Y
above X. The cycle in (b) is hypernormal,
the one in (a) is not.
For instance, the cycle in the left-hand
graph in Fig. 5 is not hypernormal, whereas
the cycle in the right-hand one is.
Lemma 4.3. A normal dominance constraint
whose undirected graph has a simple hyper-
normal cycle is unsatisfiable.
Proof. Let ? be a normal dominance con-
straint whose undirected graph contains a
simple hypernormal cycle. Assume first that
it contains a simple hypernormal cycle C that
is also a cycle in the directed graph. There is
at least one leaf of a fragment on C; let Y
be such a leaf. Because ? is normal, Y has
a mother X via a tree edge, and X is on C
as well. That is, X must dominate Y but is
properly dominated by Y in any solution of
?, so ? is unsatisfiable.
In particular, if an undirected constraint
graph has a simple hypernormal cycle C with
only one dominance edge, C is also a directed
cycle, so the constraint is unsatisfiable. Now
we can continue inductively. Let ? be a con-
straint with an undirected simple hypernor-
mal cycle C of length l, and suppose we know
that all constraints with cycles of length less
than l are unsatisfiable. If C is a directed
cycle, we are done (see above); otherwise,
the edges in C must change directions some-
where. Because ? is normal, this means that
there must be a node Z that has two incoming
dominance edges (X,Z), (Y,Z) which are ad-
jacent edges in C. If X and Y are in the same
fragment, ? is trivially unsatisfiable. Other-
wise, let ?1 and ?2 be the two constraints ob-
tained from ? by one application of (Distr) to
X,Y,Z. Let C1 be the sequence of edges we
obtain from C by replacing the path from X
to R?(Y ) via Z by the edge (X,R?(Y )). C
is hypernormal and simple, so no two dom-
inance edges in C emanate from the same
node; hence, the new edge is the only dom-
inance edge in C1 emanating from X, and
C1 is a hypernormal cycle in the undirected
graph of ?1. C1 is still simple, as we have
only removed nodes. But the length of C1
is strictly less than l, so ?1 is unsatisfiable
by induction hypothesis. An analogous ar-
gument shows unsatisfiability of ?2. But be-
cause (Distr) is sound, this means that ? is
unsatisfiable too.
Proposition 4.4. A normal dominance con-
straint is satisfiable iff its undirected con-
straint graph has no simple hypernormal cy-
cle.
Proof. The direction that a normal constraint
with a simple hypernormal cycle is unsatisfi-
able is shown in Lemma 4.3.
For the converse, we first define an ordering
?1 ? ?2 on normal dominance constraints: it
holds if both constraints have the same vari-
ables, labeling and inequality literals, and if
the reachability relation of G(?1) is a subset
of that of G(?2). If the subset inclusion is
proper, we write ?1 < ?2. We call a con-
straint ? irredundant if there is no normal
constraint ?? with fewer dominance literals
but ? ? ??. If ? is irredundant and G(?)
is acyclic, both results of applying (Distr) to
? are strictly greater than ?.
Now let ? be a constraint whose undirected
graph has no simple hypernormal cycle. We
can assume without loss of generality that
? is irredundant; otherwise we make it irre-
dundant by removing dominance edges, which
does not introduce new hypernormal cycles.
If (Distr) is not applicable to ?, ? is in
solved form and hence satisfiable. Otherwise,
we know that both results of applying the rule
are strictly greater than ?. It can be shown
that one of the results of an application of the
distribution rule contains no simple hypernor-
mal cycle. We omit this argument for lack of
space; details can be found in the proof of
Theorem 3 in (Althaus et al, 2000). Further-
more, the maximal length of a < increasing
chain of constraints is bounded by n2, where
n is the number of variables. Thus, appli-
cations of (Distr) can only be iterated a fi-
nite number of times on constraints without
simple hypernormal cycles (given redundancy
elimination), and it follows by induction that
? is satisfiable.
4.2 Testing for Simple Hypernormal
Cycles
We can test an undirected constraint graph
for the presence of simple hypernormal cycles
by solving a perfect weighted matching prob-
lem on an auxiliary graph A(G(?)). Perfect
weighted matching in an undirected graph
G = (V,E) with edge weights is the prob-
lem of selecting a subset E ? of edges such that
each node is adjacent to exactly one edge in
E?, and the sum of the weights of the edges
in E? is maximal.
The auxiliary graph A(G(?)) we consider is
an undirected graph with two types of edges.
For every edge e = (v, w) ? G(?) we have
two nodes ev, ew in A(G(?)). The edges are
as follows:
(Type A) For every edge e in G(?) we have
the edge {ev, ew}.
(Type B) For every node v and distinct
edges e, f which are both incident to v
in G(?), we have the edge {ev, fv} if ei-
ther v is not a leaf, or if v is a leaf and
either e or f is a tree edge.
We give type A edges weight zero and type B
edges weight one. Now it can be shown (Al-
thaus et al, 2000, Lemma 2) that A(G(?))
has a perfect matching of positive weight iff
the undirected version of G(?) contains a sim-
ple hypernormal cycle. The proof is by con-
structing positive matchings from cycles, and
vice versa.
Perfect weighted matching on a graph with
n nodes and m edges can be done in time
O(nm log n) (Galil et al, 1986). The match-
ing algorithm itself is beyond the scope of
this paper; for an implementation (in C++)
see e.g. (Mehlhorn and Na?her, 1999). Now
let?s say that k is the maximum number of
dominance edges into the same node in G(?),
then A(G(?)) has O((k + 1)n) nodes and
O((k + 1)2n) edges. This shows:
Proposition 4.5. A constraint graph can be
tested for simple hypernormal cycles in time
O((k + 1)3n2 log n), where n is the number of
variables and k is the maximum number of
dominance edges into the same node.
This completes the proof of Theorem 3.2:
We can test satisfiability of a normal con-
straint by first constructing the auxiliary
graph and then solving its weighted match-
ing problem, in the time claimed.
4.3 Hypernormal Constraints
It is even easier to test the satisfiability of
a hypernormal dominance constraint ? a nor-
mal dominance constraint in whose constraint
graph no node has two outgoing dominance
edges. A simple corollary of Prop. 4.4 for this
special case is:
Corollary 4.6. A hypernormal constraint is
satisfiable iff its undirected constraint graph is
acyclic.
This means that satisfiability of hypernor-
mal constraints can be tested in linear time
by a simple depth-first search.
5 Enumerating Solutions
Now we embed the satisfiability algorithms
from the previous section into an algorithm
for enumerating the irredundant solved forms
of constraints. A solved form of the normal
constraint ? is a normal constraint ?? which
is in solved form and ? ? ??, with respect to
the ? order from the proof of Prop. 4.4.4
Irredundant solved forms of a constraint
are very similar to its solutions: Their con-
straint graphs are tree-shaped, but may still
4In the literature, solved forms with respect to the
NP saturation algorithms can contain additional la-
beling literals. Our notion of an irredundant solved
form corresponds to a minimal solved form there.
1. Check satisfiability of ?. If it is unsatis-
fiable, terminate with failure.
2. Make ? irredundant.
3. If ? is in solved form, terminate with suc-
cess.
4. Otherwise, apply the distribution rule
and repeat the algorithm for both results.
Fig. 6: Algorithm for enumerating all irre-
dundant solved forms of a normal constraint.
contain dominance edges. Every solution of
a constraint is a solution of one of its irre-
dundant solved forms. However, the number
of irredundant solved forms is always finite,
whereas the number of solutions typically is
not: X:a?Y :b is in solved form, but each so-
lution must contain an additional node with
arbitrary label that combines X and Y into a
tree (e.g. f(a, b), g(a, b)). That is, we can ex-
tract a solution from a solved form by ?adding
material? if necessary.
The main workhorse of the enumeration al-
gorithm, shown in Fig. 6, is the distribution
rule (Distr) we have introduced in Section 4.
As we have already argued, (Distr) can be ap-
plied at most n2 times. Each end result is in
solved form and irredundant. On the other
hand, distribution is an equivalence transfor-
mation, which preserves the total set of solved
forms of the constraints after the same itera-
tion. Finally, the redundancy elimination in
Step 2 can be done in time O((k+1)n2) (Aho
et al, 1972). This proves:
Theorem 5.1. The algorithm in Fig. 6 enu-
merates exactly the irredundant solved forms
of a normal dominance constraint ? in time
O((k +1)4n4N log n), where N is the number
of irredundant solved forms, n is the number
of variables, and k is the maximum number
of dominance edges into the same node.
Of course, the number of irredundant
solved forms can still be exponential in the
size of the constraint. Note that for hypernor-
mal constraints, we can replace the quadratic
satisfiability test by the linear one, and we
can skip Step 2 of the enumeration algorithm
because hypernormal constraints are always
irredundant. This improves the runtime of
enumeration to O((k + 1)n3N).
6 Reductions
Instead of proving Theorem 4.4 directly as
we have done above, we can also reduce it to
a configuration problem of dominance graphs
(Althaus et al, 2000), which provides a more
general perspective on related problems as
well. Dominance graphs are unlabeled, di-
rected graphs G = (V,E unionmulti D) with tree edges
E and dominance edges D. Nodes with no in-
coming tree edges are called roots, and nodes
with no outgoing ones are called leaves; dom-
inance edges only go from leaves to roots. A
configuration of G is a graph G? = (V,E unionmulti E?)
such that every edge in D is realized by a path
in G?. The following results are proved in (Al-
thaus et al, 2000):
1. Configurability of dominance graphs is in
O((k + 1)3n2 log n), where k is the max-
imum number of dominance edges into
the same node.
2. If we specify a subset V ? ? V of closed
leaves (we call the others open) and re-
quire that only open leaves can have
outgoing edges in E ?, the configurability
problem becomes NP-complete. (This
is shown by encoding a strongly NP-
complete partitioning problem.)
3. If we require in addition that every open
leaf has an outgoing edge in E ?, the prob-
lem stays NP-complete.
Satisfiability of normal dominance constraints
can be reduced to the first problem in the
list by deleting all labels from the constraint
graph. The reduction can be shown to be
correct by encoding models as configurations
and vice versa.
On the other hand, the third problem can
be reduced to the problems of whether there
is a plugging for a description in Hole Seman-
tics (Bos, 1996), or whether a given MRS de-
scription can be resolved (Copestake et al,
1997), or whether a given normal dominance
constraints has a constructive solution.5 This
reduction is by deleting all labels and making
leaves that had nullary labels closed. This
means that (the equivalent of) deciding satis-
fiability in these approaches is NP-hard.
The crucial difference between e.g. satisfi-
ability and constructive satisfiability of nor-
mal dominance constraints is that it is pos-
sible that a solved form has no constructive
solutions. This happens e.g. in the example
from Section 5, X:a ? Y :b. The constraint,
which is in solved form, is satisfiable e.g. by
the tree f(a, b); but every solution must con-
tain an additional node with a binary label,
and hence cannot be constructive.
For practical purposes, however, it can still
make sense to enumerate the irredundant
solved forms of a normal constraint even if we
are interested only in constructive solution:
It is certainly cheaper to try to find construc-
tive solutions of solved forms than of arbitrary
constraints. In fact, experience indicates that
for those constraints we really need in scope
underspecification, all solved forms do have
constructive solutions ? although it is not yet
known why. This means that our enumera-
tion algorithm can in practice be used without
change to enumerate constructive solutions,
and it is straightforward to adapt it e.g. to
an enumeration algorithm for Hole Semantics.
7 Conclusion
We have investigated normal dominance con-
straints, a natural subclass of general dom-
inance constraints. We have given an
O(n2 log n) satisfiability algorithm for them
and integrated it into an algorithm that enu-
merates all irredundant solved forms in time
O(Nn4 log n), where N is the number of irre-
dundant solved forms.
5A constructive solution is one where every node
in the model is the image of a variable for which
a labeling literal is in the constraint. Informally,
this means that the solution only contains ?material?
?mentioned? in the constraint.
This eliminates any doubts about the
computational practicability of dominance
constraints which were raised by the NP-
completeness result for the general language
(Koller et al, 1998) and expressed e.g. in
(Willis and Manandhar, 1999). First experi-
ments confirm the efficiency of the new algo-
rithm ? it is superior to the NP algorithms
especially on larger constraints.
On the other hand, we have argued that
the problem of finding constructive solutions
even of a normal dominance constraint is NP-
complete. This result carries over to other
underspecification formalisms, such as Hole
Semantics and MRS. In practice, however, it
seems that the enumeration algorithm pre-
sented here can be adapted to those problems.
Acknowledgments. We would like to
thank Ernst Althaus, Denys Duchier, Gert
Smolka, Sven Thiel, all members of the SFB
378 project CHORUS at the University of the
Saarland, and our reviewers. This work was
supported by the DFG in the SFB 378.
References
A. V. Aho, M. R. Garey, and J. D. Ullman. 1972.
The transitive reduction of a directed graph.
SIAM Journal of Computing, 1:131?137.
E. Althaus, D. Duchier, A. Koller, K. Mehlhorn,
J. Niehren, and S. Thiel. 2000. An ef-
ficient algorithm for the configuration
problem of dominance graphs. Submit-
ted. http://www.ps.uni-sb.de/Papers/
abstracts/dom-graph.html.
R. Backofen, J. Rogers, and K. Vijay-Shanker.
1995. A first-order axiomatization of the the-
ory of finite trees. Journal of Logic, Language,
and Information, 4:5?39.
Johan Bos. 1996. Predicate logic unplugged. In
Proceedings of the 10th Amsterdam Colloquium.
A. Copestake, D. Flickinger, and I. Sag.
1997. Minimal Recursion Semantics. An In-
troduction. Manuscript, ftp://csli-ftp.
stanford.edu/linguistics/sag/mrs.ps.gz.
Denys Duchier and Claire Gardent. 1999. A
constraint-based treatment of descriptions. In
Proceedings of IWCS-3, Tilburg.
D. Duchier and S. Thater. 1999. Parsing with
tree descriptions: a constraint-based approach.
In Proc. NLULP?99, Las Cruces, New Mexico.
M. Egg, J. Niehren, P. Ruhrberg, and F. Xu.
1998. Constraints over Lambda-Structures in
Semantic Underspecification. In Proceedings
COLING/ACL?98, Montreal.
Z. Galil, S. Micali, and H. N. Gabow. 1986. An
O(EV log V ) algorithm for finding a maximal
weighted matching in general graphs. SIAM
Journal of Computing, 15:120?130.
Claire Gardent and Bonnie Webber. 1998. De-
scribing discourse semantics. In Proceedings of
the 4th TAG+ Workshop, Philadelphia.
Jerry R. Hobbs and Stuart M. Shieber. 1987.
An algorithm for generating quantifier scopings.
Computational Linguistics, 13:47?63.
A. Koller, J. Niehren, and R. Treinen. 1998. Dom-
inance constraints: Algorithms and complexity.
In Proceedings of the 3rd LACL, Grenoble. To
appear as LNCS.
M. P. Marcus, D. Hindle, and M. M. Fleck. 1983.
D-theory: Talking about talking about trees.
In Proceedings of the 21st ACL.
K. Mehlhorn and S. Na?her. 1999. The
LEDA Platform of Combinatorial and Geomet-
ric Computing. Cambridge University Press,
Cambridge. See also http://www.mpi-sb.
mpg.de/LEDA/.
R.A. Muskens. 1995. Order-independence and
underspecification. In J. Groenendijk, editor,
Ellipsis, Underspecification, Events and More
in Dynamic Semantics. DYANA Deliverable
R.2.2.C.
Guy Perrier. 2000. From intuitionistic proof nets
to interaction grammars. In Proceedings of the
5th TAG+ Workshop, Paris.
O. Rambow, K. Vijay-Shanker, and D. Weir.
1995. D-Tree grammars. In Proceedings of the
33rd ACL, pages 151?158.
J. Rogers and K. Vijay-Shanker. 1994. Obtaining
trees from their descriptions: An application to
tree-adjoining grammars. Computational Intel-
ligence, 10:401?421.
K. Vijay-Shanker. 1992. Using descriptions of
trees in a tree adjoining grammar. Computa-
tional Linguistics, 18:481?518.
A. Willis and S. Manandhar. 1999. Two accounts
of scope availability and semantic underspecifi-
cation. In Proceedings of the 37th ACL.
Underspecified Beta Reduction
Manuel Bodirsky
Katrin Erk
Joachim Niehren
Programming Systems Lab
Saarland University
D-66041 Saarbru?cken, Germany
{bodirsky|erk|niehren}@ps.uni-sb.de
Alexander Koller
Department of Computational Linguistics
Saarland University
D-66041 Saarbru?cken, Germany
koller@coli.uni-sb.de
Abstract
For ambiguous sentences, traditional
semantics construction produces large
numbers of higher-order formulas,
which must then be
 
-reduced individ-
ually. Underspecified versions can pro-
duce compact descriptions of all read-
ings, but it is not known how to perform
 
-reduction on these descriptions. We
show how to do this using
 
-reduction
constraints in the constraint language
for  -structures (CLLS).
1 Introduction
Traditional approaches to semantics construction
(Montague, 1974; Cooper, 1983) employ formu-
las of higher-order logic to derive semantic rep-
resentations compositionally; then
 
-reduction is
applied to simplify these representations. When
the input sentence is ambiguous, these approaches
require all readings to be enumerated and
 
-
reduced individually. For large numbers of read-
ings, this is both inefficient and unelegant.
Existing underspecification approaches (Reyle,
1993; van Deemter and Peters, 1996; Pinkal,
1996; Bos, 1996) provide a partial solution to this
problem. They delay the enumeration of the read-
ings and represent them all at once in a single,
compact description. An underspecification for-
malism that is particularly well suited for describ-
ing higher-order formulas is the Constraint Lan-
guage for Lambda Structures, CLLS (Egg et al,
2001; Erk et al, 2001). CLLS descriptions can
be derived compositionally and have been used
to deal with a rich class of linguistic phenomena
(Koller et al, 2000; Koller and Niehren, 2000).
They are based on dominance constraints (Mar-
cus et al, 1983; Rambow et al, 1995) and extend
them with parallelism (Erk and Niehren, 2000)
and binding constraints.
However, lifting
 
-reduction to an operation on
underspecified descriptions is not trivial, and to
our knowledge it is not known how this can be
done. Such an operation ? which we will call un-
derspecified   -reduction ? would essentially   -
reduce all described formulas at once by deriv-
ing a description of the reduced formulas. In this
paper, we show how underspecified
 
-reductions
can be performed in the framework of CLLS.
Our approach extends the work presented in
(Bodirsky et al, 2001), which defines   -reduction
constraints and shows how to obtain a complete
solution procedure by reducing them to paral-
lelism constraints in CLLS. The problem with
this previous work is that it is often necessary to
perform local disambiguations. Here we add a
new mechanism which, for a large class of de-
scriptions, permits us to perform underspecified
 
-reduction steps without disambiguating, and is
still complete for the general problem.
Plan. We start with a few examples to show
what underspecified
 
-reduction should do, and
why it is not trivial. We then introduce CLLS
and
 
-reduction constraints. In the core of the
paper we present a procedure for underspecified
 
-reduction and apply it to illustrative examples.
2 Examples
In this section, we show what underspecified
 
-
reduction should do, and why the task is nontriv-
ial. Consider first the ambiguous sentence Every
student didn?t pay attention. In first-order logic,
the two readings can be represented as
 



	
 






 





 



ffBridging the Gap Between Underspecification Formalisms:
Minimal Recursion Semantics as Dominance Constraints
Joachim Niehren
Programming Systems Lab
Universita?t des Saarlandes
niehren@ps.uni-sb.de
Stefan Thater
Computational Linguistics
Universita?t des Saarlandes
stth@coli.uni-sb.de
Abstract
Minimal Recursion Semantics (MRS) is
the standard formalism used in large-scale
HPSG grammars to model underspecified
semantics. We present the first provably
efficient algorithm to enumerate the read-
ings of MRS structures, by translating
them into normal dominance constraints.
1 Introduction
In the past few years there has been considerable
activity in the development of formalisms for un-
derspecified semantics (Alshawi and Crouch, 1992;
Reyle, 1993; Bos, 1996; Copestake et al, 1999; Egg
et al, 2001). The common idea is to delay the enu-
meration of all readings for as long as possible. In-
stead, they work with a compact underspecified rep-
resentation; readings are enumerated from this rep-
resentation by need.
Minimal Recursion Semantics (MRS) (Copes-
take et al, 1999) is the standard formalism for se-
mantic underspecification used in large-scale HPSG
grammars (Pollard and Sag, 1994; Copestake and
Flickinger, ). Despite this clear relevance, the most
obvious questions about MRS are still open:
1. Is it possible to enumerate the readings of
MRS structures efficiently? No algorithm has
been published so far. Existing implementa-
tions seem to be practical, even though the
problem whether an MRS has a reading is NP-
complete (Althaus et al, 2003, Theorem 10.1).
2. What is the precise relationship to other un-
derspecification formalism? Are all of them the
same, or else, what are the differences?
We distinguish the sublanguages of MRS nets
and normal dominance nets, and show that they
can be intertranslated. This translation answers the
first question: existing constraint solvers for normal
dominance constraints can be used to enumerate the
readings of MRS nets in low polynomial time.
The translation also answers the second ques-
tion restricted to pure scope underspecification. It
shows the equivalence of a large fragment of MRSs
and a corresponding fragment of normal dominance
constraints, which in turn is equivalent to a large
fragment of Hole Semantics (Bos, 1996) as proven
in (Koller et al, 2003). Additional underspecified
treatments of ellipsis or reinterpretation, however,
are available for extensions of dominance constraint
only (CLLS, the constraint language for lambda
structures (Egg et al, 2001)).
Our results are subject to a new proof tech-
nique which reduces reasoning about MRS struc-
tures to reasoning about weakly normal dominance
constraints (Bodirsky et al, 2003). The previous
proof techniques for normal dominance constraints
(Koller et al, 2003) do not apply.
2 Minimal Recursion Semantics
We define a simplified version of Minimal Recur-
sion Semantics and discuss differences to the origi-
nal definitions presented in (Copestake et al, 1999).
MRS is a description language for formulas of
first order object languages with generalized quanti-
fiers. Underspecified representations in MRS consist
of elementary predications and handle constraints.
Roughly, elementary predications are object lan-
guage formulas with ?holes? into which other for-
mulas can be plugged; handle constraints restrict the
way these formulas can be plugged into each other.
More formally, MRSs are formulas over the follow-
ing vocabulary:
1. Variables. An infinite set of variables ranged
over by h. Variables are also called handles.
2. Constants. An infinite set of constants ranged
over by x,y,z. Constants are the individual vari-
ables of the object language.
3. Function symbols.
(a) A set of function symbols written as P.
(b) A set of quantifier symbols ranged over
by Q (such as every and some). Pairs Qx
are further function symbols (the variable
binders of x in the object language).
4. The symbol ? for the outscopes relation.
Formulas of MRS have three kinds of literals, the
first two are called elementary predications (EPs)
and the third handle constraints:
1. h :P(x1, . . . ,xn,h1, . . . ,hm) where n,m ? 0
2. h :Qx(h1,h2)
3. h1 ? h2
Label positions are to the left of colons ?:? and argu-
ment positions to the right. Let M be a set of literals.
The label set lab(M) contains those handles of M
that occur in label but not in argument position. The
argument handle set arg(M) contains the handles of
M that occur in argument but not in label position.
Definition 1 (MRS). An MRS is finite set M of
MRS-literals such that:
M1 Every handle occurs at most once in label and
at most once in argument position in M.
M2 Handle constraints h1 ? h2 in M always relate
argument handles h1 to labels h2 of M.
M3 For every constant (individual variable) x in ar-
gument position in M there is a unique literal of
the form h :Qx(h1,h2) in M.
We call an MRS compact if it additionally satisfies:
M4 Every handle of M occurs exactly once in an
elementary predication of M.
We say that a handle h immediately outscopes a
handle h? in an MRS M iff there is an EP E in M such
that h occurs in label and h? in argument position of
E . The outscopes relation is the reflexive, transitive
closure of the immediate outscopes relation.
everyx
studentx
readx,y
somey
booky
{h1 : everyx(h2,h4),h3 : student(x),h5 : somey(h6,h8),
h7 : book(y),h9 : read(x,y),h2 ? h3,h6 ? h7}
Figure 1: MRS for ?Every student reads a book?.
An example MRS for the scopally ambiguous
sentence ?Every student reads a book? is given in
Fig. 1. We often represent MRSs by directed graphs
whose nodes are the handles of the MRS. Elemen-
tary predications are represented by solid edges and
handle constraints by dotted lines. Note that we
make the relation between bound variables and their
binders explicit by dotted lines (as from everyx to
readx,y); redundant ?binding-edges? that are sub-
sumed by sequences of other edges are omitted how-
ever (from everyx to studentx for instance).
A solution for an underspecified MRS is called a
configuration, or scope-resolved MRS.
Definition 2 (Configuration). An MRS M is a con-
figuration if it satisfies the following conditions.
C1 The graph of M is a tree of solid edges: handles
don?t properly outscope themselves or occur in
different argument positions and all handles are
pairwise connected by elementary predications.
C2 If two EPs h :P(. . . ,x, . . .) and h0 :Qx(h1,h2)
belong to M, then h0 outscopes h in M (so that
the binding edge from h0 to h is redundant).
We call M a configuration for another MRS M? if
there exists some substitution ? : arg(M?) 7? lab(M?)
which states how to identify argument handles of M?
with labels of M?, so that:
C3 M = {?(E) | E is EP in M?}, and
C4 ?(h1) outscopes h2 in M, for all h1 ? h2 ? M?.
The value ?(E) is obtained by substituting all ar-
gument handles in E , leaving all others unchanged.
The MRS in Fig. 1 has precisely two configura-
tions displayed in Fig. 2 which correspond to the two
readings of the sentence. In this paper, we present
an algorithm that enumerates the configurations of
MRSs efficiently.
everyx
studentx somey
booky readx,y
somey
booky everyx
studentx readx,y
Figure 2: Graphs of Configurations.
Differences to Standard MRS. Our version de-
parts from standard MRS in some respects. First,
we assume that different EPs must be labeled with
different handles, and that labels cannot be identi-
fied. In standard MRS, however, conjunctions are
encoded by labeling different EPs with the same
handle. These EP-conjunctions can be replaced in
a preprocessing step introducing additional EPs that
make conjunctions explicit.
Second, our outscope constraints are slightly less
restrictive than the original ?qeq-constraints.? A
handle h is qeq to a handle h? in an MRS M, h =q h?,
if either h = h? or a quantifier h :Qx(h1,h2) occurs
in M and h2 is qeq to h? in M. Thus, h =q h? im-
plies h ? h?, but not the other way round. We believe
that the additional strength of qeq-constraints is not
needed in practice for modeling scope. Recent work
in semantic construction for HPSG (Copestake et
al., 2001) supports our conjecture: the examples dis-
cussed there are compatible with our simplification.
Third, we depart in some minor details: we
use sets instead of multi-sets and omit top-handles
which are useful only during semantics construction.
3 Dominance Constraints
Dominance constraints are a general framework for
describing trees, and thus syntax trees of logical for-
mulas. Dominance constraints are the core language
underlying CLLS (Egg et al, 2001) which adds par-
allelism and binding constraints.
3.1 Syntax and Semantics
We assume a possibly infinite signature ? of func-
tion symbols with fixed arities and an infinite set Var
of variables ranged over by X ,Y,Z. We write f ,g for
function symbols and ar( f ) for the arity of f .
A dominance constraint ? is a conjunction of
dominance, inequality, and labeling literals of the
following forms where ar( f ) = n:
? ::= X/?Y | X 6= Y | X : f (X1, . . . ,Xn) | ????
Dominance constraints are interpreted over finite
constructor trees, i.e. ground terms constructed from
the function symbols in ?. We identify ground terms
with trees that are rooted, ranked, edge-ordered and
labeled. A solution for a dominance constraint con-
sists of a tree ? and a variable assignment ? that
maps variables to nodes of ? such that all constraints
are satisfied: a labeling literal X : f (X1, . . . ,Xn) is sat-
isfied iff the node ?(X) is labeled with f and has
daughters ?(X1), . . . ,?(Xn) in this order; a domi-
nance literal X/?Y is satisfied iff ?(X) is an ancestor
of ?(Y ) in ?; and an inequality literal X 6=Y is satis-
fied iff ?(X) and ?(Y ) are distinct nodes.
Note that solutions may contain additional mate-
rial. The tree f (a,b), for instance, satisfies the con-
straint Y :a?Z :b.
3.2 Normality and Weak Normality
The satisfiability problem of arbitrary dominance
constraints is NP-complete (Koller et al, 2001) in
general. However, Althaus et al (2003) identify a
natural fragment of so called normal dominance
constraints, which have a polynomial time satisfia-
bility problem. Bodirsky et al (2003) generalize this
notion to weakly normal dominance constraints.
We call a variable a hole of ? if it occurs in argu-
ment position in ? and a root of ? otherwise.
Definition 3. A dominance constraint ? is normal
(and compact) if it satisfies the following conditions.
N1 (a) each variable of ? occurs at most once in the
labeling literals of ?.
(b) each variable of ? occurs at least once in the
labeling literals of ?.
N2 for distinct roots X and Y of ?, X 6=Y is in ?.
N3 (a) if X C? Y occurs in ?, Y is a root in ?.
(b) if X C? Y occurs in ?, X is a hole in ?.
A dominance constraint is weakly normal if it satis-
fies all above properties except for N1(b) and N3(b).
The idea behind (weak) normality is that the con-
straint graph (see below) of a dominance constraint
consists of solid fragments which are connected
by dominance constraints; these fragments may not
properly overlap in solutions.
Note that Definition 3 always imposes compact-
ness, meaning that the heigth of solid fragments is at
most one. As for MRS, this is not a serious restric-
tion, since more general weakly normal dominance
constraints can be compactified, provided that dom-
inance links relate either roots or holes with roots.
Dominance Graphs. We often represent domi-
nance constraints as graphs. A dominance graph is
the directed graph (V,/?unionmulti/). The graph of a weakly
normal constraint ? is defined as follows: The nodes
of the graph of ? are the variables of ?. A labeling
literal X : f (X1, . . . ,Xn) of ? contributes tree edges
(X ,Xi) ? / for 1 ? i ? n that we draw as X Xi;
we freely omit the label f and the edge order in the
graph. A dominance literal X/?Y contributes a dom-
inance edge (X ,Y ) ? /? that we draw as X Y .
Inequality literals in ? are also omitted in the graph.
f
a
gFor example, the constraint graph
on the right represents the dominance
constraint X : f (X ?)?Y :g(Y ?)?X ?/?Z?
Y ?/?Z?Z :a?X 6=Y ?X 6=Z?Y 6=Z.
A dominance graph is weakly normal or a wnd-
graph if it does not contain any forbidden subgraphs:
Dominance graphs of a weakly normal dominance
constraints are clearly weakly normal.
Solved Forms and Configurations. The main dif-
ference between MRS and dominance constraints
lies in their notion of interpretation: solutions versus
configurations.
Every satisfiable dominance constraint has in-
finitely many solutions. Algorithms for dominance
constraints therefore do not enumerate solutions but
solved forms. We say that a dominance constraint is
in solved form iff its graph is in solved form. A wnd-
graph ? is in solved form iff ? is a forest. The solved
forms of ? are solved forms ?? that are more spe-
cific than ?, i.e. ? and ?? differ only in their dom-
inance edges and the reachability relation of ? ex-
tends the reachability of ??. A minimal solved form
of ? is a solved form of ? that is minimal with re-
spect to specificity.
The notion of configurations from MRS applies
to dominance constraints as well. Here, a configu-
ration is a dominance constraint whose graph is a
tree without dominance edges. A configuration of a
constraint ? is a configuration that solves ? in the
obvious sense. Simple solved forms are tree-shaped
solved forms where every hole has exactly one out-
going dominance edge.
L1
L2
L3 L4
L2
L1
L4L3
Figure 3: A dominance constraint (left) with a mini-
mal solved form (right) that has no configuration.
Lemma 1. Simple solved forms and configurations
correspond: Every simple solved form has exactly
one configuration, and for every configuration there
is exactly one solved form that it configures.
Unfortunately, Lemma 1 does not extend to min-
imal as opposed to simple solved forms: there are
minimal solved forms without configurations. The
constraint on the right of Fig. 3, for instance, has no
configuration: the hole of L1 would have to be filled
twice while the right hole of L2 cannot be filled.
4 Representing MRSs
We next map (compact) MRSs to weakly normal
dominance constraints so that configurations are
preserved. Note that this translation is based on a
non-standard semantics for dominance constraints,
namely configurations. We address this problem in
the following sections.
The translation of an MRS M to a dominance con-
straint ?M is quite trivial. The variables of ?M are the
handles of M and its literal set is:
{h : Px1,...,xn(h1, . . .) | h :P(x1, . . . ,xn,h1, . . .) ? M}
?{h : Qx(h1,h2) | h :Qx(h1,h2) ? M}
?{h1/?h2 | h1 ? h2 ? M}
?{h/?h0 | h :Qx(h1,h2),h0 :P(. . . ,x, . . .) ? M}
?{h6=h? | h,h? in distinct label positions of M}
Compact MRSs M are clearly translated into (com-
pact) weakly normal dominance constraints. Labels
of M become roots in ?M while argument handles
become holes. Weak root-to-root dominance literals
are needed to encode variable binding condition C2
of MRS. It could be formulated equivalently through
lambda binding constraints of CLLS (but this is not
necessary here in the absence of parallelism).
Proposition 1. The translation of a compact MRS
M into a weakly normal dominance constraint ?M
preserves configurations.
This weak correctness property follows straight-
forwardly from the analogy in the definitions.
5 Constraint Solving
We recall an algorithm from (Bodirsky et al, 2003)
that efficiently enumerates all minimal solved forms
of wnd-graphs or constraints. All results of this sec-
tion are proved there.
The algorithm can be used to enumerate config-
urations for a large subclass of MRSs, as we will
see in Section 6. But equally importantly, this algo-
rithm provides a powerful proof method for reason-
ing about solved forms and configurations on which
all our results rely.
5.1 Weak Connectedness
Two nodes X and Y of a wnd-graph ? = (V,E) are
weakly connected if there is an undirected path from
X to Y in (V,E). We call ? weakly connected if all
its nodes are weakly connected. A weakly connected
component (wcc) of ? is a maximal weakly con-
nected subgraph of ?. The wccs of ? = (V,E) form
proper partitions of V and E .
Proposition 2. The graph of a solved form of a
weakly connected wnd-graph is a tree.
5.2 Freeness
The enumeration algorithm is based on the notion of
freeness.
Definition 4. A node X of a wnd-graph ? is called
free in ? if there exists a solved form of ? whose
graph is a tree with root X .
A weakly connected wnd-graph without free
nodes is unsolvable. Otherwise, it has a solved form
whose graph is a tree (Prop. 2) and the root of this
tree is free in ?.
Given a set of nodes V ? ?V , we write ?|V ? for the
restriction of ? to nodes in V ? and edges in V ??V ?.
The following lemma characterizes freeness:
Lemma 2. A wnd-graph ? with free node X satis-
fies the freeness conditions:
F1 node X has indegree zero in graph ?, and
F2 no distinct children Y and Y ? of X in ? that are
linked to X by immediate dominance edges are
weakly connected in the remainder ?|V\{X}.
5.3 Algorithm
The algorithm for enumerating the minimal solved
forms of a wnd-graph (or equivalently constraint) is
given in Fig. 4. We illustrate the algorithm for the
problematic wnd-graph ? in Fig. 3. The graph of ?
is weakly connected, so that we can call solve(?).
This procedure guesses topmost fragments in solved
forms of ? (which always exist by Prop. 2).
The only candidates are L1 or L2 since L3 and
L4 have incoming dominance edges, which violates
F1. Let us choose the fragment L2 to be topmost.
The graph which remains when removing L2 is still
weakly connected. It has a single minimal solved
form computed by a recursive call of the solver,
where L1 dominates L3 and L4. The solved form of
the restricted graph is then put below the left hole of
L2, since it is connected to this hole. As a result, we
obtain the solved form on the right of Fig. 3.
Theorem 1. The function solved-form(?) com-
putes all minimal solved forms of a weakly normal
dominance graph ?; it runs in quadratic time per
solved form.
6 Full Translation
Next, we explain how to encode a large class of
MRSs into wnd-constraints such that configurations
correspond precisely to minimal solved forms. The
result of the translation will indeed be normal.
6.1 Problems and Examples
The naive representation of MRSs as weakly nor-
mal dominance constraints is only correct in a weak
sense. The encoding fails in that some MRSs which
have no configurations are mapped to solvable wnd-
constraints. For instance, this holds for the MRS on
the right in Fig 3.
We cannot even hope to translate arbitrary MRSs
correctly into wnd-constraints: the configurability
problem of MRSs is NP-complete, while satisfia-
bility of wnd-constraints can be solved in polyno-
mial time. Instead, we introduce the sublanguages
of MRS-nets and equivalent wnd-nets, and show that
they can be intertranslated in quadratic time.
solved-form(?) ?
Let ?1, . . . ,?k be the wccs of ? = (V,E)
Let (Vi,Ei) be the result of solve(?i)
return (V,?ki=1Ei)
solve(?) ?
precond: ? = (V,/unionmulti/?) is weakly connected
choose a node X satisfying (F1) and (F2) in ? else fail
Let Y1, . . . ,Yn be all nodes s.t. X /Yi
Let ?1, . . . ,?k be the weakly connected components of ?|V?{X ,Y1,...,Yn}
Let (Wj,E j) be the result of solve(? j), and X j ?Wj its root
return (V,?kj=1E j ?/?/?1?/?2) where
/?1 = {(Yi,X j) | ?X ? : (Yi,X ?) ? /??X ? ?Wj},
/?2 = {(X ,X j) | ??X ? : (Yi,X ?) ? /??X ? ?Wj}
Figure 4: Enumerating the minimal solved-forms of a wnd-graph.
...
...
(a) strong
.
...
...
(b) weak
.
 ...
...
(c) island
Figure 5: Fragment Schemas of Nets
6.2 Dominance and MRS-Nets
A hypernormal path (Althaus et al, 2003) in a wnd-
graph is a sequence of adjacent edges that does
not traverse two outgoing dominance edges of some
hole X in sequence, i.e. a wnd-graph without situa-
tions Y1 X Y2.
A dominance net ? is a weakly normal domi-
nance constraint whose fragments all satisfy one of
the three schemas in Fig. 5. MRS-nets can be de-
fined analogously. This means that all roots of ? are
labeled in ?, and that all fragments X : f (X1, . . . ,Xn)
of ? satisfy one of the following three conditions:
strong. n ? 0 and for all Y ? {X1, . . . ,Xn} there ex-
ists a unique Z such that Y C? Z in ?, and there exists
no Z such that X C? Z in ?.
weak. n ? 1 and for all Y ? {X1, . . . ,Xn?1,X} there
exists a unique Z such that Y C? Z in ?, and there
exists no Z such that Xn C? Z in ?.
island. n = 1 and all variables in {Y | X1 C? Y} are
connected by a hypernormal path in the graph of the
restricted constraint ?|V?{X1}, and there exists no Z
such that X C? Z in ?.
The requirement of hypernormal connections in
islands replaces the notion of chain-connectedness
in (Koller et al, 2003), which fails to apply to dom-
inance constraints with weak dominance edges.
For ease of presentation, we restrict ourselves to
a simple version of island fragments. In general, we
should allow for island fragments with n > 1.
6.3 Normalizing Dominance Nets
Dominance nets are wnd-constraints. We next trans-
late dominance nets ? to normal dominance con-
straints ?? so that ? has a configuration iff ?? is sat-
isfiable. The trick is to normalize weak dominance
edges. The normalization norm(?) of a weakly nor-
mal dominance constraint ? is obtained by convert-
ing all root-to-root dominance literals X C? Y as fol-
lows:
X C? Y ? Xn C? Y
if X roots a fragment of ? that satisfies schema
weak of net fragments. If ? is a dominance net then
norm(?) is indeed a normal dominance net.
Theorem 2. The configurations of a weakly con-
nected dominance net ? correspond bijectively
to the minimal solved forms of its normalization
norm(?).
For illustration, consider the problematic wnd-
constraint ? on the left of Fig. 3. ? has two minimal
solved forms with top-most fragments L1 and L2 re-
spectively. The former can be configured, in contrast
to the later which is drawn on the right of Fig. 3.
Normalizing ? has an interesting consequence:
norm(?) has (in contrast to ?) a single minimal
solved form with L1 on top. Indeed, norm(?) cannot
be satisfied while placing L2 topmost. Our algorithm
detects this correctly: the normalization of fragment
L2 is not free in norm(?) since it violates property
F2.
The proof of Theorem 2 captures the rest of this
section. We show in a first step (Prop. 3) that the con-
figurations are preserved when normalizing weakly
connected and satisfiable nets. In the second step,
we show that minimal solved forms of normalized
nets, and thus of norm(?), can always be configured
(Prop. 4).
Corollary 1. Configurability of weakly connected
MRS-nets can be decided in polynomial time; con-
figurations of weakly connected MRS-nets can be
enumerated in quadratic time per configuration.
6.4 Correctness Proof
Most importantly, nets can be recursively decom-
posed into nets as long as they have configurations:
Lemma 3. If a dominance net ? has a configuration
whose top-most fragment is X : f (X1, . . . ,Xn), then
the restriction ?|V?{X ,X1,...,Xn} is a dominance net.
Note that the restriction of the problematic net ?
by L2 on the left in Fig. 3 is not a net. This does not
contradict the lemma, as ? does not have a configu-
ration with top-most fragment L2.
Proof. First note that as X is free in ? it cannot have
incoming edges (condition F1). This means that the
restriction deletes only dominance edges that depart
from nodes in {X ,X1, . . . ,Xn}. Other fragments thus
only lose ingoing dominance edges by normality
condition N3. Such deletions preserve the validity
of the schemas weak and strong.
The island schema is more problematic. We have
to show that the hypernormal connections in this
schema can never be cut. So suppose that Y : f (Y1) is
an island fragment with outgoing dominance edges
Y1 C? Z1 and Y1 C? Z2, so that Z1 and Z2 are con-
nected by some hypernormal path traversing the
deleted fragment X : f (X1, . . . ,Xn). We distinguish
the three possible schemata for this fragment:
...
(a) strong
.
...
(b) weak
.
 ...
(c) island
Figure 6: Traversals through fragments of free roots
strong: since X does not have incoming dominance
edges, there is only a single non-trival kind of traver-
sal, drawn in Fig. 6(a). But such traversals contradict
the freeness of X according to F2.
weak: there is one other way of traversing weak
fragments, shown in Fig. 6(b). Let X C? Y be the
weak dominance edge. The traversal proves that Y
belongs to the weakly connected components of one
of the Xi, so the ??Xn C? Y is unsatisfiable. This
shows that the hole Xn cannot be identified with any
root, i.e. ? does not have any configuration in con-
trast to our assumption.
island: free island fragments permit one single non-
trivial form of traversals, depicted in Fig. 6(c). But
such traversals are not hypernormal.
Proposition 3. A configuration of a weakly con-
nected dominance net ? configures its normalization
norm(?), and vice versa of course.
Proof. Let C be a configuration of ?. We show that
it also configures norm(?). Let S be the simple
solved form of ? that is configured by C (Lemma 1),
and S? be a minimal solved form of ? which is more
general than S.
Let X : f (Y1, . . . ,Yn) be the top-most fragment of
the tree S. This fragment must also be the top-most
fragment of S?, which is a tree since ? is assumed to
be weakly connected (Prop. 2). S? is constructed by
our algorithm (Theorem 1), so that the evaluation of
solve(?) must choose X as free root in ?.
Since ? is a net, some literal X : f (Y1, . . . ,Yn) must
belong to ?. Let ?? = ?|{X ,Y1,...,Yn} be the restriction
of ? to the lower fragments. The weakly connected
components of all Y1, . . ., Yn?1 must be pairwise dis-
joint by F2 (which holds by Lemma 2 since X is free
in ?). The X -fragment of net ? must satisfy one of
three possible schemata of net fragments:
weak fragments: there exists a unique weak domi-
nance edge X C? Z in ? and a unique hole Yn without
outgoing dominance edges. The variable Z must be a
root in ? and thus be labeled. If Z is equal to X then
? is unsatisfiable by normality condition N2, which
is impossible. Hence, Z occurs in the restriction ??
but not in the weakly connected components of any
Y1, . . ., Yn?1. Otherwise, the minimal solved form S?
could not be configured since the hole Yn could not
be identified with any root. Furthermore, the root of
the Z-component must be identified with Yn in any
configuration of ? with root X . Hence, C satisfies
Yn C? Z which is add by normalization.
The restriction ?? must be a dominance net by
Lemma 3, and hence, all its weakly connected com-
ponents are nets. For all 1 ? i ? n? 1, the compo-
nent of Yi in ?? is configured by the subtree of C at
node Yi, while the subtree of C at node Yn configures
the component of Z in ??. The induction hypothesis
yields that the normalizations of all these compo-
nents are configured by the respective subconfigura-
tions of C. Hence, norm(?) is configured by C.
strong or island fragments are not altered by nor-
malization, so we can recurse to the lower fragments
(if there exist any).
Proposition 4. Minimal solved forms of normal,
weakly connected dominance nets have configura-
tions.
Proof. By induction over the construction of min-
imal solved forms, we can show that all holes of
minimal solved forms have a unique outgoing dom-
inance edge at each hole. Furthermore, all minimal
solved forms are trees since we assumed connect-
edness (Prop.2). Thus, all minimal solved forms are
simple, so they have configurations (Lemma 1).
7 Conclusion
We have related two underspecification formalism,
MRS and normal dominance constraints. We have
distinguished the sublanguages of MRS-nets and
normal dominance nets that are sufficient to model
scope underspecification, and proved their equiva-
lence. Thereby, we have obtained the first provably
efficient algorithm to enumerate the readings of un-
derspecified semantic representations in MRS.
Our encoding has the advantage that researchers
interested in dominance constraints can benefit from
the large grammar resources of MRS. This requires
further work in order to deal with unrestricted ver-
sions of MRS used in practice. Conversely, one can
now lift the additional modeling power of CLLS to
MRS.
References
H. Alshawi and R. Crouch. 1992. Monotonic semantic
interpretation. In Proc. 30th ACL, pages 32?39.
E. Althaus, D. Duchier, A. Koller, K. Mehlhorn,
J. Niehren, and S. Thiel. 2003. An efficient graph
algorithm for dominance constraints. Journal of Algo-
rithms. In press.
Manuel Bodirsky, Denys Duchier, Joachim Niehren, and
Sebastian Miele. 2003. An efficient algorithm for
weakly normal dominance constraints. Available at
www.ps.uni-sb.de/Papers.
Johan Bos. 1996. Predicate logic unplugged. In Amster-
dam Colloquium, pages 133?143.
Ann Copestake and Dan Flickinger. An open-
source grammar development environment and broad-
coverage English grammar using HPSG. In Confer-
ence on Language Resources and Evaluation.
Ann Copestake, Dan Flickinger, Ivan Sag, and Carl Pol-
lard. 1999. Minimal Recursion Semantics: An Intro-
duction. Manuscript, Stanford University.
Ann Copestake, Alex Lascarides, and Dan Flickinger.
2001. An algebra for semantic construction in
constraint-based grammars. In Proceedings of the
39th ACL, pages 132?139, Toulouse, France.
Markus Egg, Alexander Koller, and Joachim Niehren.
2001. The Constraint Language for Lambda Struc-
tures. Logic, Language, and Information, 10:457?485.
Alexander Koller, Joachim Niehren, and Ralf Treinen.
2001. Dominance constraints: Algorithms and com-
plexity. In LACL?98, volume 2014 of LNAI, pages
106?125.
Alexander Koller, Joachim Niehren, and Stefan Thater.
2003. Bridging the gap between underspecification
formalisms: Hole semantics as dominance constraints.
In EACL?03, April. In press.
Carl Pollard and Ivan Sag. 1994. Head-driven Phrase
Structure Grammar. University of Chicago Press.
Uwe Reyle. 1993. Dealing with ambiguities by under-
specification: Construction, representation and deduc-
tion. Journal of Semantics, 10(1).
Minimal Recursion Semantics as Dominance Constraints:
Translation, Evaluation, and Analysis
Ruth Fuchss,1 Alexander Koller,1 Joachim Niehren,2 and Stefan Thater1
1 Dept. of Computational Linguistics, Saarland University, Saarbr?cken, Germany ?
2 INRIA Futurs, Lille, France
{fuchss,koller,stth}@coli.uni-sb.de
Abstract
We show that a practical translation of MRS de-
scriptions into normal dominance constraints is fea-
sible. We start from a recent theoretical translation
and verify its assumptions on the outputs of the En-
glish Resource Grammar (ERG) on the Redwoods
corpus. The main assumption of the translation?
that all relevant underspecified descriptions are
nets?is validated for a large majority of cases; all
non-nets computed by the ERG seem to be system-
atically incomplete.
1 Introduction
Underspecification is the standard approach to deal-
ing with scope ambiguity (Alshawi and Crouch,
1992; Pinkal, 1996). The readings of underspecified
expressions are represented by compact and concise
descriptions, instead of being enumerated explic-
itly. Underspecified descriptions are easier to de-
rive in syntax-semantics interfaces (Egg et al, 2001;
Copestake et al, 2001), useful in applications such
as machine translation (Copestake et al, 1995), and
can be resolved by need.
Two important underspecification formalisms in
the recent literature are Minimal Recursion Seman-
tics (MRS) (Copestake et al, 2004) and dominance
constraints (Egg et al, 2001). MRS is the under-
specification language which is used in large-scale
HPSG grammars, such as the English Resource
Grammar (ERG) (Copestake and Flickinger, 2000).
The main advantage of dominance constraints is
that they can be solved very efficiently (Althaus et
al., 2003; Bodirsky et al, 2004).
Niehren and Thater (2003) defined, in a theo-
retical paper, a translation from MRS into normal
dominance constraints. This translation clarified the
precise relationship between these two related for-
malisms, and made the powerful meta-theory of
dominance constraints accessible to MRS. Their
goal was to also make the large grammars for MRS
? Supported by the CHORUS project of the SFB 378 of the
DFG.
and the efficient constraint solvers for dominance
constraints available to the other formalism.
However, Niehren and Thater made three techni-
cal assumptions:
1. that EP-conjunction can be resolved in a pre-
processing step;
2. that the qeq relation in MRS is simply domi-
nance;
3. and (most importantly) that all linguistically
correct and relevant MRS expressions belong
to a certain class of constraints called nets.
This means that it is not obvious whether their
result can be immediately applied to the output of
practical grammars like the ERG.
In this paper, we evaluate the truth of these as-
sumptions on the MRS expressions which the ERG
computes for the sentences in the Redwoods Tree-
bank (Oepen et al, 2002). The main result of our
evaluation is that 83% of the Redwoods sentences
are indeed nets, and 17% aren?t. A closer analysis
of the non-nets reveals that they seem to be sys-
tematically incomplete, i. e. they predict more read-
ings than the sentence actually has. This supports
the claim that all linguistically correct MRS expres-
sions are indeed nets. We also verify the other two
assumptions, one empirically and one by proof.
Our results are practically relevant because dom-
inance constraint solvers are much faster and have
more predictable runtimes when solving nets than
the LKB solver for MRS (Copestake, 2002), as we
also show here. In addition, nets might be useful as
a debugging tool to identify potentially problematic
semantic outputs when designing a grammar.
Plan of the Paper. We first recall the definitions
of MRS (?2) and dominance constraints (?3). We
present the translation from MRS-nets to domi-
nance constraints (?4) and prove that it can be ex-
tended to MRS-nets with EP-conjunction (?5). Fi-
nally we evaluate the net hypothesis and the qeq
assumption on the Redwoods corpus, and compare
runtimes (?6).
2 Minimal Recursion Semantics
This section presents a definition of Minimal Re-
cursion Semantics (MRS) (Copestake et al, 2004)
including EP-conjunctions with a merging seman-
tics. Full MRS with qeq-semantics, top handles, and
event variables will be discussed in the last para-
graph.
MRS Syntax. MRS constraints are conjunctive
formulas over the following vocabulary:
1. An infinite set of variables ranged over by h.
Variables are also called handles.
2. An infinite set of constants x,y,z denoting in-
divual variables of the object language.
3. A set of function symbols ranged over by P,
and a set of quantifier symbols ranged over by
Q. Pairs Qx are further function symbols.
4. The binary predicate symbol ?=q?.
MRS constraints have three kinds of literals, two
kinds of elementary predications (EPs) in the first
two lines and handle constraints in the third line:
1. h : P(x1, . . . ,xn,h1, . . . ,hm), where n,m ? 0
2. h : Qx(h1,h2)
3. h1 =q h2
In EPs, label positions are on the left of ?:? and argu-
ment positions on the right. Let M be a set of literals.
The label set lab(M) contains all handles of M that
occur in label but not in argument position, and the
argument handle set arg(M) contains all handles of
M that occur in argument but not in label position.
Definition 1 (MRS constraints). An MRS con-
straint (MRS for short) is a finite set M of MRS-
literals such that:
M1 every handle occurs at most once in argument
position in M,
M2 handle constraints h =q h? always relate argu-
ment handles h to labels h?, and
M3 for every constant (individual variable) x in ar-
gument position in M there is a unique literal
of the form h : Qx(h1,h2) in M.
We say that an MRS M is compact if every han-
dle h in M is either a label or an argument handle.
Compactness simplifies the following proofs, but it
is no serious restriction in practice.
We usually represent MRSs as directed graphs:
the nodes of the graph are the handles of the MRS,
EPs are represented as solid lines, and handle con-
straints are represented as dotted lines. For instance,
the following MRS is represented by the graph on
the left of Fig. 1.
{h5 : somey(h6,h8),h7 : book(y),h1 : everyx(h2,h4),
h3 : student(x),h9 : read(x,y),h2 =q h3,h6 =q h7}
everyx somey
studentx booky
readx,y
everyx
somey
studentx
booky
readx,y
everyx
someystudentx
booky readx,y
Figure 1: An MRS and its two configurations.
Note that the relation between bound variables
and their binders is made explicit by binding edges
drawn as dotted lines (cf. C2 below); transitively re-
dundand binding edges (e. g., from somey to booky)
however are omited.
MRS Semantics. Readings of underspecified rep-
resentations correspond to configurations of MRS
constraints. Intuitively, a configuration is an MRS
where all handle constraints have been resolved by
plugging the ?tree fragments? into each other.
Let M be an MRS and h,h? be handles in M. We
say that h immediately outscopes h? in M if there
is an EP in M with label h and argument handle h?,
and we say that h outscopes h? in M if the pair (h,h?)
belongs to the reflexive transitive closure of the im-
mediate outscope relation of M.
Definition 2 (MRS configurations). An MRS M is
a configuration if it satisfies conditions C1 and C2:
C1 The graph of M is a tree of solid edges: (i) all
handles are labels i. e., arg(M) = /0 and M con-
tains no handle constraints, (ii) handles don?t
properly outscope themselve, and (iii) all han-
dles are pairwise connected by EPs in M.
C2 If h : Qx(h1,h2) and h? : P(. . . ,x, . . .) belong to
M, then h outscopes h? in M i. e., binding edges
in the graph of M are transitively redundant.
We say that a configuration M is configuration of
an MRS M? if there exists a partial substitution ? :
lab(M?) arg(M?) that states how to identify labels
with argument handles of M? so that:
C3 M = {?(E) | E is an EP in M?}, and
C4 for all h =q h? in M?, h outscopes ?(h?) in M.
The value ?(E) is obtained by substituting all la-
bels in dom(?) in E while leaving all other handels
unchanged.
The MRS on the left of Fig. 1, for instance, has
two configurations given to the right.
EP-conjunctions. Definitions 1 and 2 generalize
the idealized definition of MRS of Niehren and
Thater (2003) by EP-conjunctions with a merging
semantics. An MRS M contains an EP-conjunction
if it contains different EPs with the same label h.The
intuition is that EP-conjunctions are interpreted by
object language conjunctions.
P1, P2
P3
{h1 : P1(h2),h1 : P2(h3),h4 : P3
h2 =q h4,h3 =q h4}
Figure 2: An unsolvable MRS with EP-conjunction
P1
P3P2
P1
P2, P3
configures
Figure 3: A solvable MRS without merging-free
configaration
Fig. 2 shows an MRSwith an EP-conjunction and
its graph. The function symbols of both EPs are con-
joined and their arguments are merged into a set.
The MRS does not have configurations since the ar-
gument handles of the merged EPs cannot jointly
outscope the node P4.
We call a configuration merging if it contains EP-
conjunctions, and merging-free otherwise. Merging
configurations are needed to solve EP-conjuctions
such as {h : P1, h : P2}. Unfortunately, they can also
solve MRSs without EP-conjunctions, such as the
MRS in Fig. 3. The unique configuration of this
MRS is a merging configuration: the labels of P1
and P2 must be identified with the only available ar-
gument handle. The admission of merging configu-
rations may thus have important consequences for
the solution space of arbitrary MRSs.
Standard MRS. Standard MRS requires three
further extensions: (i) qeq-semantics, (ii) top-
handles, and (iii) event variables. These extensions
are less relevant for our comparision.
The qeq-semantics restricts the interpretation of
handle constraints beyond dominance. Let M be an
MRS with handles h,h?. We say that h is qeq h? in M
if either h = h?, or there is an EP h : Qx(h0,h1) in M
and h1 is qeq h? in M. Every qeq-configuration is a
configuration as defined above, but not necessarily
vice versa. The qeq-restriction is relevant in theory
but will turn out unproblematic in practice (see ?6).
Standard MRS requires the existence of top
handles in all MRS constraints. This condition
doesn?t matter for MRSs with connected graphs (see
(Bodirsky et al, 2004) for the proof idea). MRSs
with unconnected graphs clearly do not play any
role in practical underspecified semantics.
Finally, MRSs permit events variables e,e? as a
second form of constants. They are treated equally
to individual variables except that they cannot be
bound by quantifiers.
3 Dominance Constraints
Dominance constraints are a general framework for
describing trees. For scope underspecification, they
are used to describe the syntax trees of object lan-
guage formulas. Dominance constraints are the core
language underlying CLLS (Egg et al, 2001) which
adds parallelism and binding constraints.
Syntax and semantics. We assume a possibly in-
finite signature ? = { f ,g, . . .} of function symbols
with fixed arities (written ar( f )) and an infinite set
of variables ranged over by X ,Y,Z.
A dominance constraint ? is a conjunction of
dominance, inequality, and labeling literals of the
following form, where ar( f ) = n:
? ::= X ? Y | X = Y | X : f (X1, . . . ,Xn) | ????
Dominance constraints are interpreted over fi-
nite constructor trees i. e., ground terms constructed
from the function symbols in ?. We identify ground
terms with trees that are rooted, ranked, edge-
ordered and labeled. A solution for a dominance
constraint ? consists of a tree ? and an assign-
ment ? that maps the variables in ? to nodes of ?
such that all constraints are satisfied: labeling lit-
erals X : f (X1, . . . ,Xn) are satisfied iff ?(X) is la-
beled with f and its daughters are ?(X1), . . . ,?(Xn)
in this order; dominance literals X ? Y are satisfied
iff ?(X) dominates ?(Y ) in ?; and inequality literals
X = Y are satisfied iff ?(X) and ?(Y ) are distinct
nodes.
Solved forms. Satisfiable dominance constraints
have infinitely many solutions. Constraint solvers
for dominance constraints therefore do not enumer-
ate solutions but solved forms i. e., ?tree shaped?
constraints. To this end, we consider (weakly) nor-
mal dominance constraints (Bodirsky et al, 2004).
We call a variable a hole of ? if it occurs in argu-
ment position in ? and a root of ? otherwise.
Definition 3. A dominance constraint ? is normal
if it satisfies the following conditions.
N1 (a) each variable of ? occurs at most once in
the labeling literals of ?.
(b) each variable of ? occurs at least once in
the labeling literals of ?.
N2 for distinct roots X and Y of ?, X =Y is in ?.
N3 (a) if X ? Y occurs in ?, Y is a root in ?.
(b) if X ? Y occurs in ?, X is a hole in ?.
We call ? weakly normal if it satisfies the above
properties except for N1 (b) and N3 (b).
Note that Definition 3 imposes compactness: the
height of tree fragments is always one. This is not
everyx somey
studentx booky
readx,y
everyx
someystudentx
booky readx,y
everyx
somey
studentx
booky
readx,y
Figure 4: A normal dominance constraint (left) and
its two solved forms (right).
a serious restriction, as weakly normal dominance
constraints can be compactified, provided that dom-
inance links relate either roots or holes with roots.
Weakly normal dominance constraints ? can be
represented by dominance graphs. The dominance
graph of ? is a directed graph G = (V,ET unionmultiED) de-
fined as follows. The nodes of G are the variables of
?. Labeling literals X : f (X1, . . . ,Xk) are represented
by tree edges (X ,Xi) ? ET , for 1? i? k, and domi-
nance literals X ? X ? are represented by dominance
edges (X ,X ?) ? ED. Inequality literals are not repre-
sented in the graph. In pictures, labeling literals are
drawn with solid lines and dominance edges with
dotted lines.
We say that a constraint ? is in solved form if its
graph is in solved form. A graph G is in solved form
iff it is a forest. The solved forms of G are solved
forms G? which are more specific than G i. e., they
differ only in their dominance edges and the reacha-
bility relation of G extends the reachability of G?. A
minimal solved form is a solved form which is min-
imal with respect to specificity. Simple solved forms
are solved forms where every hole has exactly one
outgoing dominance edge. Fig. 4 shows as a con-
crete example the translation of the MRS descrip-
tion in Fig. 1 together with its two minimal solved
forms. Both solved forms are simple.
4 Translating Merging-Free MRS-Nets
This section defines MRS-nets without EP-
conjunctions, and sketches their translation to
normal dominance constraints. We define nets
equally for MRSs and dominance constraints. The
key semantic property of nets is that different
notions of solutions coincide. In this section, we
show that merging-free configurations coincides
to minimal solved forms. ?5 generalizes the trans-
lation by adding EP-conjunctions and permitting
merging semantics.
Pre-translation. An MRS constraint M can be
represented as a corresponding dominance con-
straint ?M as follows: The variables of ?M are the
handles of M, and the literals of ?M correspond
... ... ...
... ...
(a) strong (b) weak (c) island
Figure 5: Fragment Schemata of Nets
those of M in the following sence:
h : P(x1, . . . ,xn,h1, . . . ,hk) 	? h : Px1,...,xn(h1, . . . ,hk)
h : Qx(h1,h2) 	? h : Qx(h1,h2)
h =q h
?
	? h ? h?
Additionally, dominance literals h ? h? are added to
?M for all h,h? s. t. h :Qx(h1,h2) and h? :P(. . . ,x, . . .)
belong to M (cf. C2), and literals h = h? are added
to ?M for all h,h? in distinct label position in M.
Lemma 1. If a compact MRS M does not contain
EP-conjunctions then ?M is weakly normal, and the
graph of M is the transitive reduction of the graph
of ?M.
Nets. A hypernormal path (Althaus et al, 2003)
in a constraint graph is a path in the undirected
graph that contains for every leaf X at most one in-
cident dominance edge.
Let ? be a weakly normal dominance constraint
and let G be the constraint graph of ?. We say that
? is a dominance net if the transitive reduction G?
of G is a net. G? is a net if every tree fragment F
of G? satisfies one of the following three conditions,
illustrated in Fig. 5:
Strong. Every hole of F has exactly one outgoing
dominance edge, and there is no weak root-to-root
dominance edge.
Weak. Every hole except for the last one has ex-
actly one outgoing dominance edge; the last hole
has no outgoing dominance edge, and there is ex-
actly one weak root-to-root dominance edge.
Island. The fragment has one hole X , and all vari-
ables which are connected to X by dominance edges
are connected by a hypernormal path in the graph
where F has been removed.
We say that an MRS M is an MRS-net if the pre-
translation of its literals results in a dominance net
?M. We say that an MRS-net M is connected if ?M
is connected; ?M is connected if the graph of ?M is
connected.
Note that this notion of MRS-nets implies that
MRS-nets cannot contain EP-conjunctions as other-
wise the resulting dominance constraint would not
be weakly normal. ?5 shows that EP-conjunctions
can be resolved i. e., MRSs with EP-conjunctions
can be mapped to corresponding MRSs without EP-
conjunctions.
If M is an MRS-net (without EP-conjunctions),
then M can be translated into a corresponding dom-
inance constraint ? by first pre-translating M into
a ?M and then normalizing ?M by replacing weak
root-to-root dominance edges in weak fragments by
dominance edges which start from the open last
hole.
Theorem 1 (Niehren and Thater, 2003). Let M be
an MRS and ?M be the translation of M. If M is a
connected MRS-net, then the merging-free configu-
rations of M bijectively correspond to the minimal
solved forms of the ?M.
The following section generalizes this result to
MRS-nets with a merging semantics.
5 Merging and EP-Conjunctions
We now show that if an MRS is a net, then all its
configurations are merging-free, which in particular
means that the translation can be applied to the more
general version of MRS with a merging semantics.
Lemma 2 (Niehren and Thater, 2003). All mini-
mal solved forms of a connected dominance net are
simple.
Lemma 3. If all solved forms of a normal domi-
nance constraint are simple, then all of its solved
forms are minimal.
Theorem 2. The configurations of an MRS-net M
are merging-free.
Proof. Let M? be a configuration of M and let ? be
the underlying substitution. We construct a solved
form ?M? as follows: the labeling literals of ?M? are
the pre-translations of the EPs in M, and ?M? has a
dominance literal h? ? h iff (h,h?) ? ?, and inequal-
ity literals X = Y for all distinct roots in ?M? .
By condition C1 in Def. 2, the graph of M? is a
tree, hence the graph of ?M? must also be a tree i. e.,
?M? is a solved form. ?M? must also be more spe-
cific than the graph of ?M because the graph of M?
satisfies all dominance requirements of the handle
constraints in M, hence ?M? is a solved form of ?M.
M clearly solved ?M? . By Lemmata 2 and 3, ?M?
must be simple and minimal because ?M is a net.
But then M? cannot contain EP-conjunctions i. e.,M?
is merging-free.
The merging semantics of MRS is needed to
solve EP-conjunctions. As we have seen, the merg-
ing semantics is not relevant for MRS constraints
which are nets. This also verifies Niehren and
Thater?s (2003) assumption that EP-conjunctions
are ?syntactic sugar? which can be resolved in a pre-
processing step: EP-conjunctions can be resolved
by exhaustively applying the following rule which
adds new literals to make the implicit conjunction
explicit:
h : E1(h1, . . . ,hn),h : E2(h
?
1, . . . ,h
?
m)?
h : ?E1&E2?(h1, . . . ,hn,h
?
1, . . . ,h
?
m),
where E(h1, . . . ,hn) stands for an EP with argument
handles h1, . . . ,hn, and where ?E1&E2? is a complex
function symbol. If this rule is applied exhaustively
to an MRS M, we obtain an MRS M? without EP-
conjunctions. It should be intuitively clear that the
configurations of M and M? correspond; Therefore,
the configurations of M also correspond to the min-
imal solved forms of the translation of M?.
6 Evaluation
The two remaining assumptions underlying the
translation are the ?net-hypothesis? that all lin-
guistically relevant MRS expressions are nets, and
the ?qeq-hypothesis? that handle constraints can be
given a dominance semantics practice. In this sec-
tion, we empirically show that both assumptions are
met in practice.
As an interesting side effect, we also compare the
run-times of the constraint-solvers we used, and we
find that the dominance constraint solver typically
outperforms the MRS solver, often by significant
margins.
Grammar and Resources. We use the English
Resource Grammar (ERG), a large-scale HPSG
grammar, in connection with the LKB system, a
grammar development environment for typed fea-
ture grammars (Copestake and Flickinger, 2000).
We use the system to parse sentences and output
MRS constraints which we then translate into domi-
nance constraints. As a test corpus, we use the Red-
woods Treebank (Oepen et al, 2002) which con-
tains 6612 sentences. We exclude the sentences that
cannot be parsed due to memory capacities or words
and grammatical structures that are not included in
the ERG, or which produce ill-formed MRS expres-
sions (typically violating M1) and thus base our
evaluation on a corpus containing 6242 sentences.
In case of syntactic ambiguity, we only use the first
reading output by the LKB system.
To enumerate the solutions of MRS constraints
and their translations, we use the MRS solver built
into the LKB system and a solver for weakly nor-
mal dominance constraints (Bodirsky et al, 2004),
...
(a) open hole (b) ill-formed island
Figure 6: Two classes of non-nets
which is implemented in C++ and uses LEDA, a
class library for efficient data types and algorithms
(Mehlhorn and N?her, 1999).
6.1 Relevant Constraints are Nets
We check for 6242 constraints whether they consti-
tute nets. It turns out that 5200 (83.31%) constitute
nets while 1042 (16.69%) violate one or more net-
conditions.
Non-nets. The evaluation shows that the hypoth-
esis that all relevant constraints are nets seems to
be falsified: there are constraints that are not nets.
However, a closer analysis suggests that these con-
straints are incomplete and predict more readings
than the sentence actually has. This can also be il-
lustrated with the average number of solutions: For
the Redwoods corpus in combination with the ERG,
nets have 1836 solutions on average, while non-nets
have 14039 solutions, which is a factor of 7.7. The
large number of solutions for non-nets is due to the
?structural weakness? of non-nets; often, non-nets
have only merging configurations.
Non-nets can be classified into two categories
(see Fig. 6): The first class are violated ?strong?
fragments which have holes without outgoing dom-
inance edge and without a corresponding root-to-
root dominance edge. The second class are violated
?island? fragments where several outgoing domi-
nance edges from one hole lead to nodes which
are not hypernormally connected. There are two
more possibilities for violated ?weak? fragments?
having more than one weak dominance edge or hav-
ing a weak dominance edge without empty hole?,
but they occur infrequently (4.4%). If those weak
fragments were normalized, they would constitute
violated island fragments, so we count them as such.
124 (11.9%) of the non-nets contain empty holes,
762 (73.13%) contain violated island fragments,
and 156 (14.97%) contain both. Those constraints
that contain only empty holes and no violated is-
land fragments cannot be configured, as in configu-
rations, all holes must be filled.
Fragments with open holes occur frequently, but
not in all contexts, for constraints representing for
example time specifications (e. g., ?from nine to
twelve? or ?a three o?clock flight?) or intensional
expressions (e. g., ?Is it?? or ?I suppose?). Ill-
availablee, ax
aycafeteriax
saunay ande,x,y
prop
ax
aycafeteriax
saunay, 
ande,x,y
availablee
prop
ax ay
cafeteriax saunay
ande,x,y
availablee
prop
?1 ?2
Figure 7: An MRS for ?A sauna and a cafeteria are
available? (top) and two of sixteen merging config-
urations (below).
ax ay
cafeteriax saunay
ande,x,y
availablee
prop
Figure 8: The ?repaired? MRS from Fig. 7
formed island fragments are often triggered by some
kind of coordination, like ?a restaurant and/or a
sauna? or ?a hundred and thirty Marks?, also im-
plicit ones like ?one hour thirty minutes? or ?one
thirty?. Constraints with both kinds of violated frag-
ments emerge when there is some input that yields
an open hole and another part of the input yields a
violated island fragment (for example in construc-
tions like ?from nine to eleven thirty? or ?the ten
o?clock flight Friday or Thursday?, but not neces-
sarily as obviously as in those examples).
The constraint on the left in Fig. 7 gives a con-
crete example for violated island fragments. The
topmost fragment has outgoing dominance edges
to otherwise unconnected subconstraints ?1 and ?2.
Under the merging-free semantics of the MRS di-
alect used in (Niehren and Thater, 2003) where ev-
ery hole has to be filled exactly once, this constraint
cannot be configured: there is no hole into which
?available? could be plugged. However, standard
MRS has merging configuration where holes can be
filled more than once. For the constraint in Fig. 7
this means that ?available? can be merged in almost
everywhere, only restricted by the ?qeq-semantics?
which forbids for instance ?available? to be merged
with ?sauna.? In fact, the MRS constraint solver de-
rives sixteen configurations for the constraint, two
of which are given in Fig. 7, although the sentence
has only two scope readings.
We conjecture that non-nets are semantically ?in-
complete? in the sense that certain constraints are
missing. For instance, an alternative analysis for the
above constraint is given in Fig. 8. The constraint
adds an additional argument handle to ?and? and
places a dominance edge from this handle to ?avail-
able.? In fact, the constraint is a net; it has exactly
two readings.
6.2 Qeq is dominance
For all nets, the dominance constraint solver cal-
culates the same number of solutions as the MRS
solver does, with 3 exceptions that hint at problems
in the syntax-semantics interface. As every config-
uration that satisfies proper qeq-constraints is also
a configuration if handle constraints are interpreted
under the weaker notion of dominance, the solutions
computed by the dominance constraint solver and
the MRS solver must be identical for every con-
straint. This means that the additional expressivity
of proper qeq-constraints is not used in practice,
which in turn means that in practice, the translation
is sound and correct even for the standard MRS no-
tion of solution, given the constraint is a net.
6.3 Comparison of Runtimes
The availability of a large body of underspecified
descriptions both in MRS and in dominance con-
straint format makes it possible to compare the
solvers for the two underspecification formalisms.
We measured the runtimes on all nets using a Pen-
tium III CPU at 1.3 GHz. The tests were run in a
multi-user environment, but as the MRS and domi-
nance measurements were conducted pairwise, con-
ditions were equal for every MRS constraint and
corresponding dominance constraint.
The measurements for all MRS-nets with less
than thirty dominance edges are plotted in Fig. 9.
Inputs are grouped according to the constraint size.
The filled circles indicate average runtimes within
each size group for enumerating all solutions us-
ing the dominance solver, and the empty circles in-
dicate the same for the LKB solver. The brackets
around each point indicate maximum and minimum
runtimes in that group. Note that the vertical axis is
logarithmic.
We excluded cases in which one or both of the
solvers did not return any results: There were 173
sentences (3.33% of all nets) on which the LKB
solver ran out of memory, and 1 sentence (0.02%)
that took the dominance solver more than two min-
utes to solve.
The graph shows that the dominance constraint
solver is generally much faster than the LKB solver:
The average runtime is less by a factor of 50 for
constraints of size 10, and this grows to a factor
of 500 for constraints of size 25. Our experiments
show that the dominance solver outperforms the
LKB solver on 98% the cases. In addition, its run-
times are much more predictable, as the brackets in
the graph are also shorter by two or three orders
of magnitude, and the standard deviation is much
smaller (not shown).
7 Conclusion
We developed Niehren and Thater?s (2003) theoret-
ical translation into a practical system for translat-
ing MRS into dominance constraints, applied it sys-
tematically to MRSs produced by English Resource
Grammar for the Redwoods treebank, and evaluated
the results. We showed that:
1. most ?real life? MRS expressions are MRS-
nets, which means that the translation is correct
in these cases;
2. for nets, merging is not necessary (or even pos-
sible);
3. the practical translation works perfectly for all
MRS-nets from the corpus; in particular, the
=q relation can be taken as synonymous with
dominance in practice.
Because the translation works so well in practice,
we were able to compare the runtimes of MRS and
dominance constraint solvers on the same inputs.
This evaluation shows that the dominance constraint
solver outperforms the MRS solver and displays
more predictable runtimes. A researcher working
with MRS can now solve MRS nets using the ef-
ficient dominance constraint solvers.
A small but significant number of the MRS con-
straints derived by the ERG are not nets. We have
argued that these constraints seem to be systemati-
cally incomplete, and their correct completions are
indeed nets. A more detailed evaluation is an impor-
tant task for future research, but if our ?net hypoth-
esis? is true, a system that tests whether all outputs
of a grammar are nets (or a formal ?safety criterion?
that would prove this theoretically) could be a use-
ful tool for developing and debugging grammars.
From a more abstract point of view, our evalua-
tion contributes to the fundamental question of what
expressive power an underspecification formalism
needs. It turned out that the distinction between qeq
 1
 10
 100
 1000
 10000
 100000
 1e+06
 0  5  10  15  20  25  30
T
i
m
e
 
(
m
s
)
Size (number of dominance edges)
DC solver (LEDA)
MRS solver
Figure 9: Comparison of runtimes for the MRS and dominance constraint solvers.
and dominance hardly plays a role in practice. If the
net hypothesis is true, it also follows that merging is
not necessary because EP-conjunctions can be con-
verted into ordinary conjunctions. More research
along these lines could help unify different under-
specification formalisms and the resources that are
available for them.
Acknowledgments We are grateful to Ann
Copestake for many fruitful discussions, and to our
reviewers for helpful comments.
References
H. Alshawi and R. Crouch. 1992. Monotonic se-
mantic interpretation. In Proc. 30th ACL, pages
32?39.
Ernst Althaus, Denys Duchier, Alexander Koller,
Kurt Mehlhorn, Joachim Niehren, and Sven
Thiel. 2003. An efficient graph algorithm for
dominance constraints. Journal of Algorithms,
48:194?219.
Manuel Bodirsky, Denys Duchier, Joachim Niehren,
and Sebastian Miele. 2004. An efficient algo-
rithm for weakly normal dominance constraints.
In ACM-SIAM Symposium on Discrete Algo-
rithms. The ACM Press.
Ann Copestake and Dan Flickinger. 2000. An
open-source grammar development environment
and broad-coverage english grammar using
HPSG. In Conference on Language Resources
and Evaluation.
Ann Copestake, Dan Flickinger, Rob Malouf, Su-
sanne Riehemann, and Ivan Sag. 1995. Transla-
tion using Minimal Recursion Semantics. Leu-
ven.
Ann Copestake, Alex Lascarides, and Dan
Flickinger. 2001. An algebra for semantic
construction in constraint-based grammars. In
Proceedings of the 39th Annual Meeting of the
Association for Computational Linguistics, pages
132?139, Toulouse, France.
Ann Copestake, Dan Flickinger, Carl Pollard, and
Ivan Sag. 2004. Minimal recursion semantics:
An introduction. Journal of Language and Com-
putation. To appear.
Ann Copestake. 2002. Implementing Typed Feature
Structure Grammars. CSLI Publications, Stan-
ford, CA.
Markus Egg, Alexander Koller, and Joachim
Niehren. 2001. The Constraint Language for
Lambda Structures. Logic, Language, and Infor-
mation, 10:457?485.
K. Mehlhorn and S. N?her. 1999. The LEDA Plat-
form of Combinatorial and Geometric Comput-
ing. Cambridge University Press, Cambridge.
See also http://www.mpi-sb.mpg.de/LEDA/.
Joachim Niehren and Stefan Thater. 2003. Bridg-
ing the gap between underspecification for-
malisms: Minimal recursion semantics as dom-
inance constraints. In Proceedings of the 41st
Annual Meeting of the Association for Computa-
tional Linguistics.
Stephan Oepen, Kristina Toutanova, Stuart Shieber,
Christopher Manning, Dan Flickinger, and
Thorsten Brants. 2002. The LinGO Redwoods
treebank: Motivation and preliminary applica-
tions. In Proceedings of the 19th International
Conference on Computational Linguistics
(COLING?02), pages 1253?1257.
Manfred Pinkal. 1996. Radical underspecification.
In 10th Amsterdam Colloquium, pages 587?606.
