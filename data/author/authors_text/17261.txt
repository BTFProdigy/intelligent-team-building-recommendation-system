Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 423?433,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
Large-scale Semantic Parsing via Schema Matching and Lexicon
Extension
Qingqing Cai
Temple University
Computer and Information Sciences
qingqing.cai@temple.edu
Alexander Yates
Temple University
Computer and Information Sciences
yates@temple.edu
Abstract
Supervised training procedures for seman-
tic parsers produce high-quality semantic
parsers, but they have difficulty scaling
to large databases because of the sheer
number of logical constants for which
they must see labeled training data. We
present a technique for developing seman-
tic parsers for large databases based on
a reduction to standard supervised train-
ing algorithms, schema matching, and pat-
tern learning. Leveraging techniques from
each of these areas, we develop a semantic
parser for Freebase that is capable of pars-
ing questions with an F1 that improves by
0.42 over a purely-supervised learning al-
gorithm.
1 Introduction
Semantic parsing is the task of translating natural
language utterances to a formal meaning represen-
tation language (Chen et al, 2010; Liang et al,
2009; Clarke et al, 2010; Liang et al, 2011; Artzi
and Zettlemoyer, 2011). There has been recent in-
terest in producing such semantic parsers for large,
heterogeneous databases like Freebase (Krishna-
murthy and Mitchell, 2012; Cai and Yates, 2013)
and Yago2 (Yahya et al, 2012), which has driven
the development of semi-supervised and distantly-
supervised training methods for semantic parsing.
Previous purely-supervised approaches have been
limited to smaller domains and databases, such as
the GeoQuery database, in part because of the cost
of labeling enough samples to cover all of the log-
ical constants involved in a domain.
This paper investigates a reduction of the prob-
lem of building a semantic parser to three stan-
dard problems in semantics and machine learning:
supervised training of a semantic parser, schema
matching, and pattern learning. Figure 1 provides
a visualization of our system architecture. We
apply an existing supervised training algorithm
for semantic parsing to a labeled data set. We
(sentence, logical form) Training data 
Test questions 
Freebase Web Relations Extracted from Web 
Supervised Semantic Parser Learning MATCHER 
LEXTENDER Freebase PCCG Grammar and Lexicon (word, Freebase symbol) correspondences 
High-Coverage Freebase PCCG Grammar and Lexicon 
Figure 1: We reduce the task of learning a large-
scale semantic parser to a combination of 1) a
standard supervised algorithm for learning seman-
tic parsers; 2) our MATCHER algorithm for find-
ing correspondences between words and database
symbols; and 3) our LEXTENDER algorithm for
integrating (word, database symbol) matches into
a semantic parsing lexicon.
apply schema matching techniques to the prob-
lem of finding correspondences between English
words w and ontological symbols s. And we ap-
ply pattern learning techniques to incorporate new
(w, s) pairs into the lexicon of the trained seman-
tic parser.
This reduction allows us to apply standard tech-
niques from each problem area, which in com-
bination provide a large improvement over the
purely-supervised approaches. On a dataset of
917 questions taken from 81 domains of the Free-
base database, a standard learning algorithm for
semantic parsing yields a parser with an F1 of
0.21, in large part because of the number of log-
ical symbols that appear during testing but never
appear during training. Our techniques can extend
this parser to new logical symbols through schema
matching, and yield a semantic parser with an F1
of 0.63 on the same task. On a more challenging
task where training and test data are divided so that
all logical constants in test are never observed dur-
423
ing training, our approach yields a semantic parser
with an F1 of 0.6, whereas the purely supervised
approach cannot parse a single test question cor-
rectly. These results indicate that it is possible to
automatically extend semantic parsers to symbols
for which little or no training data has been ob-
served.
The rest of this paper is organized as follows.
The next section discusses related work. Section 3
describes our MATCHER algorithm for performing
schema matching between a knowledge base and
text. Section 4 explains how we use MATCHER?s
schema matching to extend a standard semantic
parser to logical symbols for which it has seen no
labeled training data. Section 5 analyzes the per-
formance of MATCHER and our semantic parser.
Section 6 concludes.
2 Previous Work
Two existing systems translate between natural
language questions and database queries over
large-scale databases. Yahya et al (2012) re-
port on a system for translating natural language
queries to SPARQL queries over the Yago2 (Hof-
fart et al, 2013) database. Yago2 consists of
information extracted from Wikipedia, WordNet,
and other resources using manually-defined ex-
traction patterns. The manual extraction patterns
pre-define a link between natural language terms
and Yago2 relations. Our techniques automate
the process of identifying matches between tex-
tual phrases and database relation symbols, in or-
der to scale up to databases with more relations,
like Freebase. A more minor difference between
Yahya et al?s work and ours is that their system
handles SPARQL queries, which do not handle ag-
gregation queries like argmax and count. We
rely on an existing semantic parsing technology
to learn the language that will translate into such
aggregation queries. On the other hand, their test
questions involve more conjunctions and complex
semantics than ours. Developing a dataset with
more complicated semantics in the queries is part
of our ongoing efforts.
Krishnamurthy and Mitchell (2012) also cre-
ate a semantic parser for Freebase covering 77
of Freebase?s over 2000 relations. Like our
work, their technique uses distant supervision to
drive training over a collection of sentences gath-
ered from the Web, and they do not require any
manually-labeled training data. However, their
technique does require manual specification of
rules that construct CCG lexical entries from de-
pendency parses. In comparison, we fully auto-
mate the process of constructing CCG lexical en-
tries for the semantic parser by making it a pre-
diction task. We also leverage synonym-matching
techniques for comparing relations extracted from
text with Freebase relations. Finally, we test our
results on a dataset of 917 questions covering
over 600 Freebase relations, a more extensive test
than the 50 questions used by Krishnamurthy and
Mitchell.
Numerous methods exist for comparing two re-
lations based on their sets of tuples. For instance,
the DIRT system (Lin and Pantel, 2001) uses the
mutual information between the (X,Y ) argument
pairs for two binary relations to measure the sim-
ilarity between them, and clusters relations ac-
cordingly. More recent examples of similar tech-
niques include the Resolver system (Yates and Et-
zioni, 2009) and Poon and Domingos?s USP sys-
tem (Poon and Domingos, 2009). Our techniques
for comparing relations fit into this line of work,
but they are novel in their application of these
techniques to the task of comparing database re-
lations and relations extracted from text.
Schema matching (Rahm and Bernstein, 2001;
Ehrig et al, 2004; Giunchiglia et al, 2005) is a
task from the database and knowledge representa-
tion community in which systems attempt to iden-
tify a ?common schema? that covers the relations
defined in a set of databases or ontologies, and the
mapping between each individual database and the
common schema. Owing to the complexity of the
general case, researchers have resorted to defining
standard similarity metrics between relations and
attributes, as well as machine learning algorithms
for learning and predicting matches between rela-
tions (Doan et al, 2004; Wick et al, 2008b; Wick
et al, 2008a; Nottelmann and Straccia, 2007;
Berlin and Motro, 2006). These techniques con-
sider only matches between relational databases,
whereas we apply these ideas to matches between
Freebase and extracted relations. Schema match-
ing in the database sense often considers com-
plex matches between relations (Dhamanka et al,
2004), whereas as our techniques are currently re-
stricted to matches involving one database relation
and one relation extracted from text.
424
3 Textual Schema Matching
3.1 Problem Formulation
The textual schema matching task is to identify
natural language words and phrases that corre-
spond with each relation and entity in a fixed
schema for a relational database. To formalize this
task, we first introduce some notation.
A schema S = (E,R,C, I) consists of a
set of entities E, a set of relations R, a set of
categories C, and a set of instances I . Categories
are one-argument predicates (e.g., film(e)), and
relations are two- (or more-) argument predicates
(e.g., directed by(e1, e2)). Instances are
known tuples of entities that make a relation
or category true, such as film(Titanic)
or directed by(Titanic, James
Cameron). For a given r ? R (or c ? C),
IS(r) indicates the set of known instances of r in
schema S (and likewise for IS(c)). Examples of
such schemas include Freebase (Bollacker et al,
2008) and Yago2 (Hoffart et al, 2013). We say a
schema is a textual schema if it has been extracted
from free text, such as the Nell (Carlson et al,
2010) and ReVerb (Fader et al, 2011) extracted
databases.
Given a textual schema T and a database
schema D, the textual schema matching task is to
identify an alignment or matching M ? RT ?RD
such that (rT , rD) ? M if and only if rT can
be used to refer to rD in normal language usage.
The problem would be greatly simplified if
M were a 1-1 function, but in practice most
database relations can be referred to in many
ways by natural language users: for instance,
film actor can be referenced by the English
verbs ?played,? ?acted,? and ?starred,? along
with morphological variants of them. In addi-
tion, many English verbs can refer to several
different relations in Freebase: ?make? can refer
to computer processor manufacturer
or distilled spirits producer, among
many others. Our MATCHER algorithm for textual
schema matching handles this by producing a
confidence score for every possible (rT , rD) pair,
which downstream applications can then use to
reason about the possible alignments.
Even worse than the ambiguities in alignment,
some textual relations do not correspond with
any database relation exactly, but instead they
correspond with a projection of a relation, or a
join between multiple relations, or another com-
plex view of a database schema. As a sim-
ple example, ?actress? corresponds to a subset
of the Freebase film actor relation that inter-
sects with the set {x: gender(x, female)}.
MATCHER can only determine that ?actress?
aligns with film actor or not; it cannot pro-
duce an alignment between ?actress? and a join of
film actor and gender. These more complex
alignments are an important consideration for fu-
ture work, but as our experiments will show, quite
useful alignments can be produced without han-
dling these more complex cases.
3.2 Identifying candidate matches
MATCHER uses a generate-and-test architecture
for determining M . It uses a Web search engine
to issue queries for a database relation rD consist-
ing of all the entities in a tuple t ? ID(rD). 1000
tuples for each rD are randomly chosen for issu-
ing queries. The system then retrieves matching
snippets from the search engine results. It uses
the top 10 results for each search engine query. It
then counts the frequency of each word type in the
set of retrieved snippets for rD. The top 500 non-
stopword word types are chosen as candidates for
matches with rD. We denote the candidate set for
rD as C(rD).
MATCHER?s threshold of 500 candidates for
C(rD) results in a maximum possible recall of just
less than 0.8 for the alignments in our dataset, but
even if we double the threshold to 1000, the re-
call improves only slightly to 0.82. We therefore
settled on 500 as a point with an acceptable upper
bound on recall, while also producing an accept-
able number of candidate terms for further pro-
cessing.
3.3 Pattern-based match selection
The candidate pool C(rD) of 500 word types is
significantly smaller than the set of all textual re-
lations, but it is also extremely noisy. The can-
didates may include non-relation words, or other
frequent but unrelated words. They may also in-
clude words that are highly related to rD, but not
actually corresponding textual relations. For in-
stance, the candidate set for film director in
Freebase includes words like ?directed,? but also
words like ?film,? ?movie,? ?written,? ?produced,?
and ?starring.? We use a series of filters based on
synonym-detection techniques to help select the
true matching candidates from C(rD).
425
Pattern Condition Example
1. ?rT in E? rT ends with ?-ed? and E has
type datetime or location
?founded in 1989?
2. ?rT by E? rT ends with ?-ed? ?invented by Edison?
3. ?rT such as E? rT ends with ?-s? ?directors such as Tarantino?
4. ?E is a(n) rT ? all cases ?Paul Rudd is an actor?
Table 1: Patterns used by MATCHER as evidence of a match between rD and rT . E represents an entity
randomly selected from the tuples in ID(rD).
The first type of evidence we consider for
identifying true matches from C(rD) consists of
pattern-matching. Relation words that express rD
will often be found in complex grammatical con-
structions, and often they will be separated from
their entity arguments by long-distance dependen-
cies. However, over a large corpus, one would ex-
pect that in at least some cases, the relation word
will appear in a simple, relatively-unambiguous
grammatical construction that connects rT with
entities from rD. For instance, entities e from the
relationship automotive designer appear in
the pattern ?designed by e? more than 100 times
as often as the next most-common patterns, ?con-
sidered by e? and ?worked by e.?
MATCHER use searches over the Web to count
the number of instances where a candidate rT ap-
pears in simple patterns that involve entities from
rD. Greater counts for these patterns yield greater
evidence of a correct match between rD and rT .
Table 1 provides a list of patterns that we consider.
For each rD and each rT ? C(rD), MATCHER
randomly selects 10 entities from rD?s tuples to
include in its pattern queries. Two of the patterns
are targeted at past-tense verbs, and the other two
patterns at nominal relation words.
MATCHER computes statistics similar to point-
wise mutual information (PMI) (Turney, 2001) to
measure how related rD and rT are, for each pat-
tern p. Let c(p, rD, rT ) indicate the sum of all the
counts for a particular pattern p, database relation,
and textual relation:
fp(rT , rD) =
c(p, rD, rT )?
r?D
c(p, r?D, rT ) ?
?
r?T
c(p, rD, r?T )
For the sum over all r?D, we use all r?D in Freebase
for which rT was extracted as a candidate.
One downside of the pattern-matching evidence
is the sheer number of queries it requires. Freebase
currently has over 2,000 relations. For each rD,
we have up to 500 candidate rT , up to 4 patterns,
and up to 10 entities per pattern. To cover all of
Freebase, MATCHER needs 2, 000?500?4?10 =
40 million queries, or just over 1.25 years if it
issues 1 query per second (we covered approxi-
mately one-quarter of Freebase?s relations in our
experiments). Using more patterns and more en-
tities per pattern are desirable for accumulating
more evidence about candidate matches, but there
is a trade-off with the time required to issue the
necessary queries.
3.4 Comparing database relations with
extracted relations
Open Information Extraction (Open IE) systems
(Banko et al, 2007) can often provide a large set of
extracted tuples for a given rT , which MATCHER
can then use to make much more comprehensive
comparisons with the full tuple set for rD than the
pattern-matching technique allows.
MATCHER employs a form of PMI to compute
the degree of relatedness between rD and rT . In
its simplest form, MATCHER computes:
PMI(rT , rD) =
|ID(rD) ? IT (rT )|
|ID(rD)| ? |IT (rT )|
(1)
While this PMI statistic is already quite useful, we
have found that in practice there are many cases
where an exact match between tuples in ID(rD)
and tuples in IT (rT ) is too strict of a criterion.
MATCHER uses a variety of approximate matches
to compute variations of this statistic. Considered
as predictors for the true matches inM , these vari-
ations of the PMI statistic have a lower precision,
in that they are more likely to have high values
for incorrect matches. However, they also have a
higher recall: that is, they will have a high value
for correct candidates in C(rD) when the strict
version of PMI does not. Table 2 lists all the vari-
ations used by MATCHER.
426
Statistics for (rT , rD)
s?(rT , rD) =
?
tD?ID(rD)
?
tT?IT (rT )
?(tD, tT )
|ID(rD)|?|IT (rT )|
s??(rT , rD) = s?(rT ,rD)?
r?D
s?(r?D, rT )
s??(rT , rD) = |IT (rT )||ID(rD)|
Table 2: MATCHER statistics: for each ? func-
tion for comparing two tuples (given in Table 3),
MATCHER computes the statistics above to com-
pare rD and rT . The PMI statistic in Equation
1 corresponds to s? where ? =strict match over
? =full tuples.
?(t1, t2) for comparing tuples t1, t2
strict match:
{
1, if ?(t1) = ??(t2)
0, otherwise.
type match:
?
??
??
1, if ?kcat(?(t1)k)
= cat(??(t2)k)
0, otherwise.
Table 3: MATCHER?s ? functions for computing
whether two tuples are similar. cat maps an entity
to a category (or type) in the schema. MATCHER
has a different ? function for each possible com-
bination of ? and ?? functions, which are given in
Table 4.
MATCHER uses an API for the ReVerb Open
IE system1 (Fader et al, 2011) to collect I(rT ),
for each rT . The API for ReVerb allows for rela-
tional queries in which some subset of the entity
strings, entity categories, and relation string are
specified. The API returns all matching triples;
types must match exactly, but relation or argument
strings in the query will match any relation or ar-
gument that contains the query string as a sub-
string. MATCHER queries ReVerb with three dif-
ferent types of queries for each rT , specifying the
types for both arguments, or just the type of the
first argument, or just the second argument. Types
for arguments are taken from the types of argu-
ments for a potentially matching rD in Freebase.
To avoid overwhelming the ReVerb servers, for
our experiments we limited MATCHER to queries
1http://openie.cs.washington.edu/
?(t) for tuple t = (e1, . . . , en)
?iei (projection to one dimension)
(e1, . . . , en) (full tuple)
??(?)(e?(1), . . . , e?(n)) (permutation)
Table 4: MATCHER?s ? functions for projecting
or permuting a tuple. ? indicates a permutation of
the indices.
for the top 80 rT ? C(rD), when they are ranked
according to frequency during the candidate iden-
tification process.
3.5 Regression models for scoring candidates
Pattern statistics, the ReVerb statistics from Ta-
ble 2, and the count of rT during the candidate
identification step all provide evidence for correct
matches between rD and rT . MATCHER uses a re-
gression model to combine these various statistics
into a score for (rT , rD). The regression model
is a linear regression with least-squares parameter
estimation; we experimented with support vector
regression models with non-linear kernels, with
no significant improvements in accuracy. Section
5 explains the dataset we use to train this model.
Unlike a classifier, MATCHER does not output any
single matching M . However, downstream appli-
cations can easily convert MATCHER?s output into
a matchingM by, for instance, selecting the topK
candidate rT values for each rD, or by selecting all
(rT , rD) pairs with a score over a chosen thresh-
old. Our experiments analyze MATCHER?s suc-
cess by comparing its performance across a range
of different values for the number of rT matches
for each rD.
4 Extending a Semantic Parser Using a
Schema Alignment
An alignment between textual relations and
database relations has many possible uses: for ex-
ample, it might be used to allow queries over a
database to be answered using additional infor-
mation stored in an extracted relation store, or
it might be used to deduce clusters of synony-
mous relation words in English. Here, we de-
scribe an application in which we build a question-
answering system for Freebase by extending a
standard learning technique for semantic parsing
with schema alignment information.
As a starting point, we used the UBL system
427
developed by Kwiatkowski et al (2010) to learn
a semantic parser based on probabilistic Com-
binatory Categorial Grammar (PCCG). Source
code for UBL is freely available. Its authors
found that it achieves results competitive with the
state-of-the-art on a variety of standard semantic
parsing data sets, including Geo250 English (0.85
F1). Using a fixed CCG grammar and a procedure
based on unification in second-order logic, UBL
learns a lexicon ? from the training data which
includes entries like:
Example Lexical Entries
New York City ` NP : new york
neighborhoods in `
S\NP/NP : ?x?y.neighborhoods(x, y)
Example CCG Grammar Rules
X/Y : f Y : g ? X : f(g)
Y : g X\Y : f ? X : f(g)
Using ?, UBL selects a logical form z
for a sentence S by selecting the z with the
most likely parse derivations y: h(S) =
arg maxz
?
y p(y, z|x; ?,?). The probabilistic
model is a log-linear model with features for lex-
ical entries used in the parse, as well as indi-
cator features for relation-argument pairs in the
logical form, to capture selectional preferences.
Inference (parsing) and parameter estimation are
driven by standard dynamic programming algo-
rithms (Clark and Curran, 2007), while lexicon
induction is based on a novel search procedure
through the space of possible higher-order logic
unification operations that yield the desired logi-
cal form for a training sentence.
Our Freebase data covers 81 of the 86 core do-
mains in Freebase, and 635 of its over 2000 re-
lations, but we wish to develop a semantic parser
that can scale to all of Freebase. UBL gets us part
of the way there, by inducing a PCCG grammar, as
well as lexical entries for function words that must
be handled in all domains. It can also learn lexical
entries for relations rD that appear in the training
data. However, UBL has no way to learn lexical
entries for the many valid (rT , rD) pairs that do
not appear during training.
We use MATCHER?s learned alignment to ex-
tend the semantic parser that we get from UBL
by automatically adding in lexical entries for Free-
base relations. Essentially, for each (rT , rD) from
MATCHER?s output, we wish to construct a lexi-
cal entry that states that rT ?s semantics resembles
?x?y.rD(x, y). However, this simple process is
complicated by the fact that the semantic parser re-
quires two additional types of information for each
lexical entry: a syntactic category, and a weight.
Furthermore, for many cases the appropriate se-
mantics are significantly more complex than this
pattern.
To extend the learned semantic parser to a se-
mantic parser for all of Freebase, we introduce a
prediction task, which we call semantic lexicon ex-
tension: given a matching M together with scores
for each pair in M , predict the syntactic category
Syn, lambda-calculus semantics Sem, and weight
W for a full lexical entry for each (rT , rD) ? M .
One advantage of the reduction approach to learn-
ing a semantic parser is that we can automatically
construct training examples for this prediction task
from the other components in the reduction. We
use the output lexical entries learned by UBL as
(potentially noisy) examples of true lexical entries
for (rT , rD) pairs where rT matches the word in
one of UBL?s lexical entries, and rD forms part
of the semantics in the same lexical entry. For
(rT , rD) pairs in M where rD occurs in UBL?s
lexical entries, but not paired with rT , we create
dummy ?negative? lexical entries with very low
weights, one for each possible syntactic category
observed in all lexical entries. Note that in or-
der to train LEXTENDER, we need the output of
MATCHER for the relations in UBL?s training data,
as well as UBL?s output lexicon from the training
data.
Our system for this prediction task, which we
call LEXTENDER (for Lexicon eXtender), factors
into three components: P (Sem|rD, rT , score),
P (Syn|Sem, rD, rT , score), and
P (W |Syn, Sem, rD, rT , score). This factoriza-
tion is trivial in that it introduces no independence
assumptions, but it helps in designing models
for the task. We set the event space for random
variable Sem to be the set of all lambda calculus
expressions observed in UBL?s output lexicon,
modulo the names of specific Freebase relations.
For instance, if the lexicon includes two entries
whose semantics are ?x?y . film actor(x, y) and
?x?y . book author(x, y), the event space would
include the single expression in which relations
film actor and book author were replaced by
428
a new variable: ?p?x?y.p(x, y). The final
semantics for a lexical entry is then constructed
by substituting rD for p, or more formally, by a
function application Sem(rD). The event space
for Syn consists of all syntactic categories in
UBL?s output lexicon, and W ranges over R.
LEXTENDER?s model for Sem and Syn are
Na??ve Bayes classifiers (NBC), with features for
the part-of-speech for rT (taken from a POS tag-
ger), the suffix of rT , the number of arguments of
rD, and the argument types of rD. For Syn, we
add a feature for the predicted value of Sem. For
W , we use a linear regression model whose fea-
tures are the score from MATCHER, the probabili-
ties from the Syn and Sem NBC models, and the
average weight of all lexical entries in UBL with
matching syntax and semantics. Using the pre-
dictions from these models, LEXTENDER extends
UBL?s learned lexicon with all possible lexical en-
tries with their predicted weights, although typi-
cally only a few lexical entries have high enough
weight to make a difference during parsing. Prun-
ing entries with low weights could improve the
memory and time requirements for parsing, but
these were not an issue in our experiments, so we
did not investigate this further.
5 Experiments
We conducted experiments to test the ability of
MATCHER and LEXTENDER to produce a se-
mantic parser for Freebase. We first analyze
MATCHER on the task of finding matches between
Freebase relations and textual relations. We then
compare the performance of the semantic parser
learned by UBL with its extension provided by
LEXTENDER on a dataset of English questions
posed to Freebase.
5.1 Experimental Setup
Freebase (Bollacker et al, 2008) is a free,
online, user-contributed, relational database
(www.freebase.com) covering many different
domains of knowledge. The full schema and
contents are available for download. The ?Free-
base Commons? subset of Freebase, which is our
focus, consists of 86 domains, an average of 25
relations per domain (total of 2134 relations),
and 615,000 known instances per domain (53
million instances total). As a reference point,
the GeoQuery database ? which is a standard
benchmark database for semantic parsing ?
Examples
1. What are the neighborhoods in New
York City?
?x . neighborhoods(new york, x)
2. How many countries use the rupee?
count(x) . countries used(rupee, x)
3. How many Peabody Award winners are
there?
count(x) . ?y . award honor(y) ?
award winner(y, x) ?
award(y, peabody award)
Figure 2: Example questions with their logical
forms. The logical forms make use of Freebase
symbols as logical constants, as well as a few ad-
ditional symbols such as count and argmin, to
allow for aggregation queries.
contains a single domain (geography), 8 relations,
and 880 total instances.
Our dataset contains 917 questions (on aver-
age, 6.3 words per question) and a meaning repre-
sentation for each question written in a variant of
lambda calculus2. 81 domains are represented in
the data set, and the lambda calculus forms contain
635 distinct Freebase relations. The most com-
mon domains, film and business, each took
up no more than 6% of the overall dataset. Sev-
eral examples are listed in Fig. 2. The ques-
tions were provided by two native English speak-
ers. No restrictions were placed on the type of
questions they should produce, except that they
should produce questions for multiple domains.
By inspection, a large majority of the questions
appear to be answerable from Freebase, although
no instructions were given to restrict questions
to this sort. We also created a dataset of align-
ments from these annotated questions by creating
an alignment for each Freebase relation mentioned
in the logical form for a question, paired with a
manually-selected word from the question.
5.2 Alignment Tests
We measured the precision and recall of
MATCHER?s output against the manually la-
beled data. Let M be the set of (rT , rD) matches
produced by the system, and G the set of matches
in the gold-standard manual data. We define
2The data is available from the second author?s website.
429
0
0.1
0.2
0.3
0.4
0.5
0.6
0 0.2 0.4 0.6 0.8 1
Pre
cisi
on 
Recall  
Alignment Predictions  
Matcher
Extractions
Pattern
Frequency
Figure 3: MATCHER?s Pattern features and Extrac-
tions features complement one another, so that in
combination they outperform either subset on its
own, especially at the high-recall end of the curve.
precision and recall as:
P = |M ?G||M | , R =
|M ?G|
|G|
Figure 3 shows a Precision-Recall (PR) curve
for MATCHER and three baselines: a ?Frequency?
model that ranks candidate matches for rD by their
frequency during the candidate identification step;
a ?Pattern? model that uses MATCHER?s linear re-
gression model for ranking, but is restricted to
only the pattern-based features; and an ?Extrac-
tions? model that similarly restricts the ranking
model to ReVerb features. We have three folds in
our data; the alignments for relation rD in one fold
are predicted by models trained on the other two
folds. Once all of the alignments in all three folds
are scored, we generate points on the PR curve by
applying a threshold to the model?s ranking, and
treating all alignments above the threshold as the
set of predicted alignments.
All regression models for learning alignments
outperform the Frequency ranking by a wide mar-
gin. The Pattern model outperforms the Extrac-
tions model at the high-precision, low-recall end
of the curve. At the high-recall points, the Pat-
tern model drops quickly in precision. However,
the combination of the two kinds of features in
MATCHER yields improved precision at all levels
of recall.
5.3 Semantic Parsing Tests
While our alignment tests can tell us in relative
terms how well different models are performing,
it is difficult to assess these models in absolute
terms, since alignments are not typical applica-
tions that people care about in their own right. We
now compare our alignments on a semantic pars-
ing task for Freebase.
In a first semantic parsing experiment, we train
UBL, MATCHER, and LEXTENDER on a random
sample of 70% of the questions, and test them
on the remaining 30%. In a second test, we fo-
cus on the hard case where all questions from the
test set contain logical constants that have never
been seen before during training. We split the
data into 3 folds, making sure that no Freebase do-
main has symbols appearing in questions in more
than one fold. We then perform 3-fold cross-
validation for all of our supervised models. We
varied the number of matches that the alignment
model (MATCHER, Pattern, Extractions, or Fre-
quency) could make for each Freebase relation,
and measured semantic parsing performance as a
function of the number of matches.
Figure 4 shows the F1 scores for these se-
mantic parsers, judged by exact match between
the top-scoring logical form from the parser and
the manually-produced logical form. Exact-match
tests are overly-strict, in the sense that the sys-
tem may be judged incorrect even when the log-
ical form that is produced is logically equivalent
to the correct logical form. However, by inspec-
tion such cases appear to be very rare in our data,
and the exact-match criterion is often used in other
semantic parsing experimental settings.
The semantic parsers produced by
MATCHER+LEXTENDER and the other alignment
techniques significantly outperform the baseline
semantic parser learned by UBL, which achieves
an overall F1 of 0.21 on these questions in the
70/30 split of the data, and an F1 of 0 in the
cross-domain experiment. Purely-supervised
approaches to this data are severely limited, since
they have almost no chance of correctly parsing
questions that refer to logical symbols that never
appeared during training. However, MATCHER
and LEXTENDER combine with UBL to produce
an effective semantic parser. The best semantic
parser we tested, which was produced by UBL,
MATCHER, and LEXTENDER with 9 matches per
Freebase relation, had a precision of 0.67 and a
recall of 0.59 on the 70/30 split experiment.
The difference in alignment performance be-
tween MATCHER, Pattern, and Extractions carries
over to semantic parsing. MATCHER drops in F1
with more matches as additional matches tend to
be low-quality and low-probability, whereas Pat-
430
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0 5 1 0 1 5 2 0 2 5 3 0
F1 fo
r ex
act m
atch
 
 
of lo
gica
l form
s
 
Number of Matches per Freebase Relation  
Semantic Parsing (70/30 Split)  
Matcher
Pattern
Extractions
Frequency
Baseline
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0 5 1 0 1 5 2 0 2 5 3 0
F1 fo
r ex
act m
atch
 
 
of lo
gica
l form
s
 
Number of Matches per Freebase Relation  
Semantic Parsing (Cross -Domain)  
Matcher
Extractions
Pattern
Frequency
Figure 4: Semantic parsers produced by UBL+MATCHER+LEXTENDER outperform the purely-
supervised baseline semantic parser on a random 70/30 split of the data (left) by as much as
0.42 in F1. In the case of this split and in the case of a cross-domain experiment (right),
UBL+MATCHER+LEXTENDER outperforms UBL+Pattern+LEXTENDER by as much as 0.06 in F1.
tern and Extractions keep improving as more low-
probability alignments are added. Interestingly,
the Extractions model begins to overtake the Pat-
tern model in F1 at higher numbers of matches,
and all three models trend toward convergence in
F1 with increasing numbers of matches. Neverthe-
less, MATCHER clearly improves over both, and
reaches a higher F1 than either Pattern or Extrac-
tions using a small number of matches, which cor-
responds to a smaller lexicon and a leaner model.
To place these results in context, many different
semantic parsers for databases like GeoQuery and
ATIS (including parsers produced by UBL) have
achieved F1 scores of 0.85 and higher. However,
in all such tests, the test questions refer to logi-
cal constants that also appeared during training, al-
lowing supervised techniques for learning seman-
tic parsers to achieve strong accuracy. As we have
argued, Freebase is large enough that is difficult
to produce enough labeled training data to cover
all of its logical constants. An unsupervised se-
mantic parser for GeoQuery has achieved an F1
score of 0.66 (Goldwasser et al, 2011), impres-
sive in its own right and slightly better than our F1
score. However, this parser was given questions
which it knew a priori to contain words that re-
fer to the logical constants in the database. Our
MATCHER and LEXTENDER systems address a
different challenge: how to learn a semantic parser
for Freebase given the Web and a set of initial la-
beled questions.
6 Conclusion
Scaling semantic parsing to large databases re-
quires an engineering effort to handle large
datasets, but also novel algorithms to extend se-
mantic parsing models to testing examples that
look significantly different from labeled training
data. The MATCHER and LEXTENDER algo-
rithms represent an initial investigation into such
techniques, with early results indicating that se-
mantic parsers can handle Freebase questions on a
large variety of domains with an F1 of 0.63.
We hope that our techniques and datasets will
spur further research into this area. In particu-
lar, more research is needed to handle more com-
plex matches between database and textual rela-
tions, and to handle more complex natural lan-
guage queries. As mentioned in section 3.1, words
like ?actress? cannot be addressed by the cur-
rent methodology, since MATCHER assumes that
a word maps to a single Freebase relation, but
the closest Freebase equivalent to the meaning of
?actress? involves the two relations film actor
and gender. Another limitation is that our cur-
rent methodology focuses on finding matches for
nouns and verbs. Other important limitations of
the current methodology include:
? the assumption that function words have no
domain-specific meaning, which prepositions
in particular can violate;
? low accuracy when there are few relevant re-
sults among the set of extracted relations;
? and the restriction to a single database (Free-
base) for finding answers.
While significant challenges remain, the reduction
of large-scale semantic parsing to a combination
of schema matching and supervised learning of-
fers a new path toward building high-coverage se-
mantic parsers.
431
References
Yoav Artzi and Luke Zettlemoyer. 2011. Bootstrap-
ping Semantic Parsers from Conversations. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing (EMNLP).
M. Banko, M. J. Cafarella, S. Soderland, M. Broad-
head, and O. Etzioni. 2007. Open information ex-
traction from the web. In IJCAI.
Jacob Berlin and Amihai Motro. 2006. Database
schema matching using machine learning with fea-
ture selection. In Advanced Information Systems
Engineering. Springer.
Kurt Bollacker, Colin Evans, Praveen Paritosh, Tim
Sturge, and Jamie Taylor. 2008. Freebase: A col-
laboratively created graph database for structuring
human knowledge. In Proceedings of the Interna-
tional Conference on Management of Data (SIG-
MOD), pages 1247?1250.
Qingqing Cai and Alexander Yates. 2013. Semantic
Parsing Freebase: Towards Open-Domain Semantic
Parsing. In Second Joint Conference on Lexical and
Computational Semantics.
Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr
Settles, Estevam R. Hruschka Jr., and Tom M.
Mitchell. 2010. Toward an Architecture for Never-
Ending Language Learning. In Proceedings of the
Twenty-Fourth Conference on Artificial Intelligence
(AAAI 2010).
David L. Chen, Joohyun Kim, and Raymond J.
Mooney. 2010. Training a Multilingual
Sportscaster: Using Perceptual Context to Learn
Language. Journal of Artificial Intelligence Re-
search, 37:397?435.
Stephen Clark and James R. Curran. 2007. Wide-
coverage efficient statistical parsing with ccg and
log-linear models. Computational Linguistics,
33(4):493?552.
J. Clarke, D. Goldwasser, M. Chang, and D. Roth.
2010. Driving semantic parsing from the world?s re-
sponse. In Computational Natural Language Learn-
ing (CoNLL).
R. Dhamanka, Y. Lee, A. Doan, A. Halevy, and
P. Domingos. 2004. iMAP: Discovering Complex
Semantic Matches between Database Schemas. In
SIGMOD.
A. Doan, J. Madhavan, P. Domingos, and A. Halevy.
2004. Ontology Matching: A Machine Learning
Approach. In S. Staab and R. Studer, editors, Hand-
book on Ontologies in Information Systems, pages
397?416. Springer-Verlag.
M. Ehrig, P. Haase, N. Stojanovic, and M. Hefke.
2004. Similarity for ontologies-a comprehensive
framework. In Workshop Enterprise Modelling and
Ontology: Ingredients for Interoperability, PAKM.
Anthony Fader, Stephen Soderland, and Oren Etzioni.
2011. Identifying Relations for Open Information
Extraction. In Conference on Empirical Methods in
Natural Language Processing (EMNLP).
Fausto Giunchiglia, Pavel Shvaiko, and Mikalai
Yatskevich. 2005. Semantic schema matching.
On the Move to Meaningful Internet Systems 2005:
CoopIS, DOA, and ODBASE, pages 347?365.
D. Goldwasser, R. Reichart, J. Clarke, and D. Roth.
2011. Confidence driven unsupervised semantic
parsing. In Association for Computational Linguis-
tics (ACL).
Johannes Hoffart, Fabian M. Suchanek, Klaus
Berberich, and Gerhard Weikum. 2013. YAGO2:
A Spatially and Temporally Enhanced Knowl-
edge Base from Wikipedia. Artificial Intelligence,
194:28?61, January.
Jayant Krishnamurthy and Tom Mitchell. 2012.
Weakly Supervised Training of Semantic Parsers. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing (EMNLP).
Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing Probabilis-
tic CCG Grammars from Logical Form with Higher-
order Unification. In Proceedings of the Conference
on Empirical Methods in Natural Language Pro-
cessing (EMNLP).
P. Liang, M. I. Jordan, and D. Klein. 2009. Learning
semantic correspondences with less supervision. In
Association for Computational Linguistics and In-
ternational Joint Conference on Natural Language
Processing (ACL-IJCNLP).
P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Association for Computational Linguistics (ACL).
D. Lin and P. Pantel. 2001. DIRT ? Discovery of In-
ference Rules from Text. In KDD.
Henrik Nottelmann and Umberto Straccia. 2007. In-
formation retrieval and machine learning for proba-
bilistic schema matching. Information processing &
management, 43(3):552?576.
Hoifung Poon and Pedro Domingos. 2009. Unsu-
pervised semantic parsing. In Proceedings of the
2009 Conference on Empirical Methods in Natu-
ral Language Processing, EMNLP ?09, pages 1?10,
Stroudsburg, PA, USA. Association for Computa-
tional Linguistics.
E. Rahm and P.A. Bernstein. 2001. A survey of ap-
proaches to automatic schema matching. The VLDB
Journal, 10:334?350.
P. D. Turney. 2001. Mining the Web for Synonyms:
PMI-IR versus LSA on TOEFL. In Procs. of the
Twelfth European Conference on Machine Learning
(ECML), pages 491?502, Freiburg, Germany.
432
M. Wick, K. Rohanimanesh, A. McCallum, and A.H.
Doan. 2008a. A discriminative approach to ontol-
ogy mapping. In International Workshop on New
Trends in Information Integration (NTII) at VLDB
WS.
M.L. Wick, K. Rohanimanesh, K. Schultz, and A. Mc-
Callum. 2008b. A unified approach for schema
matching, coreference and canonicalization. In Pro-
ceeding of the 14th ACM SIGKDD international
conference on Knowledge discovery and data min-
ing.
Mohamed Yahya, Klaus Berberich, Shady Elbas-
suoni, Maya Ramanath, Volker Tresp, and Gerhard
Weikum. 2012. Natural Language Questions for the
Web of Data. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing
(EMNLP).
Alexander Yates and Oren Etzioni. 2009. Unsuper-
vised methods for determining object and relation
synonyms on the web. Journal of Artificial Intelli-
gence Research (JAIR), 34:255?296, March.
433
Second Joint Conference on Lexical and Computational Semantics (*SEM), Volume 1: Proceedings of the Main Conference
and the Shared Task, pages 328?338, Atlanta, Georgia, June 13-14, 2013. c?2013 Association for Computational Linguistics
Semantic Parsing Freebase: Towards Open-domain Semantic Parsing
Qingqing Cai
Temple University
Computer and Information Sciences
qingqing.cai@temple.edu
Alexander Yates
Temple University
Computer and Information Sciences
yates@temple.edu
Abstract
Existing semantic parsing research has
steadily improved accuracy on a few domains
and their corresponding databases. This paper
introduces FreeParser, a system that trains on
one domain and one set of predicate and con-
stant symbols, and then can parse sentences
for any new domain, including sentences that
refer to symbols never seen during training.
FreeParser uses a domain-independent archi-
tecture to automatically identify sentences
relevant to each new database symbol, which
it uses to supplement its manually-annotated
training data from the training domain. In
cross-domain experiments involving 23
domains, FreeParser can parse sentences for
which it has seen comparable unannotated
sentences with an F1 of 0.71.
1 Introduction
Semantic parsing is the task of converting a sentence
into a representation of its meaning, usually in a log-
ical form grounded in the symbols of some fixed
ontology or relational database (Zelle and Mooney,
1996; Zettlemoyer and Collins, 2005; Kate and
Mooney, 2006). A growing body of research on
semantic parsing has yielded consistent improve-
ments in parsing accuracy. Yet existing semantic
parsers have always been limited by the need for
significant amounts of manually-annotated training
data for each domain of discourse, or for each new
database. As a result, current semantic parsers have
been constrained to small domains, like answering
geography questions.
In an effort to break out of these narrowly-
constrained domains, we investigate semantic
parsers for Freebase, an online database of user-
contributed facts divided into 86 domains, includ-
ing everything from architecture to zoos. Freebase is
much larger than standard benchmark databases for
semantic parsing; for example, it contains 300 times
as many relations, and 75,000 times as many in-
stances, as the GeoQuery database. On average, the
benchmark GeoQuery dataset has 125 training sen-
tences per relation. An equivalent dataset for Free-
base would require labeling close to 40,000 training
sentences, an expensive undertaking.
The size and diversity of data in Freebase forces
us to consider a new task of open-domain seman-
tic parsing. We introduce FreeParser, which trains
on labeled examples from a select group of initial
domains. It also uses the information in Freebase
to automatically find unlabeled training sentences
from Wikipedia for every Freebase relation. Using
a self-supervised architecture, FreeParser automat-
ically labels these sentences, and then trains a se-
mantic parser for all of Freebase. The current re-
striction to Wikipedia has a downside: 44% of the
test questions in our dataset contained a word that
never appeared in our set of automatically-collected
sentences, suggesting that significant further gains
could be had by scaling to a larger corpus. However,
FreeParser is able to find correct parses for 70% of
the questions from new domains where it could find
relevant sentences in Wikipedia, at a precision of
72%.
The next section provides background on se-
mantic parsing for Freebase, and discusses related
work. Section 3 describes the main modules of the
FreeParser system. Section 4 analyzes the perfor-
mance of FreeParser on an open-domain semantic
parsing task. Section 5 concludes.
328
domain num. queries % of total
film 49 12
business 46 11
tv 34 8
location 32 8
award 32 8
people 30 7
medicine 25 6
organization 24 6
finance 21 5
book 21 5
et al 89 22
total 403 100
Table 1: Breakdown of our Freebase data set into do-
mains. Several questions used symbols from multiple
Freebase domains, in which cases human judges selected
the best domain they could for that question?s category.
2 Background and Previous Work
2.1 Freebase Dataset
Freebase is a free, online, user-contributed, rela-
tional database (www.freebase.com) covering many
different domains of knowledge. The full schema
and contents are available for download.
Freebase has a number of advantages for build-
ing an open-domain semantic parser. Most obvi-
ously, it provides a much tougher test for seman-
tic parsing than traditional benchmark databases like
GeoQuery. It also provides a testbed for semantic
parsing across domains. As a reference point, the
GeoQuery database contains a single domain (ge-
ography), 8 relations, and 698 total instances. The
?Freebase Commons? subset of Freebase, which is
our focus, consists of 86 domains, an average of 25
relations per domain (total of 2134 relations), and
615,000 known instances per domain (53 million in-
stances total). By dividing Freebase into different
sub-databases according to domain, we can readily
test the portability of our parser across domains, and
its ability to handle relations and symbols that never
occur in manually-labeled training data.
Our dataset contains 403 questions and a meaning
representation for each question, written in a variant
of lambda calculus1. We believe the dataset in it-
self is an important contribution to the field, as it
1The data is available from the second author?s webpage.
Examples
1. What are the neighborhoods in New
York City?
?x . neighborhoods(new york, x)
2. How many countries use the rupee?
count(x) . countries used(rupee, x)
3. How many Peabody Award winners are
there?
count(x) . ?y . award honor(y) ?
award winner(y, x) ?
award(y, peabody award)
Figure 1: Example questions with their logical forms.
provides a testbed for semantic parsing across mul-
tiple domains. Several examples are listed in Fig. 1,
and Table 1 provides a breakdown of the domains in
our data. The questions were provided by two na-
tive English speakers, one high school student and
one computer science undergraduate student. Each
contributor was introduced to the Freebase website,
and asked to come up with English questions that
they would like to have answered. No restrictions
were placed on the type of questions they should
produce, except that they should produce questions
for multiple domains. 23 domains are represented in
the data set. Inspection of the dataset indicates that
most questions have relatively simple and regular
syntax, compared with the more complex construc-
tions observed in datasets like GeoQuery. Collecting
more complex questions for open-domain tests is an
ongoing project, but the existing dataset is already
a significant challenge for current semantic parsing
learning algorithms.
2.2 Challenges for a Freebase Semantic Parser
To provide a benchmark for comparison, we applied
the PCCG-based semantic parser called UBL, de-
veloped by Kwiatkowski et al (2010). Source code
for UBL is freely available. Its authors found that it
achieves results competitive with the state-of-the-art
on a variety of standard semantic parsing data sets,
including Geo250 English (0.85 F1). Using a fixed
CCG grammar and a procedure based on unification
in second-order logic, UBL learns a lexicon ? from
the training data which includes entries like:
329
Example Lexical Entries
New York City ` NP : new york
neighborhoods in `
S\NP/NP : ?x?y.neighborhoods(x, y)
Example CCG Grammar Rules
X/Y : f Y : g ? X : f(g)
Y : g X\Y : f ? X : f(g)
Using ?, UBL selects a logical form z for a sen-
tence S by selecting the z with the most likely parse
derivations y: h(S) = arg maxz
?
y p(y, z|x; ?,?).
The probabilistic model is a log-linear model with
features for lexical entries used in the parse, as
well as indicator features for relation-argument pairs
in the logical form, to capture selectional prefer-
ences. Inference (parsing) and parameter estimation
are driven by standard dynamic programming algo-
rithms (Clark and Curran, 2007; Wilks et al, 1990),
using a context-free, combinatory categorial gram-
mar that includes rules for forward application and
composition.
In a standard experimental setup on our dataset,
UBL provides an F1 of 0.35. We took a random split
of 70% of the data for training, 30% for test. An
F1 of 0.35 is significantly worse than UBL?s perfor-
mance on GeoQuery data (F1 of 0.85) but within the
bounds of reason, given that our data has over 200
relation symbols that need to be learned using less
than 300 training sentences, compared with the 8 re-
lations and 250 sentences that make up the Geo250
English dataset.
However, UBL is not designed for open-domain
semantic parsing, and after training on the training
set above, it is not be able to handle questions for
any of the remaining 63 domains in Freebase. In
open-domain tests, it achieves an F1 of 0.0, and for
most sentences, it cannot produce a parse. As one
example, we created a test set from the business
and finance domains, and separated the remain-
ing domains for training. Every test example has a
predicate symbol that has never been observed be-
fore in training. The F1 of 0.0 on this dataset is not a
fault of UBL, but rather it shows the difficulty of the
task. Porting a system across domains often results
in substantial loss of accuracy for many natural lan-
guage processing tasks (Huang et al, 2011), but usu-
ally the drop in accuracy is no more than 10-20%.
Open-domain semantic parsing is an even starker
challenge; it involves not just new natural language
words in the new domains, but also new database
symbols, which existing technology cannot handle.
2.3 Previous Work
Krishnamurthy and Mitchell (2012) also create a se-
mantic parser for Freebase, covering 77 of Free-
base?s over 2000 relations. Like our work, their
technique uses distant supervision to drive training
over a collection of sentences gathered from the
Web, and they do not require any manually-labeled
training data. However, their technique does require
manual specification of rules that construct CCG
lexical entries from dependency parses. In compar-
ison, we fully automate the process of constructing
CCG lexical entries for the semantic parser by mak-
ing it a learning task. We test our results on a dataset
of over 400 questions covering over 200 Freebase re-
lations, a more extensive test than the 50 questions
used by Krishnamurthy and Mitchell.
Yahya et al (2012) report on a system for
translating natural language queries to SPARQL
queries over the Yago2 (Hoffart et al, 2013)
database. Yago2 consists of information extracted
from Wikipedia, WordNet, and other resources us-
ing manually-defined extraction patterns. The man-
ual extraction patterns pre-define a link between nat-
ural language terms and Yago2 relations. Our tech-
niques automate the process of identifying matches
between textual phrases and database relation sym-
bols, in order to scale up to databases with more
relations, like Freebase. A more minor difference
between Yahya et al?s work and ours is that their
system handles SPARQL queries, which do not han-
dle aggregation queries like argmax and count.
We rely on an existing semantic parsing technology
to learn the language that will translate into such
aggregation queries. On the other hand, their test
questions involve more conjunctions and complex
semantics than ours. Developing a dataset with more
complicated semantics in the queries is part of our
ongoing efforts.
Goldwasser et al?s self-supervised, grounded se-
mantic parser (2011) relies on co-training between
two different semantic parsing models, one being a
simple machine-translation model and the other a
more complex structured-prediction model. They
achieve an impressive F1 of 0.66 on the bench-
mark GeoQuery 250 (English) dataset, compared
with state-of-the-art supervised models that achieve
330
accuracies around 0.85. Unlike semantic parsers
for Freebase, Goldwasser et al?s work assumes that
a dataset of unlabeled geography questions already
exists, for use in unsupervised training. FreeParser
answers orthogonal questions: how can we auto-
matically acquire a dataset containing the right key-
words and phrases, given only the database itself,
and how can we ensure that the acquired sentences
are relevant to the relations in the database, with-
out manual supervision? Also, unlike Goldwasser
et al?s experiments, FreeParser is tested in a signif-
icantly more challenging setting, with far more do-
mains, relations, and entities to be learned.
Many supervised learning frameworks have been
applied, including inductive logic programming
(Zelle and Mooney, 1996; Thompson and Mooney,
1999; Thompson and Mooney, 2003), support vec-
tor machine-based kernel approaches (Kate et al,
2005; Kate and Mooney, 2006; Kate and Mooney,
2007), machine translation-style synchronous gram-
mars (Wong and Mooney, 2007), and context-
free grammar-based approaches like probabilistic
Combinatory Categorial Grammar (Zettlemoyer and
Collins, 2005; Zettlemoyer and Collins, 2007;
Zettlemoyer and Collins, 2009; Kwiatkowski et al,
2010; Kwiatkowski et al, 2011; Lu et al, 2008) and
discriminative reranking (Ge and Mooney, 2006; Ge
and Mooney, 2009). These approaches have yielded
steady improvements on standard test sets like Geo-
Query, but are difficult to apply to Freebase because
of their built-in assumption that relation symbols
will be observed during training.
There has been a recent push towards develop-
ing techniques which reduce the annotation cost or
the data complexity of the models. Models have
been developed which can handle some ambiguity
in terms of which logical form is the correct label
for each training sentence (Chen et al, 2010; Liang
et al, 2009). Another set of approaches has investi-
gated the case where no logical forms are provided,
but instead some form of feedback or response from
the world is used as evidence for what the correct
logical form must have been (Clarke et al, 2010;
Liang et al, 2011; Artzi and Zettlemoyer, 2011).
While such techniques are important, they can only
reduce the annotation cost per domain, and annota-
tion efforts would still be required for each new do-
main that contains new database symbols. The goal
of the Freebase semantic parser, in contrast, is to
program actor role 
Party Down Ryan Hansen Kyle Bradway 
structure owner 
CN Tower Canada Lands Co. 
particle sub-particle number 
Proton Up Quark 2 
TV domain 
cast member table 
Architecture domain 
ownership table 
Physics domain 
particle composition 
Figure 2: Example Freebase relations (tables) and in-
stances for three domains.
port to all domains automatically, without any new
manually-labeled data per domain.
3 FreeParser
We introduce FreeParser, an automated system for
converting natural language sentences into represen-
tations of their meaning, where the relation and con-
stant symbols for the meaning representations are
taken from Freebase. FreeParser?s modules are de-
scribed below.
Sentence Retrieval Engine: This module con-
structs keyword queries for sentences that are likely
to express the same relationships as the ones ob-
served in Freebase. It uses an index over a large
corpus, currently a snapshot of English Wikipedia,
to identify sentences that match the query. Each sen-
tence, along with the Freebase relation r and query
q that generated it, is then fed to the Auto-Labeler.
Auto-Labeler: The Auto-Labeler uses knowledge
of the relation and query for a sentence to automati-
cally generate a simple logical form for the sentence.
The automatically-labeled sentences are then sent to
the Assessor.
Assessor: Using a set of domain-independent fea-
tures, the Assessor filters out sentences that are un-
suitable for training the semantic parser. These in-
clude sentences that are too long or complex, and
sentences where the label from the Auto-Labeler ap-
pears to be incorrect. The sentences that pass this
filter are added to the training data for FreeParser?s
semantic parser.
Open-domain Regularizer: FreeParser relies on an
existing semantic parser, but with a novel regularizer
that helps it learn more appropriate lexical entries for
domain-independent function words.
3.1 Sentence Retrieval Engine
The Sentence Retrieval Engine is FreeParser?s open-
domain technique for retrieving sentences from a
331
Input: Freebase relation r, unlabeled corpus C
Output: Sent, a set of sentences relevant to r
1. Initialize Sent? ?
2. E ?M random instances from r,
each projected onto two random attributes
3. E? ? N pairs (e1, e2) ? E with smallest
relation-count(e1, e2)
4. For each (e1, e2) ? E?:
S2? {sentences in C containing e1 and e2}
S1? {sents containing e2, in docs with e1}
Sent? Sent ? S1 ? S2
5. Return Sent
Figure 3: The Sentence Retrieval Engine algorithm
corpus that are relevant to a particular relation in the
database.
Definition relevance: We say that a sentence s is
relevant to a relation r in Freebase if there exist
database symbols a1, . . . , ak such that r(a1, . . . , ak)
appears in Freebase, and r(a1, . . . , ak) forms part of
the meaning of s, if the meaning were written in a
logical form.
For example, for the cast member relation in the
Freebase sample shown in Figure 2, the sentence
Hansen also played Kyle Bradway on the
Starz show Party Down.
would be relevant, since the sentence expresses a
known instance of cast member.
Of course, the corpus given as input to the Sen-
tence Retrieval Engine contains only sentences, not
the logical forms required to determine relevance ac-
cording to our definition. FreeParser?s strategy is
to generate keyword queries that list several named
entities that belong to a particular relation. For in-
stance, one query that the Sentence Retrieval Engine
might generate for the cast member relation is
?Ryan Hansen Kyle Bradway,? and another might
be ?Kyle Bradway Party Down.?
Figure 3 shows the algorithm for the Sentence
Retrieval Engine. In our experiments, we create
M = 1000 candidate entity pairs, and we select
N = 50 for queries. We use the open-source Apache
Lucene software for constructing an index over the
Wikipedia corpus and retrieving relevant sentences.
We have found that selecting good queries is in
fact quite tricky, and our experiments in Section 4.4
indicate how badly things can go wrong if it is not
done carefully. Two important lessons stand out:
First, for reasonable recall, we limit queries to just
one or two names. Queries with two names (we call
these 2-entity queries) are very often highly relevant,
but there are not enough sentences in Wikipedia that
match such queries for all relations. We therefore
also include queries (which we refer to as 1-entity
queries) that first identify Wikipedia articles for one
name from a relation, such as articles that mention
?Ryan Hansen?, and then within this resulting docu-
ment set, we select sentences that match a second
name, such as ?Party Down?. The resulting sen-
tences therefore always contain one name from the
relation, and appear near (within the same document
as) a second name. These sentences are noisier than
sentences selected with two names, but there are far
more matches of such sentences within Wikipedia.
The second lesson for sentence retrieval is that we
need to select queries that are not ambiguous. For
instance, ?James Cameron Avatar? retrieves many
sentences for the relation directed by. Un-
fortunately, this same query also produces many
sentences for the relations written by and won
award for. The two entities are not enough to un-
ambiguously identify the relationship between them.
To combat this problem, FreeParser scores candidate
queries according to relation-count, the number of
relations in Freebase that hold between the names
in the query, and keeps the top-N least ambiguous
queries, breaking ties randomly.
3.2 Auto-Labeler
The Auto-Labeler automatically generates a log-
ical form label for every sentence in our data
set. It provides a form of ?distant supervision?
(Bunescu and Mooney, 2007). As an example, if
the sentence above were generated from the cast
member relation using the query ?Hansen Brad-
way?, and ?Hansen? and ?Bradway? are names
for the database symbols Ryan Hansen and
Kyle Bradway, then the Auto-Labeler produces
?pcast member(p,Ryan Hansen,Kyle Bradway) as a la-
bel for the sentence. The existentially quantified p
variable is necessary to supply enough arguments for
the cast member relation.
For the general case, let s be a sentence generated
from a relation r of arity n via queries involving the
entities e = (e1, . . . , em), and let a = (a1, . . . , am)
be the sequence of attribute indices of r such that
332
Input: auto-labeled sentences S for relation r
Output: S? ? S, a high-quality training dataset
1. For each (s, l) ? S:
C[s, l]? complexity-score(s, l)
2. Sort S in descending order according to C
3. T ? top 100 examples from S
4. CW ? critical-words(T )
5. result? ?
6. For each cw ? CW :
Scw ? top two (s, l) ? (S ? result)
such that s contains cw
result? result ? Scw
7. Return result
Figure 4: The Assessor algorithm
ei is a value for r?s attribute ai. The Auto-Labeler
produces the following logical form for s:
?v1, . . . vn s.t. r(v1, . . . , vn)?
va1 = e1 ? . . . ? vam = em
3.3 Assessor
Automatically retrieving training sentences from an
unlabeled corpus is a noisy process. In order to
improve its precision, FreeParser automatically as-
sesses whether each sentence from the Sentence Re-
trieval Engine is relevant and useful for training. Its
goal is to select, for each relation r, a set of sen-
tences that are all structurally simple; that include a
variety of ways of expressing r in English; and that
do not include any sentences about other relations
r?. The full Assessor algorithm is given in Figure 4.
The Assessor uses two sources of evidence. The
first is the complexity of the sentence. After ex-
perimenting with numerous features for measur-
ing complexity, we have found that a few types
of word counts are the most helpful. Specifically,
the most helpful features include: the number of
words between two named entities (for two-entity
queries), the number of words before the named
entity that was part of the query (for one-entity
queries), and the total number of non-named-entity,
non-stopword words in the sentence. Our imple-
mentation uses a list of 200 common stopwords. We
trained a maximum-entropy classifier over the com-
plexity features to predict the probability that a sen-
tence is simple enough for training. We manually
labeled a small sample of 50 sentences, which were
retrieved for relations not found in any of our test
sentences. Sentences that truly expressed the rela-
tions in the logical form and no other relation were
labeled as positive, and all others were labeled neg-
ative. The Assessor uses the probability from this
classifier to rank all sentences for a relation, and se-
lects the top 100 sentences for further processing.
Complexity statistics alone are not sufficient for
selecting good training sentences. For instance,
??Being Spiderman is a dream come true,? says An-
drew Garfield? is a short sentence mentioning two
entities that participate in the acted in relation.
However, none of the words in the sentence are par-
ticularly indicative of acted in, and if FreeParser
were to use this as a training sentence, it would most
likely learn a wrong lexical entry.
The Assessor additionally weeds out sentences
which do not include words strongly associated with
a database relation. Previous work has used statisti-
cal machine translation models like IBM Model 1
(Brown et al, 1993) as a method for initially de-
termining which words should be associated with
which database symbols. After experimenting with
this and other models, as implemented in GIZA++
(Och and Ney, 2003), we have found that a simpler
procedure is more effective for finding the words
which are most indicative of a database relation.
Taking the set T of top 100 sentences for r from the
complexity ranker, we preprocess the sentences by
discarding stopwords and applying stemming. We
then count all the remaining word types v ? V
appearing in T , and rank them by frequency. We
select the top K as word stems that are highly in-
dicative of relation r; we call these word stems the
critical words for r. For example, for the relation
date founded, this technique produces the crit-
ical words ?found,? ?establish,? and ?settl,? among
others. Sentences which do not contain some vari-
ant of one of these critical words are unlikely to be
good training examples. To obtain a set of diverse
but relevant sentences, the Assessor selects at most
two sentences for each of the K critical words, tak-
ing care not to select any sentence twice. In practice
we found that using more than 2 sentences per criti-
cal word has no effect on parsing accuracy, but slows
the parser training procedure significantly. We tuned
K on development data, and set it to K = 7.
333
Example lexical entries for ?is? learned by UBL
S|NP : ?x . religion(x)
S|NP |NP : ?x?y . person(x)?
appearance type(x, newscaster)
S|NP |NP : ?x?y . brand(x, y)?
company brand relationship(x)
Table 2: Overly-specific lexical entries for the function
word ?is,? as learned by a state-of-the-art PCCG se-
mantic parser on our Freebase data set. All entries
shown have significant positive weight in the learned lex-
icon.
3.4 Initializing the Lexicon for Learning a
Semantic Parser
Existing semantic parsing technology requires some
initial knowledge in order to learn a full parser. Typ-
ically, this knowledge includes lexical entries for
named entities and the database symbols to which
they correspond, a small number of additional en-
tries for important function words, and a procedure
for initializing the weights for learned lexical en-
tries. For instance, UBL uses GIZA++ (Och and
Ney, 2003) to initialize the weight of learned lexi-
cal entries.
FreeParser includes initial lexical entries for all
named entities in our dataset, as well as 29 hand-
crafted lexical entries for the words ?who,? ?what,?
?when,? and ?where.? These helped to combat
the problem of learning a semantic parser from
small numbers of questions and large numbers of
automatically-retrieved sentences that were almost
all declarative statements rather than questions. Fol-
lowing Kwiatkowski et al, these hand-crafted lexi-
cal entries are assigned a fixed positive initial weight
of 10. We found the following procedure more effec-
tive than GIZA++ for initializing the lexicon weights
for learned lexical entries in practice: for each crit-
ical word and relation pair (v, r) in the sentences
from the Assessor, we found a maximum likelihood
estimate of P (v|r), the probability of observing the
critical word v, given that a sentence expresses the
relation r. We then created initial learned lexical en-
tries that pair v and r, with a weight equal to P (v|r).
3.5 New Learning Component for Semantic
Parsing: An Open-Domain Regularizer
Training FreeParser?s semantic parsing component
on the automatically-labeled sentences, as the sys-
tem has been described thus far, results in disap-
pointing performance. This is in large part because
the UBL semantic parser learns highly domain-
specific meanings for function words. Table 2 shows
example lexical entries learned for the word ?is?.
These types of learned meanings are the rule, not
the exception, in the existing semantic parser. For
single-domain tests, they pose no particular diffi-
culties, even though intuitively they are bad repre-
sentations of the meaning of a function word. For
open-domain semantic parsing, however, it becomes
nearly impossible to parse sentences correctly on
a new domain, if the only meanings for function
words include relations from training domains.
To overcome this problem, we devised a novel
regularization technique to encourage the parser to
learn domain-independent meanings for function
words. Unlike most of FreeParser, this technique
is specific to the log-linear CCG semantic pars-
ing technique used by Kwiatkowski et al How-
ever, similar mechanisms could potentially be de-
vised for other semantic parsing frameworks. The
Kwiatkowski et al model includes a feature func-
tion fw,l for every lexical entry mapping a wordw to
a logical form l. Our novel regularizer R(?) over the
parameters ?, which we call an open-domain regu-
larizer, penalizes parameters for lexical entries map-
ping function words to any domain-specific lambda
calculus expression. Formally, let F be a set of func-
tion words, and P a set of domain-specific predi-
cates from Freebase:
R(?) =
?
w,l
{
?2w,l if w ? F ? ?p ? P.p ? l
0 otherwise.
In our implementation, we added all relations in
Freebase that are not part of its common domain to
P , and collected a set of 282 common English func-
tion words for F .
4 Experiments
We now test FreeParser?s ability to provide semantic
parses in domains where it has seen no manually-
labeled training data. We also empirically analyze
the design decisions for FreeParser.
4.1 Experimental Setup
All of our experiments are conducted on the Free-
base dataset described in Section 2.1. To create
334
Q: What is ?Big Daddy? rated?
Movie ratings are stored as special codes in Free-
base, and are rarely observed ?as is? in text.
Q: Who is the CEO of Apple?
Wikipedia regularly uses the full form ?Chief Ex-
ecutive Officer?; no retrieved sentence had ?CEO?
together with the executive?s name and company
name.
Q: When did Jack Albertson die?
Many sentences contain ?person died on date?, but
no retrieved sentence contained the morphological
variant ?(did) die.?
Table 3: Example infeasible questions, and why
FreeParser had difficulty finding sentences in Wikipedia
that contain the relevant keywords from the question.
manually-labeled training and test sets for domain
adaptation, we divide the dataset into three groups
of nearly-equal size by placing similar domains to-
gether in the same group. No domain has ques-
tions in more than one group. We then perform 3-
fold cross-validation across these three groups. We
run FreeParser?s Sentence Retrieval Engine, Auto-
Labeler, and Assessor for all relations that appear
in our dataset, and we include the automatically-
labeled data in the training data.
4.2 Testing the Sentence Retrieval Engine
179 of the 403 questions (44%) in our dataset in-
cluded critical words which could not be found us-
ing the Sentence Retrieval Engine?s queries over
Wikipedia. Table 3 lists example infeasible ques-
tions. One obvious improvement is to open the re-
trieval engine to sentences from the Web, for greater
recall; this is an important task for future work. For
now, this is FreeParser?s biggest source of errors.
However, note that without this component, the se-
mantic parser parses none of the test data correctly.
4.3 Open-domain semantic parsing tests
We now turn to an experiment that assesses the full
FreeParser system on open-domain semantic pars-
ing. For the current experiments, we concentrate
on the 224 questions (56% of the full dataset) for
which all of the words (except named entities) could
be found in at least one of the auto-labeled sentences
returned by the Sentence Retrieval Engine. We call
these 224 questions the feasible questions. For the
remaining infeasible questions, FreeParser almost
never produces a correct logical form.
Figure 5 shows FreeParser?s performance on fea-
sible questions in all test domains, as well as for each
of the seven most-common test domains. FreeParser
performs quite well, achieving an overall F1 of
0.71, which represents a huge improvement over the
F1 of 0.0 for the supervised UBL semantic parser
in a domain adaptation setting. An unsupervised
parser, which uses only the initial lexical entries
from FreeParser and the auto-labeled training data,
achieves an F1 of 0.43. Precision and recall differ-
ences between FreeParser and these two baselines
are statistically significant (p < 0.01) using Fisher?s
exact test. Including both feasible and infeasible
questions, FreeParser?s F1 is 0.37 because of the low
recall on infeasible questions, but as more unlabeled
text becomes available to FreeParser, it should have
fewer and fewer infeasible questions.
4.4 Testing Critical Design Components
We tested FreeParser with different choices for key
parts of the design, to measure their impact. Ta-
ble 4 presents precision, recall, and F1 scores for
four variations of FreeParser, where each variation
is missing a critical component of the design. In the
first variation, the Sentence Retrieval Engine only
issues two-entity queries; it is missing the ability to
issue the less-precise single-entity queries. In the
second variation, the Assessor uses only the critical
words to select sentences for training; it is missing
the ability to rank sentences based on their complex-
ity. In the third variation, the Assessor selects the
top 2K, or 14, sentences based on the complexity
ranking; it ignores the critical words test. Finally,
the last variation shows FreeParser?s performance
when UBL?s training procedure has not been mod-
ified with the open-domain regularizer.
Deleting any one of these critical design ele-
ments substantially degrades FreeParser?s perfor-
mance, but the 1-entity queries appear to be the most
critical design choice, followed by the critical words
test and open-domain regularizer. Removing the 1-
entity queries surprisingly hurts both precision and
recall. The 2-entity queries do tend to retrieve bet-
ter sentences on average than 1-entity queries, but
because they retrieve so few, the Assessor has more
difficulty selecting good critical words.
Error analysis showed that incorrect or missing
335
.72 .68 
.29 
.82 
.93 
.57 
.89 
.27 
.70 .68 
.27 
.82 .81 
.53 
.67 
.27 
.71 .68 
.28 
.82 
.87 
.55 
.76 
.27 
.00
.20
.40
.60
.80
1.00
all (224) film (31) tv (22) location (22) medicine(16) business (15) people (12) award (11)
Open-Domain Semantic Parsing on Feasible Questions 
precision recall f1
Figure 5: FreeParser achieves an overall F1 of 0.71, in a test where every correct logical form has some element
never seen in manually-labeled training data. Results across different domains vary, but FreeParser performs well
in a variety of domains. Numbers next to domain labels indicate the number of feasible test questions. Results for
?all? domains are the micro-average across our three cross-validation folds.
Model P R F1
?1-entity queries .29 .29 .29
?complexity ranking .59 .53 .56
?critical words test .47 .41 .44
?open-domain regul. .50 .45 .47
FreeParser .72 .70 .71
Table 4: FreeParser compared with variations that are
missing critical design components. All precision and
recall differences between the full system and its varia-
tions are statistically significant (p < 0.01) using a two-
tailed Fisher?s exact test.
lexical entries for critical words were responsible for
most (68%) of the 67 incorrect or missing parses for
feasible test questions. Many of the incorrect en-
tries mapped critical words like ?directed? to related
but incorrect predicates, like written by. Miss-
ing lexical entries were often because the Assessor
incorrectly weeded out good auto-labeled examples.
The remaining 32% of the errors were mostly due to
complex syntax in the questions, or vague questions
that require significant reasoning to come up with a
valid interpretation.
5 Conclusion and Future Work
Most work on semantic parsing focuses on improv-
ing parser accuracy on a small number of relations in
a single domain. FreeParser is an exploration of the
possibility of automated semantic parsing for arbi-
trary domains. Among the lessons from our experi-
ence in designing FreeParser, these stand out: First,
finding training sentences that cover all of the dif-
ferent ways a person may refer to a database ele-
ment is difficult, and requires carefully constructed
retrieval mechanisms for sufficient recall. Second,
simple measures of sentence complexity and cooc-
currence statistics are effective techniques for iden-
tifying good training sentences. And third, standard
semantic parsing algorithms require modification for
open-domain semantic parsing, to enforce that func-
tion words are not mapped to domain-specific logi-
cal forms. We report results that help in understand-
ing FreeParser?s current strengths and weaknesses,
and that also serve as a baseline for future open-
domain semantic parsers.
Significant work remains: ideally, a system would
be able to incorporate relational data from multi-
ple schemas, and could leverage much larger cor-
pora for learning alignments. Also, FreeParser cur-
rently maps English words only to individual Free-
base symbols; more sophisticated algorithms and
representations are necessary for learning how to
map to conjunctions, disjunctions, and more com-
plex combinations of Freebase symbols.
Acknowledgements
This material is based upon work supported by the
National Science Foundation under Grant No. IIS-
1218692. We wish to thank Sophia Kohlhaas and
Ragine Williams for providing data for the project.
336
References
Yoav Artzi and Luke Zettlemoyer. 2011. Bootstrapping
Semantic Parsers from Conversations. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing (EMNLP).
P. F. Brown, S. D. Pietra, V. J. D. Pietra, and R. L. Mercer.
1993. The mathematics of statistical machine transla-
tion: Parameter estimation. Computational Linguis-
tics, 19(2):263?311.
Razvan Bunescu and Raymond Mooney. 2007. Learning
to extract relations from the web using minimal super-
vision. In Proceedings of the 45th Annual Meeting of
the Association for Computational Linguistics (ACL-
07).
David L. Chen, Joohyun Kim, and Raymond J. Mooney.
2010. Training a Multilingual Sportscaster: Using
Perceptual Context to Learn Language. Journal of Ar-
tificial Intelligence Research, 37:397?435.
Stephen Clark and James R. Curran. 2007. Wide-
coverage efficient statistical parsing with ccg and log-
linear models. Computational Linguistics, 33(4):493?
552.
J. Clarke, D. Goldwasser, M. Chang, and D. Roth.
2010. Driving semantic parsing from the world?s re-
sponse. In Computational Natural Language Learn-
ing (CoNLL).
Ruifang Ge and Raymond J. Mooney. 2006. Discrimina-
tive Reranking for Semantic Parsing. In Proceedings
of the 21st International Conference on Computational
Linguistics and 44th Annual Meeting of the Associ-
ation for Computational Linguistics (COLING/ACL-
06).
Ruifang Ge and Raymond J. Mooney. 2009. Learning a
Compositional Semantic Parser using an Existing Syn-
tactic Parser. In Joint Conference of the 47th Annual
Meeting of the Association for Computational Linguis-
tics and the 4th International Joint Conference on Nat-
ural Language Processing of the Asian Federation of
Natural Language Processing (ACL-IJCNLP 2009).
D. Goldwasser, R. Reichart, J. Clarke, and D. Roth.
2011. Confidence driven unsupervised semantic pars-
ing. In Association for Computational Linguistics
(ACL).
Johannes Hoffart, Fabian M. Suchanek, Klaus Berberich,
and Gerhard Weikum. 2013. YAGO2: A Spa-
tially and Temporally Enhanced Knowledge Base from
Wikipedia. Artificial Intelligence, 194:28?61, Jan-
uary.
Fei Huang, Alexander Yates, Arun Ahuja, and Doug
Downey. 2011. Language Models as Representations
for Weakly Supervised NLP Tasks. In Conference on
Computational Natural Language Learning (CoNLL).
Rohit J. Kate and Raymond J. Mooney. 2006. Using
String-Kernels for Learning Semantic Parsers. In Pro-
ceedings of the 21st International Conference on Com-
putational Linguistics and the 44th annual meeting of
the ACL.
Rohit J. Kate and Raymond J. Mooney. 2007. Semi-
Supervised Learning for Semantic Parsing using Sup-
port Vector Machines. In Proceedings of the Human
Language Technology Conference of the North Ameri-
can Chapter of the Association for Computational Lin-
guistics, Short Papers (NAACL/HLT-2007).
Rohit J. Kate, Yuk Wah Wong, and Raymond J. Mooney.
2005. Learning to Transform Natural to Formal Lan-
guages. In Proceedings of the Twentieth National
Conference on Artificial Intelligence (AAAI-05).
Jayant Krishnamurthy and Tom Mitchell. 2012. Weakly
Supervised Training of Semantic Parsers. In Proceed-
ings of the Conference on Empirical Methods in Natu-
ral Language Processing (EMNLP).
Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing Probabilis-
tic CCG Grammars from Logical Form with Higher-
order Unification. In Proceedings of the Conference
on Empirical Methods in Natural Language Process-
ing (EMNLP).
Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwater,
and Mark Steedman. 2011. Lexical Generalization
in CCG Grammar Induction for Semantic Parsing. In
Proceedings of the Conference on Empirical Methods
in Natural Language Processing (EMNLP).
P. Liang, M. I. Jordan, and D. Klein. 2009. Learning
semantic correspondences with less supervision. In
Association for Computational Linguistics and Inter-
national Joint Conference on Natural Language Pro-
cessing (ACL-IJCNLP).
P. Liang, M. I. Jordan, and D. Klein. 2011. Learning
dependency-based compositional semantics. In Asso-
ciation for Computational Linguistics (ACL).
Wei Lu, Hwee Tou Ng, Wee Sun Lee, and Luke S. Zettle-
moyer. 2008. A Generative Model for Parsing Natural
Language to Meaning Representations. In Proceed-
ings of The Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP).
Franz Josef Och and Hermann Ney. 2003. A system-
atic comparison of various statistical alignment mod-
els. Computational Linguistics, 29(1):19?51.
C.A. Thompson and R.J. Mooney. 1999. Automatic con-
struction of semantic lexicons for learning natural lan-
guage interfaces. In Proc. 16th National Conference
on Artificial Intelligence (AAAI-99), pages 487?493.
Cynthia A. Thompson and Raymond J. Mooney. 2003.
Acquiring Word-Meaning Mappings for Natural Lan-
guage Interfaces. Journal of Artificial Intelligence Re-
search (JAIR), 18:1?44.
337
Y. Wilks, D. Fass, C. Guo, J. MacDonald, T. Plate, and
B. Slator. 1990. Providing Machine Tractable Dictio-
nary Tools. MIT Press.
Yuk Wah Wong and Raymond J. Mooney. 2007. Learn-
ing Synchronous Grammars for Semantic Parsing with
Lambda Calculus. In Proceedings of the 45th Annual
Meeting of the Association for Computational Linguis-
tics (ACL-2007).
Mohamed Yahya, Klaus Berberich, Shady Elbassuoni,
Maya Ramanath, Volker Tresp, and Gerhard Weikum.
2012. Natural Language Questions for the Web of
Data. In Proceedings of the Conference on Empirical
Methods in Natural Language Processing (EMNLP).
John M. Zelle and Raymond J. Mooney. 1996. Learn-
ing to Parse Database Queries using Inductive Logic
Programming. In AAAI/IAAI, pages 1050?1055.
Luke S. Zettlemoyer and Michael Collins. 2005. Learn-
ing to Map Sentences to Logical Form: Structured
Classification with Probabilistic Categorial Grammars.
In Proceedings of the Twenty First Conference on Un-
certainty in Artificial Intelligence (UAI).
Luke S. Zettlemoyer and Michael Collins. 2007. On-
line Learning of Relaxed CCG Grammars for Parsing
to Logical Form. In Proceedings of the Joint Confer-
ence on Empirical Methods in Natural Language Pro-
cessing and Computational Natural Language Learn-
ing (EMNLP-CoNLL).
Luke S. Zettlemoyer and Michael Collins. 2009. Learn-
ing Context-dependent Mappings from Sentences to
Logical Form. In Proceedings of the Joint Conference
of the Association for Computational Linguistics and
International Joint Conference on Natural Language
Processing (ACL-IJCNLP).
338
