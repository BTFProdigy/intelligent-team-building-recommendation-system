Proceedings of the 23rd International Conference on Computational Linguistics (Coling 2010), pages 465?473,
Beijing, August 2010
Normal-form parsing for Combinatory Categorial Grammars
with generalized composition and type-raising
Julia Hockenmaier Yonatan Bisk
University of Illinois at Urbana-Champaign
{juliahmr, bisk1}@illinois.edu
Abstract
We propose and implement a modifica-
tion of the Eisner (1996) normal form to
account for generalized composition of
bounded degree, and an extension to deal
with grammatical type-raising.
1 Introduction
Combinatory Categorial Grammar (Steedman,
2000) is a linguistically expressive grammar for-
malism that has been used for many NLP appli-
cations, including wide-coverage parsing (Clark
and Curran, 2007; Hockenmaier, 2003) and se-
mantic interpretation (Curran et al, 2007), se-
mantic role-labeling (Gildea and Hockenmaier,
2003; Boxwell et al, 2009), semantic parsing
(Zettlemoyer and Collins, 2005) and natural lan-
guage generation (Espinosa et al, 2008).
An essential feature of CCG is its flexible
constituent structure, licensed by type-raising
and composition rules which can create ?non-
standard? constituents such as ?John saw?, or
?Mary talked to?, required in constructions in-
volving non-local dependencies, such as wh-
extraction (Fig. 1) or right-node raising. Since
?John saw? can now also be a constituent in
?John saw Mary?, this leads to a combinato-
rial explosion of spurious ambiguities, i.e. mul-
tiple syntactic derivations of the same seman-
tic interpretation (Wittenburg, 1986). This can
create problems for applications based on CCG,
e.g. for the induction of stochastic CCGs from
text annotated with logical forms (Zettlemoyer
and Collins, 2007), where spreading probabil-
ity mass over equivalent derivations should be
avoided. A number of normal-form (NF) parsing
algorithms that aim to produce only one deriva-
tion per interpretation have been proposed (Wit-
tenburg, 1986; Niv, 1994; Pareschi and Steed-
man, 1987; Hepple and Morrill, 1989; Eis-
ner, 1996). Computationally, such algorithms
are very attractive since they do not require
costly semantic equivalence checks (Karttunen,
1989; Komagata, 2004) during parsing. Eis-
ner?s (1996) normal form is the most devel-
oped and well-known of these approaches, but
is only defined for a variant of CCG where
type-raising is a lexical operation and where the
degree of composition is unbounded. There-
fore, it and its equivalent reformulation by Hoyt
and Baldridge (2008) in a multimodal variant of
CCG are not safe (preserve all interpretations)
and complete (remove all spurious ambiguities)
for more commonly used variants of CCG. In
particular, this NF is not safe when the degree
of composition is bounded,1 and not complete
when type-raising is a grammatical operation.
This paper defines a NF for CCG with bounded
composition and grammatical type-raising.
2 Combinatory Categorial Grammar
In CCG, every constituent (?John saw?) has a
syntactic category (S/NP) and a semantic in-
terpretation (?x.saw(john?, x)).2 Constituents
combine according to a small set of language-
1Although Eisner (1996, section 5) also provides a safe
and complete parsing algorithm which can return non-NF
derivations when necessary to preseve an interpretation if
composition is bounded or the grammar is restricted in
other (arbitrary) ways.
2More complex representations than simple predicate-
argument structures are equally possible.
the man that John saw
NP (NP\NP)/(S/NP) NP (S\NP)/NP
>T
S/(S\NP)
>B1
S/NP
>B0
NP\NP
<B0NP
Figure 1: CCG derivations for wh-extraction
465
Application (>) X/Y : ?x.f(x) Y : a ? X : f(a)
(<) Y : a X\Y : ?x.f(x) ? X : f(a)
Composition (>B1) X/Y : ?x.f(x) Y/Z : ?y.g(y) ? X/Y : ?z.f(g(z))
(<B1) Y\Z : ?y.g(y) X\Y : ?x.f(x) ? X\Y : ?z.f(g(z))
(>B 1?) X/Y : ?x.f(x) Y\Z : ?y.g(y) ? X\Y : ?z.f(g(z))
(<B 1?) Y/Z : ?y.g(y) X\Y : ?x.f(x) ? X/Y : ?z.f(g(z))
(>Bn) X/Y : ?x.f(x) Y|Z1|...|Zn : ?zn..z1.g(z1...zn) ? X|Z1|...|Zn : ?zn...z1.f(g(z1...zn))
(<Bn) Y|Z1|...|Zn : ?zn..z1.g(z1...zn) X\Y : ?x.f(x) ? X|Z1|...|Zn : ?zn...z1.f(g(z1...zn))
Typeraising (>T ) For X ? Carg : X : a ? T/i(T\iX) : ?f.f(a)
(<T ) For X ? Carg : X : a ? T\i(T/iX) : ?f.f(a)
Figure 2: CCG?s combinatory rules.
independent combinatory rules (Fig. 2). The lex-
icon pairs words with categories and interpreta-
tions and is language-specific.
Syntax We distinguish atomic (S, NP, PP,
etc.) from complex categories ((S\NP)/NP,
N/N, etc.). A complex category of the form X/Y
(or X\Y) represents a function which returns a
result of type X when applied to an argument
of type Y, which, in the case of a forward slash
(/) has to follow the functor, and in the case of
a backslash (\) has to preceed it. X and Y can
themselves be complex again. We will use cat-
egories with vertical slashes when the direction
of the slash does not matter, and may omit un-
necessary parentheses (so X|Y|Z will represent
(X\Y)/Z, (X\Y)\Z, ...). We will also use the
shorthand X|Y1..n (or X|?) to refer to a category
with (possibly complex) result X and arguments
Y1...Yn (or an unspecified, possibly empty, list
of arguments ? = Y0...n, where |?| = n) that
can each appear with either type of slash.
Semantics If the category of a constituent is
atomic (NP; S), its interpretation will also be
atomic (kim?; sleeps?(kim?)), and if the category
is a functor of arity n (X|Y1..n), the interpretation
is a ?-expression ?yn..?y1?(y1...yn) of arity n.
The lexicon Each language defines a finite set
of lexical category types Clex (e.g. (S\NP)/NP
is in the English lexicon, but (S\NP)\NP is not)
with maximal arity NL. This defines a set of
lexical argument category types Carg , consist-
ing of all categories Y that are the argument
of some lexical category (X|Y)|? ? Clex (with
|?| ? 0). Since Clex is finite, Carg is strictly
smaller than Clex (and usually consists of basic
categories such as NP, S, S\NP).
Combinatory Rules In addition to function
application (>,<), CCG has three kinds of com-
binatory rules (Fig. 2): harmonic function com-
position (>B(1), <B(1)), crossing function com-
position (>B ?,<B ?) and type-raising (>T ,
<T ). All rules take one or two input categories
and yield one output category, and consist of a
syntactic and a corresponding semantic opera-
tion. Composition also has generalized variants
>Bn, <Bn up to a fixed degree NB .3 Compo-
sition of unbounded degree increases the genera-
tive capacity of CCG (Weir, 1988), and should be
disallowed. Application (>,<) can be seen as a
special case of composition (>B0,<B0). When
composing X|Y with Y|Z to X|Z, we call X|Y
the primary input and Y|Z the secondary in-
put. Harmonic composition allows associativ-
ity: the string A/B B/C C now has an alter-
native derivation where A/B and B/C compose
into A/C, whereas crossing composition enables
novel permutations, such as C A/B B\C.
Type-raising swaps the functor-argument rela-
tion. Although it is often assumed to take place
in the lexicon, we will distinguish lexical cate-
gories (e.g. for quantifiers) that have the syn-
tactic type of type-raised categories, but seman-
tics that could not be obtained by type-raising a
simple category from grammatically type-raised
categories. We follow the common definition
of CCG (Steedman, 2000) and allow only cat-
egories X ? Carg to be type-raised.4 Instantia-
3In X|Y1..n or X|?=X|Y1...|?|, we do not assume the
slash variable | ? {/, \} to be instantiated the same way for
all Yi. We will therefore only distinguish between forward
and backward generalized composition Bn>1.
4We stipulate that it may be further necessary to only
allow those argument categories to type-raise that are not
used to project unbounded dependencies, such as S/NP in
466
tions of the variable T should also be restricted
to categories of finite arity NT in oder to pre-
vent an increase in generative capacity (Hoff-
man, 1995; Komagata, 1997). We refer to the
arity of T as the degree of any particular instan-
tation of T . We follow Steedman (2000) and
assume NT = NB .
Coordination requires a ternary rule (?) which
can be binarized (?>, ?<) to simplify parsing:5
(?) X conj X ? X
(?>) X X[conj] ? X
(?<) conj X ? X[conj]
Uses of type-raising and composition In En-
glish, type-raising and composition are required
for wh-extraction and right node raising of argu-
ments as well as so-called argument cluster co-
ordination. In other languages, they are needed
for scrambling and cross-serial dependencies.
It is important to note that when type-raising is
required, it always occurs in tandem with com-
position. Since type-raising an argument Y to
X/(X\Y) and applying it to the functor X\Y is
semantically equivalent to applying X\Y directly
to Y, type-raising is never required when func-
tion application can be used instead. That is, in
all cases, a type-raised argument must be com-
posed with another constituent, usually the orig-
inal functor (head). Only in argument-cluster co-
ordination will the type-raised element be com-
posed with a non-head constituent. In the lat-
ter case, coordination will be required before
the argument cluster can be combined with the
head. Composition without type-raising may oc-
cur, e.g. for adjuncts, which have categories X|X,
but may modify a constituent with category X|?.
Restrictions on type-raising and composition
In order to prevent overgenerations of the form
?John speaks because Chinese, he enjoys Bei-
jing.?, we assume a variant of CCG in which
forward crossing composition >B 1? (e.g. of be-
cause:(S/S)/S) into the result of backward type-
raising <T (e.g. Chinese:S\(S/NP), and, simi-
larly, <Bx into the result of >T , are disallowed.
(NP\NP)/(S/NP) for English object relative pronouns.
5Here, X needs to be restricted to a finite set of cate-
gories (Weir, 1988). In multimodal CCG, conjunction have
categories of the form (X?\?X)/?X, i.e. must apply to their
argument
Punctuation and Type-changing rules CCG-
bank (Hockenmaier and Steedman, 2007) uses
special punctuation rules such as S . ? S or
, NP\NP ? NP\NP, and a small number of
(non-recursive) type-changing rules (with id-
iosyncratic semantics) such as N ? NP (for
determiner-less NPs) or S[pss]\NP ? NP\NP
(for complex adjuncts, here passive VPs being
used as NP postmodifiers):
Punctuation (>P) X:? [., ; ] ? X:?
(<P) [., ; ] X:? ? X:?
TypeChanging (TCR) X:? ? Y:?(?)
CCG parsing CCG can be parsed with a
bottom-up CKY-like algorithm (Shieber et al,
1995; Steedman, 2000), which differs from stan-
dard CKY in that it requires one (or two) unary
completion steps in each cell to deal with type-
raising (and type changing).6 Chart items are of
the form ?X, i, j?, where X is a category, and the
indices i and j represent the span of the item.
Interpretations need only to be constructed for
complete derivations when unpacking the chart.
3 The Eisner normal form
The Eisner normal form Eisner (1996)
presents a normal-form parsing algorithm for
CCG without grammatical type raising (where
the lexicon may still contain categories like
S/(S\NP), but there is no combinatory rule
that changes a complex (derived) NP to e.g.
S/(S\NP)). He proves that his algorithm finds
only one canonical derivation for each semantic
interpretation of an input string consisting of a
sequence of words and their lexical categories.
Since the presence of both pre- and postmodi-
fiers (as in ?intentionally knock twice?7) intro-
duces a genuine ambiguity, Eisner proves that
the only kind of spurious ambiguity that can
arise in his variant of CCG is due to associative
chains of composition such as A/B B/C C/D or
A/B B/C C\D, which can be derived as either
6Since composition allows the arity of derived (? non-
terminal) CCG categories to grow with the length of the
input string, worst-case complexity of this naive algorithm
is exponential. (Vijay-Shanker and Weir, 1993)?s O(n6)
algorithm has a more compact representation of categories.
7This can mean ?x.intentionally ?(twice ?(knock ?(x)))
or ?x.twice ?(intentionally ?(knock ?(x))).
467
Eisner NF Not Eisner NF
(A|B1..b)/C (C|D1..d)/E (E|F1..f)/G G|H1..h
>Bh
(E|F1..f)|H1..h
>Bf+h
((C|D1..d)|F1..f)|H1..h
>Bd+f+h
(((A|B1..b)|D1..d)|F1..f)|H1..h
(A|B1..b)/C (C|D1..d)/E (E|F1..f)/G G|H1..h
>Bd+1
((A|B1..b)|D1..d)/E
>Bf+1
(((A|B1..b)|D1..d)|F1..f)|G
>Bh
(((A|B1..b)|D1..d)|F1..f)|H1..h
Figure 3: Eisner NF and generalized composition Bn>1
Left branching Right branching
>B0(>Bm+1,...)?>Bm?0(...,>B0) A/B (B|D0..m)/C C m ? 0
>B1(>Bm?1,...)?>Bm?1(...,>B1) A/B (B|C1...m?1)/D D/E m ? 1
>Bn?1(>B1,...) ?>Bn(...,>Bm=n) A/B B/C C/D1..n m = n ? 1
? :>Bn>1(...,>Bm>n) A/(B|D1..k) B/C ((C|D1..k)|E1..n m > n > 1
>Bm(>Bk,...) ?>Bn>1(...,>B1<m<n) A/B (B|C1..k?1)/D D|E1..m n > m > 1
Figure 4: Associative composition chains: our NF disallows the grayed-out derivations.
>B (..., >B ) or >B (>B , ). This is eliminated
by the following constraint:
Eisner NF Constraint 1. The output X|? of
forward composition >Bn>0 cannot be the pri-
mary input to forward application or composi-
tion >Bm?0. The output of <Bn>0 cannot be
the primary input to <Bm?0.
This can be implemented by a ternary feature
HE ? {>Bn, <Bn, ?} and chart items of the
form ?X, HE, i, j? where HE =>Bn (or <Bn)
if X was produced by the corresponding compo-
sition rule (for any n > 0) and ? otherwise.
4 A new normal form for CCG
4.1 Generalized composition
Eisner NF and generalized composition Un-
boundedly long sequences of generalized com-
position are required e.g. for Dutch verb clus-
ters that give rise to cross-serial dependen-
cies (N1...NnV1...Vn with Ni the argument of
Vi). These can be obtained through standard
bounded-degree compositions, but the Eisner NF
produces a derivation that requires compositions
of unbounded degree (Fig. 3). Although this is
allowed in the variant of CCG Eisner considers,
compositions of unbounded degree are usually
disallowed because they increase the generative
capacity of CCG (Weir, 1988). We stipulate that
the NF of any derivation ? should not require
composition rules of higher degree than ? itself.
Note that the output of function application (B0)
always has lower arity than its functor; the output
of regular composition (B1) has the same arity as
its primary functor, but the output of generalized
composition (Bn>1) has an arity that is n ? 1
higher than that of the primary functor. Bn>1
therefore requires a different treatment.
Our reformulation of the Eisner NF As-
sociative composition chains for constituents
A B C can lead to spurious ambiguity if both a
left-branching >Bn(>Bm(A B) C) and a right-
branching >Bn?(A >Bm?(B C)) are possible and
lead to the same interpretation. Figure 4 il-
lustrates all possible cases consisting of three
constituents. In most cases, the right-branching
(Eisner NF) derivation is to be preferred. For
generalized composition >Bn>1, >Bm>1, left-
branching >Bn>1(>Bm>1, ...) is always al-
lowed, but right-branching >Bn(..., >Bm) is
only allowed if m ? n.
NF Constraint 1 (B0 and Bn?1). The output of
>Bn?1 (resp. <Bn?1) cannot be primary func-
tor for >Bn?1 (resp. <Bn?1).
NF Constraint 2 (B1 and Bn?1). The output of
>B1 (resp. <B1) cannot be primary functor for
>Bn?1 (resp. <Bn?1).
NF Constraint 3 (Bn>1 and Bm>1). The out-
put of >Bm (resp. <Bm) cannot be secondary
functor for >Bn>m (resp. <Bn>m).
4.2 Grammatical type-raising
Eisner NF and type-raising Figure 5 illus-
trates a spurious ambiguity arising through type-
468
which Sue ate happily
NP : (S\NP)/NP : S\S :
s? ?y.?x.ate?(x, y) ?z.happily?(z)
>T
S/(S\NP) :
?f.f(s?)
>B1
S/NP : ?y.ate?(s?, y)
<B1?
S/NP : ?y.happily?(ate?(s?, y))
which Sue ate happily
NP : (S\NP)/NP : S\S :
s? ?y.?x.ate?(x, y) ?z.happily?(z)
>T
S/(S\NP) :
?f.f(s?)
<B2?
(S\NP)/NP :
?y.?x.happily?(ate?(x, y))
>B1
S/NP : ?y.happily?(ate?(s?, y))
Figure 5: The Eisner NF allows spurious ambiguity arising due to type-raising
raising that the Eisner NF does not exclude.8
Here two derivations can be obtained because
the result of combining the adverb with the
subject-verb cluster is no longer the output of
a forward composition, and can therefore ap-
ply to the object. The derivations are semanti-
cally equivalent: although type-raising reverses
the syntactic functor-argument relation, a type-
raised argument applied to a predicate returns
the same interpretation as when the predicate
is applied directly to the original. But Eis-
ner treats S/(S\NP) as a category with se-
mantics ?x.?(x), in which case the derivations
yield indeed different scope relations. Eis-
ner?s analyis is correct for certain classes of
words which have lexical categories that ap-
pear like type-raised categories, but have a dif-
ferent interpretation from that of categories ob-
tained by type-raising. These are usually scope-
bearing elements, such as the universal quantifer
every ((S/(S\NP))/N : ?P?Q?xP(x) ? Q(x)),
and there may not be a single derivation which
captures all semantic interpretations. Lexical-
ized pseudo-type-raising therefore needs to be
distinguished from grammatical type-raising.
Our extension of the (modified) Eisner NF
In Fig. 5, Eisner NF licenses two derivations.
Both contain an instance of composition in
which the type-raised argument is the primary
component. In the analysis in which this is the
second derivation step, the canceled part of this
<B2 composition (boxed) contains a category
(\NP) that was part of the argument output of
the first >B1 composition (bold-faced):
8We have chosen a slighly unusual adverb category to
illustrate a general problem.
which Sue ate happily
S/ (S\NP) (S\NP)/NP S\S
<B2?
S\NP /NP
>B1
S/NP
Our NF will eliminate derivations of this type
and prefer the other, lower-degree derivation.
We stipulate that the spurious ambiguities that
arise through type-raising and composition can
be eliminated through the following rule:
NF Constraint 4 (T and Bn>0). The output of
>T cannot be primary input to >Bn>0 if the
secondary input is the output of <Bm>n. The
output of <T cannot be primary input in <Bn>0
if the secondary input is the output of >Bm>n.
We also stipulate that a type-raised T/(T\X)
cannot be used as a functor in application (since
T\X could always apply directly to X).
NF Constraint 5 (T and B0). The output of for-
ward (or backward) type-raising >T (resp. <T )
cannot be the functor in application > (resp. <).
Additional spurious ambiguities arise through
the interaction of type-raising and coordination:
Since any category can be coordinated, we can
either coordinate X and then type-raise the co-
ordinated X to T/(T\X), or we can first type-
raise each conjunct to T/(T\X) and then con-
join. Since nonsymmetric coordinations of an
argument-adjunct cluster and a single argument
(as in eats ((pizza for lunch) and pasta)) require
type-raising before coordination, we formulate
the following rule to eliminate interactions be-
tween type-raising and coordination:
NF Constraint 6 (T and ?). The result of coor-
dination ? cannot be type-raised.
469
NF Derivation A NF Derivation B
A B C
X/X : (X|?a)|?b : (X|?a)\(X|?a) :
?Pa(P ) ?xbxab(xaxb) ?Q?zac(Q(za))
<Bb
(X|?a)|?b : ?xbxac(b(xaxb))
>Ba+b?
(X|?a)|?b : ?xbxaa(c(b(xaxb)))
A B C
X/X : (X|?a)|?b : (X|?a)\(X|?a) :
?Pa(P ) ?xbxab(xaxb) ?Q?zac(Q(za))
>Ba+b?
(X|?a)|?b : ?xbxaa(b(xaxb))
<Bb?
(X|?a)|?b : ?xbxac(a(b(xaxb)))
Figure 6: Constituents with pre- and postmodifiers have two semantically distinct derivations
Punctuation and Type-changing rules Punc-
tuation results in spurious ambiguities, either
when a constituent X has both an initial and a fi-
nal punctuation mark (e.g. a comma), or when it
has an initial (final) punctuation mark and a final
(initial) modifier. The first case is easy to fix by
disallowing the output of , X ? X to be the in-
put of X ,? X. The latter could be eliminated by
disallowing the output X of right-recursive (left-
recursive) punctuation rule to be secondary input
to any left-recursive (right-recursive) application
or composition rule (e.g. X X\X ? X).9
Implementation Our normal-form constraints
can be implemented in a bottom-up parser with
items of the form ?X, C, i, j?, with
C ? {>, >B 1, >B 2, ..., >Bn; <, <B 1, <B 2, ..., <Bn;
>T , <T , >Pct,<Pct, ?>, ?<, TCR}
4.3 Is our normal form safe and complete?
Here we sketch the beginnings of a proof that
our algorithm allows one and only one syntac-
tic derivation per semantic interpretation for the
version of CCG we consider. We first examine
all cases of two adjacent constituents A, B which
must combine into a category C:
Functor X/Y and argument Y combine to X
The functor must apply to the argument. The ar-
gument could type-raise, but then cannot apply.
Functor X/Y|? and argument Y combine to
X|? The functor cannot apply to the argument.
The argument must type-raise to X\(X/Y), and
can then backward-compose into the functor.
Functor X/X and X\X can combine to X/X or
X\X This is not a spurious ambiguity, since the
output categories are different.
9If punctuation can be used both with X and Y, it also
interacts with type-changing rules X ? Y. Our current
implementation does not deal with this case.
Functor X|Y and Y|Z combine to X|Z Our re-
formulation of Eisner?s NF eliminates spurious
ambiguities that are due to such associative com-
position chains. This covers not only argument
clusters (which must compose), but also ambigu-
ous cases where one constituent (e.g. Y/Z with
? = ) is the argument of the first (X/Y), and ei-
ther takes the third (Z) as its own argument or is
modified by the third Y\Y (there are, of course,
other arrangements of such categories which are
not ambiguous, e.g. X/Y Z Y\Z.
We now focus our attention on the ternary
cases in which one of the constituents is a head
(predicate), and the other two are either its argu-
ments or modifiers. The counterexample to Eis-
ner?s normal-form algorithm shows that there is
at least one additional kind of spurious ambigu-
ity that arises when there are three adjacent con-
stituents A, B, C and both A and C can compose
into B. There are three cases: 1) A and C are
both modifiers of B, 2) one of A or C is a mod-
ifier of B, the other is an argument of B, and 3)
A and C are both arguments of B. Only 1) is a
real ambiguity, but the other cases are instances
of spurious ambiguity which our NF eliminates.
Argument Y, head (X\Y)/Z and argument Z
combine to X In the NF derivation, the head
applies first to the Z, than to Y. All other deriva-
tions are blocked, either because type-raised cat-
egories cannot apply, or because the output of
composition cannot apply.
Modifier X/X, head (X|?)|? and modifier
(X|?)\(X|?) combine to (X|?)|? (Fig. 4.2).
This is the ?intentionally knock twice? example.
The derivations have different semantics.
Argument Y, head ((X|?)\Y)|?, and modifier
X\X combine to (X|?)|? (Fig. 7). If there is
an ambiguity, B must have a category of the form
470
Normal form Not normal form
A B C
Y ((X|?a)\Y)|?b : X\X
a ?xbxixab(xaxixb) ?Q?zac(Q(za))
>T
(X|?a)/((X|?a)\Y) :
?P?yaP (aya)
>Bb?
(X|?a)|?b : ?xbxab(xaaxb)
<Ba+b?
(X|?a)|?b : ?xbxac(b(xaaxb))
A B C
Y ((X|?a)\Y)|?b : X\X
a ?xbxixab(xaxixb) ?Q?zac(Q(za))
>T <Ba+b+1?
(X|?a)/((X|?a)\Y) : ((X|?a)\Y)|?b :
?P?yaP (aya) ?xbxixac(b(xaxixb))
>Bb?
(X|?a)|?b : ?xbxac(b(xaaxb))
Figure 7: Argument Y, head ((X|?a)\Y)|?b, and modifier X\X combine to (X|?a)|?b
Normal form Not normal form
A B C
Y (((X\Y)|?a)/Z)|?b Z
a ?xbxjxaxib(xixaxjxb) c
>T <T
X/(X\Y) ((X\Y)|?a)\(((X\Y)|?a)/Z)
?P?yaP (aya) ?Q?zazizaQ(czaziza)
<Bb?
((X\Y)|?a)|?b : ?xbxaxib(xixacxb)
>Ba+b?
(X|?a)|?b : ?xbxab(axacxb)
A B C
Y (((X\Y)|?a)/Z)|?b : Z
a ?xbxjxaxib(xixaxjxb) c
>T <T
X/(X\Y) (X|?a)\((X|?a)/Z)
?P?yaP (aya) ?Q?zaQ(cza)
>Ba+b+1?
((X|?a)/Z)|?b : ?xbxjxab(axaxjxb)
<Bb?
(X|?a)|?b : ?xbxab(axacxb)
Figure 8: Argument Y, head (((X\Y)|?)/Z)|? and argument Z combine to (X|?)|?
((X|?)\Yi)|? (with X possibly complex and ?, ?
possibly empty), and C must have a category of
the form X\X. We obtain the NF derivation by
first combining head and argument, followed by
the modifier. The other derivation violates the
NF constraints.
Argument Y, head (((X\Y)|?)/Z)|? and ar-
gument Z combine to (X|?)|? (Fig. 8) The
derivation in which Z composes first is in NF.
The derivation in which the Y combines first
with the head is blocked.
Arguments YA, YB, head (((X\Y1)|?)\Y2)|?
combine to (X|?)|? There are two readings:
standard (YA:=Y1, YB:=Y2), and scrambled
(YA:=Y2, YB:=Y1). If ? and ? are empty, func-
tion application is sufficient for the standard
reading, and our NF constraint 1 excludes the
?argument cluster? derivation in which both YA
and YB type-raise, compose and then apply to the
head. Otherwise, at least one of the arguments
has to type-raise and compose into the head. If
both ? and ? are non-empty, each interpretation
has only one derivation in which the type-raised
YA composes into the output of the composition
of the type-raised YB with the head. Since the
degree of the second composition is lower than
the first, this is allowed by our NF constraint 2.
Argument YA and heads (((X\Y1)|?)/Z and
((Z|?)\Y2)|? combine to (((X|?)|?)\Y2)|? or
to (((X|\Y1?)|?)|? There are two readings:
standard (YA:=Y1) or scrambled (YA:=Y2). De-
pending on the maximal degree n of Bn allowed
by the grammar, the standard reading one can ei-
ther be obtained by type-raising YA and compos-
ing into the first head (allowed by our NF) or by
first composing the two heads and then compos-
ing the type-raised YA into the cluster (allowed
by Eisner, but not by us). The second reading
requires the heads to compose and then YA to
apply or compose (depending on the arity of ?),
which is allowed by our NF constraint 2 because
the degree of this second composition is lower
than that of the first.
Our NF and the bound NT on type-raising
If X\X in Fig. 7 is replaced with a (non-type-
raised) category Z\X (for Z 
= X), the non-NF
derivation requires T|Z|+a, whereas the NF-
derivation requires T|X|+a. If we stipulate a fi-
nite bound NT on the degree of type-raising,
and if |X| > |Z| and |X| + a > NT , our
NF cannot be derived anymore. If such Z\X
(with X ? Carg ) can be derived from the lexi-
con, our NF requires therefore a potentially un-
bounded degree of type-raising. The T-degree
471
Sentence length l=15...30
15 20 25 30
No NF (total #derivs) 4.13E6 5.66E8 3.06E11 1.59E14
Eisner B 18.92% 9.05% 3.63% 2.14%
Our B 18.38% 8.97% 3.60% 2.02%
Our B , T 2.92% 1.22% 0.37% 0.10%
Our full NF 2.60% 0.93% 0.33% 0.09%
(a) Median % of allowed derivations
Sentence length l= 30
Min Mean Median Max
No NF 5.99E9 8.19E15 1.59E14 2.61E17
Eisner B 1.60% 2.68% 2.14% 2.76%
Our B 1.57% 2.49% 2.02% 2.69%
Our B ,T 0.64% 0.07% 0.10% 0.05%
Our full NF 0.53% 0.06% 0.09% 0.05%
(b) Statistics on the % of allowed derivations
Figure 9: Experimental results: the effect of different normal forms on the number of derivations
of the non-NF derivation in Fig. 8 is also one less
than that of the NF derivation, but its B-degree is
increased by one, so for NT = NB either both
derivations are possible or neither.
What remains to be proven is that we have
considered all cases of spurious ambiguity in-
volving three constituents, and that all cases of
spurious ambiguity that arise for more than three
constituents reduce to these cases.
5 The effects of normal form parsing
We now illustrate the impact of the different nor-
mal form variants on a small, restricted, gram-
mar. We define a set of atomic categories, a set of
lexical categories (up to a fixed arity NLex), and
compile out all possible rule instantiations (in-
cluding compositions up to a fixed degree N|B)
that generate categories up to a fixed arity Ncat10
The effect of different normal forms This
experiment is intended to examine how nor-
mal form parsing might reduce spurious ambi-
guity for actual grammars, e.g. for unsuper-
vised estimation of stochastic CCGs. We cre-
ated a small English grammar with atomic cat-
egories S,NP,N, conj, ., , ; and 47 lexical cate-
gories using NLex = 3, NB = 3, NCat = 15.
There are two type-changing rules (N ? NP
and S/NP ? NP\NP ). We accept deriva-
tions of S, NP and S\NP. The T|X in T has
to be a lexical category. Our lexical categories
are divided into disjoint sets of adjuncts of the
form X|X and (X|X)|Y, head (both atomic and
complex), and punctuation and conjunction cat-
egories. The comma can act as a conjunction or
to set off modifiers (requiring punctuation rules
10The restriction of categories to a fixed arity
means that we could generate cross-serial dependencies
N1...NnV1...Vn only up to n = Acat .
of the form X|X , ? X|X and , X|X ? X|X).
We furthermore define coarse-grained parts of
speech (noun, verb, function word, conj, other)
and decide for each part of speech which lexical
categories it can take. We compare different NF
settings for sentences of lengths 15?30 from Eu-
roparl (Koehn, 2005). At each length, we com-
pare 100 sentences that our grammar can parse.
All NFs can parse all sentences the full grammar
can parse. Results (Fig. 9(a)) show that our NF
reduces the number of derivations significantly
over Eisner?s NF, even though our (full) gram-
mar only allows a restricted set of type-raising
rules. Fig. 9(b) illustrates the combinatorial ex-
plosion of spurious derivations as the sentence
length increases.
6 Conclusions
We have proposed a modification and extension
of Eisner (1996)?s normal form that is more ap-
propriate for commonly used variants of CCG
with grammatical type-raising and generalized
composition of bounded degree, as well as some
non-combinatory extensions to CCG. Our exper-
iments indicate that incorporating normal form
constraints to deal with grammatical type-raising
drastically reduces the number of derivations.
We have sketched the outline of a proof that our
normal form is safe and complete for the variant
of CCG we consider, althoug we have seen that
under certain circumstances, type-raising of un-
bounded degree may be required. Future work
will investigate this issue further, and will also
aim to turn our informal arguments about the ad-
equacy of our approach into a full proof, and pro-
vide more experiments on a wider range of gram-
mars and languages.
472
References
Boxwell, Stephen, Dennis Mehay, and Chris Brew.
2009. Brutus: A semantic role labeling system in-
corporating CCG, CFG, and dependency features.
In Proceedings of the 47th ACL/4th IJCNLP, pages
37?45.
Clark, Stephen and James R. Curran. 2007. Wide-
coverage efficient statistical parsing with CCG
and log-linear models. Computational Linguistics,
33(4):493?552.
Curran, James, Stephen Clark, and Johan Bos.
2007. Linguistically motivated large-scale NLP
with C&C and boxer. In Proceedings of the 45th
ACL Companion Volume (Demo and Poster Ses-
sions), pages 33?36, Prague, Czech Republic.
Eisner, Jason. 1996. Efficient normal-form pars-
ing for Combinatory Categorial Grammar. In Pro-
ceedings of the 34th ACL, pages 79?86, Santa
Cruz, CA.
Espinosa, Dominic, Michael White, and Dennis
Mehay. 2008. Hypertagging: Supertagging for
surface realization with CCG. In Proceedings of
ACL-08: HLT, pages 183?191, Columbus, Ohio.
Gildea, Daniel and Julia Hockenmaier. 2003. Iden-
tifying semantic roles using Combinatory Catego-
rial Grammar. In Proceedings of EMNLP, Sap-
poro, Japan.
Hepple, Mark and Glyn Morrill. 1989. Parsing and
derivational equivalence. In Proceedings of the
Fourth EACL, pages 10?18, Manchester, UK.
Hockenmaier, Julia and Mark Steedman. 2007.
CCGbank: A corpus of CCG derivations and de-
pendency structures extracted from the penn tree-
bank. Computational Linguistics, 33(3):355?396.
Hockenmaier, Julia. 2003. Data and models for
statistical parsing with Combinatory Categorial
Grammar. Ph.D. thesis, School of Informatics,
University of Edinburgh.
Hoffman, Beryl. 1995. Computational Analysis of
the Syntax and Interpretation of ?Free? Word-order
in Turkish. Ph.D. thesis, University of Pennsylva-
nia. IRCS Report 95-17.
Hoyt, Frederick and Jason Baldridge. 2008. A log-
ical basis for the D combinator and normal form
in CCG. In Proceedings of ACL-08: HLT, pages
326?334, Columbus, Ohio.
Karttunen, Lauri. 1989. Radical lexicalism. In
Baltin, M.R. and A.S. Kroch, editors, Alternative
Conceptions of Phrase Structure. Chicago Univer-
sity Press, Chicago.
Koehn, Philipp. 2005. Europarl: A parallel cor-
pus for statistical machine translation. In 10th MT
Summit, pages 79?86, Phuket, Thailand.
Komagata, Nobo. 1997. Generative power of
CCGs with generalized type-raised categories. In
ACL35/EACL8 (Student Session), pages 513?515.
Komagata, Nobo. 2004. A solution to the spurious
ambiguity problem for practical combinatory cate-
gorial grammar parsers. Computer Speech & Lan-
guage, 18(1):91 ? 103.
Niv, Michael. 1994. A psycholinguistically moti-
vated parser for CCG. In Proceedings of The 32nd
ACL, Las Cruces, NM, pages 125?132.
Pareschi, Remo and Mark Steedman. 1987. A lazy
way to chart parse with categorial grammars. In
Proceedings of the 25th ACL, pages 81?88, Stan-
ford, CA.
Shieber, Stuart M., Yves Schabes, and Fernando
C. N. Pereira. 1995. Principles and implemen-
tation of deductive parsing. Journal of Logic Pro-
gramming, 24(1?2):3?36, July?August.
Steedman, Mark. 2000. The Syntactic Process. MIT
Press, Cambridge, MA.
Vijay-Shanker, K and David J Weir. 1993. Parsing
some constrained grammar formalisms. Compu-
tational Linguistics, 19(4):591?636.
Weir, David. 1988. Characterising Mildly Context-
sensitive Grammar Formalisms. Ph.D. thesis, Uni-
versity of Pennsylvania. Tech. Report CIS-88-74.
Wittenburg, Kent B. 1986. Natural Language Pars-
ing with Combinatory Categorial Grammar in a
Graph-Unification Based Formalism. Ph.D. the-
sis, University of Texas at Austin.
Zettlemoyer, Luke S. and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In Proceedings of the 21st UAI, pages
658?666, Edinburgh, UK.
Zettlemoyer, Luke and Michael Collins. 2007. On-
line learning of relaxed CCG grammars for pars-
ing to logical form. In Proceedings of EMNLP-
CoNLL, pages 678?687, Prague, Czech Republic.
Acknowledgements
We would like to thank Mark Steedman for help-
ful discussions, and Jason Eisner for his very
generous feedback which helped to greatly im-
prove this paper. All remaining errors and omis-
sions are our own responsibility. J.H is supported
by NSF grant IIS 08- 03603 INT2-Medium.
473
Transactions of the Association for Computational Linguistics, 1 (2013) 75?88. Action Editor: Sharon Goldwater.
Submitted 11/2012; Revised 1/2013; Published 3/2013. c?2013 Association for Computational Linguistics.
An HDP Model for Inducing Combinatory Categorial Grammars
Yonatan Bisk and Julia Hockenmaier
Department of Computer Science
The University of Illinois at Urbana-Champaign
201 N Goodwin Ave Urbana, IL 61801
{bisk1,juliahmr}@illinois.edu
Abstract
We introduce a novel nonparametric Bayesian
model for the induction of Combinatory Cat-
egorial Grammars from POS-tagged text. It
achieves state of the art performance on a
number of languages, and induces linguisti-
cally plausible lexicons.
1 Introduction
What grammatical representation is appropriate for
unsupervised grammar induction? Initial attempts
with context-free grammars (CFGs) were not very
successful (Carroll and Charniak, 1992; Charniak,
1993). One reason may be that CFGs require the
specification of a finite inventory of nonterminal cat-
egories and rewrite rules, but unless one adopts lin-
guistic principles such as X-bar theory (Jackendoff,
1977), these nonterminals are essentially arbitrary
labels that can be combined in arbitrary ways. While
further CFG-based approaches have been proposed
(Clark, 2001; Kurihara and Sato, 2004), most re-
cent work has followed Klein and Manning (2004)
in developing models for the induction of projec-
tive dependency grammars. It has been shown that
more sophisticated probability models (Headden III
et al, 2009; Gillenwater et al, 2011; Cohen and
Smith, 2010) and learning regimes (Spitkovsky et
al., 2010), as well as the incorporation of prior lin-
guistic knowledge (Cohen and Smith, 2009; Berg-
Kirkpatrick and Klein, 2010; Naseem et al, 2010)
can lead to significant improvement over Klein and
Manning?s baseline model. The use of dependency
grammars circumvents the question of how to obtain
an appropriate inventory of categories, since depen-
dency parses are simply defined by unlabeled edges
between the lexical items in the sentence. But de-
pendency grammars make it also difficult to cap-
ture non-local structures, and Blunsom and Cohn
(2010) show that it may be advantageous to refor-
mulate the underlying dependency grammar in terms
of a tree-substitution grammar (TSG) which pairs
words with treelets that specify the number of left
and right dependents they have. In this paper, we
explore yet another option: instead of dependency
grammars, we use Combinatory Categorial Gram-
mar (CCG, Steedman (1996; 2000)), a linguistically
expressive formalism that pairs lexical items with
rich categories that capture all language-specific in-
formation. This may seem a puzzling choice, since
CCG requires a significantly larger inventory of cat-
egories than is commonly assumed for CFGs. How-
ever, unlike CFG nonterminals, CCG categories are
not arbitrary symbols: they encode, and are deter-
mined by, the basic word order of the language and
the number of arguments each word takes. CCG is
very similar to TSG in that it also pairs lexical items
with rich items that capture all language-specific in-
formation. Like TSG and projective dependency
grammars, we restrict ourselves to a weakly context-
free fragment of CCG. But while TSG does not dis-
tinguish between argument and modifier dependen-
cies, CCG makes an explicit distinction between the
two. And while the elementary trees of Blunsom
and Cohn (2010)?s TSG and their internal nodel la-
bels have no obvious linguistic interpretation, the
syntactic behavior of any CCG constituent can be
directly inferred from its category. To see whether
75
the algorithm has identified the basic syntactic prop-
erties of the language, it is hence sufficient to in-
spect the induced lexicon. Conversely, Boonkwan
and Steedman (2011) show that knowledge of these
basic syntactic properties makes it very easy to cre-
ate a language-specific lexicon for accurate unsu-
pervised CCG parsing. We have recently proposed
an algorithm for inducing CCGs (Bisk and Hocken-
maier, 2012b) that has been shown to be competitive
with other approaches even when paired with a very
simple probability model (Gelling et al, 2012). In
this paper, we pair this induction algorithm with a
novel nonparametric Bayesian model that is based
on a different factorization of CCG derivations, and
show that it outperforms our original model and
many other approaches on a large number of lan-
guages. Our results indicate that the use of CCG
yields grammars that are significantly more robust
when dealing with longer sentences than most de-
pendency grammar-based approaches.
2 Combinatory Categorial Grammar
Combinatory Categorial Grammar (Steedman,
2000) is a linguistically expressive, lexicalized
grammar formalism that associates rich syntactic
types with words and constituents. For simplicity,
we restrict ourselves to the standard two atomic
types S (sentences) and N (encompassing both
nouns and noun phrases) from which we recursively
build categories. Complex categories are of the
form X/Y or X\Y, and represent functions which
return a result of type X when combined with an
argument of type Y. The directionality of the slash
indicates whether the argument precedes or follows
the functor. We write X|Y when the direction of the
slash does not matter.
The CCG lexicon encodes all language-specific
information. It pairs every word with a set of cate-
gories that define both its specific syntactic behavior
as well as the overall word order of the language:
N : {he, girl , lunch, ...} N/N : {good , the, eating , ...}
S\N : {sleeps, ate, eating , ...} (S\N)/N : {sees, ate, ...}
S\S : {quickly , today ...} (S\N)/(S\N) : {good , the, ...}
To draw a simple contrast, in Spanish we would
expect adjectives to take the category N\N because
Spanish word ordering dictates that the adjective fol-
low the noun. The lexical categories also capture
word-word dependencies: head-argument relations
are captured by the lexical category of the head (e.g.
(S\N)/N), whereas head-modifier relations are cap-
tured by the lexical category of the modifier, which
is of the form X\X or X/X, and may take further
arguments of its own. Our goal will be to automati-
cally learn these types of lexicons for a language. In
Figure 3, we juxtapose several such lexicons which
were automatically discovered by our system.
The rules of CCG are defined by a small set of
of combinatory rules, which are traditionally writ-
ten as schemas that define how constituents can be
combined in a bottom-up fashion (although genera-
tive probability models for CCG view them in a top-
down manner, akin to CFG rules). The first, and
most obvious, of these rules is function application:
X/Y Y ? X (B0>)
Y X\Y ? X (B0<)
Here the functor X/Y or X\Y is applied to an
argument Y resulting in X. While standard CCG
has a number of additional combinatory rules (type-
raising, generalized variants of composition and
substitution) that increase its generative capacity be-
yond context-free grammars and allow an elegant
treatment of non-local dependencies arising in ex-
traction, coordination and scrambling, we follow
Bisk and Hockenmaier (2012b) and use a restricted
fragment, without type-raising, that allows only ba-
sic composition and is context-free:
X/Y Y/Z ? X/Z (B1> )
X/Y Y\Z ? X\Z (B1X>)
Y\Z X\Y ? X\Z (B1< )
Y/Z X\Y ? X/Z (B1X<)
The superscript 1 denotes the arity of the compo-
sition which is too low to recover non-projective de-
pendencies, and our grammar is thus weakly equiva-
lent to the dependency grammar representations that
are commonly used for grammar induction. The
main role of composition in our fragment is that it
allows sentential and verb modifiers to both take cat-
egories of the form S\S and S/S. Composition in-
76
troduces spurious ambiguities, which we eliminate
by using Eisner (1996)?s normal form.1
Coordinating conjunctions have a special cate-
gory conj, and we binarize coordination as follows
(Hockenmaier and Steedman, 2007):
X X[conj] ?&1 X (&1)
conj X ?&2 X[conj] (&2)
3 Category induction
Unlike dependency grammars, CCG requires an in-
ventory of lexical categories. Given a set of lexical
categories, the combinatory rules define the set of
parses for each sentence. We follow the algorithm
proposed by Bisk and Hockenmaier (2012b) to au-
tomatically induce these categories. The lexicon is
initialized by pairing all nominal tags (nouns, pro-
nouns and determiners) with the category N, all verb
tags with the category S, and coordinating conjunc-
tions with the category conj:
CONJ ? conj
DET, NOUN, NUM, PRON ? N
VERB ? S
Although our lexicons are defined over corpus-
specific POS tags, we use a slightly modified version
of Petrov et al (2012)?s Universal POS tagset to cat-
egorize them into these broad classes. The primary
changes we make to their mappings are the addition
of a distinction (where possible) between subordi-
nating and coordinating conjunctions and between
main and auxiliary verbs2.
Since the initial lexicon consists only of atomic
categories, it cannot parse any complex sentences:
The man ate quickly
DT NNS VBD RB
- N S -
Complex lexical categories are induced by con-
sidering the local context in which tokens appear.
Given an input sentence, and a current lexicon which
assigns categories to at least some of the tokens in
the sentence, we apply the following two rules to
add new categories to the lexicon: The argument
rule allows any lexical tokens that have categories
other than N and conj to take immediately adjacent
1The normal-form of Hockenmaier and Bisk (2010) is not
required for this fragment of CCG.
2This distinction was suggested by the authors (p.c.)
Ns as arguments. The modifier rule allows any to-
ken (other than coordinating conjunctions that ap-
pear in the middle of sentences) to modify an imme-
diate neighbor that has the category S or N or is a
modifier (S|S or N|N) itself.
The man ate quickly
DT NNS VBD RB
N/N N, S/S S, N\N S\S
S\N
These rules can be applied iteratively to form
more complex categories. We restrict lexical cate-
gories to a maximal arity of 2, and disallow the cat-
egory (S/N)\N, since it is equivalent to (S\N)/N.
The man ate quickly
DT NNS VBD RB
N/N, N, S/S S, N\N, S\S,
(S/S)/(S/S)(N\N)/(N\N) S\N (N\N)\(N\N)
(N/N)\(N/N) (S/S)\(S/S)
(S\S)/(S\S)
The resultant, overly general, lexicon is then used
to parse the training data. Each complete parse has
to be of category S or N, with the constraint that
sentences that contain a main verb can only form
parses of category S.
4 A new probability model for CCG
Generative models define the probability of a parse
tree ? as the product of individual rule probabili-
ties. Our previous work (Bisk and Hockenmaier,
2012b) uses the most basic model of Hockenmaier
and Steedman (2002), which first generates the head
direction (left, right, unary, or lexical), followed by
the head category, and finally the sister category. 3
This factorization does not take advantage of the
unique functional nature of CCG. We therefore in-
troduce a new factorization we call the Argument
Model. It exploits the fact that CCG imposes strong
constraints on a category?s left and right children,
since these must combine to create the parent type
via one of the combinators. In practice this means
that given the parent X/Z, the choice of combinator4
c and an argument Y we can uniquely determine the
categories of the left and right children:
3Huang et al (2012) present a (deficient) variant and
Bayesian extension of the Bisk and Hockenmaier (2012b)
model without k-best smoothing that both underperform our
published results.
4If X is an atomic category, only application is possible.
77
Parent c ? Left Right
X/Z B0> (X/Z)/Y Y
B0< Y (X/Z)\Y
B1> X/Y Y/Z
B1< Y/Z X\Y
and correspondingly for X\Z:
Parent c ? Left Right
X\Z B0> (X\Z)/Y Y
B0< Y (X\Z)\Y
B1> X/Y Y\Z
B1< Y\Z X\Y
While type-changing and raising are not used in
this work the model?s treatment of root productions
extends easily to handle these other unary cases. We
simply treat the argument Y as the unary outcome so
that the parent, combinator and argument uniquely
specify every detail of the unary rule:
Parent c ? Y
TOP TOP ? {S,N}
S/(S\N) T< N
S\(S/N) T> N
We still distinguish the same rule types as before
(lexical, unary, binary with head left/right), leading
us to the following model definition:
Given: P := X/Z
where type(t) ? {Left,Right,Unary,Lex}
p(t|P)?
{
p(w|P, t) Lex
p(Y|P, t)? p(c|P, t,Y) o.w.
Argument Combinator
Note that this model generates only one CCG cat-
egory but uniquely defines the two children of a par-
ent node. We will see below that this greatly simpli-
fies the development of non-parametric extensions.
5 HDP-CCG: a nonparametric model
Simple generative models such as PCFGs or Bisk
and Hockenmaier (2012b)?s CCG model are not
robust in the face of sparsity, since they assign
zero probability to any unseen event. Sparsity is
a particular problem for formalisms like CCG that
have a rich inventory of object types. Nonpara-
metric Bayesian models, e.g. Dirichlet Processes
(Teh, 2010) or their hierarchical variants (Teh et
al., 2006) and generalizations (Teh, 2006) overcome
this problem in a very elegant manner, and are used
by many state-of-the-art grammar induction systems
(Naseem et al, 2010; Blunsom and Cohn, 2010;
Boonkwan and Steedman, 2011). They also im-
pose a rich-getting-richer behavior that seems to be
advantageous in many modeling applications. By
contrast, Bisk and Hockenmaier (2012b) propose a
weighted top-k scheme to address these issues in an
ad-hoc manner.
The argument model introduced above lends it-
self particularly well to nonparametric extensions
such as the standard Hierarchical Dirichlet Pro-
cesses (HDP). In this work the size of the grammar
and the number of productions are fixed and small,
but we present the formulation as infinite to allow for
easy extension in the future. Specifically, this frame-
work allows for extensions which grow the grammar
during parsing/training or fully lexicalize the pro-
ductions. Additionally, while our current work uses
only a restricted fragment of CCG that has only a
finite set of categories, the literature?s generalized
variants of composition make it possible to gener-
ate categories of unbounded arity. We therefore be-
lieve that this is a very natural probabilistic frame-
work for CCG, since HDPs make it possible to con-
sider a potentially infinite set of categories that can
instantiate the Y slot, while allowing the model to
capture language-specific preferences for the set of
categories that can appear in this position.
The HDP-CCG model In Bayesian models,
multinomials are drawn from a corresponding n-
dimensional Dirichlet distribution. The Dirichlet
Process (DP) generalizes the Dirichlet distribution
to an infinite number of possible outcomes, allowing
us to deal with a potentially infinite set of categories
or words. DPs are defined in terms of a base dis-
tribution H that corresponds to the mean of the DP,
and a concentration or shape parameter ?. In a Hi-
erarchical Dirichlet Process (Teh et al, 2006), there
is a hierarchy of DPs, such that the base distribution
of a DP at level n is a DP at level n? 1.
The HDP-CCG (Figure 1) is a reformulation of
the Argument Model introduced above in terms of
Hierarchical Dirichlet Processes.5 At the heart of
the model is a distribution over CCG categories. By
combining a stick breaking process with a multino-
mial over categories we can define a DP over CCG
5An alternative HDP model for semantic parsing with CCG
is proposed by Kwiatkowski et al (2012).
78
HDP-CCG
1) Draw global parameters
Define MLE root parameter ?TOP
Draw top-level symbol weights ?Y ? GEM(?Y )
Draw top-level lexical weights ?L ? GEM(?L)
For each grammar symbol z ? {1, 2, ...}:
Define MLE rule type parameters ?Tz
Draw argument parameters ?Yz ? DP(?Y, ?Y )
Draw lexical emission parameters ?Lz ? DP(?L, ?L)
For each grammar symbol y ? {1, 2, ...}:
Define MLE combinator parameters ?Cz,y
2) For each parse tree:
Generate root node zTOP ? Binomial(?TOP )
For each node i in the parse tree:
Choose rule type ti ?Multinomial(?Tzi )If ti == Lex:
Emit terminal symbol xi ?Multinomial(?Lzi )If ti == Left/Right/Unary:
Generate argument category yi ?Multinomial(?Yzi )Generate combinator ci ?Multinomial(?Czi,yi )Deterministically create zL(i) (and zR(i) if binary)
zi
yi ci
zL(i) zR(i)
xL(i) xR(i)z ?
?y
?Y
?T
?C
?L
?Y
?L
Because we are working with CCG, the
parent zi, argument yi and combinator ci
uniquely define the two children categories
(zL(i), zR(i)). The dashed arrows here rep-
resent the deterministic process used to
generate these two categories.
Figure 1: The HDP-CCG has two base distributions, one over the space of categories and the other over
words (or tags). For every grammar symbol, an argument distribution and emission distribution is drawn
from the corresponding Dirichlet Processes. In addition, there are several MLE distributions tied to a given
symbol for generating rule types, combinators and lexical tokens.
categories whose stick weights (?Y ) correspond to
the frequency of the category in the corpus. Next we
build the hierarchical component of our model by
choosing an argument distribution (?Y ), again over
the space of categories, for every parent X/Z. This
argument distribution is drawn from the previously
defined base DP, allowing for an important level of
parameter tying across all argument distributions.
While the base DP does define the mean around
which all argument distributions are drawn, we also
require a notion of variance or precision which de-
termines how similar individual draws will be. This
precision is determined by the magnitude of the hy-
perparameter ?Y . This hierarchy is paralleled for
lexical productions which are drawn from a unigram
base DP over terminal symbols controlled by ?L.
For simplicity we use the same scheme for setting
the values for ?L as ?Y . We present experimen-
tal results in which we vary the value of ?Y as a
function of the number of outcomes allowed by the
grammar for argument categories or the corpus in
the case of terminal symbols. Specifically, we set
?Y = np for conditioning contexts with n out-
comes. Since Liang et al (2009) found that the ideal
value for alpha appears to be superlinear but sub-
quadratic in n, we present results where p takes the
values 0, 1.0, 1.5, and 2.0 to explore the range from
uniform to quadratic. This setting for ? is the only
free parameter in the model. By controlling preci-
sion we can tell the model to what extent global cor-
pus statistics should be trusted. We believe this has
a similar effect to Bisk and Hockenmaier (2012b)?s
top-k upweighting and smoothing scheme.
One advantage of the argument model is that it
only requires a single distribution over categories for
each binary tree. In contrast to similar proposals for
CFGs (Liang et al, 2007), which impose no formal
restrictions on the nonterminals X, Y, Z that can ap-
pear in a rewrite rule X? Y Z, this greatly sim-
plifies the modeling problem (yielding effectively a
model that is more akin to nonparametric HMMs),
since it avoids the need to capture correlations be-
79
tween different base distributions for Y and Z.
Variational Inference HDPs need to be estimated
with approximate techniques. As an alternative to
Gibbs sampling (Teh et al, 2006), which is exact,
but typically very slow and has no clear convergence
criteria, variational inference algorithms (Bishop,
2006; Blei and Jordan, 2004) estimate the parame-
ters of a truncated model to maximize a lower bound
of the likelihood of the actual model. This allows for
factorization of the model and a training procedure
analogous to the Inside-Outside algorithm (Lari and
Young, 1991), allowing training to run very quickly
and in a trivially parallelizable manner.
To initialize the base DP?s stick weights, we fol-
low the example of Kurihara et al (2007) and use
an MLE model initialized with uniform distributions
to compute global counts for the categories in our
grammar. When normalized these provide a better
initialization than a uniform set of weights. Updates
to the distributions are then performed in a coordi-
nate descent manner which includes re-estimation of
the base DPs.
In variational inference, multinomial weights W
take the place of probabilities. The weights for an
outcome Y with conditioning variable P are com-
puted by summing pseudocounts with a scaled mean
vector from the base DP. The computation involves
moving in the direction of the gradient of the Dirich-
let distribution which results in the following differ-
ence of Digammas (?):
WP (Y ) = ?(C(P, Y ) + ?P?Y )
??(C(P, ?) + ?P )
Importantly, the Digamma and multinomial
weights comprise a righ-get-richer scheme, biasing
the model against rare outcomes. In addition, since
variational inference is done by coordinate descent,
it is trivially parallelizeable. In practice, training and
testing our models on the corpora containing sen-
tences up to length 15 used in this paper takes be-
tween one minute to at most three hours on a single
12-core machine depending on their size.
6 Evaluation
As is standard for this task, we evaluate our systems
against a number of different dependency treebanks,
and measure performance in terms of the accuracy of
directed dependencies (i.e. the percentage of words
in the test corpus that are correctly attached). We use
the data from the PASCAL challenge for grammar
induction (Gelling et al, 2012), the data from the
CoNLL-X shared task (Buchholz and Marsi, 2006)
and Goldberg (2011)?s Hebrew corpus.
Converting CCG derivations into dependencies is
mostly straightforward, since the CCG derivation
identifies the root word of each sentence, and head-
argument and head-modifier dependencies are easily
read off of CCG derivations, since the lexicon de-
fines them explicitly. Unlike dependency grammar,
CCG is designed to recover non-local dependencies
that arise in control and binding constructions as
well as in wh-extraction and non-standard coordi-
nation, but since this requires re-entrancies, or co-
indexation of arguments (Hockenmaier and Steed-
man, 2007), within the lexical categories that trigger
these constructions, our current system returns only
local dependencies. But since dependency gram-
mars also captures only local dependencies, this has
no negative influence on our current evaluation.
However, a direct comparison between depen-
dency treebanks and dependencies produced by
CCG is more difficult (Clark and Curran, 2007),
since dependency grammars allow considerable
freedom in how to analyze specific constructions
such as verb clusters (which verb is the head?)
prepositional phrases and particles (is the head the
noun or the preposition/particle?), subordinating
conjunctions (is the conjunction a dependent of the
head of the main clause and the head of the embed-
ded clause a dependent of the conjunction, or vice
versa?) and this is reflected in the fact that the tree-
banks we consider often apply different conventions
for these cases. Although remedying this issue is
beyond the scope of this work, these discrepancies
very much hint at the need for a better mechanism to
evaluate linguistically equivalent structures or tree-
bank standardization.
The most problematic construction is coordina-
tion. In standard CCG-to-dependency schemes, both
conjuncts are independent, and the conjunction itself
is not attached to the dependency graph, whereas de-
pendency grammars have to stipulate that either one
of the conjuncts or the conjunction itself is the head,
with multiple possibilities of where the remaining
80
constituents attach. In addition to the standard CCG
scheme, we have identified five main styles of con-
junction in our data (Figure 2), although several cor-
pora distinguish multiple types of coordinating con-
junctions which use different styles (not all shown
here). Since our system has explicit rules for coordi-
nation, we transform its output into the desired target
representation that is specific to each language.
7 Experiments
We evaluate our system on 13 different languages.
In each case, we follow the test and training regimes
that were used to obtain previously published results
in order to allow a direct comparison. We com-
pare our system to the results presented at the PAS-
CAL Challenge on Grammar Induction (Gelling et
al., 2012)6, as well as to Gillenwater et al (2011)
and Naseem et al (2012). We use Nivre (2006)?s
Penn2Malt implementation of Collins (2003)?s head
rules to translate the WSJ Penn Treebank (Marcus
et al, 1993) into dependencies. Finally, when train-
ing the MLE version of our model we use a simple
smoothing scheme which defines a small rule proba-
bility (e?15) to prevent any rule used during training
from going to zero.
7.1 PASCAL Challenge on Grammar
Induction
In Table 1, we compare the performance of the ba-
sic Argument model (MLE), of our HDP model with
four different settings of the hyperparameters (as ex-
plained above) and of the systems presented in the
PASCAL Challenge on Grammar Induction (Gelling
et al, 2012). The systems in this competition were
instructed to train over the full dataset, including the
unlabelled test data, and include Bisk and Hocken-
maier (2012a)?s CCG-based system (BH) to Cohn et
al. (2010)?s reimplementation of Klein and Manning
(2004)?s DMV model in a tree-substitution gram-
mar framework (BC), as well as three other de-
pendency based systems which either incorporate
Naseem et al (2010)?s rules in a deterministic fash-
ion (S?gaard, 2012), rely on extensive tuning on
6Numbers are from personal correspondence with the orga-
nizers. The previously published numbers are not comparable
to literature due to an error in the evaluation. http://wiki.
cs.ox.ac.uk/InducingLinguisticStructure/
ResultsDepComparable
the development set (Tu, 2012) or incorporate mil-
lions of additional tokens from Wikipedia to esti-
mate model parameters (Marecek and Zabokrtsky,
2012). We ignore punctuation for all experiments
reported in this paper, but since the training data
(but not the evaluation) includes punctuation marks,
participants were free to choose whether to include
punctuation or ignore it.
While BH is the only other system with directly
interpretable linguistic output, we also include a di-
rect comparison with BC, whose TSG representa-
tion is equally expressive to ours. Finally we present
a row with the maximum performance among the
other three models. As we have no knowledge of
how much data was used in the training of other sys-
tems we simply present results for systems trained
on length 15 (not including punctuation) sentences
and then evaluated at lengths 10 and 15.
The MLE version of our model shows rather vari-
able performance: although its results are particu-
larly bad on Basque (Eu), it outperforms both BH
and BC on some other settings. By contrast, the
HDP system is always better than the MLE model.
It outperforms all other systems on half of the cor-
pora. On average, it outperforms BH and BC by
10.3% and 9.3% on length 10, or 9.7% and 7.8 %
on length 15 respectively. The main reason why our
system does not outperform BC by an even higher
margin is the very obvious 11.4%/11.5% deficit on
Slovene. However, the Slovene dependency tree-
bank seems to follow a substantially different anno-
tation scheme. In particular, the gold standard an-
notation of the 1,000 sentences in the Slovene de-
velopment set treats many of them as consisting of
independent sentences (often separated by punctua-
tion marks that our system has no access to), so that
the average number of roots per sentence is 2.7:
>>
?
verjeti
believe
ti
I
,
,
??
?
je
is
mehko
soft
rekla
said
When our system is presented with these short
components in isolation, it oftentimes analyzes them
correctly, but since it has to return a tree with a sin-
gle root, its performance degrades substantially.
We believe the HDP performs so well as com-
pared to the MLE model because of the influence
of the shared base distribution, which allows the
81
Ar, Eu, Cs, Nl,
WSJ, Ch, He Da, He Es, Bg, De, Pt Sv, Sl Ja
noun conj noun noun conj noun noun conj noun noun conj noun noun conj noun
Figure 2: In the treebanks used for evaluation different standards exist for annotating coordination. While
not exhaustive, this table demonstrates five of the most common schemes used in the literature. Syntactically
these are identical and traditionally CCG draws arcs only to the arguments without attaching the conjunction.
For the purposes of comparison with the literature we have implemented these five translation schemes.
Arabic Danish Slovene Swedish Dutch Basque Portuguese WSJ Childes Czech
# Tokens 5,470 25,341 54,032 61,877 78,737 81,345 158,648 163,727 290,604 436,126
# Tags 20 24 36 30 304 14 23 36 69 62
PA
SC
AL BC 60.8/58.4 44.7/39.4 62.6/57.9 63.2/56.6 51.8/52.0 53.0/48.9 52.4/50.2 68.6/63.3 47.4/46.1 47.9/43.1Max 67.2/66.8 60.1/56.0 65.6/61.8 72.8/63.4 51.1/47.6 53.7/47.8 67.0/61.8 71.2/64.8 56.0/54.5 58.3/54.4
BH 41.6/43.7 46.4/43.8 49.6/43.9 63.7/57.0 49.7/43.6 45.1/39.6 70.8/67.2 68.2/59.6 61.4/59.8 45.0/38.9
Th
isw
ork
MLE 41.6/42.9 43.4/39.2 46.1/41.1 70.1/59.7 52.2/47.2 29.6/26.5 62.2/59.7 59.5/52.4 53.3/51.9 50.5/45.8
HDP0.0 48.0/50.0 63.9/58.5 44.8/39.8 67.6/62.1 45.0/33.9 41.6/39.1 71.0/66.0 59.8/52.9 56.3/55.2 54.0/49.0
HDP1.0 45.6/47.1 45.7/42.3 53.9/46.9 74.5/66.9 58.5/54.4 50.1/44.6 65.1/60.6 64.3/56.5 71.5/70.3 55.8/50.7
HDP1.5 49.6/50.4 58.7/54.4 53.2/48.2 74.3/67.1 57.4/54.5 50.6/45.0 70.0/64.7 65.5/57.2 69.6/68.6 55.6/50.3
HDP2.0 66.4/65.1 56.5/49.5 54.2/46.4 71.6/64.1 51.7/48.3 49.4/43.3 76.3/70.5 70.7/62.9 74.1/73.3 54.4/48.5
+/? -0.8/-1.7 +3.8/+2.5 -11.4/-15.4 +1.7/+3.5 +6.7/+2.4 -3.1/-3.9 +5.5/+3.3 -0.5/-1.9 +12.7/+13.5 -2.5/-3.7
Table 1: A comparison of the basic Argument model (MLE) and four hyper-parameter settings of the HDP-
CCG against two syntactic formalisms that participated in the PASCAL Challenge (Gelling et al, 2012),
BH (Bisk and Hockenmaier, 2012a) and BC (Blunsom and Cohn, 2010), in addition to a max over all other
participants. We trained on length 15 data (punctuation removed), including the test data as recommended
by the organizers. The last row indicates the difference between our best system and the competition.
global category distribution to influence each of the
more specific distributions. Further, it provides a
very simple knob in the choice of hyperparame-
ters, which has a substantial effect on performance.
A side effect of the hyperparameters is that their
strength also determines the rate of convergence.
This may be one of the reasons for the high vari-
ance seen in the four settings tested, although we
note that since our initialization is always uniform,
and not random, consecutive runs do not introduce
variance in the model?s performance.
7.2 Comparison with systems that capture
linguistic constraints
Since our induction algorithm is based on the knowl-
edge of which POS tags are nouns and verbs, we
compare in Table 2 our system to Naseem et al
(2010), who present a nonparametric dependency
model that incorporates thirteen universal linguistic
constraints. Three of these constraints correspond
to our rules that verbs are the roots of sentences and
may take nouns as dependents, but the other ten con-
straints (e.g. that adjectives modify nouns, adverbs
modify adjectives or verbs, etc.) have no equivalent
in our system. Although our system has less prior
knowledge, it still performs competitively.
On the WSJ, Naseem et al demonstrate the im-
portance and effect of the specific choice of syntactic
rules by comparing the performance of their system
with hand crafted universal rules (71.9), with En-
glish specific rules (73.8), and with rules proposed
by Druck et al (2009) (64.9). The performance of
Naseem et al?s system drops very significantly as
sentence length (and presumable parse complexity)
82
Sl Es Da Pt Sv
?#Tokens 3.8K 4.2K 9.5K 15K 24K
N10 50.9 67.2 51.9 71.5 63.3
HDP 56.6 62.1 51.5 74.7 69.8
Table 2: A comparison of our system with Naseem
et al (2010), both trained and tested on the length 10
training data from the CoNLL-X Shared Task.
increases, whereas our system shows significantly
less decline, and outperforms their universal system
by a significant margin.7
? 10 ? 20
Naseem Universal Rules 71.9 50.4
Naseem English Rules 73.8 66.1
HDP-CCG 68.2 64.2
HDP-CCG (train ? 20) 71.9
In contrast to Spitkovsky et al (2010), who reported
that performance of their dependency based system
degrades when trained on longer sentences, our per-
formance on length 10 sentences increases to 71.9
when we train on sentences up to length 20.
Another system that is also based on CCG, but
captures significantly more linguistic knowledge
than ours, was presented by Boonkwan and Steed-
man (2011), who achieve an accuracy of 74.5 on
WSJ10 section 23 (trained on sections 02-22). Us-
ing the same settings, our system achieves an accu-
racy of 68.4. Unlike our approach, Boonkwan and
Steedman do not automatically induce an appropri-
ate inventory of lexical category, but use an exten-
sive questionnaire that defines prototype categories
for various syntactic constructions, and requires sig-
nificant manual engineering of which POS tags are
mapped to what categories to generate a language-
specific lexicon. However, their performance de-
grades significantly when only a subset of the ques-
tions are considered. Using only the first 14 ques-
tions, covering facts about the ordering of subjects,
verbs and objects, adjectives, adverbs, auxiliaries,
adpositions, possessives and relative markers, they
achieve an accuracy of 68.2, which is almost iden-
7Our earlier generative model showed similar behavior, al-
though the results in Bisk and Hockenmaier (2012b) are not
directly comparable due to differences in the data.
Sl Es Da Pt Sv
#Tokens 3,857 4,230 9,549 15,015 24,021
G10 51.2 62.4 47.2 54.3 48.6
HDP 57.9 65.4 49.3 73.5 73.2
Bg WSJ Nl Ja De
#Tokens 38,220 42,442 43,405 43,501 77,705
G10 59.8 64.4 47.5 60.2 47.4
HDP 66.1 70.3 56.2 64.1 68.4
Table 3: A comparison of our system with Gillenwa-
ter et al (2010), both trained on the length 10 train-
ing data, and tested on the length 10 test data, from
the CoNLL-X Shared task.
tical to ours, even though we use significantly less
initial knowledge. However, the lexicons we present
below indicate that we are in fact learning many of
the very exact details that in their system are con-
structed by hand. The remaining 14 questions in
Boonkwan and Steedman?s questionnaire cover less
frequent phenomena such as the order of negative
markers, dative shift, and pro-drop. The obvious ad-
vantage of this approach is that this allows them to
define a much more fine-grained inventory of lexical
categories than our system can automatically induce.
We also stipulate that for certain languages knowl-
edge of pro-drop could play a significant role in the
success of their approach: if complete sentences are
allowed to be of the form S\N or S/N, the same lex-
ical category can be used for the verb regardless of
whether the subject is present or has been dropped.
7.3 Additional Languages
In order to provide results on additional languages,
we present in Table 3 a comparison to the work of
Gillenwater et al (2010) (G10), using the ConLL-X
Shared Task data (Buchholz and Marsi, 2006). Fol-
lowing Gillenwater et al, we train only on sentences
of length 10 from the training set and evaluate on the
test set. Since this is a different training regime, and
these corpora differ for many languages from that of
the PASCAL challenge, numbers from Table 1 can-
not be compared directly with those in Table 3. We
have also applied our model to Goldberg (2011)?s
Hebrew corpus, where it achieves an accuracy of
62.1 (trained and tested on all sentences length 10;
7,253) and 59.6 (length 15; 21,422 tokens).
83
Arabic % Swedish % WSJ % Childes % Japanese % Czech %
VERB (S\N)/N 56 S 45 S\N 52 S/N 44 S 84 S 26
(S/N)/N 29 S\N 20 (S\N)/N 19 S 37 S\N 25
ADP N\N 68 (S\S)/N 49 (S\S)/N 46 (S\S)/N 45 (S/S)\N 44 (S\S)/N 42
N/N 21 (N\N)/N 25 (N\N)/N 20 N/N 25 N\N 23 (S/S)/N 26
NOUN N\N 50 N 91 N 79 N 89 N 73 N 74
N 35 N/N 12
ADJ N\N 82 N/N 50 N/N 70 N/N 46 S/S 64 N/N 55
Figure 3: Partial lexicons demonstrating language specific knowledge learned automatically for five lan-
guages. For ease of comparison between languages, we use the universal tag label (Verb, Adposition, Noun
and Adjective). Shown are the most common categories and the fraction of occurrences of the tag that are
assigned this category (according to the Viterbi parses).
8 The Induced Lexicons
Since our approach is based on a lexicalized for-
malism such as CCG, our system automatically in-
duces lexicons that pair words (or, in our case, POS-
tags) with language-specific categories that capture
their syntactic behavior. If our approach is success-
ful, it should learn the basic syntactic properties of
each language, which will be reflected in the corre-
sponding lexicon. In Figure 3 one sees how verbs
subcategorize differently, how word ordering differs
by language, and how the attachment structures of
prepositions are automatically discovered and differ
across languages. In Arabic, for example, the sys-
tem learns that word order is variable and therefore
the verb must allow for both SVO and VOS style
constructions. We generally learn that adpositions
(prepositions or postpositions) take nouns as argu-
ments. In Czech, PPs can appear before and after the
verb, leading to two different categories ((S\S)/N
and (S/S)/N). Japanese has postpositions that ap-
pear in preverbal position ((S/S)\N), but when this
category is assigned to nominal particles that cor-
respond to case markers, it effectively absorbs the
noun, leading to a preference for verbs that do not
take any arguments (S), and to a misanalysis of ad-
jectives as verb modifiers (S/S). Our lexicons also
reflect differences in style: while Childes and the
WSJ are both English, they represent very different
registers. We learn that subjects are mostly absent in
the informal speech and child-directed instructions
contained in Childes, while effectively mandatory in
the Wall Street Journal.
9 Conclusions
This paper has introduced a novel factorization for
CCG models and showed how when combined with
non-parametric Bayesian statistics it can compete
with every other grammar induction system cur-
rently available, including those that capture a sig-
nificant amount of prior linguistic knowledge. The
use of a powerful syntactic formalism proves ben-
eficial both in terms of requiring very limited uni-
versal knowledge and robustness at longer sentence
lengths. Unlike standard grammar induction sys-
tems that are based on dependency grammar, our
system returns linguistically interpretable lexicons
for each language that demonstrate it has discov-
ered their basic word order. Of particular note is the
simplicity of the model both algorithmically and in
terms of implementation. By not faltering on longer
sentences or requiring extensive tuning, the system
can be easily and quickly deployed on a new lan-
guage and return state of the art performance and
easily interpretable lexicons. In this paper, we have
applied this model only to a restricted fragment of
CCG, but future work will address the impact of lex-
icalization and the inclusion of richer combinators.
10 Acknowledgements
This work is supported by NSF CAREER award
1053856 (Bayesian Models for Lexicalized Gram-
mars).
84
References
Taylor Berg-Kirkpatrick and Dan Klein. 2010. Phyloge-
netic Grammar Induction. In Proceedings of the 48th
Annual Meeting of the Association for Computational
Linguistics, pages 1288?1297, Uppsala, Sweden, July.
Christopher Bishop. 2006. Pattern Recognition and Ma-
chine Learning. Springer-Verlag, August.
Yonatan Bisk and Julia Hockenmaier. 2012a. Induction
of Linguistic Structure with Combinatory Categorial
Grammars. In NAACL HLT Workshop on Induction of
Linguistic Structure, pages 90?95, Montre?al, Canada,
June.
Yonatan Bisk and Julia Hockenmaier. 2012b. Simple
Robust Grammar Induction with Combinatory Cate-
gorial Grammars. In Proceedings of the Twenty-Sixth
Conference on Artificial Intelligence (AAAI-12), pages
1643?1649, Toronto, Canada, July.
David M Blei and Michael I Jordan. 2004. Variational
Methods for the Dirichlet Process. In Proceedings of
the Twenty-First International Conference on Machine
Learning (ICML 2004), Banff, Alberta, Canada, July.
Phil Blunsom and Trevor Cohn. 2010. Unsupervised
Induction of Tree Substitution Grammars for Depen-
dency Parsing. Proceedings of the 2010 Conference
on Empirical Methods of Natural Language Process-
ing, pages 1204?1213, October.
Prachya Boonkwan and Mark Steedman. 2011. Gram-
mar Induction from Text Using Small Syntactic Proto-
types. In Proceedings of 5th International Joint Con-
ference on Natural Language Processing, pages 438?
446, Chiang Mai, Thailand, November.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
Shared Task on Multilingual Dependency Parsing. In
Proceedings of the 10th Conference on Computational
Natural Language Learning (CoNLL-X), pages 149?
164, New York City, June.
Glenn Carroll and Eugene Charniak. 1992. Two Exper-
iments on Learning Probabilistic Dependency Gram-
mars from Corpora. Working Notes of the Workshop
Statistically-Based NLP Techniques, pages 1?13.
Eugene Charniak. 1993. Statistical Language Learning.
The MIT Press, Cambridge, Massachusetts.
Stephen Clark and James R Curran. 2007. Formalism-
Independent Parser Evaluation with CCG and Dep-
Bank. In Proceedings of the 45th Annual Meeting of
the Association of Computational Linguistics, pages
248?255, Prague, Czech Republic, June.
Alex Clark. 2001. Unsupervised Language Acquisition:
Theory and Practice. Ph.D. thesis, University of Sus-
sex, September.
Shay B Cohen and Noah A Smith. 2009. Variational
Inference for Grammar Induction with Prior Knowl-
edge. Proceedings of the ACL-IJCNLP 2009 Confer-
ence Short Papers, pages 1?4.
Shay B Cohen and Noah A Smith. 2010. Covariance
in Unsupervised Learning of Probabilistic Grammars.
The Journal of Machine Learning Research, pages
3117?3151, November.
Trevor Cohn, Phil Blunsom, and Sharon Goldwater.
2010. Inducing Tree-Substitution Grammars. The
Journal of Machine Learning Research, 11:3053?
3096, November.
Michael Collins. 2003. Head-Driven Statistical Mod-
els for Natural Language Parsing. Computational Lin-
guistics, 29(4):589?637, December.
Gregory Druck, Gideon Mann, and Andrew McCal-
lum. 2009. Semi-supervised Learning of Dependency
Parsers using Generalized Expectation Criteria. In
Proceedings of the Joint Conference of the 47th An-
nual Meeting of the ACL and the 4th International
Joint Conference on Natural Language Processing of
the AFNLP, pages 360?368, Suntec, Singapore, Au-
gust.
Jason Eisner. 1996. Efficient Normal-Form Parsing for
Combinatory Categorial Grammar. In Proceedings of
the 34th Annual Meeting of the Association for Com-
putational Linguistics, pages 79?86, Santa Cruz, Cali-
fornia, USA, June.
Douwe Gelling, Trevor Cohn, Phil Blunsom, and Joa?o V
Graca. 2012. The PASCAL Challenge on Grammar
Induction. In NAACL HLT Workshop on Induction of
Linguistic Structure, pages 64?80, Montre?al, Canada,
June.
Jennifer Gillenwater, Kuzman Ganchev, Joa?o V Graca,
Fernando Pereira, and Ben Taskar. 2010. Sparsity in
Dependency Grammar Induction. In Proceedings of
the 48th Annual Meeting of the Association for Com-
putational Linguistics, pages 194?199, Uppsala, Swe-
den, July.
Jennifer Gillenwater, Kuzman Ganchev, Joa?o V Graca,
Fernando Pereira, and Ben Taskar. 2011. Posterior
Sparsity in Unsupervised Dependency Parsing. The
Journal of Machine Learning Research, 12:455?490,
February.
Yoav Goldberg. 2011. Automatic Syntactic Processing of
Modern Hebrew. Ph.D. thesis, Ben-Gurion University
of the Negev, November.
William P Headden III, Mark Johnson, and David Mc-
Closky. 2009. Improving Unsupervised Dependency
Parsing with Richer Contexts and Smoothing. In Pro-
ceedings of Human Language Technologies: The 2009
Annual Conference of the North American Chapter of
the Association for Computational Linguistics, pages
101?109, Boulder, Colorado, June.
Julia Hockenmaier and Yonatan Bisk. 2010. Normal-
form parsing for Combinatory Categorial Grammars
with generalized composition and type-raising. In
85
Proceedings of the 23rd International Conference on
Computational Linguistics (Coling 2010), pages 465?
473, Beijing, China, August. Coling 2010 Organizing
Committee.
Julia Hockenmaier and Mark Steedman. 2002. Gener-
ative Models for Statistical Parsing with Combinatory
Categorial Grammar. In Proceedings of 40th Annual
Meeting of the Association for Computational Lin-
guistics, pages 335?342, Philadelphia, Pennsylvania,
USA, July.
Julia Hockenmaier and Mark Steedman. 2007. CCG-
bank: A Corpus of CCG Derivations and Dependency
Structures Extracted from the Penn Treebank. Com-
putational Linguistics, 33(3):355?396, September.
Yun Huang, Min Zhang, and Chew Lim Tan. 2012.
Improved Combinatory Categorial Grammar Induc-
tion with Boundary Words and Bayesian Inference.
In Proceedings of the 24rd International Conference
on Computational Linguistics (Coling 2012), Mumbai,
India, December.
Ray Jackendoff. 1977. X-Bar Syntax: A Study of Phrase
Structure. The MIT Press.
Dan Klein and Christopher D Manning. 2004. Corpus-
Based Induction of Syntactic Structure: Models of De-
pendency and Constituency. In Proceedings of the
42nd Meeting of the Association for Computational
Linguistics (ACL?04), Main Volume, pages 478?485,
Barcelona, Spain, July.
Kenichi Kurihara and Taisuke Sato. 2004. An Appli-
cation of the Variational Bayesian Approach to Prob-
abilistic Context-Free Grammars. International Joint
Conference on Natural Language Language Process-
ing Workshop Beyond Shallow Analyses, March.
Kenichi Kurihara, Max Welling, and Yee-Whye Teh.
2007. Collapsed Variational Dirichlet Process Mix-
ture Models. In Proceedings of the 20th International
Joint Conference on Artificial Intelligence (IJCAI07),
pages 2796?2801, Hyderabad, India, January.
Tom Kwiatkowski, Sharon Goldwater, Luke Zettlemoyer,
and Mark Steedman. 2012. A probabilistic model of
syntactic and semantic acquisition from child-directed
utterances and their meanings. In Proceedings of the
13th Conference of the European Chapter of the As-
sociation for Computational Linguistics, pages 234?
244, Avignon, France, April. Association for Compu-
tational Linguistics.
Karim Lari and Steve J Young. 1991. Applications
of stochastic context-free grammars using the Inside-
Outside algorithm. Computer speech & language,
5(3):237?257, January.
Percy Liang, Slav Petrov, Michael I Jordan, and Dan
Klein. 2007. The Infinite PCFG Using Hierarchical
Dirichlet Processes. In Proceedings of the 2007 Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning (EMNLP-CoNLL), pages 688?697,
Prague, Czech Republic.
Percy Liang, Michael I Jordan, and Dan Klein. 2009.
Probabilistic Grammars and Hierarchical Dirichlet
Processes. In The Oxford Handbook of Applied
Bayesian Analysis. Oxford University Press.
Mitchell P Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a Large Annotated
Corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313?330, June.
David Marecek and Zdenek Zabokrtsky. 2012. Unsu-
pervised Dependency Parsing using Reducibility and
Fertility features. In NAACL HLT Workshop on Induc-
tion of Linguistic Structure, pages 84?89, Montre?al,
Canada, June.
Tahira Naseem, Harr Chen, Regina Barzilay, and Mark
Johnson. 2010. Using Universal Linguistic Knowl-
edge to Guide Grammar Induction. In Proceedings of
the 2010 Conference on Empirical Methods in Natural
Language Processing, pages 1234?1244, Cambridge,
MA, October.
Tahira Naseem, Regina Barzilay, and Amir Globerson.
2012. Selective Sharing for Multilingual Dependency
Parsing. In Proceedings of the 50th Annual Meeting
of the Association for Computational Linguistics (Vol-
ume 1: Long Papers), pages 629?637, Jeju, Republic
of Korea, July.
Joakim Nivre. 2006. Inductive Dependency Parsing.
Springer.
Slav Petrov, Dipanjan Das, and Ryan McDonald. 2012.
A Universal Part-of-Speech Tagset. In Proceedings
of the 8th International Conference on Language Re-
sources and Evaluation (LREC-2012), pages 2089?
2096, Istanbul, Turkey, May.
Anders S?gaard. 2012. Two baselines for unsuper-
vised dependency parsing. In NAACL HLT Work-
shop on Induction of Linguistic Structure, pages 81?
83, Montre?al, Canada, June.
Valentin I Spitkovsky, Hiyan Alshawi, and Daniel Juraf-
sky. 2010. From Baby Steps to Leapfrog: How ?Less
is More? in Unsupervised Dependency Parsing. In Hu-
man Language Technologies: The 2010 Annual Con-
ference of the North American Chapter of the Associ-
ation for Computational Linguistics, pages 751?759,
Los Angeles, California, June.
Mark Steedman. 1996. Surface Structure and Interpre-
tation. The MIT Press, January.
Mark Steedman. 2000. The Syntactic Process. The MIT
Press, September.
Yee-Whye Teh, Michael I Jordan, Matthew J Beal, and
David M Blei. 2006. Hierarchical Dirichlet Pro-
86
cesses. Journal of the American Statistical Associa-
tion, 101(476):1566?1581.
Yee-Whye Teh. 2006. A Hierarchical Bayesian Lan-
guage Model based on Pitman-Yor Processes. In Pro-
ceedings of the 21st International Conference on Com-
putational Linguistics and 44th Annual Meeting of
the Association for Computational Linguistics, pages
985?992, Sydney, Australia, July.
Yee-Whye Teh. 2010. Dirichlet Process. In Encyclope-
dia of Machine Learning, pages 280?287. Springer.
Kewei Tu. 2012. Combining the Sparsity and Unambi-
guity Biases for Grammar Induction. In NAACL HLT
Workshop on Induction of Linguistic Structure, pages
105?110, Montre?al, Canada, June.
87
88
NAACL-HLT Workshop on the Induction of Linguistic Structure, pages 90?95,
Montre?al, Canada, June 3-8, 2012. c?2012 Association for Computational Linguistics
Induction of Linguistic Structure with Combinatory Categorial Grammars
Yonatan Bisk and Julia Hockenmaier
Department of Computer Science
University of Illinois at Urbana-Champaign
201 N Goodwin Ave. Urbana IL, 61801
{bisk1,juliahmr}@illinois.edu
Abstract
Our system consists of a simple, EM-based
induction algorithm (Bisk and Hockenmaier,
2012), which induces a language-specific
Combinatory Categorial grammar (CCG) and
lexicon based on a small number of linguistic
principles, e.g. that verbs may be the roots of
sentences and can take nouns as arguments.
1 Introduction
Much of the recent work on grammar induction has
focused on the development of sophisticated statisti-
cal models that incorporate expressive priors (Cohen
and Smith, 2010) or linguistic universals (Naseem et
al., 2010; Boonkwan and Steedman, 2011) that have
all been shown to be very helpful. But, with some
notable exceptions, such as (Cohn et al, 2011),
the question of what underlying linguistic represen-
tation to use has received considerably less atten-
tion. Our induction algorithm is based on Com-
binatory Categorial Grammar (Steedman, 2000), a
linguistically expressive, lexicalized grammar for-
malism which associates words with rich syntactic
categories that capture language-specific facts about
basic word order and subcategorization. While
Boonkwan and Steedman (2011) have shown that
linguists can easily devise a language-specific in-
ventory of such categories that allows a parser to
achieve high performance in the absence of anno-
tated training data, our algorithm automatically dis-
covers the set of categories it requires to parse the
sentences in the training data.
2 Combinatory Categorial Grammar
(CCG)
The set of CCG categories is built recursively from
two atomic types, S (sentence) and N (noun). Com-
plex types are of the form X/Y or X\Y, and repre-
sent functions which combine with an argument of
type Y to yield a constituent of type X as result. The
slash indicates whether the Y precedes (\) or follows
(/) the functor. An English lexicon should contain
categories such as S\N and (S\N)/N for verbs: both
transitive and intransitive verbs subcategorize for a
preceding subject, and the transitive verb addition-
ally takes an object to its right. In this manner,
the argument slots of lexical categories also define
word-word dependencies between heads and their
arguments (Clark and Hockenmaier, 2002; Hocken-
maier and Steedman, 2007). Modifiers are gener-
ally of the form X|X: in English, pre-nominal adjec-
tives are N/N, whereas adverbs may be (N/N)/(N/N),
S/S, or S\S, and prepositions can have categories
such as (N\N)/N or (S\S)/N. That is, CCG assumes
that the direction of the corresponding dependency
goes from the modifier to the head. This discrep-
ancy between CCG and most other analyses can eas-
ily be removed under the assumption that all cate-
gories of the form X|X are modifiers whose depen-
dencies should be reversed when comparing against
other frameworks.
Adjacent constituents can be combined according
to a small, universal set of combinatory rules. For
the purposes of this work we restrict ourselves to
function application and B1 composition:
X/Y Y ? X (>)
90
Y X\Y ? X (<)
X/Y Y|iZ ? X|iZ (B1>)
Y|iZ X\Y ? X|iZ (B1<)
Here the slash variable |i can be instantiated with
either the forward or backward slash.
These rules allow derivations (parses) such as:
The man ate quickly
DT NNS VBD RB
N/N N S\N S\S
> <B
N S\N
<
S
CCG also has unary type-raising rules of the form
X ? T/(T\X) ( >T)
X ? T\(T/X) ( <T)
We only allow nouns to be type-raised, and impose
the restriction that the argument T\N (or T/N) of the
type-raised category has to already be present in the
lexicon of the language.
This restricted set of combinatory rules provides
sufficient power for reasonable parse accuracy but
does not allow us to capture non-projective (cross-
ing) dependencies.
Coordination is handled by a ternary rule
X conj X ? X (>)
which we binarize as:
X X[conj] ? X (< &)
conj X ? X[conj] (> &)
Punctuation, when present, can be absorbed by
rules of the form
X Pct ? X (< p)
Pct X ? X (> p)
The iterative combination of these categories re-
sulting in S or N is considered a successful parse. In
order to avoid spurious ambiguities, we restrict our
derivations to be normal-form (Hockenmaier and
Bisk, 2010).
3 An algorithm for unsupervised CCG
induction
We now describe our induction algorithm, which
consists of two stages: category induction (creation
of the grammar), followed by parameter estimation
for the probability model.
3.1 Category induction
We assume there are two atomic categories, N (nouns
or noun phrases) and S (sentences), a special con-
junction category conj, and a special start symbol
TOP. We assume that all strings we encounter are
either nouns or sentences:
N? TOP S? TOP
We also assume that we can group POS-tags into
four groups: nominal tags, verbal tags, conjunctions,
and others. This allows us to create an initial lexicon
L(0), which only contains entries for atomic cate-
gories, e.g. for the English Penn Treebank tag set
(Marcus et al, 1993):
N : {NN,NNS,NNP,PRP,DT}
S : {MD,VB,VBZ,VBG,VBN,VBD}
conj : {CC}
We force any string that contains one or more verbs
(besides VBG in English), to be parsed with the S?
TOP rule.
Since the initial lexicon would only allow us
to parse single word utterances (or coordinations
thereof), we need to induce complex functor cat-
egories. The lexicon entries for atomic categories
remain, but all POS-tags, including nouns and con-
junctions, will be able to acquire complex categories
during induction. We impose the following con-
straints on the lexical categories we induce:
1. Nouns (N) do not take any arguments.
2. The heads of sentences (S|...) and modifiers
(X|X, (X|X)|(X|X)) may take N or S as arguments.
3. Sentences (S) may only take nouns (N) as argu-
ments.
(We assume S\S and S/S are modifiers).
4. Modifiers (X/X or X\X) can be modified
by categories of the form (X/X)|(X/X) or
(X\X)|(X\X).
5. The maximal arity of any lexical category is 3.
6. Since (S\N)/N is completely equivalent to
(S/N)\N, we only allow the former category.
Induction is an iterative process. At each stage,
we aim to parse all sentences Si in our training cor-
pus D = {S1, ...., SD} with the current lexicon
91
L(t). In order to parse a sentence S = w0...wn, all
words wi ? S need to have lexical categories that al-
low a complete parse (resulting in a constituent TOP
that spans the entire sentence). Initially, only some
words will have lexical categories:
The man ate quickly
DT NNS VBD RB
- N S -
We assume that any word may modify adjacent con-
stituents:
The man ate quickly
DT NNS VBD RB
N/N N, S/S S, N\N S\S
We also assume that any word that previously had
a category other than N (which we postulate does
not take any arguments) can take any adjacent non-
modifier category as argument, leading us here to
introduce S\N for the verb:
The man ate quickly
DT NNS VBD RB
N/N N, S/S S, N\N, S\N S\S
With these categories, we obtain the correct parse:
The man ate quickly
DT NNS VBD RB
N/N N S\N S\S
> <B
N S\N
<
S
We then update the lexicon with all new tag-category
pairs that have been found, excluding those that did
not lead to a successful parse:
N/N : {DT} S\N : {VBD,VBZ} S\S : {RB,NNS,IN}
The first stage of induction can only introduce func-
tors of arity 1, but many words, such as prepositions
or transitive verbs, require more complex categories,
leading us to complete, but incorrect parses such as
The man eats with friends
DT NNS VBZ IN NNS
N/N N S\N S\S S\S
> <B
N S\N
<B
S\N
<
S
During the second iteration, we can discover addi-
tional simple, as well as more complex, categories.
We now discover transitive verb categories:
The man ate chips
DT NNS VBD NNS
N/N N (S\N)/N N
> >
N S\N
<
S
The second stage also introduces a large number
of complex modifiers of the form (X/X)|(X/X) or
(X\X)|(X\X), e.g.:
The man ate very quickly
DT NNS VBD RB RB
N/N, N, S/S S, N\N, S\S, S\S,
(S/S)/(S/S) (N\N)/(N\N) S\N (S\S)/(S\S) (S\S)\(S\S)
(N/N)\(N/N) (S/S)\(S/S) (N\N)\(N\N)
(S\S)/(S\S)
The final induction step takes adjacent constituents
that can be derived from the existing lexicon into
account. This allows us to induce (S\S)/N for IN,
since we can combine a and friend to N.
3.2 Parameter estimation
After constructing the lexicon, we parse the training
corpus, and use the Inside-Outside algorithm (Lari
and Young, 1991), a variant of the Expectation-
Maximization algorithm for probabilistic context-
free grammars, to estimate model parameters. We
use the baseline model of Hockenmaier and Steed-
man (2002), which is a simple generative model that
is equivalent to an unlexicalized PCFG. In a CFG,
the set of terminals and non-terminals is disjoint, but
in CCG, not every category can be lexical. Since
this model is also the basis of a lexicalized model
that captures dependencies, it distinguishes between
lexical expansions (which produce words), unary ex-
pansions (which are the result of type-raising or the
TOP rules), binary expansions where the head is the
left child, and binary expansions whose head is the
right child. Each tree is generated top-down from the
start category TOP. For each (parent) node, first its
expansion type exp ? {Lex,Unary,Left,Right} is
generated. Based on the expansion type, the model
then produces either the word w, or the category of
the head child (H), and, possibly the category of the
non-head sister category (S):
92
Lexical pe(exp=Lex | P)? pw(w | P, exp=Lex)
Unary pe(exp=Unary | P)? pH(H | P, exp=Unary)
Left pe(exp=Left | P)? pH(H | P, exp=Left)
? pS(S | P,H, exp=Left)
Right pe(exp=Right | P)? pH(H | P, exp=Right)
? pS(S | P,H, exp=Right)
3.3 Dependency generation
We use the following regime for generating depen-
dencies from the resulting CCG derivations:
1. Arguments Y are dependents of their heads X|Y
2. Modifiers X|X are dependents of their heads X
or X|Y.
3. The head of the entire string is a dependent of
the root node (0)
4. Following the CoNLL-07 shared task represen-
tation (Johansson and Nugues, 2007), we ana-
lyze coordinations (X1 conj X2) as creating a
dependency from the first conjunct, X1, to the
conjunction conj, and from conj to the sec-
ond conjunct X2.
In the case of parse failures we return a right-
branching dependency tree.
3.4 Training details
The data provided includes fine, coarse and univer-
sal part-of-speech tags. Additionally, the data was
split into train, test and development sets though the
organizers encouraged merging the data for train-
ing. Finally, while punctuation was present, it was
not evaluated but potentially provided an additional
source of signal during training and test. We chose
from among these options and maximum sentence
length based on performance on the development
set. We primarily focused on training with shorter
sentences but grew the dataset if necessary or if, as
is the case in Arabic, there was very little short sen-
tence data. Our final training settings were:
Language Tags Max Len Punc
Arabic Fine 40 X
Basque Coarse 20
Childes Fine 20 X
Czech Fine 10
Danish Fine 20 X
Dutch Fine 10 X
Slovene Fine 10 X
Swedish Fine 15
PTB Fine 10
Portuguese Fine 10
In the case of Czech, we only trained on the test-
set because the data set was so large and the results
from randomly downsampling the merged dataset
were equivalent to simply using the previously de-
fined test-set.
3.5 Future directions
Since our current system is so simple, there is ample
space for future work. We plan to investigate the
effect of more complex statistical models and priors
that have been shown to be helpful in dependency
grammar-based systems. We also wish to relax the
assumption that we know in advance which part-of-
speech tags are nouns, verbs, or conjunctions.
4 Final observations regarding evaluation
Although the analysis of constructions involving ba-
sic head-argument and head-modifier dependencies
is generally uncontroversial, many common con-
structions allow a number of plausible analyses.
This makes it very difficult to evaluate and compare
different unsupervised approaches for grammar in-
duction. The corpora used in this workshop also
assume different conventions for a number of con-
structions. Figure 1 shows the three different types
of analysis for coordination adopted by the corpora
used in this shared task (as well as the standard
CCG analysis). The numbers to the side indicate
for each corpus what percentage of our system?s er-
ror rate is due to missed dependencies within coor-
dinated structures (i.e between a conjunction and a
conjunct, or between two conjuncts). It is important
to note that the way in which we extract dependen-
cies from coordinations is somewhat arbitrary (and
completely independent of the underlying probabil-
ity model, which currently captures no explicit de-
93
WILS-12
Ar 25.5%
Eu 22.6%
??? ????? ??? ???????
Childes 7.7%
Cz 21.4%
Da 13.1%
Nl 15.3%
PTB 18.1%
??? ????? ??? ???????
WILS-12
Sl 17.2%
Sv 11.1%
??? ????? ??? ???????
WILS-12 & CoNLL-07
Pt 7.8%
??? ????? ??? ???????
Standard CCG
Figure 1: Different analyses of coordination in the
various corpora used in this shared task. Our sys-
tem adopts the CoNLL-07 convention, instead of the
standard CCG analysis. For the development set of
each corpus, we also indicate what percentage of the
errors our system makes is due to missed coordina-
tion dependencies.
pendencies). These systematic differences of anal-
ysis are also reflected in our final results. The only
exception is the Childes corpus, where coordination
is significantly rarer.
However, this is a general problem. There are
many other constructions for which no agreed-upon
standard exists. For example, the Wall Street Journal
data used in this shared task assumes a dependency
between the verb of the main clause and the verb of
a subordinate clause, whereas the CoNLL-07 anal-
ysis stipulates a dependency between the main verb
and the subordinating conjunction:
??????????????????????????????????????
??????????????????????????????????????
(a) CoNLL-07
??????????????????????????????????????
??????????????????????????????????????
(b) WILS-12
We therefore believe that much further work is
required to address the problems surrounding eval-
uation and comparison of unsupervised induction
systems adequately. Even if the community can-
not agree on a single gold standard, systems should
not be penalized for producing one kind of linguisti-
cally plausible analysis over another. The systematic
divergences that arise with coordination for our ap-
proach are relatively easy to fix, since we only need
to change the way in which we read off dependen-
cies. But this points to a deeper underlying problem
that affects the entire field.
Acknowledgements
This research is supported by the National Science
Foundation through CAREER award 1053856 and
award 0803603.
References
Yonatan Bisk and Julia Hockenmaier. 2012. Simple Ro-
bust Grammar Induction with Combinatory Categorial
Grammars. In Association for the Advancement of Ar-
tificial Intelligence.
Prachya Boonkwan and Mark Steedman. 2011. Gram-
mar Induction from Text Using Small Syntactic Pro-
totypes. In International Joint Conference on Natural
Language Processing, pages 438?446, November.
Stephen Clark and Julia Hockenmaier. 2002. Evaluating
a wide-coverage CCG parser. In Proceedings of the
LREC Beyond PARSEVAL workshop, page 2002, Las
Palmas, Spain.
S. B. Cohen and N. A. Smith. 2010. Covariance in unsu-
pervised learning of probabilistic grammars. Journal
of Machine Learning Research, 11:3017?3051.
Trevor Cohn, Phil Blunsom, and Sharon Goldwater.
2011. Inducing tree-substitution grammars. Jour-
nal of Machine Learning Research, pages 3053?3096,
November.
Julia Hockenmaier and Yonatan Bisk. 2010. Normal-
form parsing for Combinatory Categorial Grammars
with generalized composition and type-raising. In
COLING.
Julia Hockenmaier and Mark Steedman. 2002. Gen-
erative models for statistical parsing with Combina-
tory Categorial Grammar. In Association for Compu-
tational Linguistics, pages 335?342.
Julia Hockenmaier and Mark Steedman. 2007. CCG-
bank: a corpus of CCG derivations and dependency
structures extracted from the Penn Treebank. Compu-
tational Linguistics, pages 355?396, January.
94
Richard Johansson and Pierre Nugues. 2007. Extended
constituent-to-dependency conversion for english. In
Proceedings of NODALIDA 2007, Tartu, Estonia.
K Lari and S Young. 1991. Applications of stochastic
context-free grammars using the inside-outside algo-
rithm. Computer speech & language, 5(3):237?257,
January.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a large annotated cor-
pus of English: the Penn Treebank. Computational
Linguistics, 19(2):313?330.
Tahira Naseem, Harr Chen, Regina Barzilay, and Mark
Johnson. 2010. Using universal linguistic knowledge
to guide grammar induction. In Empirical Methods in
Natural Language Processing, pages 1234?1244, Oc-
tober.
Mark Steedman. 2000. The syntactic process. MIT
Press, January.
95
