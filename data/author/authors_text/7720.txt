Proceedings of the 12th Conference of the European Chapter of the ACL, pages 763?771,
Athens, Greece, 30 March ? 3 April 2009. c?2009 Association for Computational Linguistics
Semi-supervised Training for the Averaged Perceptron POS Tagger
Drahom??ra ?johanka? Spoustova? Jan Hajic? Jan Raab Miroslav Spousta
Institute of Formal and Applied Linguistics
Faculty of Mathematics and Physics,
Charles University Prague, Czech Republic
{johanka,hajic,raab,spousta}@
ufal.mff.cuni.cz
Abstract
This paper describes POS tagging exper-
iments with semi-supervised training as
an extension to the (supervised) averaged
perceptron algorithm, first introduced for
this task by (Collins, 2002). Experiments
with an iterative training on standard-sized
supervised (manually annotated) dataset
(106 tokens) combined with a relatively
modest (in the order of 108 tokens) un-
supervised (plain) data in a bagging-like
fashion showed significant improvement
of the POS classification task on typo-
logically different languages, yielding bet-
ter than state-of-the-art results for English
and Czech (4.12 % and 4.86 % relative er-
ror reduction, respectively; absolute accu-
racies being 97.44 % and 95.89 %).
1 Introduction
Since 2002, we have seen a renewed interest in
improving POS tagging results for English, and
an inflow of results (initial or improved) for many
other languages. For English, after a relatively big
jump achieved by (Collins, 2002), we have seen
two significant improvements: (Toutanova et al,
2003) and (Shen et al, 2007) pushed the results
by a significant amount each time.1
1In our final comparison, we have also included the re-
sults of (Gime?nez and Ma`rquez, 2004), because it has sur-
passed (Collins, 2002) as well and we have used this tag-
ger in the data preparation phase. See more details below.
Most recently, (Suzuki and Isozaki, 2008) published their
Semi-supervised sequential labelling method, whose results
on POS tagging seem to be optically better than (Shen et al,
2007), but no significance tests were given and the tool is not
available for download, i.e. for repeating the results and sig-
nificance testing. Thus, we compare our results only to the
tools listed above.
Even though an improvement in POS tagging
might be a questionable enterprise (given that its
effects on other tasks, such as parsing or other
NLP problems are less than clear?at least for En-
glish), it is still an interesting problem. Moreover,
the ?ideal?2 situation of having a single algorithm
(and its implementation) for many (if not all) lan-
guages has not been reached yet. We have cho-
sen Collins? perceptron algorithm because of its
simplicity, short training times, and an apparent
room for improvement with (substantially) grow-
ing data sizes (see Figure 1). However, it is clear
that there is usually little chance to get (substan-
tially) more manually annotated data. Thus, we
have been examining the effect of adding a large
monolingual corpus to Collins? perceptron, appro-
priately extended, for two typologically different
languages: English and Czech. It is clear however
that the features (feature templates) that the tag-
gers use are still language-dependent.
One of the goals is also to have a fast im-
plementation for tagging large amounts of data
quickly. We have experimented with various clas-
sifier combination methods, such as those de-
scribed in (Brill and Wu, 1998) or (van Halteren et
al., 2001), and got improved results, as expected.
However, we view this only as a side effect (yet, a
positive one)?our goal was to stay on the turf of
single taggers, which are both the common ground
for competing on tagger accuracy today and also
significantly faster at runtime.3 Nevertheless, we
have found that it is advantageous to use them to
(pre-)tag the large amounts of plain text data dur-
2We mean easy to use for further research on problems
requiring POS tagging, especially multilingual ones.
3And much easier to (re)implement as libraries in proto-
type systems, which is often difficult if not impossible with
other people?s code.
763
Training data size (thousands of tokens)
Accu
racy
 on d
evel
opm
ent d
ata
100 200 300 400 500 600 700 800 900
96.0
96.5
97.0
97.5
98.0
Figure 1: Accuracy of the original averaged per-
ceptron, supervised training on PTB/WSJ (En-
glish)
ing the training phase.
Apart from feeding the perceptron by various
mixtures of manually tagged (?supervised?) and
auto-tagged (?unsupervised?)4 data, we have also
used various feature templates extensively; for ex-
ample, we use lexicalization (with the added twist
of lemmatization, useful especially for Czech, an
inflectionally rich language), ?manual? tag clas-
sification into large classes (again, useful espe-
cially for Czech to avoid the huge, still-to-be-
overcome data sparseness for such a language5),
and sub-lexical features mainly targeted at OOV
words. Inspired i.a. by (Toutanova et al, 2003)
and (Hajic? and Vidova?-Hladka?, 1998), we also use
?lookahead? features (however, we still remain
in the left-to-right HMM world ? in this respect
our solution is closer to the older work of (Hajic?
and Vidova?-Hladka?, 1998) than to (Toutanova et
al., 2003), who uses bidirectional dependencies
to include the right-hand side disambiguated tags,
4For brevity, we will use the terms ?supervised? and ?un-
supervised? data for ?manually annotated? and ?(automat-
ically annotated) plain (raw) text? data, respectively, even
though these adjectives are meant to describe the process of
learning, not the data themselves.
5As (Hajic?, 2004) writes, Czech has 4400 plausible tags,
of which we have observed almost 2000 in the 100M cor-
pus we have used in our experiments. However, only 1100
of them have been found in the manually annotated PDT 2.0
corpus (the corpus on which we have based the supervised
experiments). The situation with word forms (tokens) is even
worse: Czech has about 20M different word forms, and the
OOV rate based on the 1.5M PDT 2.0 data and measured
against the 100M raw corpus is almost 10 %.
which we cannot.)
To summarize, we can describe our system as
follows: it is based on (Votrubec, 2006)?s imple-
mentation of (Collins, 2002), which has been fed
at each iteration by a different dataset consisting
of the supervised and unsupervised part: precisely,
by a concatenation of the manually tagged training
data (WSJ portion of the PTB 3 for English, mor-
phologically disambiguated data from PDT 2.0 for
Czech) and a chunk of automatically tagged unsu-
pervised data. The ?parameters? of the training
process (feature templates, the size of the unsu-
pervised chunks added to the trainer at each itera-
tion, number of iterations, the combination of tag-
gers that should be used in the auto-tagging of the
unsupervised chunk, etc.) have been determined
empirically in a number of experiments on a de-
velopment data set. We should also note that as a
result of these development-data-based optimiza-
tions, no feature pruning has been employed (see
Section 4 for details); adding (even lexical) fea-
tures from the auto-tagged data did not give signif-
icant accuracy improvements (and only made the
training very slow).
The final taggers have surpassed the current
state-of-the-art taggers by significant margins (we
have achieved 4.12 % relative error reduction for
English and 4.86 % for Czech over the best pre-
viously published results, single or combined),
using a single tagger. However, the best En-
glish tagger combining some of the previous state-
of-the-art ones is still ?optically? better (yet not
significantly?see Section 6).
2 The perceptron algorithm
We have used the Morc?e6 tagger (Votrubec, 2006)
as a main component in our experiments. It is a
reimplementation of the averaged perceptron de-
scribed in (Collins, 2002), which uses such fea-
tures that it behaves like an HMM tagger and thus
the standard Viterbi decoding is possible. Collins?
GEN(x) set (a set of possible tags at any given
position) is generated, in our case, using a mor-
phological analyzer for the given language (essen-
6The name ?Morc?e? stands for ?MORfologie C?Es?tiny?
(?Czech morphology?, see (Votrubec, 2006)), since it
has been originally developed for Czech. We keep this
name in this paper as the generic name of the aver-
aged perceptron tagger for the English-language experi-
ments as well. We have used the version available at
http://ufal.mff.cuni.cz/morce/.
764
tially, a dictionary that returns all possible tags7
for an input word form). The transition and out-
put scores for the candidate tags are based on a
large number of binary-valued features and their
weights, which are determined during iterative
training by the averaged perceptron algorithm.
The binary features describe the tag being pre-
dicted and its context. They can be derived from
any information we already have about the text at
the point of decision (respecting the HMM-based
overall setting). Every feature can be true or false
in a given context, so we can consider the true fea-
tures at the current position to be the description
of a tag and its context.
For every feature, the perceptron keeps its
weight coefficient, which is (in its basic version)
an integer number, (possibly) changed at every
training sentence. After its final update, this in-
teger value is stored with the feature to be later
retrieved and used at runtime. Then, the task of
the perceptron algorithm is to sum up all the co-
efficients of true features in a given context. The
result is passed to the Viterbi algorithm as a tran-
sition and output weight for the current state.8 We
can express it as
w(C, T ) =
n?
i=1
?i.?i(C, T ) (1)
where w(C, T ) is the transition weight for tag T
in context C, n is the number of features, ?i is the
weight coefficient of the ith feature and ?i(C, T )
is the evaluation of the ith feature for context C
and tag T . In the averaged perceptron, the val-
ues of every coefficient are added up at each up-
date, which happens (possibly) at each training
sentence, and their arithmetic average is used in-
stead.9 This trick makes the algorithm more re-
sistant to weight oscillations during training (or,
more precisely, at the end of it) and as a result, it
substantially improves its performance.10
7And lemmas, which are then used in some of the fea-
tures. A (high recall, low precision) ?guesser? is used for
OOV words.
8Which identifies unambiguously the corresponding tag.
9Implementation note: care must be taken to avoid inte-
ger overflows, which (at 100 iterations through millions of
sentences) can happen for 32bit integers easily.
10Our experiments have shown that using averaging helps
tremendously, confirming both the theoretical and practical
results of (Collins, 2002). On Czech, using the best feature
set, the difference on the development data set is 95.96 % vs.
95.02 %. Therefore, all the results presented in the following
text use averaging.
The supervised training described in (Collins,
2002) uses manually annotated data for the esti-
mation of the weight coefficients ?. The train-
ing algorithm is very simple?only integer num-
bers (counts and their sums for the averaging) are
updated for each feature at each sentence with
imperfect match(es) found against the gold stan-
dard. Therefore, it can be relatively quickly re-
trained and thus many different feature sets and
other training parameters, such as the number of
iterations, feature thresholds etc. can be con-
sidered and tested. As a result of this tuning,
our (fully supervised) version of the Morc?e tag-
ger gives the best accuracy among all single tag-
gers for Czech and also very good results for En-
glish, being beaten only by the tagger (Shen et al,
2007) (by 0.10 % absolute) and (not significantly)
by (Toutanova et al, 2003).
3 The data
3.1 The ?supervised? data
For English, we use the same data division of Penn
Treebank (PTB) parsed section (Marcus et al,
1994) as all of (Collins, 2002), (Toutanova et al,
2003), (Gime?nez and Ma`rquez, 2004) and (Shen
et al, 2007) do; for details, see Table 1.
data set tokens sentences
train (0-18) 912,344 38,220
dev-test (19-21) 131,768 5,528
eval-test (22-24) 129,654 5,463
Table 1: English supervised data set ? WSJ part
of Penn Treebank 3
For Czech, we use the current standard Prague
Dependency Treebank (PDT 2.0) data sets (Hajic?
et al, 2006); for details, see Table 2.
data set tokens sentences
train 1,539,241 91,049
dev-test 201,651 11,880
eval-test 219,765 13,136
Table 2: Czech supervised data set ? Prague De-
pendency Treebank 2.0
3.2 The ?unsupervised? data
For English, we have processed the North Amer-
ican News Text corpus (Graff, 1995) (without the
765
WSJ section) with the Stanford segmenter and to-
kenizer (Toutanova et al, 2003). For Czech, we
have used the SYN2005 part of Czech National
Corpus (CNC, 2005) (with the original segmenta-
tion and tokenization).
3.3 GEN(x): The morphological analyzers
For English, we perform a very simple morpholog-
ical analysis, which reduces the full PTB tagset to
a small list of tags for each token on input. The re-
sulting list is larger than such a list derived solely
from the PTB/WSJ, but much smaller than a full
list of tags found in the PTB/WSJ.11 The English
morphological analyzer is thus (empirically) opti-
mized for precision while keeping as high recall
as possible (it still overgenerates). It consists of a
small dictionary of exceptions and a small set of
general rules, thus covering also a lot of OOV to-
kens.12
For Czech, the separate morphological analyzer
(Hajic?, 2004) usually precedes the tagger. We use
the version from April 2006 (the same as (Spous-
tova? et al, 2007), who reported the best previous
result on Czech tagging).
4 The perceptron feature sets
The averaged perceptron?s accuracy is determined
(to a large extent) by the set of features used. A
feature set is based on feature templates, i.e. gen-
eral patterns, which are filled in with concrete val-
ues from the training data. Czech and English
are morphosyntactically very different languages,
therefore each of them needs a different set of
feature templates. We have empirically tested
hundreds of feature templates on both languages,
taken over from previous works for direct compar-
ison, inspired by them, or based on a combination
of previous experience, error analysis and linguis-
tic intuition.
In the following sections, we present the best
performing set of feature templates as determined
on the development data set using only the super-
vised training setting; our feature templates have
thus not been influenced nor extended by the un-
supervised data.13
11The full list of tags, as used by (Shen et al, 2007), also
makes the underlying Viterbi algorithm unbearably slow.
12The English morphology tool is also downloadable as a
separate module on the paper?s accompanying website.
13Another set of experiments has shown that there is not,
perhaps surprisingly, a significant gain in doing so.
4.1 English feature templates
The best feature set for English consists of 30 fea-
ture templates. All templates predict the current
tag as a whole. A detailed description of the En-
glish feature templates can be found in Table 3.
Context predicting whole tag
Tags
Previous tag
Previous two tags
First letter of previous tag
Word forms
Current word form
Previous word form
Previous two word forms
Following word form
Following two word forms
Last but one word form
Current word affixes
Prefixes of length 1-9
Suffixes of length 1-9
Current word features
Contains number
Contains dash
Contains upper case letter
Table 3: Feature templates for English
A total of 1,953,463 features has been extracted
from the supervised training data using the tem-
plates from Table 3.
4.2 Czech feature templates
The best feature set for Czech consists of 63 fea-
ture templates. 26 of them predict current tag as
a whole, whereas the rest predicts only some parts
of the current tag separately (e.g., detailed POS,
gender, case) to avoid data sparseness. Such a fea-
ture is true, in an identical context, for several dif-
ferent tags belonging to the same class (e.g., shar-
ing a locative case). The individual grammatical
categories used for such classing have been cho-
sen on both linguistic grounds (POS, detailed fine-
grained POS) and also such categories have been
used which contribute most to the elimination of
the tagger errors (based on an extensive error anal-
ysis of previous results, the detailed description of
which can be found in (Votrubec, 2006)).
Several features can look ahead (to the right
of the current position) - apart from the obvious
word form, which is unambiguous, we have used
(in case of ambiguity) a random tag and lemma of
the first position to the right from the current po-
sition which might be occupied with a verb (based
on dictionary and the associated morphological
guesser restrictions).
A total of 8,440,467 features has been extracted
from the supervised training data set. A detailed
description is included in the distribution down-
loadable from the Morc?e website.
766
5 The (un)supervised training setup
We have extended the averaged perceptron setup
in the following way: the training algorithm is
fed, in each iteration, by a concatenation of the
supervised data (the manually tagged corpus) and
the automatically pre-tagged unsupervised data,
different for each iteration (in this order). In
other words, the training algorithm proper does
not change at all: it is the data and their selection
(including the selection of the way they are auto-
matically tagged) that makes all the difference.
The following ?parameters? of the (unsuper-
vised part of the) data selection had to be deter-
mined experimentally:
? the tagging process for tagging the selected
data
? the selection mechanism (sequential or ran-
dom with/without replacement)
? the size to use for each iteration
? and the use and order of concatenation with
the manually tagged data.
We have experimented with various settings to
arrive at the best performing configuration, de-
scribed below. In each subsection, we compare
the result of our ,,winning? configuration with re-
sults of the experiments which have the selected
attributes omitted or changed; everything is mea-
sured on the development data set.
5.1 Tagging the plain data
In order to simulate the labeled training events,
we have tagged the unsupervised data simply by
a combination of the best available taggers. For
practical reasons (to avoid prohibitive training
times), we have tagged all the data in advance, i.e.
no re-tagging is performed between iterations.
The setup for the combination is as follows (the
idea is simplified from (Spoustova? et al, 2007)
where it has been used in a more complex setting):
1. run N different taggers independently;
2. join the results on each position in the data
from the previous step ? each token thus
ends up with between 1 and N tags, a union
of the tags output by the taggers at that posi-
tion;
3. do final disambiguation (by a single tag-
ger14).
Tagger Accuracy
Morc?e 97.21
Shen 97.33
Combination 97.44
Table 4: Dependence on the tagger(s) used to tag
the additional plain text data (English)16
Table 4 illustrates why it is advantageous to go
through this (still)16 complicated setup against a
single-tagger bootstrapping mechanism, which al-
ways uses the same tagger for tagging the unsu-
pervised data.
For both English and Czech, the selection of
taggers, the best combination and the best over-
all setup has been optimized on the development
data set. A bit surprisingly, the final setup is very
similar for both languages (two taggers to tag the
data in Step 1, and a third one to finish it up).
For English, we use three state-of-the-art tag-
gers: the taggers of (Toutanova et al, 2003) and
(Shen et al, 2007) in Step 1, and the SVM tag-
ger (Gime?nez and Ma`rquez, 2004) in Step 3. We
run the taggers with the parameters which were
shown to be the best in the corresponding papers.
The SVM tagger needed to be adapted to accept
the (reduced) list of possible tags.17
For Czech, we use the Feature-based tagger
(Hajic?, 2004) and the Morc?e tagger (with the new
feature set as described in section 4) in Step 1, and
an HMM tagger (Krbec, 2005) in Step 3. This
combination outperforms the results in (Spoustova?
et al, 2007) by a small margin.
5.2 Selection mechanism for the plain data
We have found that it is better to feed the training
with different chunks of the unsupervised data at
each iteration. We have then experimented with
14This tagger (possibly different from any of theN taggers
from Step 1) runs as usual, but it is given a minimal list of (at
most N ) tags that come from Step 2 only.
15?Accuracy? means accuracy of the semi-supervised
method using this tagger for pre-tagging the unsupervised
data, not the accuracy of the tagger itself.
16In fact, we have experimented with other tagger
combinations and configurations as well?with the TnT
(Brants, 2000), MaxEnt (Ratnaparkhi, 1996) and TreeTag-
ger (Schmid, 1994), with or without the Morc?e tagger in the
pack; see below for the winning combination.
17This patch is available on the paper?s website (see Sec-
tion 7).
767
three methods of unsupervised data selection, i.e.
generating the unsupervised data chunks for each
training iteration from the ,,pool? of sentences.
These methods are: simple sequential chopping,
randomized data selection with replacement and
randomized selection without replacement. Ta-
ble 5 demonstrates that there is practically no dif-
ference in the results. Thus, we use the sequential
chopping mechanism, mainly for its simplicity.
Method of data selection English Czech
Sequential chopping 97.44 96.21
Random without replacement 97.44 96.20
Random with replacement 97.44 96.21
Table 5: Unsupervised data selection
5.3 Joining the data
We have experimented with various sizes of the
unsupervised parts (from 500k tokens to 5M) and
also with various numbers of iterations. The best
results (on the development data set) have been
achieved with the unsupervised chunks containing
approx. 4 million tokens for English and 1 million
tokens for Czech. Each training process consists
of (at most) 100 iterations (Czech) or 50 iterations
(English); therefore, for the 50 (100) iterations we
needed only about 200,000,000 (100,000,000) to-
kens of raw texts. The best development data set
results have been (with the current setup) achieved
on the 44th (English) and 33th (Czech) iteration.
The development data set has been also used to
determine the best way to ?merge? the manually
labeled data (the PTB/WSJ and the PDT 2.0 train-
ing data) and the unsupervised parts of the data.
Given the properties of the perceptron algorithm,
it is not too surprising that the best solution is to
put (the full size of) the manually labeled data first,
followed by the (four) million-token chunk of the
automatically tagged data (different data in each
chunk but of the same size for each iteration). It
corresponds to the situation when the trainer is pe-
riodically ?returned to the right track? by giving it
the gold standard data time to time.
Figure 2 (English) and especially Figure 3
(Czech) demonstrate the perceptron behavior in
cases where the supervised data precede the un-
supervised data only in selected iterations. A sub-
set of these development results is also present in
Table 6.
0 10 20 30 40 509
7.20
97.2
5
97.3
0
97.3
5
97.4
0
Iteration
Accu
racy
 on d
evel
opm
ent d
ata
Every iterationEvery 4th iterationEvery 8th iterationEvery 16th iterationOnce at the beginning    No supervised data
Figure 2: Dependence on the inclusion of the su-
pervised training data (English)
English Czech
No supervised data 97.37 95.88
Once at the beginning 97.40 96.00
Every training iteration 97.44 96.21
Table 6: Dependence on the inclusion of the su-
pervised training data
5.4 The morphological analyzers and the
perceptron feature templates
The whole experiment can be performed with
the original perceptron feature set described in
(Collins, 2002) instead of the feature set described
in this article. The results are compared in Table 7
(for English only).
Also, for English it is not necessary to use our
morphological analyzer described in section 3.3
(other variants are to use the list of tags derived
solely from the WSJ training data or to give each
token the full list of tags found in WSJ). It is
practically impossible to perform the unsupervised
training with the full list of tags (it would take sev-
eral years instead of several days with the default
setup), thus we compare only the results with mor-
phological analyzer to the results with the list of
tags derived from the training data, see Table 8.
It can be expected (some approximated exper-
iments were performed) that the results with the
full list of tags would be very similar to the results
with the morphological analyzer, i.e. the morpho-
logical analyzer is used mainly for technical rea-
sons. Our expectations are based mainly (but not
768
0 10 20 30 40 50
95.6
95.7
95.8
95.9
96.0
96.1
96.2
Iteration
Accu
racy
 on d
evel
opm
ent d
ata
Every iterationEvery 4th iterationEvery 8th iterationEvery 16th iterationOnce at the beginning    No supervised data
Figure 3: Dependence on the inclusion of the su-
pervised training data (Czech)
only) on the supervised training results, where the
performance of the taggers using the morpholog-
ical analyzer output and using the full list of tags
are nearly the same, see Table 9.
Feature set Accuracy
Collins? 97.38
Our?s 97.44
Table 7: Dependence on the feature set used by the
perceptron algorithm (English)
GEN(x) Accuracy
List of tags derived from train 97.13
Our morphological analyzer 97.44
Table 8: Dependence on the GEN(x)
6 Results
In Tables 10 and 11, the main results (on the eval-
test data sets) are summarized. The state-of-the
art taggers are using feature sets discribed in the
corresponding articles ((Collins, 2002), (Gime?nez
and Ma`rquez, 2004), (Toutanova et al, 2003) and
(Shen et al, 2007)), Morc?e supervised and Morc?e
semi-supervised are using feature set desribed in
section 4.
For significance tests, we have used the paired
Wilcoxon signed rank test as implemented in the
R package (R Development Core Team, 2008)
GEN(x) Accuracy
List of tags derived from train 95.89
Our morphological analyzer 97.17
Full tagset 97.15
Table 9: Supervised training results: dependence
on the GEN(x)
Tagger accuracy
Collins 97.07 %
SVM 97.16 %
Stanford 97.24 %
Shen 97.33 %
Morc?e supervised 97.23 %
combination 97.48 %
Morc?e semi-supervised 97.44 %
Table 10: Evaluation of the English taggers
Tagger accuracy
Feature-based 94.04 %
HMM 94.82 %
Morc?e supervised 95.67 %
combination 95.70 %
Morc?e semi-supervised 95.89 %
Table 11: Evaluation of the Czech taggers
in wilcox.test(), dividing the data into 100
chunks (data pairs).
6.1 English
The combination of the three existing English tag-
gers seems to be best, but it is not significantly
better than our semi-supervised approach.
The combination is significantly better than
(Shen et al, 2007) at a very high level, but more
importantly, Shen?s results (currently represent-
ing the replicable state-of-the-art in POS tagging)
have been significantly surpassed also by the semi-
supervised Morc?e (at the 99 % confidence level).
In addition, the semi-supervised Morc?e per-
forms (on single CPU and development data set)
77 times faster than the combination and 23 times
faster than (Shen et al, 2007).
6.2 Czech
The best results (Table 11) are statistically signif-
icantly better than the previous results: the semi-
supervised Morc?e is significantly better than both
769
the combination and the supervised (original) vari-
ant at a very high level.
7 Download
We decided to publish our system for wide use un-
der the name COMPOST (Common POS Tagger).
All the programs, patches and data files are avail-
able at the website http://ufal.mff.cuni.cz/compost
under either the original data provider license, or
under the usual GNU General Public License, un-
less they are available from the widely-known and
easily obtainable sources (such as the LDC, in
which case pointers are provided on the download
website).
The Compost website also contains easy-to-run
Linux binaries of the best English and Czech sin-
gle taggers (based on the Morc?e technology) as de-
scribed in Section 6.
8 Conclusion and Future Work
We have shown that the ?right?18 mixture of su-
pervised and unsupervised (auto-tagged) data can
significantly improve tagging accuracy of the av-
eraged perceptron on two typologically different
languages (English and Czech), achieving the best
known accuracy to date.
To determine what is the contribution of the in-
dividual ?dimensions? of the system setting, as
described in Sect. 5, we have performed exper-
iments fixing all but one of the dimensions, and
compared their contribution (or rather, their loss
when compared to the best ?mix? overall). For
English, we found that excluding the state-of-the-
art-tagger (in fact, a carefully selected combina-
tion of taggers yielding significantly higher qual-
ity than any of them has) drops the resulting ac-
curacy the most (0.2 absolute). Significant yet
smaller drop (less than 0.1 percent) appears when
the manually tagged portion of the data is not used
or used only once (or infrequently) in the input
to the perceptron?s learner. The difference in us-
ing various feature templates (yet al largely sim-
ilar to what state-of-the-art taggers currently use)
is not significant. Similarly, the way the unsuper-
vised data is selected plays no role, either; this dif-
fers from the bagging technique (Breiman, 1996)
where it is significant. For Czech, the drop in ac-
curacy appears in all dimensions, except the unsu-
pervised data selection one. We have used novel
features inspired by previous work but not used in
18As empirically determined on the development data set.
the standard perceptron setting yet (linguistically
motivated tag classes in features, lookahead fea-
tures). Interestingly, the resulting tagger is better
than even a combination of the previous state-of-
the-art taggers (for English, this comparison is in-
conclusive).
We are working now on parallelization of the
perceptron training, which seems to be possible
(based i.a. on small-scale preliminary experiments
with only a handful of parallel processes and
specific data sharing arrangements among them).
This would further speed up the training phase, not
just as a nice bonus per se, but it would also allow
for a semi-automated feature template selection,
avoiding the (still manual) feature template prepa-
ration for individual languages. This would in turn
facilitate one of our goals to (publicly) provide
single-implementation, easy-to-maintain state-of-
the-art tagging tools for as many languages as pos-
sible (we are currently preparing Dutch, Slovak
and several other languages).19
Another area of possible future work is more
principled tag classing for languages with large
tagsets (in the order of 103), and/or adding
syntactically-motivated features; it has helped
Czech tagging accuracy even when only the ?in-
trospectively? defined classes have been added. It
is an open question if a similar approach helps
English as well (certain grammatical categories
can be generalized from the current WSJ tagset as
well, such as number, degree of comparison, 3rd
person present tense).
Finally, it would be nice to merge some of the
approaches by (Toutanova et al, 2003) and (Shen
et al, 2007) with the ideas of semi-supervised
learning introduced here, since they seem orthog-
onal in at least some aspects (e.g., to replace the
rudimentary lookahead features with full bidirec-
tionality).
Acknowledgments
The research described here was supported by the
projects MSM0021620838 and LC536 of Ministry
of Education, Youth and Sports of the Czech Re-
public, GA405/09/0278 of the Grant Agency of the
Czech Republic and 1ET101120503 of Academy
of Sciences of the Czech Republic.
19Available soon also on the website.
770
References
Thorsten Brants. 2000. TnT - a Statistical Part-of-
Speech Tagger. In Proceedings of the 6th Applied
Natural Language Processing Conference, pages
224?231, Seattle, WA. ACL.
Leo Breiman. 1996. Bagging predictors. Mach.
Learn., 24(2):123?140.
Eric Brill and Jun Wu. 1998. Classifier Combination
for Improved Lexical Disambiguation. In Proceed-
ings of the 17th international conference on Compu-
tational linguistics, pages 191?195, Montreal, Que-
bec, Canada. Association for Computational Lin-
guistics.
CNC, 2005. Czech National Corpus ? SYN2005. In-
stitute of Czech National Corpus, Faculty of Arts,
Charles University, Prague, Czech Republic.
Michael Collins. 2002. Discriminative Training Meth-
ods for Hidden Markov Models: Theory and Exper-
iments with Perceptron Algorithms. In EMNLP ?02:
Proceedings of the ACL-02 conference on Empirical
methods in natural language processing, volume 10,
pages 1?8, Philadelphia, PA.
Jesu?s Gime?nez and Llu??s Ma`rquez. 2004. SVMTool:
A General POS Tagger Generator Based on Support
Vector Machines. In Proceedings of the 4th Interna-
tional Conference on Language Resources and Eval-
uation, pages 43?46, Lisbon, Portugal.
David Graff, 1995. North American News Text Cor-
pus. Linguistic Data Consortium, Cat. LDC95T21,
Philadelphia, PA.
Jan Hajic? and Barbora Vidova?-Hladka?. 1998. Tag-
ging Inflective Languages: Prediction of Morpho-
logical Categories for a Rich, Structured Tagset.
In Proceedings of the 17th international conference
on Computational linguistics, pages 483?490. Mon-
treal, Quebec, Canada.
Jan Hajic?. 2004. Disambiguation of Rich Inflection
(Computational Morphology of Czech). Nakladatel-
stv?? Karolinum, Prague.
Jan Hajic?, Eva Hajic?ova?, Jarmila Panevova?, Petr Sgall,
Petr Pajas, Jan S?te?pa?nek, Jir??? Havelka, and Marie
Mikulova?. 2006. Prague Dependency Treebank
v2.0, CDROM, LDC Cat. No. LDC2006T01. Lin-
guistic Data Consortium, Philadelphia, PA.
Pavel Krbec. 2005. Language Modelling for Speech
Recognition of Czech. Ph.D. thesis, UK MFF,
Prague, Malostranske? na?me?st?? 25, 118 00 Praha 1.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1994. Building a large anno-
tated corpus of English: The Penn Treebank. Com-
putational Linguistics, 19(2):313?330.
R Development Core Team, 2008. R: A Language and
Environment for Statistical Computing. R Foun-
dation for Statistical Computing, Vienna, Austria.
ISBN 3-900051-07-0.
Adwait Ratnaparkhi. 1996. A maximum entropy
model for part-of-speech tagging. In Proceedings
of the 1st EMNLP, pages 133?142, New Brunswick,
NJ. ACL.
Helmut Schmid. 1994. Probabilistic part-of-speech
tagging using decision trees. In Proceedings of the
International Conference on New Methods in Lan-
guage Processing, page 9pp., Manchester, GB.
Libin Shen, Giorgio Satta, and Aravind K. Joshi. 2007.
Guided Learning for Bidirectional Sequence Classi-
fication. In Proceedings of the 45th Annual Meet-
ing of the Association of Computational Linguistics,
pages 760?767, Prague, Czech Republic, June. As-
sociation for Computational Linguistics.
Drahom??ra ?johanka? Spoustova?, Jan Hajic?, Jan
Votrubec, Pavel Krbec, and Pavel Kve?ton?. 2007.
The Best of Two Worlds: Cooperation of Statistical
and Rule-Based Taggers for Czech. In Proceedings
of the Workshop on Balto-Slavonic Natural Lan-
guage Processing 2007, pages 67?74, Prague, Czech
Republic, June. Association for Computational Lin-
guistics.
Jun Suzuki and Hideki Isozaki. 2008. Semi-supervised
sequential labeling and segmentation using giga-
word scale unlabeled data. In Proceedings of ACL-
08: HLT, pages 665?673, Columbus, Ohio, June.
Association for Computational Linguistics.
Kristina Toutanova, Dan Klein, Christopher D. Man-
ning, and Yoram Singer. 2003. Feature-Rich Part-
of-Speech Tagging with a Cyclic Dependency Net-
work. In NAACL ?03: Proceedings of the 2003 Con-
ference of the North American Chapter of the As-
sociation for Computational Linguistics on Human
Language Technology, pages 173?180, Edmonton,
Canada. Association for Computational Linguistics.
Hans van Halteren, Walter Daelemans, and Jakub Za-
vrel. 2001. Improving accuracy in word class
tagging through the combination of machine learn-
ing systems. Computational Linguistics, 27(2):199?
229.
Jan Votrubec. 2006. Morphological Tagging Based
on Averaged Perceptron. In WDS?06 Proceedings of
Contributed Papers, pages 191?195, Prague, Czech
Republic. Matfyzpress, Charles University.
771
Unsupervised Relation Extraction from Web Documents
Kathrin Eichler, Holmer Hemsen and Gu?nter Neumann
DFKI GmbH, LT-Lab, Stuhlsatzenhausweg 3 (Building D3 2), D-66123 Saarbru?cken
{FirstName.SecondName}@dfki.de
Abstract
The IDEX system is a prototype of an interactive dynamic Information Extraction (IE) system. A user of the system
expresses an information request in the form of a topic description, which is used for an initial search in order to retrieve
a relevant set of documents. On basis of this set of documents, unsupervised relation extraction and clustering is done by
the system. The results of these operations can then be interactively inspected by the user. In this paper we describe the
relation extraction and clustering components of the IDEX system. Preliminary evaluation results of these components are
presented and an overview is given of possible enhancements to improve the relation extraction and clustering components.
1. Introduction
Information extraction (IE) involves the process of au-
tomatically identifying instances of certain relations of
interest, e.g., produce(<company>, <product>, <lo-
cation>), in some document collection and the con-
struction of a database with information about each
individual instance (e.g., the participants of a meet-
ing, the date and time of the meeting). Currently, IE
systems are usually domain-dependent and adapting
the system to a new domain requires a high amount
of manual labour, such as specifying and implement-
ing relation?specific extraction patterns manually (cf.
Fig. 1) or annotating large amounts of training cor-
pora (cf. Fig. 2). These adaptations have to be made
offline, i.e., before the specific IE system is actually
made. Consequently, current IE technology is highly
statical and inflexible with respect to a timely adapta-
tion to new requirements in the form of new topics.
Figure 1: A hand-coded rule?based IE?system (schemat-
ically): A topic expert implements manually task?specific
extraction rules on the basis of her manual analysis of a
representative corpus.
1.1. Our goal
The goal of our IE research is the conception and im-
plementation of core IE technology to produce a new
Figure 2: A data?oriented IE system (schematically): The
task?specific extraction rules are automatically acquired by
means of Machine Learning algorithms, which are using
a sufficiently large enough corpus of topic?relevant docu-
ments. These documents have to be collected and costly
annotated by a topic?expert.
IE system automatically for a given topic. Here, the
pre?knowledge about the information request is given
by a user online to the IE core system (called IDEX)
in the form of a topic description (cf. Fig. 3). This
initial information source is used to retrieve relevant
documents and extract and cluster relations in an un-
supervised way. In this way, IDEX is able to adapt
much better to the dynamic information space, in par-
ticular because no predefined patterns of relevant re-
lations have to be specified, but relevant patterns are
determined online. Our system consists of a front-end,
which provides the user with a GUI for interactively in-
specting information extracted from topic-related web
documents, and a back-end, which contains the rela-
tion extraction and clustering component. In this pa-
per, we describe the back-end component and present
preliminary evaluation results.
1.2. Application potential
However, before doing so we would like to motivate
the application potential and impact of the IDEX ap-
Figure 3: The dynamic IE system IDEX (schematically):
a user of the IDEX IE system expresses her information
request in the form of a topic description which is used for
an initial search in order to retrieve a relevant set of doc-
uments. From this set of documents, the system extracts
and collects (using the IE core components of IDEX) a set
of tables of instances of possibly relevant relations. These
tables are presented to the user (who is assumed to be the
topic?expert), who will analyse the data further for her in-
formation research. The whole IE process is dynamic, since
no offline data is required, and the IE process is interactive,
since the topic expert is able to specify new topic descrip-
tions, which express her new attention triggered by a novel
relationship she was not aware of beforehand.
proach by an example application. Consider, e.g., the
case of the exploration and the exposure of corruptions
or the risk analysis of mega construction projects. Via
the Internet, a large pool of information resources of
such mega construction projects is available. These
information resources are rich in quantity, but also
in quality, e.g., business reports, company profiles,
blogs, reports by tourists, who visited these construc-
tion projects, but also web documents, which only
mention the project name and nothing else. One of
the challenges for the risk analysis of mega construc-
tion projects is the efficient exploration of the possibly
relevant search space. Developing manually an IE sys-
tem is often not possible because of the timely need
of the information, and, more importantly, is proba-
bly not useful, because the needed (hidden) informa-
tion is actually not known. In contrast, an unsuper-
vised and dynamic IE system like IDEX can be used
to support the expert in the exploration of the search
space through pro?active identification and clustering
of structured entities. Named entities like for example
person names and locations, are often useful indicators
of relevant text passages, in particular, if the names are
in some relationship. Furthermore, because the found
relationships are visualized using an advanced graph-
ical user interface, the user can select specific names
and find associated relationships to other names, the
documents they occur in or she can search for para-
phrases of sentences.
2. System architecture
The back-end component, visualized in Figure 4, con-
sists of three parts, which are described in detail in this
section: preprocessing, relation extraction and relation
clustering.
2.1. Preprocessing
In the first step, for a specific search task, a topic of
interest has to be defined in the form of a query. For
this topic, documents are automatically retrieved from
the web using the Google search engine. HTML and
PDF documents are converted into plain text files. As
the tools used for linguistic processing (NE recogni-
tion, parsing, etc.) are language-specific, we use the
Google language filter option when downloading the
documents. However, this does not prevent some doc-
uments written in a language other than our target
language (English) from entering our corpus. In ad-
dition, some web sites contain text written in several
languages. In order to restrict the processing to sen-
tences written in English, we apply a language guesser
tool, lc4j (Lc4j, 2007) and remove sentences not clas-
sified as written in English. This reduces errors on
the following levels of processing. We also remove sen-
tences that only contain non-alphanumeric characters.
To all remaining sentences, we apply LingPipe (Ling-
Pipe, 2007) for sentence boundary detection, named
entity recognition (NER) and coreference resolution.
As a result of this step database tables are created,
containing references to the original document, sen-
tences and detected named entities (NEs).
2.2. Relation extraction
Relation extraction is done on the basis of parsing po-
tentially relevant sentences. We define a sentence to be
of potential relevance if it at least contains two NEs.
In the first step, so-called skeletons (simplified depen-
dency trees) are extracted. To build the skeletons, the
Stanford parser (Stanford Parser, 2007) is used to gen-
erate dependency trees for the potentially relevant sen-
tences. For each NE pair in a sentence, the common
root element in the corresponding tree is identified and
the elements from each of the NEs to the root are col-
lected. An example of a skeleton is shown in Figure 5.
In the second step, information based on dependency
types is extracted for the potentially relevant sen-
tences. Focusing on verb relations (this can be ex-
tended to other types of relations), we collect for each
verb its subject(s), object(s), preposition(s) with ar-
guments and auxiliary verb(s). We can now extract
verb relations using a simple algorithm: We define a
verb relation to be a verb together with its arguments
(subject(s), object(s) and prepositional phrases) and
consider only those relations to be of interest where at
least the subject or the object is an NE. We filter out
relations with only one argument.
2.3. Relation clustering
Relation clusters are generated by grouping relation
instances based on their similarity.
web documents document
retrieval
topic specific documents plain text documents
sentence/documents+
 NE tables
languagefiltering
syntactic +typed dependencyparsing 
sov?relationsskeletons +
clustering
conversion
Preprocessing
Relation extraction
Relation clustering
sentencesrelevant
filtering of
relationfiltering
table of clustered relations
sentence boundary
resolutioncoreference
detection,NE recognition,
Figure 4: System architecture
Figure 5: Skeleton for the NE pair ?Hohenzollern? and ?Brandenburg? in the sentence ?Subsequent members of
the Hohenzollern family ruled until 1918 in Berlin, first as electors of Brandenburg.?
The comparably large amount of data in the corpus
requires the use of an efficient clustering algorithm.
Standard ML clustering algorithms such as k-means
and EM (as provided by the Weka toolbox (Witten
and Frank, 2005)) have been tested for clustering the
relations at hand but were not able to deal with the
large number of features and instances required for an
adequate representation of our dataset. We thus de-
cided to use a scoring algorithm that compares a re-
lation to other relations based on certain aspects and
calculates a similarity score. If this similarity score ex-
ceeds a predefined threshold, two relations are grouped
together.
Similarity is measured based on the output from the
different preprocessing steps as well as lexical informa-
tion from WordNet (WordNet, 2007):
? WordNet: WordNet information is used to deter-
mine if two verb infinitives match or if they are in
the same synonym set.
? Parsing: The extracted dependency information is
used to measure the token overlap of the two sub-
jects and objects, respectively. We also compare
the subject of the first relation with the object of
the second relation and vice versa. In addition,
we compare the auxiliary verbs, prepositions and
preposition arguments found in the relation.
? NE recognition: The information from this step
is used to count how many of the NEs occurring
in the contexts, i.e., the sentences in which the
two relations are found, match and whether the
NE types of the subjects and objects, respectively,
match.
? Coreference resolution: This type of information
is used to compare the NE subject (or object) of
one relation to strings that appear in the same
coreference set as the subject (or object) of the
second relation.
Manually analyzing a set of extracted relation in-
stances, we defined weights for the different similarity
measures and calculated a similarity score for each re-
lation pair. We then defined a score threshold and clus-
tered relations by putting two relations into the same
cluster if their similarity score exceeded this threshold
value.
3. Experiments and results
For our experiments, we built a test corpus of doc-
uments related to the topic ?Berlin Hauptbahnhof?
by sending queries describing the topic (e.g., ?Berlin
Hauptbahnhof?, ?Berlin central station?) to Google
and downloading the retrieved documents specifying
English as the target language. After preprocessing
these documents as described in 2.1., our corpus con-
sisted of 55,255 sentences from 1,068 web pages, from
which 10773 relations were automatically extracted
and clustered.
3.1. Clustering
From the extracted relations, the system built 306 clus-
ters of two or more instances, which were manually
evaluated by two authors of this paper. 81 of our clus-
ters contain two or more instances of exactly the same
relation, mostly due to the same sentence appearing in
several documents of the corpus. Of the remaining 225
clusters, 121 were marked as consistent, 35 as partly
consistent, 69 as not consistent. We defined consis-
tency based on the potential usefulness of a cluster to
the user and identified three major types of potentially
useful clusters:
? Relation paraphrases, e.g.,
accused (Mr Moore, Disney, In letter)
accused (Michael Moore, Walt Disney
Company)
? Different instances of the same pattern, e.g.,
operates (Delta, flights, from New York)
offers (Lufthansa, flights, from DC)
? Relations about the same topic (NE), e.g.,
rejected (Mr Blair, pressure, from Labour
MPs)
reiterated (Mr Blair, ideas, in speech, on
March)
created (Mr Blair, doctrine)
...
Of our 121 consistent clusters, 76 were classified as be-
ing of the type ?same pattern?, 27 as being of the type
?same topic? and 18 as being of the type ?relation para-
phrases?. As many of our clusters contain two instances
only, we are planning to analyze whether some clusters
should be merged and how this could be achieved.
3.2. Relation extraction
In order to evaluate the performance of the relation ex-
traction component, we manually annotated 550 sen-
tences of the test corpus by tagging all NEs and verbs
and manually extracting potentially interesting verb
relations. We define ?potentially interesting verb rela-
tion? as a verb together with its arguments (i.e., sub-
ject, objects and PP arguments), where at least two
of the arguments are NEs and at least one of them
is the subject or an object. On the basis of this crite-
rion, we found 15 potentially interesting verb relations.
For the same sentences, the IDEX system extracted 27
relations, 11 of them corresponding to the manually
extracted ones. This yields a recall value of 73% and
a precision value of 41%.
There were two types of recall errors: First, errors in
sentence boundary detection, mainly due to noisy in-
put data (e.g., missing periods), which lead to parsing
errors, and second, NER errors, i.e., NEs that were
not recognised as such. Precision errors could mostly
be traced back to the NER component (sequences of
words were wrongly identified as NEs).
In the 550 manually annotated sentences, 1300 NEs
were identified as NEs by the NER component. 402
NEs were recognised correctly by the NER, 588
wrongly and in 310 cases only parts of an NE were
recognised. These 310 cases can be divided into three
groups of errors. First, NEs recognised correctly, but
labeled with the wrong NE type. Second, only parts
of the NE were recognised correctly, e.g., ?Touris-
mus Marketing GmbH? instead of ?Berlin Tourismus
Marketing GmbH?. Third, NEs containing additional
words, such as ?the? in ?the Brandenburg Gate?.
To judge the usefulness of the extracted relations, we
applied the following soft criterion: A relation is con-
sidered useful if it expresses the main information given
by the sentence or clause, in which the relation was
found. According to this criterion, six of the eleven
relations could be considered useful. The remaining
five relations lacked some relevant part of the sen-
tence/clause (e.g., a crucial part of an NE, like the
?ICC? in ?ICC Berlin?).
4. Possible enhancements
With only 15 manually extracted relations out of 550
sentences, we assume that our definition of ?potentially
interesting relation? is too strict, and that more inter-
esting relations could be extracted by loosening the ex-
traction criterion. To investigate on how the criterion
could be loosened, we analysed all those sentences in
the test corpus that contained at least two NEs in order
to find out whether some interesting relations were lost
by the definition and how the definition would have to
be changed in order to detect these relations. The ta-
ble in Figure 6 lists some suggestions of how this could
be achieved, together with example relations and the
number of additional relations that could be extracted
from the 550 test sentences.
In addition, more interesting relations could be
found with an NER component extended by more
types, e.g., DATE and EVENT. Open domain NER
may be useful in order to extract NEs of additional
types. Also, other types of relations could be inter-
esting, such as relations between coordinated NEs,
option example additional relations
extraction of relations,
where the NE is not the
complete subject, object or
PP argument, but only part
of it
Co-operation with <ORG>M.A.X.
2001<\ORG> <V>is<\V> clearly of
benefit to <ORG>BTM<\ORG>.
25
extraction of relations with
a complex VP
<ORG>BTM<\ORG> <V>invited and or
supported<\V> more than 1,000 media rep-
resentatives in <LOC>Berlin<\LOC>.
7
resolution of relative pro-
nouns
The <ORG>Oxford Centre for Maritime
Archaeology<\ORG> [...] which will
<V>conduct<\V> a scientific symposium in
<LOC>Berlin<\LOC>.
2
combination of several of the
options mentioned above
<LOC>Berlin<\LOC> has <V>developed to
become<\V> the entertainment capital of
<LOC>Germany<\LOC>.
7
Figure 6: Table illustrating different options according to which the definition of ?potentially interesting relation?
could be loosened. For each option, an example sentence from the test corpus is given, together with the number
of relations that could be extracted additionally from the test corpus.
e.g., in a sentence like The exhibition [...] shows
<PER>Clemens Brentano<\PER>, <PER>Achim
von Arnim<\PER> and <PER>Heinrich von
Kleist<\PER>, and between NEs occurring in the
same (complex) argument, e.g., <PER>Hanns Peter
Nerger<\PER>, CEO of <ORG>Berlin Tourismus
Marketing GmbH (BTM) <\ORG>, sums it up [...].
5. Related work
Our work is related to previous work on domain-
independent unsupervised relation extraction, in par-
ticular Sekine (2006), Shinyama and Sekine (2006) and
Banko et al (2007).
Sekine (2006) introduces On-demand information ex-
traction, which aims at automatically identifying
salient patterns and extracting relations based on these
patterns. He retrieves relevant documents from a
newspaper corpus based on a query and applies a POS
tagger, a dependency analyzer and an extended NE
tagger. Using the information from the taggers, he ex-
tracts patterns and applies paraphrase recognition to
create sets of semantically similar patterns. Shinyama
and Sekine (2006) apply NER, coreference resolution
and parsing to a corpus of newspaper articles to ex-
tract two-place relations between NEs. The extracted
relations are grouped into pattern tables of NE pairs
expressing the same relation, e.g., hurricanes and their
locations. Clustering is performed in two steps: they
first cluster all documents and use this information to
cluster the relations. However, only relations among
the five most highly-weighted entities in a cluster are
extracted and only the first ten sentences of each arti-
cle are taken into account.
Banko et al (2007) use a much larger corpus, namely
9 million web pages, to extract all relations between
noun phrases. Due to the large amount of data, they
apply POS tagging only. Their output consists of mil-
lions of relations, most of them being abstract asser-
tions such as (executive, hired by, company) rather
than concrete facts.
Our approach can be regarded as a combination of
these approaches: Like Banko et al (2007), we extract
relations from noisy web documents rather than com-
parably homogeneous news articles. However, rather
than extracting relations from millions of pages we re-
duce the size of our corpus beforehand using a query in
order to be able to apply more linguistic preprocessing.
Like Sekine (2006) and Shinyama and Sekine (2006),
we concentrate on relations involving NEs, the assump-
tion being that these relations are the potentially in-
teresting ones. The relation clustering step allows us
to group similar relations, which can, for example, be
useful for the generation of answers in a Question An-
swering system.
6. Future work
Since many errors were due to the noisiness of the ar-
bitrarily downloaded web documents, a more sophisti-
cated filtering step for extracting relevant textual infor-
mation from web sites before applying NE recognition,
parsing, etc. is likely to improve the performance of
the system.
The NER component plays a crucial role for the qual-
ity of the whole system, because the relation extraction
component depends heavily on the NER quality, and
thereby the NER quality influences also the results of
the clustering process. A possible solution to improve
NER in the IDEX System is to integrate a MetaNER
component, combining the results of several NER com-
ponents. Within the framework of the IDEX project
a MetaNER component already has been developed
(Heyl, to appear 2008), but not yet integrated into the
prototype. The MetaNER component developed uses
the results from three different NER systems. The out-
put of each NER component is weighted depending on
the component and if the sum of these values for a pos-
sible NE exceeds a certain threshold it is accepted as
NE otherwise it is rejected.
The clustering step returns many clusters containing
two instances only. A task for future work is to in-
vestigate, whether it is possible to build larger clus-
ters, which are still meaningful. One way of enlarging
cluster size is to extract more relations. This could
be achieved by loosening the extraction criteria as de-
scribed in section 4. Also, it would be interesting to see
whether clusters could be merged. This would require
a manual analysis of the created clusters.
Acknowledgement
The work presented here was partially supported by a
research grant from the?Programm zur Fo?rderung von
Forschung, Innovationen und Technologien (ProFIT)?
(FKZ: 10135984) and the European Regional Develop-
ment Fund (ERDF).
7. References
Michele Banko, Michael J. Cafarella, Stephen Soder-
land, Matthew Broadhead, and Oren Etzioni. 2007.
Open information extraction from the web. In Proc.
of the International Joint Conference on Artificial
Intelligence (IJCAI).
Andrea Heyl. to appear 2008. Unsupervised relation
extraction. Master?s thesis, Saarland University.
Lc4j. 2007. Language categorization library for Java.
http://www.olivo.net/software/lc4j/.
LingPipe. 2007. http://www.alias-i.com/lingpipe/.
Satoshi Sekine. 2006. On-demand information extrac-
tion. In ACL. The Association for Computer Lin-
guistics.
Yusuke Shinyama and Satoshi Sekine. 2006. Preemp-
tive information extraction using unrestricted re-
lation discovery. In Proc. of the main conference
on Human Language Technology Conference of the
North American Chapter of the Association of Com-
putational Linguistics, pages 304?311. Association
for Computational Linguistics.
Stanford Parser. 2007. http://nlp.stanford.edu/
downloads/lex-parser.shtml.
Ian H. Witten and Eibe Frank. 2005. Data Min-
ing: Practical machine learning tools and techniques.
Morgan Kaufmann, San Francisco, 2nd edition.
WordNet. 2007. http://wordnet.princeton.edu/.
Balto-Slavonic Natural Language Processing 2007, June 29, 2007, pages 43?50,
Prague, June 2007. c?2007 Association for Computational Linguistics
Towards the Automatic Extraction of Definitions in Slavic
1Adam Przepio?rkowski
2?ukasz Dego?rski
8Beata Wo?jtowicz
Institute of Computer Science PAS
Ordona 21, Warsaw, Poland
adamp@ipipan.waw.pl
ldegorski@bach.ipipan.waw.pl
beataw@bach.ipipan.waw.pl
4Kiril Simov
5Petya Osenova
Institute for Parallel Processing BAS
Bonchev St. 25A, Sofia, Bulgaria
kivs@bultreebank.org
petya@bultreebank.org
3Miroslav Spousta
7Vladislav Kubon?
Charles University
Malostranske? na?me?st?? 25
Prague, Czech Republic
spousta@ufal.ms.mff.cuni.cz
vk@ufal.ms.mff.cuni.cz
6Lothar Lemnitzer
University of Tu?bingen
Wilhelmstr. 19, Tu?bingen, Germany
lothar@sfs.uni-tuebingen.de
Abstract
This paper presents the results of the prelim-
inary experiments in the automatic extrac-
tion of definitions (for semi-automatic glos-
sary construction) from usually unstructured
or only weakly structured e-learning texts
in Bulgarian, Czech and Polish. The ex-
traction is performed by regular grammars
over XML-encoded morphosyntactically-
annotated documents. The results are less
than satisfying and we claim that the rea-
son for that is the intrinsic difficulty of the
task, as measured by the low interannota-
tor agreement, which calls for more sophis-
ticated deeper linguistic processing, as well
as for the use of machine learning classifica-
tion techniques.
1 Introduction
The aim of this paper is to report on the preliminary
results of a subtask of the European Project Lan-
guage Technology for eLearning (http://www.
lt4el.eu/) consisting in the identification of
term definitions in eLearning materials (Learning
Objects; henceforth: LOs), where definitions are
understood pragmatically, as those text fragments
which may, after perhaps some minor editing, be
put into a glossary. Such automatically extracted
term definitions are to be presented to the author or
the maintainer of the LO and, thus, significantly fa-
cilitate and accelerate the creation of a glossary for
a given LO. From this specification of the task it fol-
lows that good recall is much more important than
good precision, as it is easier to reject wrong glos-
sary candidates than to browse the LO for term def-
initions which were not automatically spotted.
The project involves 9 European languages in-
cluding 3 Slavic (and, regrettably, no Baltic) lan-
guages: one South Slavic, i.e., Bulgarian, and two
West Slavic, i.e., Czech and Polish. For all lan-
guages, shallow grammars identifying definitions
have been constructed; after mentioning some previ-
ous work on Information Extraction (IE) for Slavic
languages and on extraction of definitions in sec-
tion 2, we briefly describe the three Slavic grammars
developed within this project in section 3. Section 4
presents the results of the application of these gram-
mars to LOs in respective languages. These results
are evaluated in section 5, where main problems, as
well as some possible solutions, are discussed. Fi-
nally, section 6 concludes the paper.
43
2 Related Work
Definition extraction is an important NLP task,
most frequently a subtask of terminology extraction
(Pearson, 1996), the automatic creation of glossaries
(Klavans and Muresan, 2000; Klavans and Muresan,
2001), question answering (Miliaraki and Androut-
sopoulos, 2004; Fahmi and Bouma, 2006), learning
lexical semantic relations (Malaise? et al, 2004; Stor-
rer and Wellinghoff, 2006) and automatic construc-
tion of ontologies (Walter and Pinkal, 2006). Tools
for definition extraction are invariably language-
specific and involve shallow or deep processing,
with most work done for English (Pearson, 1996;
Klavans and Muresan, 2000; Klavans and Muresan,
2001) and other Germanic languages (Fahmi and
Bouma, 2006; Storrer and Wellinghoff, 2006; Wal-
ter and Pinkal, 2006), as well as French (Malaise? et
al., 2004). To the best of our knowledge, no previ-
ous attempts at definition extraction have been made
for Slavic, with the exception of some work on Bul-
garian (Tanev, 2004; Simov and Osenova, 2005).
Other work on Slavic information extraction has
been carried out mainly for the last 5 years. Prob-
ably the first forum where such work was compre-
hensively presented was the International Workshop
on Information Extraction for Slavonic and Other
Central and Eastern European Languages (IESL),
RANLP, Borovets, 2003, Bulgaria. One of the pa-
pers presented there, (Droz?dz?yn?ski et al, 2003), dis-
cusses shallow SProUT (Becker et al, 2002) gram-
mars for Czech, Polish and Lithuanian. SProUT has
subsequently been extensively used for the informa-
tion extraction from Polish medical texts (Piskorski
et al, 2004; Marciniak et al, 2005).1
3 Shallow Grammars for Definition
Extraction
The input to the task of definition extraction is
XML-encoded morphosyntactically-annotated text,
possibly with some keywords already marked by an
1SProUT has not been seriously considered for the task at
hand for two reasons: first, it was decided that only open source
tools will be used in the current project, if only available, sec-
ond, the input format to the current task is morphosyntactically-
annotated XML-encoded text, rather than raw text, as normally
expected by SProUT. The second obstacle could be removed by
converting input texts to the SProUT-internal XML representa-
tion.
independent process. For example, the representa-
tion of a Polish sentence starting as Konstruktywizm
k?adzie nacisk na (Eng. ?Constructivism puts em-
phasis on?) may be as follows:2
<s id="s9">
<markedTerm id="mt7" kw="y">
<tok base="konstruktywizm" ctag="subst"
id="t253"
msd="sg:nom:m3">Konstruktywizm</tok>
</markedTerm>
<tok base="klasc" ctag="fin" id="t254"
msd="sg:ter:imperf">kladzie</tok>
<tok base="nacisk" ctag="subst" id="t255"
msd="sg:acc:m3">nacisk</tok>
<tok base="na" ctag="prep" id="t256"
msd="acc">na</tok>
[...]
<tok base="." ctag="interp" id="t273">.
</tok>
</s>
For each language, definitions were manually
marked in two batches of texts: the first batch, con-
sulted during the process of grammar development,
contained at least 300 definitions, and the second
batch, held out for evaluation, contained about 150
definitions. All grammars are regular grammars im-
plemented with the use of the lxtransduce tool
(Tobin, 2005), a component of the LTXML2 toolset
developed at the University of Edinburgh.3 An ex-
ample of a simple rule for prepositional phrases is
given below:
<rule name="PP">
<seq>
<query match="tok[@ctag = ?prep?]"/>
<ref name="NP1">
<with-param name="case" value="??"/>
</ref>
</seq>
</rule>
This rule identifies a sequence whose first element
is a token tagged as a preposition and whose subse-
quent elements are identified by a rule called NP1.
This latter rule (not shown here for brevity) is a pa-
rameterised rule which finds a nominal phrase of a
given case, but the way it is called above ensures that
it will find an NP of any case.
2Part of the representation has been replaced by ?[...]?.
3Among the tools considered here were also CLaRK (Simov
et al, 2001), ultimately rejected because it currently does not
work in batch mode, and GATE / JAPE (Cunningham et al,
2002), not used here because we found GATE?s handling of
previously XML-annotated texts rather cumbersome and ill-
documented. Cf. also fn. 1.
44
Currently the grammars show varying degrees of
sophistication, with a small Bulgarian grammar (8
rules in a 2.5-kilobyte file), a larger Polish grammar
(34 rules in a 11KiB file) and a sophisticated Czech
grammar most developed (147 rules in a 28KiB
file). The patterns defined by these three grammars
are similar, but sufficiently different to defy an at-
tempt to write a single parameterised grammar.4 The
remainder of this section briefly describes the gram-
mars.
3.1 Bulgarian
The Bulgarian grammar is manually constructed af-
ter examination of the manually annotated defini-
tions. Here is a list of the rule schemata, together
with the number and percentage of matching defini-
tions:
Pattern # %
NP is NP 140 34.2
NP verb NP 18 29.8
NP - NP 21 5.0
This is NP 15 3.7
It represents NP 4 1.0
other patterns 107 26.2
Table 1: Bulgarian definition types
In the second schema above, ?verb? is a verb or
a verb phrase (not necessarily a constituent) which
is one of the following: ?????????????? (to repre-
sent), ????????? (to show), ?????????? (to mean),
???????? (to describe), ??? ????????? (to be used),
??????????? (to allow), ????? ?????????? ???
(to give opportunity), ??? ??????? (is called),
??????????? (to improve), ??????????? (to ensure),
?????? ??? (to serve as), ??? ???????? (to be under-
stood as), ???????????? (to denote), ????????? (to
contain), ?????????? (to determine), ?????????
(to include), ??? ???????? ????? (is defined as),
??? ???????? ??? (is based on).
We classify the rules in five types: copula defi-
nitions, copula definitions with anaphoric relation,
copula definitions with ellipsis of the copula, defi-
nitions with a verb phrase, definitions with a verb
4Because of this relative language-dependence of definition
patters, which includes, e.g., idiosyncratic case information,
we have not seriously considered re-using rules for other, non-
Slavic, languages.
phrase and anaphoric relation. Each of these types of
definitions defines an NP (sometimes via anaphoric
relation) by another one. There are some variations
of the models where some parenthetical expressions
are presented in the definition.
The grammar contains several most important
rules for each type. The different verb patterns are
encoded as a lexicon. For some of the rules, variants
with parenthetical phrases are also encoded. The rest
of the grammar is devoted to the recognition of noun
phrases and parenthetical phrases. For parentheti-
cal phrases, we have encoded a list of such possible
phrases, extracted on the basis of a bigger corpus.
The NP grammar in our view is the crucial grammar
for recognition of the definitions. Most work now
has to be invested into developing the more complex
and recursive NPs.
3.2 Czech
The Czech grammar for definition context extraction
is constructed to follow both linguistic intuition and
observation of common patterns in manually anno-
tated data.
We adapted a grammar5 based mainly on the ob-
servation of Czech Wikipedia entries. Encyclopedia
definitions are usually clear and very well structured,
but it is quite difficult to find such well-formed defi-
nitions in common texts, including learning objects.
The rules were extended using part of our manually
annotated texts, evaluated and adjusted in several it-
erations, based on the observation of the annotated
data.
Pattern # %
NP is/are NP 52 21.2
NP verb NP 45 18.4
structural 39 15.9
NP (NP) 30 12.2
NP -/:/= NP 20 8.2
other patterns 59 24.1
Table 2: Czech definition types
There are 21 top level rules, divided into five cate-
gories. Most of the correctly marked definitions fall
into the copula verb (?is/are?) category. The sec-
5The grammar was originally developed by Nguyen Thu
Trang.
45
ond most successful rule is the one using selected
verbs like ?definuje? (defines), ?znamen?? (means),
?vymezuje? (delimits), ?pr?edstavuje? (presents) and
several others. The remaining categories make use
of the typical patterns of characters (dash, colon,
equal sign and brackets) or additional structural in-
formation (e.g., HTML tags).
3.3 Polish
The Polish grammar rules are divided into three lay-
ers. Similarly to the Czech grammar, each layer only
refers to itself or lower layers. This allows for ex-
pressing top level rules in a clear and easily man-
ageable way.
The top level layer consists of rules representing
typical patterns found in Polish documents:
Pattern # %
NP (...) are/is NP-INS 40 15.6
NP -/: NP 39 15.2
NP (are/is) to NP-NOM 27 10.6
NP VP-3PERS 25 9.8
NP - i.e./or WH-question 11 4.3
N ADJ - PPAS 8 3.1
NP, i.e./or NP 7 2.7
NP-ACC one may
describe/define as NP-ACC 5 2.0
other patterns
(not in the grammar) 94 36.7
Table 3: Polish definition types
The middle layer consists of rules catching pat-
terns such as ?simple NP in given case, followed by
a sequence of non-punctuation elements? or ?cop-
ula?.
The bottom layer rules basically only refer to
POS markup in the input files (or other bottom layer
rules).
4 Results
As mentioned above, the testing corpus for each lan-
guage consists of about 150 definitions, unseen dur-
ing the construction of the grammar.6
6Obviously, three different corpora had to be used to eval-
uate the grammars for the three languages, but the corpora are
similar in size and character, so any differences in results stem
mostly from the differences in the three grammars.
The Bulgarian test corpus, containing around
76,800 tokens, consists of the third part of the
Calimera guidelines (http://www.calimera.
org/). We view this document as appropriate for
testing because it reflects the chosen domain and it
combines definitions from otherwise different sub-
domains, such as XML language, Internet usage,
etc. There are 203 manually annotated definitions
in this corpus: 129 definitions contained in one sen-
tence, 69 definitions split across 2 sentences, 4 def-
initions in 3 sentences and one definition in 4 sen-
tences. Note that the real test part is the set of the
129 definitions in one sentence, since the Bulgar-
ian grammar does not consider cross-sentence def-
initions in any way.
Czech data used for evaluation consist of several
chapters of the Calimera guidelines and Microsoft
Excel tutorial. The tutorial is a typical text used
in e-learning, consisting of five chapters describing
sheets, tables, formating, graphs and lists. The cor-
pus consists of over 90,000 tokens and contains 162
definitions, out of which 153 are contained in a sin-
gle sentence, 6 span 2 sentences, and 3 definitions
span 3 sentences.
Polish test corpus consists of over 83,200 tokens
containing 157 definitions: 148 definitions are con-
tained within one sentence, while 9 span 2 sen-
tences. The corpus is made up of 10 chapters of a
popular introduction to and history of computer sci-
ence and computer hardware.
Each grammar was quantitatively evaluated by
comparing manually annotated files with the same
files annotated automatically by the grammar. After
considering various ways of quantitative evaluation,
we decided to do the comparison at token level: pre-
cision was calculated as the ratio of the number of
those tokens which were parts of both a manually
marked definition and an automatically discovered
definition to the number of all tokens in automati-
cally discovered definitions, while recall was taken
to be the ratio of the number of tokens simultane-
ously in both kinds of definitions to the number of
tokens in all manually annotated definitions. Since,
for this task, recall is more important than precision,
we used the F2-measure for the combined result.7
7In general, F? = (1 + ?) ? (precision ? recall)/(? ?
precision+recall). Perhaps? larger than 2 could be used, but it
is currently not clear to us what criteria should be assumed when
46
The results for the three grammars are given in
Table 4. Note that the processing model for Czech
precision recall F2
Bulgarian 20.5% 2.2% 3.1
Czech 18.3% 40.7% 28.9
Polish 14.8% 22.2% 19.0
Table 4: Token-based evaluation of shallow gram-
mars
differs from the other two languages, as the input
text is converted to a flat format, as described in sec-
tion 5.3, and grammar rules are sensitive to sentence
boundaries (and may operate over them).
5 Evaluation and Possible Improvements
5.1 Interannotator Agreement
We calculated Cohen?s kappa statistic (1) for the cur-
rent task, where both the relative observed agree-
ment among raters Pr(a) and the probability that
agreement is due to chance Pr(e) where calculated
at token level.
? =
Pr(a) ? Pr(e)
1 ? Pr(e)
(1)
More specifically, we assumed that two annotators
agree on a token if the token belongs to a definition
either according to both annotations or according to
neither. In order to estimate the probability of agree-
ment due to chance Pr(e), we measured, separately
for each annotator, the proportion of tokens found in
definitions to all tokens in text, which resulted in two
probability estimates p1 and p2, and treated Pr(e) as
the probability that the two annotators agree if they
randomly, with their own probability, classify a to-
ken as belonging to a definition, i.e.:
Pr(e) = p1 ? p2 + (1 ? p1) ? (1 ? p2) (2)
The interannotator agreement (IAA) was mea-
sured this way for Czech and Polish, where ? for
each language ? the respective test corpus was an-
notated by two annotators. The results are 0.44 for
Czech and 0.31 for Polish. Such results are very low
for any classification task, and especially low for a
deciding on the exact value of ?. Note that it would not make
sense to use recall alone, as it is trivial to write all-accepting
grammars with 100% recall.
binary classification task. They show that the task of
identifying definitions in running texts and agreeing
on which parts of text count as a definition is intrin-
sically very difficult. They also call for the recon-
sideration of the evaluation and IAA measurement
methodology based on token classification.8
5.2 Evaluation Methodology
To the best of our knowledge, there is no estab-
lished evaluation methodology for the task of def-
inition extraction, where definitions may span sev-
eral sentences.9 For this reason we evaluated the re-
sults again, in a different way: we treated an auto-
matically discovered definition as correct, if it over-
lapped with a manually annotated definition. We
calculated precision as the number of automatic defi-
nitions overlapping with manual definitions, divided
by the number of automatic definitions, while re-
call ? as the number of manual definitions overlap-
ping automatic definitions, divided by the number of
manual definitions.10
The results for the three grammars, given in Ta-
ble 5, are much higher than those in Table 4 above,
although still less than satisfactory.
precision recall F2
Bulgarian 22.5% 8.9% 11.1
Czech 22.3% 46% 33.9
Polish 23.3% 32% 28.4
Table 5: Definition-based evaluation of shallow
grammars
5.3 Definitions and Sentence Boundaries
Regardless of the inherent difficulties of the task and
difficulties with the evaluation of the results, there
is clear room for improvement; one possible path
8A better approximation would be to measure IAA on the
basis of sentence or (as suggested by an anonymous reviewer)
NP classification; we intend to pursue this idea in future work.
9With the assumption that definitions are no longer than
a sentence, usually the task is treated as a classification task,
where sentences are classified as definitional or not, and ap-
propriate precision and recall measures are applied at sentence
level.
10At this stage definition fragments distributed across a num-
ber of different sentences were treated as different definitions,
which negatively affects the evaluation of the Bulgarian gram-
mar, as the Bulgarian test corpus contains a large number of
multi-sentence definitions.
47
to explore concerns multi-sentence definitions. As
noted above, for all languages considered here, there
were definitions which were spanning 2 or more sen-
tences; this turned out to be a problem especially for
Bulgarian, were 36% of definitions crossed a sen-
tence boundary.11
Such multi-sentence definitions are a problem be-
cause in the DTD adopted in this project definitions
are subelements of sentences rather than the other
way round. In case of a multi-sentence definition,
for each sentence there is a separate element en-
capsulating the part of the definition contained in
this sentence. Although these are linked via spe-
cial attributes and the information that they are part
of the same definition can subsequently be recov-
ered, it is difficult to construct an lxtransduce
grammar which would be able to automatically mark
such multi-sentence definitions: an lxtransduce
grammar expects to find a sequence of elements and
wrap them in a single larger element.
A solution to this technical problem has been im-
plemented in the Czech grammar, where first the in-
put text is flattened (via an XSLT script), so that,
e.g.:
<par id="d1p2">
<s id="d1p2s1">
<tok id="d1p2s1t1" base="Pavel"
ctag="N" msd="NMS1-----A----">
Pavel</tok>
<tok id="d1p2s1t2" base="satrapa"
ctag="N" msd="NMS1-----A----">
Satrapa</tok>
</s>
</par>
becomes:
<par id="Sd1p2"/>
<s id="Sd1p2s1"/>
<tok id="d1p2s1t1" base="Pavel"
ctag="N" msd="NMS1-----A----">
Pavel</tok>
<tok id="d1p2s1t2" base="satrapa"
ctag="N" msd="NMS1-----A----">
Satrapa</tok>
<s id="Ed1p2s1"/>
<par id="Ed1p2"/>
11An example of a Polish manually annotated multi-sentence
definition is: . . . opracowano techniki antyspamowe. Tech-
niki te drastycznie zaniz?aja? wartos?c? strony albo ja? banuja?. . .
(Eng. ?. . . anti-spam techniques were developed. Such tech-
niques drastically lower the value of the page or they ban it. . . ?).
The definition is split into two fragments fully contained in re-
spective sentences: techniki antyspamowe and Techniki te. . . .
No attempt at anaphora resolution is made.
This flattened representation is an input to a gram-
mar which is sensitive to the empty s and par ele-
ments and may discover definitions containing such
elements; in such a case, the postprocessing script,
which restores the hierarchical paragraph and sen-
tence structure, splits such definitions into smaller
elements, fully contained in respective sentences.
5.4 Problems Specific to Slavic
At least in case of the two West Slavic languages
considered here, the task of writing a definition
grammar is intrinsically more difficult than for Ger-
manic or Romance languages, mainly for the follow-
ing two reasons.
First, Czech and Polish have very rich nominal
inflection with a large number of paradigm-internal
syncretisms. These syncretisms are a common cause
of tagger errors, which percolate to further stages of
processing. Moreover, the number of cases makes it
more difficult to encode patterns like ?NP verb NP?,
as different verbs may combine with NPs of different
case. In fact, even two different copulas in Polish
take different cases!
Second, the relatively free word order increases
the number of rules that must be encoded, and makes
the grammar writing task more labour-intensive and
error-prone. The current version of the Polish gram-
mar, with 34 rules, is rather basic, and even the 147
rules of the Czech grammar do not take into consid-
eration all possible patterns of grammar definitions.
As Tables 4 and 5 show, there is a positive corre-
lation between the grammar size and the value of
F2, and the Bulgarian and Polish grammars certainly
have room to grow. Moreover, a path that is well
worth exploring is to drastically increase the num-
ber of rules and, hence, the recall, and then deal with
precision via Machine Learning methods (cf. sec-
tion 5.6).
5.5 Levels of Linguistic Processing
The work reported here has been an excercise in
definition extraction using shallow parsing methods.
However, the poor results suggest that this is one
of the tasks that require a much more sophisticated
and deeper approach to language analysis. In fact,
in turns out that virtually all successful attempts at
definition extraction that we are aware of build on
worked-out deep linguistic approaches (Klavans and
48
Muresan, 2000; Fahmi and Bouma, 2006; Walter
and Pinkal, 2006), some of them combining syn-
tactic and semantic information (Miliaraki and An-
droutsopoulos, 2004; Walter and Pinkal, 2006).
Unfortunately, for most Baltic and Slavic lan-
guages, such deep parsers are unavailable or have
not yet been extensively tested on real texts. One
exception is Czech, where a number of parsers were
already described and evaluated (on the Prague De-
pendency Treebank) in (Zeman, 2004, ? 14.2); the
best of these parsers reach 80?85% accuracy.
For Polish, apart from a number of linguistically
motivated toy parsers, there is a possibly wide cov-
erage deep parser (Wolin?ski, 2004), but it has not yet
been evaluated on naturally occurring texts. The sit-
uation is probably most dire for Bulgarian, although
there have been attempts at the induction of a depen-
dency parser from the BulTreeBank (Marinov and
Nivre, 2005; Chanev et al, 2006).
Nevertheless, if other possible paths of improve-
ment suggested in this section do not bring satisfac-
tory results, we plan to make an attempt at adapting
these parsers to the task at hand.
5.6 Postprocessing: Machine Learning and
Keyword Identification
Various approaches to the machine learning treat-
ment of the task of classifying sentences or snippets
as definitions or non-definitions can be found, e.g.,
in (Miliaraki and Androutsopoulos, 2004; Fahmi
and Bouma, 2006) and references therein. In the
context of the present work, such methods may be
used to postprocess apparent definitions found at
earlier processing stages and decide which of them
are genuine definitions. For example, (Fahmi and
Bouma, 2006) report that a system trained on 2299
sentences, including 1366 definition sentences, may
increase the accuracy of a definition extraction tool
from 59% to around 90%.12
Another possible improvement may consist in,
again, aiming at very high recall and then using
an independent keyword detector to mark keywords
(and key phrases) in text and classifying as genuine
definitions those definitions, whose defined term has
been marked as a keyword.
12The numbers are so high ?probably due to the fact that the
current corpus consists of encyclopedic material only? (Fahmi
and Bouma, 2006, fn. 4).
Whatever postprocessing technique or combina-
tion of techniques proves most efficient, it seems that
the linguistic processing should aim at high recall
rather than high precision, which further justifies the
use of the F2 measure for evaluation.13
6 Conclusion
To the best of our knowledge, this paper is the first
report on the task of definition extraction for a num-
ber of Slavic languages. It shows that the task is
intrinsically very difficult, which partially explains
the relatively low results obtained. It also calls atten-
tion to the fact that there is no established evaluation
methodology where possibly multi-sentence defini-
tions are involved and suggests what such method-
ology could amount to. Finally, the paper suggests
ways of improving the results, which we hope to fol-
low and report in the future.
References
Markus Becker et al 2002. SProUT ? shallow process-
ing with typed feature structures and unification. In
Proceedings of the International Conference on NLP
(ICON 2002), Mumbai, India.
Sharon A. Caraballo. 2001. Automatic Construction of a
Hypernym-Labeled Noun Hierarchy from Text. Ph. D.
dissertation, Brown University.
Atanas Chanev, Kiril Simov, Petya Osenova, and Sve-
toslav Marinov. 2006. Dependency conversion and
parsing of the BulTreeBank. In proceedings of the
LREC workshop Merging and Layering Linguistic In-
formation, Genoa, Italy.
Hamish Cunningham, Diana Maynard, Kalina
Bontcheva, and Valentin Tablan. 2002. GATE:
A framework and graphical development environment
for robust NLP tools and applications. In Proceedings
of the 40th Anniversary Meeting of the Association for
Computational Linguistics.
Witold Droz?dz?yn?ski, Petr Homola, Jakub Piskorski, and
Vytautas Zinkevic?ius. 2003. Adapting SProUT to
processing Baltic and Slavonic languages. In Infor-
mation Extraction for Slavonic and Other Central and
Eastern European Languages, pp. 18?25.
Ismail Fahmi and Gosse Bouma. 2006. Learning to iden-
tify definitions using syntactic features. In Proceed-
ings of the EACL 2006 workshop on Learning Struc-
tured Information in Natural Language Applications.
13Note that the situation here is different than in the task of
acquiring hyponymic relations from texts, where high-precision
manual rules (Hearst, 1992) must be augmented with statistical
clustering methods to increase recall (Caraballo, 2001).
49
Marti Hearst. 1992. Automatic acquisition of hy-
ponyms from large text corpora. In Proceedings of
the Fourteenth International Conference on Computa-
tional Linguistics, Nantes, France.
Judith L. Klavans and Smaranda Muresan. 2000.
DEFINDER: Rule-based methods for the extraction of
medical terminology and their associated definitions
from on-line text. In Proceedings of the Annual Fall
Symposium of the American Medical Informatics As-
sociation.
Judith L. Klavans and Smaranda Muresan. 2001. Eval-
uation of the DEFINDER system for fully automatic
glossary construction. In Proceedings of AMIA Sym-
posium 2001.
V?ronique Malais?, Pierre Zweigenbaum, and Bruno
Bachimont. 2004. Detecting semantic relations be-
tween terms in definitions. In S. Ananadiou and
P. Zweigenbaum, editors, COLING 2004 CompuTerm
2004: 3rd International Workshop on Computational
Terminology, pp. 55?62, Geneva, Switzerland. COL-
ING.
Ma?gorzata Marciniak, Agnieszka Mykowiecka, Anna
Kups?c?, and Jakub Piskorski. 2005. Intelligent con-
tent extraction from Polish medical texts. In L. Bolc
et al, editors, Intelligent Media Technology for Com-
municative Intelligence, Second International Work-
shop, IMTCI 2004, Warsaw, Poland, September 13-14,
2004, Revised Selected Papers, volume 3490 of Lec-
ture Notes in Computer Science, pp. 68?78. Springer-
Verlag.
Svetoslav Marinov and Joakim Nivre. 2005. A data-
driven parser for Bulgarian. In Proceedings of the
Fourth Workshop on Treebanks and Linguistic Theo-
ries, pp. 89?100, Barcelona.
Spyridoula Miliaraki and Ion Androutsopoulos. 2004.
Learning to identify single-snippet answers to defi-
nition questions. In Proceedings of COLING 2004,
pp. 1360?1366, Geneva, Switzerland. COLING.
Jennifer Pearson. 1996. The expression of defini-
tions in specialised texts: a corpus-based analysis.
In M. Gellerstam et al, editors, Proceedings of the
Seventh Euralex International Congress, pp. 817?824,
G?teborg.
Jakub Piskorski et al 2004. Information extraction for
Polish using the SProUT platform. In M. A. K?opotek
et al, editors, Intelligent Information Processing and
Web Mining, pp. 227?236. Springer-Verlag, Berlin.
Kiril Simov and Petya Osenova. 2005. BulQA:
Bulgarian-Bulgarian Question Answering at CLEF
2005. In CLEF, pp. 517?526.
Kiril Simov et al 2001. CLaRK ? an XML-based sys-
tem for corpora development. In P. Rayson et al, edi-
tors, Proceedings of the Corpus Linguistics 2001 Con-
ference, pp. 558?560, Lancaster.
Angelika Storrer and Sandra Wellinghoff. 2006. Auto-
mated detection and annotation of term definitions in
German text corpora. In Proceedings of LREC 2006.
Hristo Tanev. 2004. Socrates: A question answering
prototype for Bulgarian. In Recent Advances in Nat-
ural Language Processing III, Selected Papers from
RANLP 2003, pages 377?386. John Benjamins.
Richard Tobin, 2005. Lxtransduce, a replace-
ment for fsgmatch. University of Edinburgh.
http://www.cogsci.ed.ac.uk/~richard/
ltxml2/lxtransduce-manual.html.
Stephan Walter and Manfred Pinkal. 2006. Automatic
extraction of definitions from German court decisions.
In Proceedings of the Workshop on Information Ex-
traction Beyond The Document, pp. 20?28, Sydney,
Australia. Association for Computational Linguistics.
Marcin Wolin?ski. 2004. Komputerowa weryfikacja gra-
matyki S?widzin?skiego. Ph. D. dissertation, ICS PAS,
Warsaw.
Daniel Zeman. 2004. Parsing with a Statistical Depen-
dency Model. Ph. D. dissertation, Charles University,
Prague.
50
Comparable Fora
Johanka Spoustova? Miroslav Spousta
Institute of Formal and Applied Linguistics
Faculty of Mathematics and Physics,
Charles University Prague, Czech Republic
{johanka,spousta}@ufal.mff.cuni.cz
Abstract
As the title suggests, our paper deals with web
discussion fora, whose content can be consid-
ered to be a special type of comparable cor-
pora. We discuss the potential of this vast
amount of data available now on the World
Wide Web nearly for every language, regard-
ing both general and common topics as well
as the most obscure and specific ones. To il-
lustrate our ideas, we propose a case study
of seven wedding discussion fora in five lan-
guages.
1 Introduction to comparable corpora
Nearly every description of comparable corpora be-
gins with the EAGLES (Expert Advisory Group on
Language Engineering Standards) definition:1
?A comparable corpus is one which selects simi-
lar texts in more than one language or variety. The
possibilities of a comparable corpus are to com-
pare different languages or varieties in similar cir-
cumstances of communication, but avoiding the in-
evitable distortion introduced by the translations of
a parallel corpus.?
(Maia, 2003), which also became nearly standard
during the recent years, emphasizes the fact that
comparable monolingual corpora usually provide us
with much better linguistic quality and representa-
tiveness than translated parallel corpora. The other
advantages over the parallel corpora, i.e. amount
and availability, are obvious.
Nowadays, the most popular usage of compara-
ble corpora is improving machine translation, more
1http://www.ilc.cnr.it/EAGLES96/corpustyp/node21.html
precisely, compensating the lack of parallel train-
ing data. The articles (Munteanu et al, 2004),
(Munteanu and Marcu, 2005) and (Munteanu and
Marcu, 2006) are introducing algorithms for ex-
tracting parallel sentences and sub-sententional frag-
ments from comparable corpora and using the auto-
matically extracted parallel data for improving sta-
tistical machine translation algorithms performance.
Present day most popular comparable corpora
come either from the newswire resources (AFP,
Reuters, Xinhua), leading to data sets like LDC
English, Chinese and Arabic Gigaword, or from
Wikipedia. Mining Wikipedia became very popu-
lar in the recent years. For example, (Toma?s et al,
2008) is exploring both parallel and comparable po-
tential of Wikipedia, (Filatova, 2009) examines mul-
tilingual aspects of a selected subset of Wikipedia
and (Gamallo and Lo?pez, 2010) describes convert-
ing Wikipedia into ?CorpusPedia?.
2 Introduction to fora
Just to avoid confusion: In this article, we focus only
on fora or boards, i.e. standalone discussion sites on
a stated topic. We are not talking about comments
accompanying news articles or blog posts.
The internet discussion fora cover, in surprisingly
big amounts of data and for many languages, the
most unbelievable topics (real examples from the
authors? country). People, who eat only uncooked
(?raw?) food. People, who eat only cooked food.
Mothers with young children, women trying to con-
ceive, communities of people absolutely avoiding
sex. Fans of Volvo, BMW, Maserati, Trabant cars.
Probably also in your country mothers like to talk
96
Proceedings of the 4th Workshop on Building and Using Comparable Corpora, pages 96?101,
49th Annual Meeting of the Association for Computational Linguistics,
Portland, Oregon, 24 June 2011. c?2011 Association for Computational Linguistics
about their children and men like to compare their
engine?s horse power.
Everyone who has any specific interest or hobby
and is friendly with the web, probably knows at least
one discussion forum focused on his/her favourite
topic, inhabited by intelligent, friendly debaters pro-
ducing interesting, on-topic content. These types of
fora often have very active administrators, who clean
the discussions from off-topics, vulgarities, move
the discussion threads into correct thematic cate-
gories etc. The administrators? ?tidying up? effort
can be even regarded as a kind of annotation.
The rapidly growing amount of web discussion
fora was until now linguistically exploited only in a
strictly monolingual manner. To the best of our (and
Google Scholar) knowledge, nobody has published
any work regarding the possibility of using internet
discussion fora as a multilingual source of data for
linguistic or machine translation purposes.
2.1 Forum structure
A typical forum is divided into thematic categories
(larger fora split into boards and boards into cate-
gories). Every category usually contains from tens
to thousands of separate discussions. A discussion
consists of messages (posts) and sometimes its con-
tent is further arranged using threads.
A discussion should be placed in appropriate cat-
egory and messages in the discussion should hold
onto the discussion topic, otherwise the administra-
tor removes the inappropriate messages or even the
whole discussion.
Fora usually have an entire off-topic category
where their members can talk about anything ?out-
of-domain?.
To avoid spam, usually only registered members
can contribute. Some fora keep their memberlist vis-
ible to the public, some do not.
3 Why comparable fora?
Besides their amount and availability, comparable
fora have a few other advantages over other types
of comparable corpora.
They contain ?spontaneous writing? ? an original,
previously unpublished content, which is almost cer-
tainly not a translation of other language original.
This is obviously not the case of parallel corpora,
and we cannot be sure even for other popular com-
parable corpora. A journalist may be inspired by a
news agency report or by another media source, and
a Wikipedia author must also reconcile his claims
with existing resources, which more or less affects
his writing style.
The other advantage is easier domain classifi-
cation, or more effective pre-selection before run-
ning an automatic parallel sentences alignment. A
generic newspaper article is provided only with a
title, language and release date. A Wikipedia en-
try has a title, history and is classified into a the-
matic category. Fora messages have both dates, titles
and category classifications and they are available in
much larger amounts than Wikipedia entries and are
covering more thematic domains than news articles.
4 A case study: wedding sites
As a topic of our case study, we have chosen an event
which occurs to most of the people at least once in
their life ? a wedding.
4.1 General overview
We looked over five language mutations of the
same forum operated by Asmira Company ? Fi-
nalstitch.co.uk (EN), Braupunkt.de (DE), Faire-
lanoce.fr (FR), Mojasvadba.sk (SK), Beremese.cz
(CZ); and two other fora, Brides.com/forums (EN2)
and Organisation-mariage.net (FR2), which seem to
be larger and more popular in the target countries.
We have manually examined fora sizes and possi-
bilities of their alignment on the category level.
Tables 1 and 2 summarize the total number of dis-
cussions and messages contained in selected cate-
gories, shared by most of the fora. For the Asmira
fora, we omitted the discussions accessible both
from CZ and SK sites.
If we assume average length of a message to be
about 60 words (see below), the proposed sites give
us a few millions of words of multilingual compa-
rable corpora in each category (focussed on very re-
stricted topic, such as wedding clothes, or hairdress-
ing & make-up) even for ?non-mainstream? lan-
guages, such as Czech or Slovak.
4.2 Quantitative characteristics
In order to learn more about the amount and textual
quality of the data, we have downloaded all the con-
97
EN DE FR CZ SK EN2 FR2
Ceremony and reception 389 280 232 1 532 2 345 N/A 1 536
Wedding-preparations 474 417 654 916 1270 13632 1 873
Date & location 63 119 154 839 529 371 N/A
Beauty 68 47 74 472 794 2 858 2 452Wedding clothing 291 166 200 715 1 108 10 832
After the wedding 37 47 47 236 245 1 530 390
Table 1: Total number of discussions in the selected wedding fora.
EN DE FR CZ SK EN2 FR2
Ceremony and reception 3 863 3 947 4 174 43 436 64 273 N/A 19 002
Wedding-preparations 4 908 4 987 8 867 51 880 27 837 130 408 24 585
Date & location 1 004 1 988 3 178 550 969 279 091 24 513 N/A
Beauty 692 852 1 462 32 118 32 620 15 946 38 582Wedding clothing 2 634 2 336 3 588 27 624 28 048 75 331
After the wedding 527 1 012 1 065 30 588 18 090 23 612 6 286
Table 2: Total number of messages in the selected wedding fora.
tent of the five Asmira fora, extracted their messages
into five monolingual corpora and measured some
basic characteristics of the texts. The downloading
and extracting task needed about 20 minutes of cod-
ing and a few days of waiting for the result (we did
not want to overload the fora webservers).
Table 3 shows us average messages lengths (in
words) for particular categories of these fora.
In graphs 1, 2 and 3, we present normalized sen-
tence length distributions for particular fora. For
English and Czech, we added for comparison sen-
tence length distributions of reference corpora of
comparable sizes, i.e. The Penn Treebank, train-
ing set (Marcus et al, 1994), for English and The
Czech National Corpus, SYN2005 (CNC, 2005), for
Czech.
4.3 Examples of similar discussion topics
The category distinction may be still too coarse for
potential alignment. The site FR2 has a joint cate-
gory for Beauty and Wedding clothing, and on the
contrary, it has separate categories for Wedding and
Reception. Therefore, we tried to examine the fora
on a deeper level. In table 4, we present some exam-
ples of discussions on the same topic.
As you can guess, fully automatic alignment of
the discussion titles will not be an easy task. On the
other side, every machine translation specialist must
0 20 40 60 80 100
Sentence length
R
el
at
ive
 F
re
qu
en
cy
0
Forum
PTB
Figure 1: The EN forum and The Penn Treebank - sen-
tence length distributions.
shiver with pleasure when seeing some of the dis-
cussion titles to be almost translations of each other,
and it would be a sin to leave these data unexploited.
98
EN DE FR CZ SK
Ceremony and reception 70.0 68.7 51.9 59.7 56.9
Wedding-preparations 73.8 62.5 55.1 63.7 62.3
Date & location 59.2 56.4 61.7 52.0 48.8
Beauty 67.7 61.3 53.4 65.8 56.6
Wedding clothing 61.1 60.4 42.1 57.0 50.0
After the wedding 71.8 69.5 52.0 66.8 68.6
Table 3: Average messages lengths (in words) for the selected wedding fora categories.
0 20 40 60 80 100
Sentence length
R
el
at
ive
 F
re
qu
en
cy
0
Forum
CNC
Figure 2: The CZ forum and The Czech National Corpus
- sentence length distributions.
5 Technical issues
Of course, language mutations of the same forum
(sharing the same category structure and running on
the same forum engine) are a ?researcher?s dream?
and not the case of the majority of potential compa-
rable fora.
You will probably ask two questions: 1) How to
effectively extract messages from a site with undoc-
umented structure? 2) How to put together compara-
ble fora in multiple languages and how to align their
category hierarchy?
5.1 Messages mining
According to an internet source 2, about 96 % of in-
ternet discussion fora are powered by two most pop-
2http://www.qualityposts.com/ForumMarketShare.php
0 20 40 60 80 100
Sentence length
R
el
at
ive
 F
re
qu
en
cy
0
brautpunkt.de
fairelanoce.fr
mojasvatba.sk
Figure 3: The DE, FR and SK fora - sentence length dis-
tributions.
ular forum systems, phpBB and vBulletin, and an-
other 3 % are powered by Simple Machines Forum,
MyBB and Invision Power Board.
Our observation is, that small hobby fora run
mostly on unadapted (?as is?) phpBB or another free
system, while large commercial fora often have their
own systems.
If you intend to automatically process only a few
selected fora, you will probably use XPath queries
on the HTML Document Object Model. According
to our experience, it is very easy and straightforward
task to write a single wrapper for a particular forum.
But it would be nice, of course, to have a general
solution which does not rely on a fixed forum struc-
ture. Unfortunately, general web page cleaning al-
gorithms, e.g. Victor (Spousta et al, 2008), are not
99
EN2 How to set up a budget
DE Budget?
FR2 Financement mariage
CZ Jaky? ma?te rozpoc?et na svatbu???
SK Svadobny rozpocet
EN Mobile hair and makeup
DE Friseur und Kosmetik daheim?
FR2 Estheticienne a domicile?
CZ Nal??c?en?? plus u?c?es doma - Praha
SK Licenie a uces - v den svadby a doma
EN Hair extensions?
DE Echthaar-Clip-Extensions
FR2 Extensions pour cheveux
CZ Prodluz?ova?n?? vlasu?
SK Predlzovanie vlasov
EN Where should we go for our honeymoon?
DE Habt ihr Tipps fu?r eine scho?ne
Hochzeitsreise???
FR2 Quelle destination pour le voyage de noce?
CZ Svatebn?? cesta
SK Kam idete na svadobnu? cestu?
Table 4: Examples of similar discussions.
very succesfull with this type of input (i.e. ten to
fifty rather small textual portions on one page).
However, there are some invariants shared among
all types of fora 3. The content is automatically gen-
erated and therefore all the messages on one page
(can be generalized to one site) usually ?look simi-
lar?, in terms of HTML structure. (Limanto et al,
2005) exploits this fact and introduces a subtree-
matching algorithm for detecting messages on a dis-
cussion page. (Li et al, 2009) proposes more com-
plex algorithm which extracts not only the messages
content but also the user profile information.
5.2 Fora coupling
The task of optimal fora, categories, discussions,
sentences and phrases alignment remains open. Our
article is meant to be an inspiration, thus for now,
we will not provide our reader with any surprising
practical solutions, only with ideas.
The sentence and sub-sentence level can be main-
tained by existing automatic aligners. For the rest,
we believe that combined use of hierarchical struc-
3and some other types of web sites, eg. e-shops or blogs
ture of the fora together with terms, named entities
or simple word translations can help. For example,
nearly every EU top level domain hosts a ?Volvo Fo-
rum? or ?Volvo Club?, and each Volvo Forum con-
tains some portion of discussions mentioning model
names, such as V70 or S60, in their titles.
Besides, according to our case study, the amount
of acquired data compared to the amount of hu-
man effort should be reasonable even when cou-
pling the fora sites and their top categories manu-
ally. Present day approaches to acquiring compara-
ble corpora also require some human knowledge and
effort, e.g. you need to pick out manually the most
reliable and appropriate news resources.
6 Conclusion
We have proposed an idea of using co-existent web
discussion fora in multiple languages addressing the
same topic as comparable corpora. Our case study
shows that using this approach, one can acquire large
portions of comparable multilingual data with min-
imal effort. We also discussed related technical is-
sues.
You may ask, whether the forum language is the
right (addition to a) training set for a machine trans-
lation system. The answer may depend on, what
type of system it is and what type of input do you
want to translate. If you need to translate parliamen-
tary proceedings, you will surely be more satisfied
with parliament-only training data. But do you want
an anything-to-speech machine translation system to
talk to you like a parliamentary speaker, or like a
Wikipedia author, or like a friend of yours from your
favourite community of interest?
We hope that our article drew the attention of the
linguistic audience to this promising source of com-
parable texts and we are looking forward to seeing
some interesting resources and applications.
Acknowledgments
The research described here was supported by the
project GA405/09/0278 of the Grant Agency of the
Czech Republic.
100
References
CNC, 2005. Czech National Corpus ? SYN2005. In-
stitute of Czech National Corpus, Faculty of Arts,
Charles University, Prague, Czech Republic.
Elena Filatova. 2009. Directions for exploiting asymme-
tries in multilingual wikipedia. In Proceedings of the
Third International Workshop on Cross Lingual Infor-
mation Access: Addressing the Information Need of
Multilingual Societies, CLIAWS3 ?09, pages 30?37,
Stroudsburg, PA, USA. Association for Computational
Linguistics.
Pablo Gamallo and Isaac Gonza?lez Lo?pez. 2010.
Wikipedia as multilingual source of comparable cor-
pora. In Proceedings of the LREC Workshop on Build-
ing and Using Comparable Corpora, pages 30?37.
Suke Li, Liyong Tang, Jianbin Hu, and Zhong Chen.
2009. Automatic data extraction from web discussion
forums. Frontier of Computer Science and Technol-
ogy, Japan-China Joint Workshop on, 0:219?225.
Hanny Yulius Limanto, Nguyen Ngoc Giang, Vo Tan
Trung, Jun Zhang, Qi He, and Nguyen Quang Huy.
2005. An information extraction engine for web dis-
cussion forums. In Special interest tracks and posters
of the 14th international conference on World Wide
Web, WWW ?05, pages 978?979, New York, NY,
USA. ACM.
Belinda Maia. 2003. What are comparable corpora?
In Proceedings of the Workshop on Multilingual Cor-
pora: Linguistic requirements and technical perspec-
tives, at the Corpus Linguistics 2003, pages 27?34,
Lancaster, UK, March.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beat-
rice Santorini. 1994. Building a large annotated cor-
pus of English: The Penn Treebank. Computational
Linguistics, 19(2):313?330.
Dragos Stefan Munteanu and Daniel Marcu. 2005. Im-
proving machine translation performance by exploit-
ing non-parallel corpora. Computational Linguistics,
31(4).
Dragos Stefan Munteanu and Daniel Marcu. 2006. Ex-
tracting parallel sub-sentential fragments from non-
parallel corpora. In Proceedings of the 21st Interna-
tional Conference on Computational Linguistics and
44th Annual Meeting of the Association for Compu-
tational Linguistics, pages 81?88, Sydney, Australia,
July. Association for Computational Linguistics.
Dragos Stefan Munteanu, Alexander Fraser, and Daniel
Marcu. 2004. Improved machine translation perfor-
mance via parallel sentence extraction from compara-
ble corpora. In HLT-NAACL 2004: Main Proceedings,
pages 265?272, Boston, Massachusetts, USA, May.
Association for Computational Linguistics.
Miroslav Spousta, Michal Marek, and Pavel Pecina.
2008. Victor: the web-page cleaning tool. In Pro-
ceedings of the Web as Corpus Workshop (WAC-4),
Marrakech, Morocco.
Jesu?s Toma?s, Jordi Bataller, Francisco Casacuberta, and
Jaime Lloret. 2008. Mining wikipedia as a parallel
and comparable corpus. Language Forum, 34.
101
