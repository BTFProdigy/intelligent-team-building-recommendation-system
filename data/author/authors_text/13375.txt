Proceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 116?123,
The University of Tokyo, September 24-25, 2010. c?2010 Association for Computational Linguistics
Parameter estimation for agenda-based user simulation
Simon Keizer, Milica Gas?ic?, Filip Jurc???c?ek, Franc?ois Mairesse,
Blaise Thomson, Kai Yu, and Steve Young ?
University of Cambridge, Department of Engineering, Cambridge (UK)
{sk561,mg436,fj228,farm2,brmt2,ky219,sjy}@cam.ac.uk
Abstract
This paper presents an agenda-based user
simulator which has been extended to be
trainable on real data with the aim of more
closely modelling the complex rational be-
haviour exhibited by real users. The train-
able part is formed by a set of random de-
cision points that may be encountered dur-
ing the process of receiving a system act
and responding with a user act. A sample-
based method is presented for using real
user data to estimate the parameters that
control these decisions. Evaluation results
are given both in terms of statistics of gen-
erated user behaviour and the quality of
policies trained with different simulators.
Compared to a handcrafted simulator, the
trained system provides a much better fit
to corpus data and evaluations suggest that
this better fit should result in improved di-
alogue performance.
1 Introduction
In spoken dialogue systems research, modelling
dialogue as a (Partially Observable) Markov Deci-
sion Process ((PO)MDP) and using reinforcement
learning techniques for optimising dialogue poli-
cies has proven to be an effective method for de-
veloping robust systems (Singh et al, 2000; Levin
et al, 2000). However, since this kind of optimi-
sation requires a simulated user to generate a suffi-
ciently large number of interactions to learn from,
this effectiveness depends largely on the quality
of such a user simulator. An important require-
ment for a simulator is for it to be realistic, i.e., it
should generate behaviour that is similar to that of
real users. Trained policies are then more likely to
perform better on real users, and evaluation results
on simulated data are more likely to predict results
on real data more accurately.
?This research was partly funded by the UK EPSRC un-
der grant agreement EP/F013930/1 and by the EU FP7 Pro-
gramme under grant agreement 216594 (CLASSiC project:
www.classic-project.org).
This is one of the reasons why learning user
simulation models from data on real user be-
haviour has become an important direction of re-
search (Scheffler and Young, 2001; Cuaya?huitl et
al., 2005; Georgila et al, 2006). However, the data
driven user models developed so far lack the com-
plexity required for training high quality policies
in task domains where user behaviour is relatively
complex. Handcrafted models are still the most
effective in those cases.
This paper presents an agenda-based user simu-
lator which is handcrafted for a large part, but ad-
ditionally can be trained with data from real users
(Section 2). As a result, it generates behaviour that
better reflects the statistics of real user behaviour,
whilst preserving the complexity and rationality
required to effectively train dialogue management
policies. The trainable part is formed by a set of
random decision points, which, depending on the
context, may or may not be encountered during
the process of receiving a system act and decid-
ing on a response act. If such a point is encoun-
tered, the simulator makes a random decision be-
tween a number of options which may directly or
indirectly influence the resulting output. The op-
tions for each random decision point are reason-
able in the context in which it is encountered, but
a uniform distribution of outcomes might not re-
flect real user behaviour.
We will describe a sample-based method for es-
timating the parameters that define the probabili-
ties for each possible decision, using data on real
users from a corpus of human-machine dialogues
(Section 3). Evaluation results will be presented
both in terms of statistics on generated user be-
haviour and the quality of dialogue policies trained
with different user simulations (Section 4).
2 Agenda-based user simulation
In agenda-based user simulation, user acts are gen-
erated on the basis of a user goal and an agenda
(Schatzmann et al, 2007a). The simulator pre-
sented here is developed and used for a tourist in-
116
formation application, but is sufficiently generic to
accommodate slot-filling applications in any do-
main.1 The user goal consists of the type of venue,
for example hotel, bar or restaurant, a list
of constraints in the form of slot value pairs, such
as food=Italian or area=east, and a list
of slots the user wants to know the value of, such
as the address (addr), phone number (phone),
or price information (price) of the venue. The
user goals for the simulator are randomly gener-
ated from the domain ontology describing which
combinations of venue types and constraints are
allowed and what are the possible values for each
slot. The agenda is a stack-like structure contain-
ing planned user acts. When the simulator receives
a system act, the status of the user goal is updated
as well as the agenda, typically by pushing new
acts onto it. In a separate step, the response user
act is selected by popping one or more items off
the agenda.
Although the agenda-based user simulator in-
troduced by Schatzmann et al (2007a) was en-
tirely handcrafted, it was realistic enough to suc-
cessfully test a prototype POMDP dialogue man-
ager and train a dialogue policy that outperformed
a handcrafted baseline (Young et al, 2009). A
method to train an agenda-based user simula-
tor from data was proposed by Schatzmann et
al. (2007b). In this approach, operations on
the agenda are controlled by probabilities learned
from data using a variation of the EM algorithm.
However, this approach does not readily scale to
more complex interactions in which users can, for
example, change their goal midway through a dia-
logue.
2.1 Random decision parameters
Each time the user simulator receives a system act,
a complex, two-fold process takes place involving
several decisions, made on the basis of both the
nature of the incoming system act and the infor-
mation state of the user, i.e., the status of the user
goal and agenda. The first phase can be seen as
an information state update and involves actions
like filling requested slots or checking whether the
provided information is consistent with the user
goal constraints. In the second phase, the user de-
cides which response act to generate, based on the
updated agenda. Many of the decisions involved
are deterministic, allowing only one possible op-
tion given the context. Other decisions allow for
some degree of variation in the user behaviour and
are governed by probability distributions over the
1We have to date also implemented systems in appoint-
ment scheduling and bus timetable inquiries.
options allowed in that context. For example, if
the system has offered a venue that matches the
user?s goal, the user can randomly decide to either
change his goal or to accept the venue and ask for
additional information such as the phone number.
The non-deterministic part of the simulator is
formalised in terms of a set of random decision
points (RDPs) embedded in the decision process.
If an RDP is encountered (depending on the con-
text), a random choice between the options de-
fined for that point is made by sampling from a
probability distribution. Most of the RDPs are
controlled by a multinomial distribution, such as
deciding whether or not to change the goal after
a system offer. Some RDPs are controlled by a
geometric distribution, like in the case where the
user is planning to specify one of his constraints
(with an inform act popped from the agenda) and
then repeatedly adds an additional constraint to the
act (by combining it with an additional inform act
popped from the agenda) until it randomly decides
not to add any more constraints (or runs out of
constraints to specify). The parameter for this dis-
tribution thus controls how cautious the user is in
providing information to the system.
Hence, the user simulator can be viewed as
a ?decision network?, consisting of deterministic
and random decision points. This is illustrated in
Figure 1 for the simplified case of a network with
only four RDPs; the actual simulator has 23 RDPs,
with 27 associated parameters in total. Each time
the simulator receives a system act, it follows a
path through the network, which is partly deter-
mined by that system act and the user goal and
agenda, and partly by random decisions made ac-
cording to the probability distributions for each
random decision point i given by its parameters
?i.
3 Training the simulator from data
The parameterisation of the user simulator as de-
scribed in Section 2.1 forms the basis for a method
for training the simulator with real user data. The
parameters describing the probability distributions
for each RDP are estimated in order to generate
user behaviour that fits the user behaviour in the
corpus as closely as possible. In order to do so,
a sample based maximum likelihood approach is
taken, in which the simulator is run repeatedly
against the system acts in the corpus, and the ran-
dom decisions that lead to simulated acts matching
the true act in the corpus are recorded. The param-
eters are then estimated using the counts for each
of the random decision points.
117
incoming
system act
outgoing
user act
user goal + agenda
?2
?1
?3
?4
Figure 1: User simulator viewed as a ?decision network?: square nodes indicate deterministic decision
points; round nodes indicate random decision points, and have associated parameters ?i; the loop on one
of the nodes indicates it has a geometric distribution associated with it.
3.1 Parameter estimation
Before starting the process of matching simulated
acts with true acts and collecting counts for the
RDPs, the parameters are initialised to values cor-
responding to uniform distributions. Then, the
simulator is run against all dialogues in the cor-
pus in such a way that for each turn in a dialogue
(consisting of a system act and a user act), the user
simulator is provided with the system act and is
run repeatedly to generate several simulated user
response acts for that turn. For the first turn of a di-
alogue, the simulator is initialised with the correct
user state (see Section 3.2). For each response, the
simulator may make different random decisions,
generally leading to different user acts. The deci-
sions that lead to a simulated act that matches the
true act are recorded as successful. By generating
a sufficiently large number of simulated acts, all
possible combinations of decisions are explored to
find a matching act. Given the high complexity of
the simulator, this sampling approach is preferred
over directly enumerating all decision combina-
tions to identify the successful ones. If none of
the combinations are successful, then either a) the
processing of the dialogue is ended, or b) the cor-
rect context is set for the next turn and processing
is continued. Whereas the former approach aims at
matching sequences of turns, the latter only aims
at matching each user turn separately. In either
case, after all data is processed, the parameters are
estimated using the resulting counts of successful
decisions for each of the RDPs.
For each RDP i, let DPi represent the decision
taken, and dij the j?th possible decision. Then, for
each decision point i that is controlled by a multi-
nomial distribution, the corresponding parameter
estimates ?ij are obtained as follows from the de-
cision frequencies c(DPi = dij):
?ij =
c(DPi = dij)
?
j c(DPi = dij)
(1)
Random decision points that are controlled
by geometric distributions involve potentially
multiple random decisions between two options
(Bernoulli trials). The parameters for such RDPs
are estimated as follows:
?i =
(
1
n
n
?
k=1
bik
)?1
(2)
where bik is the number of Bernoulli trials re-
quired at the k?th time decision point i was en-
countered. In terms of the decision network, this
estimate is correlated with the average number of
times the loop of the node was taken.
3.2 User goal inference
In order to be able to set the correct user goal
state in any given turn, a set of update rules is
used to infer the user?s goals from a dialogue be-
forehand, on the basis of the entire sequence of
system acts and ?true? user acts (see Section 4.1)
in the corpus. These update rules are based on
the notion of dialogue act preconditions, which
specify conditions of the dialogue context that
must hold for a dialogue agent to perform that
act. For example, a precondition for the act
inform(area=central) is that the speaker
wants a venue in the centre. The user act model
118
of the HIS dialogue manager is designed accord-
ing to this same notion (Keizer et al, 2008). In this
model, the probability of a user act in a certain dia-
logue context (the last system act and a hypothesis
regarding the user goal) is determined by checking
the consistency of its preconditions with that con-
text. This contributes to updating the system?s be-
lief state on the basis of which it determines its re-
sponse action. For the user goal inference model,
the user act is given and therefore its precondi-
tions can be used to directly infer the user goal.
So, for example, in the case of observing the user
act inform(area=central), the constraint
(area=central) is added to the user goal.
In addition to using the inferred user goals, the
agenda is corrected in cases where there is a mis-
match between real and simulated user acts in the
previous turn.
In using this offline goal inference model, our
approach takes a position between (Schatzmann et
al., 2007b), in which the user?s goal is treated as
hidden, and (Georgila et al, 2006), in which the
user?s goal is obtained directly from the corpus an-
notation.
4 Evaluation
The parameter estimation technique for training
the user simulator was evaluated in two differ-
ent ways. The first evaluation involved compar-
ing the statistics of simulated and real user be-
haviour. The second evaluation involved compar-
ing dialogue manager policies trained with differ-
ent simulators.
4.1 Data
The task of the dialogue systems we are develop-
ing is to provide tourist information to users, in-
volving venues such as bars, restaurants and hotels
that the user can search for and ask about. These
venues are described in terms of features such as
price range, area, type of food, phone number,
address, and so on. The kind of dialogues with
these systems are commonly called slot-filling di-
alogues.
Within the range of slot-filling applications the
domain is relatively complex due to its hierarchi-
cal data structure and relatively large number of
slots and their possible values. Scalability is in-
deed one of the primary challenges to be addressed
in statistical approaches to dialogue system devel-
opment, including user simulation.
The dialogue corpus that was used for training
and evaluating the simulator was obtained from
the evaluation of a POMDP spoken dialogue sys-
tem with real users. All user utterances in the
resulting corpus were transcribed and semanti-
cally annotated in terms of dialogue acts. Dia-
logue acts consist of a series of semantic items,
including the type (describing the intention of
the speaker, e.g., inform or request) and a
list of slot value pairs (e.g., food=Chinese or
area=south). An extensive analysis of the an-
notations from three different people revealed a
high level of inter-annotator agreement (ranging
from 0.81 to 0.94, depending on which pair of an-
notations are compared), and a voting scheme for
selecting a single annotation for each turn ensured
the reliability of the ?true? user acts used for train-
ing the simulator.
4.2 Corpus statistics results
A first approach to evaluating user simulations is
to look at the statistics of the user behaviour that
is generated by a simulator and compare it with
that of real users as observed in a dialogue cor-
pus. Several metrics for such evaluations have
been considered in the literature, all of which have
both strong points and weaknesses. For the present
evaluation, a selection of metrics believed to give
a reasonable first indication of the quality of the
user simulations was considered2 .
4.2.1 Metrics
The first corpus-based evaluation metric is the Log
Likelihood (LL) of the data, given the user simu-
lation model. This is what is in fact maximised by
the parameter estimation algorithm. The log like-
lihood can be computed by summing the log prob-
abilities of each user turn du in the corpus data D:
ll(D|{?ij}, {?i}) =
?
u
log P (du|{?ij}, {?i})
(3)
The user turn probability is given by the prob-
ability of the decision paths (directed paths in the
decision network of maximal length, such as the
one indicated in Figure 1 in bold) leading to a sim-
ulated user act in that turn that matches the true
user act. The probability of a decision path is ob-
tained by multiplying the probabilities of the de-
cisions made at each decision point i that was en-
countered, which are given by the parameters ?ij
2Note that not all selected metrics are metrics in the strict
sense of the word; the term should therefore be interpreted as
a more general one.
119
and ?i:
logP (du|{?ij}, {?i}) =
?
i?Im(u)
log
(
?
j
?ij ? ?ij(u)
)
+ (4)
?
i?Ig(u)
log
(
?
k
(1 ? ?i)k?1 ? ?i ? ?ik(u)
)
where Im(u) = {i ? Im|?j ?ij(u) > 0} and
Ig(u) = {i ? Ig|
?
k ?ik(u) > 0} are the subsets
of the multinomial (Im) and geometric (Ig) de-
cision points respectively containing those points
that were encountered in any combination of deci-
sions resulting in the given user act:
?ij(u) =
?
?
?
?
?
1 if decision DPi = dij was
taken in any of the
matching combinations
0 otherwise
(5)
?ik(u) =
?
?
?
?
?
1 if any of the matching
combinations required
k > 0 trials
0 otherwise
(6)
It should be noted that the log likelihood only
represents those turns in the corpus for which the
simulated user can produce a matching simulated
act with some probability. Hence, it is impor-
tant to also take into account the corpus cover-
age when considering the log likelihood in cor-
pus based evaluation. Dividing by the number of
matched turns provides a useful normalisation in
this respect.
The expected Precision (PRE), Recall (RCL),
and F-Score (FS) are obtained by comparing the
simulated user acts with the true user acts in the
same context (Georgila et al, 2006). These scores
are obtained by pairwise comparison of the simu-
lated and true user act for each turn in the corpus
at the level of the semantic items:
PRE = #(matched items)#(items in simulated act) (7)
RCL = #(matched items)#(items in true act) (8)
FS = 2 ? PRE ? RCLPRE + RCL (9)
By sampling a sufficient number of simulated
acts for each turn in the corpus and comparing
them with the corresponding true acts, this results
in an accurate measure on average.
The problem with precision and recall is that
they are known to heavily penalise unseen data.
Any attempt to generalise and therefore increase
the variability of user behaviour results in lower
scores.
Another way of evaluating the user simulator
is to look at the global user act distributions it
generates and compare them to the distributions
found in the real user data. A common metric
for comparing such distributions is the Kullback-
Leibler (KL) distance. In (Cuaya?huitl et al,
2005) this metric was used to evaluate an HMM-
based user simulation approach. The KL dis-
tance is computed by taking the average of the
two KL divergences3 DKL(simulated||true) and
DKL(true||simulated), where:
DKL(p||q) =
?
i
pi ? log2(
pi
qi
) (10)
KL distances are computed for both full user act
distributions (taking into account both the dia-
logue act type and slot value pairs) and user act
type distributions (only regarding the dialogue act
type), denoted by KLF and KLT respectively.
4.2.2 Results
For the experiments, the corpus data was ran-
domly split into a training set, consisting of 4479
user turns in 541 dialogues, used for estimat-
ing the user simulator parameters, and a test set,
consisting of 1457 user turns in 175 dialogues,
used for evaluation only. In the evaluation, the
following parameter settings were compared: 1)
non-informative, uniform parameters (UNIF); 2)
handcrafted parameters (HDC); 3) parameters es-
timated from data (TRA); and 4) deterministic pa-
rameters (DET), in which for each RDP the prob-
ability of the most probable decision according to
the estimated parameters is set to 1, i.e., at all
times, the most likely decision according to the es-
timated parameters is chosen.
For both trained and deterministic parameters,
a distinction is made between the two approaches
to matching user acts during parameter estimation.
Recall that in the turn-based approach, in each
turn, the simulator is run with the corrected con-
text to find a matching simulated act, whereas in
the sequence-based approach, the matching pro-
cess for a dialogue is stopped in case a turn
is encountered which cannot be matched by the
simulator. This results in estimated parameters
TRA-T and deterministic parameters DET-T for
3Before computing the distances, add-one smoothing was
applied in order to avoid zero-probabilities.
120
PAR nLL-T nLL-S PRE RCL FS KLF KLT
UNIF ?3.78 ?3.37 16.95 (?0.75) 9.47 (?0.59) 12.15 3.057 2.318
HDC ?4.07 ?2.22 44.31 (?0.99) 34.74 (?0.95) 38.94 1.784 0.623
TRA-T ?2.97 - 37.60 (?0.97) 28.14 (?0.90) 32.19 1.362 0.336
DET-T ?? - 47.70 (?1.00) 40.90 (?0.98) 44.04 2.335 0.838
TRA-S - ?2.13 43.19 (?0.99) 35.68 (?0.96) 39.07 1.355 0.155
DET-S - ?? 49.39 (?1.00) 43.04 (?0.99) 46.00 2.310 0.825
Table 1: Results of the sample-based user simulator evaluation on the Mar?09 training
corpus (the corpus coverage was 59% for the turn-based and 33% for the sequence-based
matching approach).
PAR nLL-T nLL-S PRE RCL FS KLF KLT
UNIF ?3.61 ?3.28 16.59 (?1.29) 9.32 (?1.01) 11.93 2.951 2.180
HDC ?3.90 ?2.19 45.35 (?1.72) 36.04 (?1.66) 40.16 1.780 0.561
TRA-T ?2.84 - 38.22 (?1.68) 28.74 (?1.57) 32.81 1.405 0.310
DET-T ?? - 49.15 (?1.73) 42.17 (?1.71) 45.39 2.478 0.867
TRA-S - ?2.12 43.90 (?1.72) 36.52 (?1.67) 39.87 1.424 0.153
DET-S - ?? 50.73 (?1.73) 44.41 (?1.72) 47.36 2.407 0.841
Table 2: Results of the sample-based user simulator evaluation on the Mar?09 test corpus
(corpus coverage 59% for the turn-based, and 36% for sequence-based matching).
the turn-based approach and analogously TRA-S
and DET-S for the sequence-based approach. The
corresponding normalised (see Section 4.2.1) log-
likelihoods are indicated by nLL-T and nLL-S.
Tables 1 and 2 give the results on the training
and test data respectively. The results show that in
terms of log-likelihood and KL-distances, the es-
timated parameters outperform the other settings,
regardless of the matching method. In terms of
precision/recall (given in percentages with 95%
confidence intervals), the estimated parameters
are worse than the handcrafted parameters for
turn-based matching, but have similar scores for
sequence-based matching.
The results for the deterministic parameters il-
lustrate that much better precision/recall scores
can be obtained, but at the expense of variability as
well as the KL-distances. It will be easier to train
a dialogue policy on such a deterministic simula-
tor, but that policy is likely to perform significantly
worse on the more varied behaviour generated by
the trained simulator, as we will see in Section 4.3.
Out of the two matching approaches, the
sequence-based approach gives the best results:
TRA-S outperforms TRA-T on all scores, except
for the coverage which is much lower for the
sequence-based approach (33% vs. 59%).
4.3 Policy evaluation results
Although the corpus-based evaluation results give
a useful indication of how realistic the behaviour
generated by a simulator is, what really should be
evaluated is the dialogue management policy that
is trained using that simulator. Therefore, differ-
ent parameter sets for the simulator were used to
train and evaluate different policies for the Hidden
Information State (HIS) dialogue manager (Young
et al, 2009). Four different policies were trained:
one policy using handcrafted simulation param-
eters (POL-HDC); two policies using simulation
parameters estimated (using the sequence-based
matching approach) from two data sets that were
obtained by randomly splitting the data into two
parts of 358 dialogues each (POL-TRA1 and POL-
TRA2); and finally, a policy using a determin-
istic simulator (POL-DET) constructed from the
trained parameters as discussed in Section 4.2.2.
The policies were then each evaluated on the sim-
ulator using the four parameter settings at different
semantic error rates.
The performance of a policy is measured in
terms of a reward that is given for each dialogue,
i.e. a reward of 20 for a successful dialogue, mi-
nus the number of turns. A dialogue is consid-
ered successful if the system has offered a venue
matching the predefined user goal constraints and
has given the correct values of all requested slots
for this venue. During the policy optimisation, in
which a reinforcement learning algorithm tries to
optimise the expected long term reward, this dia-
logue scoring regime was also used.
In Figures 2, 3, and 4, evaluation results are
given resulting from running 3000 dialogues at
each of 11 different semantic error rates. The
curves show average rewards with 95% confidence
intervals. The error rate is controlled by a hand-
121
-2
 0
 2
 4
 6
 8
 10
 12
 0  0.1  0.2  0.3  0.4  0.5
Av
er
ag
e 
re
wa
rd
Error rate
POL-HDC
POL-TRA1
POL-TRA2
POL-DET
Figure 2: Average rewards for each policy when
evaluated on UM-HDC.
-4
-2
 0
 2
 4
 6
 8
 10
 0  0.1  0.2  0.3  0.4  0.5
Av
er
ag
e 
re
wa
rd
Error rate
POL-HDC
POL-TRA1
POL-TRA2
POL-DET
Figure 3: Average rewards for each policy when
evaluated on UM-TRA1.
 2
 4
 6
 8
 10
 12
 14
 16
 0  0.1  0.2  0.3  0.4  0.5
Av
er
ag
e 
re
wa
rd
Error rate
POL-HDC
POL-TRA1
POL-TRA2
POL-DET
Figure 4: Average rewards for each policy when
evaluated on UM-DET.
 0
 1
 2
 3
 4
 5
 6
 7
 0  0.1  0.2  0.3  0.4  0.5
Av
er
ag
e 
re
wa
rd
 lo
ss
Error rate
POL-HDC
POL-TRA2
POL-DET
Figure 5: Average loss in reward for each policy,
across three different simulators.
crafted error model that converts the user act gen-
erated by the simulator into an n-best list of dia-
logue act hypotheses.
The policy that was trained using the hand-
crafted simulator (POL-HDC) outperforms the
other policies when evaluated on that same sim-
ulator (see Figure 2), and both policies trained us-
ing the trained simulators (POL-TRA1 and POL-
TRA2) outperform the other policies when evalu-
ated on either trained simulator (see Figure 3 for
the evaluation on UM-TRA1; the evaluation on
UM-TRA2 is very similar and therefore omitted).
There is little difference in performance between
policies POL-TRA1 and POL-TRA2, which can
be explained by the fact that the two trained
parameter settings are quite similar, in contrast
to the handcrafted parameters. The policy that
was trained on the deterministic parameters (POL-
DET) is competitive with the other policies when
evaluated on UM-DET (see Figure 4), but per-
forms significantly worse on the other parameter
settings which generate the variation in behaviour
that the dialogue manager did not encounter dur-
ing training of POL-DET.
In addition to comparing the policies when eval-
uated on each simulator separately, another com-
parison was made in terms of the average perfor-
mance across all simulators. For each policy and
each simulator, we first computed the difference
between the policy?s performance and the ?maxi-
mum? performance on that simulator as achieved
by the policy that was also trained on that simu-
lator, and then averaged over all simulators. To
avoid biased results, only one of the trained simu-
lators was included. The results in Figure 5 show
that the POL-TRA2 policy is more robust than
POL-DET, and has similar robustness as POL-
HDC. Similar results are obtained when including
UM-TRA1 only.
Given that the results of Section 4.2 show that
the dialogues generated by the trained simulator
more closely match real corpus data, and given
that the above simulation results show that the
POL-TRA policies are at least as robust as the
122
other policies, it seems likely that policies trained
using the trained user simulator will show im-
proved performance when evaluated on real users.
However, this claim can only be properly
demonstrated in a real user evaluation of the di-
alogue system containing different dialogue man-
agement policies. Such a user trial would also be
able to confirm whether the results from evalua-
tions on the trained simulator can more accurately
predict the actual performance expected with real
users.
5 Conclusion
In this paper, we presented an agenda-based user
simulator extended to be trainable on real user
data whilst preserving the necessary rationality
and complexity for effective training and evalu-
ation of dialogue manager policies. The exten-
sion involved the incorporation of random deci-
sion points in the process of receiving and re-
sponding to a system act in each turn. The deci-
sions made at these points are controlled by prob-
ability distributions defined by a set of parameters.
A sample-based maximum likelihood approach
to estimating these parameters from real user data
in a corpus of human-machine dialogues was dis-
cussed, and two kinds of evaluations were pre-
sented. When comparing the statistics of real ver-
sus simulated user behaviour in terms of a selec-
tion of different metrics, overall, the estimated pa-
rameters were shown to give better results than
the handcrafted baselines. When evaluating dia-
logue management policies trained on the simula-
tor with different parameter settings, it was shown
that: 1) policies trained on a particular parame-
ter setting outperform other policies when evalu-
ated on the same parameters, and in particular, 2)
a policy trained on the trained simulator outper-
forms other policies on a trained simulator. With
the general goal of obtaining a dialogue manager
that performs better in practice, these results are
encouraging, but need to be confirmed by an eval-
uation of the policies on real users.
Additionally, there is still room for improving
the quality of the simulator itself. For example,
the variation in user behaviour can be improved by
adding more random decision points, in order to
achieve better corpus coverage. In addition, since
there is no clear consensus on what is the best met-
ric for evaluating user simulations, additional met-
rics will be explored in order to get a more bal-
anced indication of the quality of the user simu-
lator and how the various metrics are affected by
modifications to the simulator. Perplexity (related
to the log likelihood, see (Georgila et al, 2005)),
accuracy (related to precision/recall, see (Zuker-
man and Albrecht, 2001; Georgila et al, 2006)),
and Crame?r-von Mises divergence (comparing di-
alogue score distributions, see (Williams, 2008))
are some of the metrics worth considering.
References
H. Cuaya?huitl, S. Renals, O. Lemon, and H. Shi-
modaira. 2005. Human-computer dialogue sim-
ulation using hidden markov models. In Proc.
ASRU?05, pages 290?295.
K. Georgila, J. Henderson, and O. Lemon. 2005.
Learning user simulations for information state up-
date dialogue systems. In Proc. Interspeech ?05.
K. Georgila, J. Henderson, and O. Lemon. 2006. User
simulation for spoken dialogue systems: Learning
and evaluation. In Proc. Interspeech/ICSLP.
S. Keizer, M. Gas?ic?, F. Mairesse, B. Thomson, K. Yu,
and S. Young. 2008. Modelling user behaviour in
the HIS-POMDP dialogue manager. In Proc. SLT,
Goa, India.
E. Levin, R. Pieraccini, and W. Eckert. 2000. A
stochastic model of human-machine interaction for
learning dialogue strategies. IEEE Transactions on
Speech and Audio Processing, 8(1).
J. Schatzmann, B. Thomson, K. Weilhammer, H. Ye,
and S. Young. 2007a. Agenda-based user simula-
tion for bootstrapping a POMDP dialogue system.
In Proceedings HLT/NAACL, Rochester, NY.
J. Schatzmann, B. Thomson, and S. Young. 2007b.
Statistical user simulation with a hidden agenda. In
Proc. SIGDIAL?07, pages 273?282, Antwerp, Bel-
gium.
K. Scheffler and S. Young. 2001. Corpus-based dia-
logue simulation for automatic strategy learning and
evaluation. In Proceedings NAACL Workshop on
Adaptation in Dialogue.
S. Singh, M. Kearns, D. Litman, and M. Walker. 2000.
Reinforcement learning for spoken dialogue sys-
tems. In S. Solla, T. Leen, and K. Mu?ller, editors,
Advances in Neural Information Processing Systems
(NIPS). MIT Press.
J. Williams. 2008. Evaluating user simulations with
the Crame?r-von Mises divergence. Speech Commu-
nication, 50:829?846.
S. Young, M. Gas?ic?, S. Keizer, F. Mairesse, B. Thom-
son, and K. Yu. 2009. The Hidden Information
State model: a practical framework for POMDP
based spoken dialogue management. Computer
Speech and Language, 24(2):150?174.
I. Zukerman and D. Albrecht. 2001. Predictive statis-
tical models for user modeling. User Modeling and
User-Adapted Interaction, 11:5?18.
123
Proceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 201?204,
The University of Tokyo, September 24-25, 2010. c?2010 Association for Computational Linguistics
Gaussian Processes for Fast Policy Optimisation of POMDP-based
Dialogue Managers
M. Gas?ic?, F. Jurc???c?ek, S. Keizer, F. Mairesse, B. Thomson, K. Yu and S. Young
Cambridge University Engineering Department
Trumpington Street, Cambridge CB2 1PZ, UK
{mg436, fj228, sk561, farm2, brmt2, ky219, sjy}@eng.cam.ac.uk
Abstract
Modelling dialogue as a Partially Observ-
able Markov Decision Process (POMDP)
enables a dialogue policy robust to speech
understanding errors to be learnt. How-
ever, a major challenge in POMDP pol-
icy learning is to maintain tractability, so
the use of approximation is inevitable.
We propose applying Gaussian Processes
in Reinforcement learning of optimal
POMDP dialogue policies, in order (1) to
make the learning process faster and (2) to
obtain an estimate of the uncertainty of the
approximation. We first demonstrate the
idea on a simple voice mail dialogue task
and then apply this method to a real-world
tourist information dialogue task.
1 Introduction
One of the main challenges in dialogue manage-
ment is effective handling of speech understand-
ing errors. Instead of hand-crafting the error han-
dler for each dialogue step, statistical approaches
allow the optimal dialogue manager behaviour
to be learnt automatically. Reinforcement learn-
ing (RL), in particular, enables the notion of plan-
ning to be embedded in the dialogue management
criteria. The objective of the dialogue manager is
for each dialogue state to choose such an action
that leads to the highest expected long-term re-
ward, which is defined in this framework by the Q-
function. This is in contrast to Supervised learn-
ing, which estimates a dialogue strategy in such a
way as to make it resemble the behaviour from a
given corpus, but without directly optimising over-
all dialogue success.
Modelling dialogue as a Partially Observable
Markov Decision Process (POMDP) allows action
selection to be based on the differing levels of un-
certainty in each dialogue state as well as the over-
all reward. This approach requires that a distribu-
tion of states (belief state) is maintained at each
turn. This explicit representation of uncertainty in
the POMDP gives it the potential to produce more
robust dialogue policies (Young et al, 2010).
The main challenge in the POMDP approach is
the tractability of the learning process. A dis-
crete state space POMDP can be perceived as a
continuous space MDP where the state space con-
sists of the belief states of the original POMDP.
A grid-based approach to policy optimisation as-
sumes discretisation of this space, allowing for
discrete space MDP algorithms to be used for
learning (Brafman, 1997) and thus approximating
the optimal Q-function. Such an approach takes
the order of 100, 000 dialogues to train a real-
world dialogue manager. Therefore, the training
normally takes place in interaction with a simu-
lated user, rather than real users. This raises ques-
tions regarding the quality of the approximation
as well as the potential discrepancy between sim-
ulated and real user behaviour.
Gaussian Processes have been successfully used
in Reinforcement learning for continuous space
MDPs, for both model-free approaches (Engel et
al., 2005) and model-based approaches (Deisen-
roth et al, 2009). We propose using GP Rein-
forcement learning in a POMDP dialogue man-
ager to, firstly, speed up the learning process and,
secondly, obtain the uncertainty of the approxima-
tion. We opt for the model-free approach since it
has the potential to allow the policy obtained in
interaction with the simulated user to be further
refined in interaction with real users.
In the next section, the core idea of the method is
explained on a toy dialogue problem where differ-
ent aspects of GP learning are examined. Follow-
ing that, in Section 3, it is demonstrated how this
methodology can be effectively applied to a real
world dialogue. We conclude with Section 4.
2 Gaussian Process RL on a Toy Problem
2.1 Gaussian Process RL
A Gaussian Process is a generative model of
Bayesian inference that can be used for function
regression (Rasmussen and Williams, 2005). A
Gaussian Process is fully defined by a mean and a
kernel function. The kernel function defines prior
function correlations, which is crucial for obtain-
ing good posterior estimates with just a few ob-
servations. GP-Sarsa is an on-line reinforcement
learning algorithm for both continuous and dis-
crete MDPs that incorporates GP regression (En-
201
gel et al, 2005). Given the observation of rewards,
it estimates the Q-function utilising its correlations
in different parts of the state and the action space
defined by the kernel function. It also gives a vari-
ance of the estimate, thus modelling the uncer-
tainty of the approximation.
2.2 Voice Mail Dialogue Task
In order to demonstrate how this methodology
can be applied to a dialogue system, we first ex-
plain the idea on the voice mail dialogue prob-
lem (Williams, 2006).
The state space of this task consists of three states:
the user asked for the message either to be saved
or deleted, or the dialogue ended. The system
can take three actions: ask the user what to do,
save or delete the message. The observation of
what the user wants is corrupted with noise, there-
fore we model this as a three-state POMDP. This
POMDP can be viewed as a continuous MDP,
where the MDP state is the POMDP belief state,
a 3-dimensional vector of probabilities. For both
learning and evaluation, a simulated user is used
which makes an error with probability 0.3 and ter-
minates the dialogue after at most 10 turns. In the
final state, it gives a positive reward of 10 or a
penalty of ?100 depending on whether the system
performed a correct action or not. Each interme-
diate state receives the penalty of ?1. In order to
keep the problem simple, a model defining tran-
sition and observation probabilities is assumed so
that the belief can be easily updated, but the policy
optimisation is performed in an on-line fashion.
2.3 Kernel Choice for GP-Sarsa
The choice of kernel function is very important
since it defines the prior knowledge about the Q-
function correlations. They have to be defined on
both states and actions. In the voice mail dialogue
problem the action space is discrete, so we opt for
a simple ? kernel over actions:
k(a, a?) = 1 ? ?a(a?), (1)
where ?a is the Kronecker delta function. The
state space is a 3-dimensional continuous space
and the kernel functions over the state space that
we explore are given in Table 1. Each kernel func-
kernel function expression
polynomial k(x,x?) = ?x,x??
parametrised poly. k(x,x?) =
PD
i=1
xix
?
i
r2i
Gaussian k(x,x?) = p2 exp ? ?x ? x
??2
2?2k
scaled norm k(x,x?) = 1 ? ?x ? x
??2
?x?2?x??2
Table 1: Kernel functions
tion defines a different correlation. The polyno-
mial kernel views elements of the state vector as
features, the dot-product of which defines the cor-
relation. They can be given different relevance ri
in the parametrised version. The Gaussian ker-
nel accounts for smoothness, i.e., if two states are
close to each other the Q-function in these states
is correlated. The scaled norm kernel defines posi-
tive correlations in the points that are close to each
other and a negative correlation otherwise. This
is particularly useful for the voice mail problem,
where, if two belief states are very different, tak-
ing the same action in these states generates a neg-
atively correlated reward.
2.4 Optimisation of Kernel Parameters
Some kernel functions are in a parametrised
form, such as Gaussian or parametrised polyno-
mial kernel. These parameters, also called the
hyper-parameters, are estimated by maximising
the marginal likelihood1 on a given corpus (Ras-
mussen and Williams, 2005). We adapted the
available code (Rasmussen and Williams, 2005)
for the Reinforcement learning framework to ob-
tain the optimal hyper-parameters using a dialogue
corpus labelled with states, actions and rewards.
2.5 Grid-based RL Algorithms
To assess the performance of GP-Sarsa, it was
compared with a standard grid-based algorithm
used in (Young et al, 2010). The grid-based ap-
proach discretises the continuous space into re-
gions with their representative points. This then
allows discrete MDP algorithms to be used for pol-
icy optimisation, in this case the Monte Carlo Con-
trol (MCC) algorithm (Sutton and Barto, 1998).
2.6 Optimal POMDP Policy
The optimal POMDP policy was obtained us-
ing the POMDP solver toolkit (Cassandra, 2005),
which implements the Point Based Value Itera-
tion algorithm to solve the POMDP off-line using
the underlying transition and observation proba-
bilities. We used 300 sample dialogues between
the dialogue manager governed by this policy and
the simulated user as data for optimisation of the
kernel hyper-parameters (see Section 2.4).
2.7 Training set-up and Evaluation
The dialogue manager was trained in interaction
with the simulated user and the performance was
compared between the grid-based MCC algorithm
and GP-Sarsa across different kernel functions
from Table 1.
The intention was, not only to test which algo-
rithm yields the best policy performance, but also
to examine the speed of convergence to the opti-
mal policy. All the algorithms use an ?-greedy
approach where the exploration rate ? was fixed
at 0.1. The learning process greatly depends on
1Also called evidence maximisation in the literature.
202
the actions that are taken during exploration. If
early on during the training, the systems discovers
a path that generates high rewards due to a lucky
choice of actions, then the convergence is faster.
To alleviate this, we adopted the following proce-
dure. For every training set-up, exactly the same
training iterations were performed using 1000 dif-
ferent random generator seedings. After every 20
dialogues the resulting 1000 partially optimised
policies were evaluated. Each of them was tested
on 1000 dialogues. The average reward of these
1000 dialogues provides just one point in Fig. 1.
20 60 100 140 180 220 260 300 340 380 420 460 500 540 580 620
?50
?45
?40
?35
?30
?25
?20
?15
?10
?5
0
Training dialogues
Av
er
ag
e 
re
wa
rd
polynomial kernel ? 
? Gaussian kernel with learned hyper?parameters
? scaled norm kernel
polynomial kernel with learned hyper?parameters
?
 
 
Optimal POMDP Policy
GP?Sarsa
Grid?based Monte Carlo Control
Figure 1: Evaluation results on Voice Mail task
The grid-based MCC algorithm used a Euclid-
ian distance to generate the grid by adding every
point that was further than 0.01 from other points
as a representative of a new region. As can be
seen from Fig 1, the grid-Based MCC algorithm
has a relatively slow convergence rate. GP-Sarsa
with the polynomial kernel exhibited a learning
rate similar to MCC in the first 300 training di-
alogues, continuing with a more upward learning
trend. The parametrised polynomial kernel per-
forms slightly better. The Gaussian kernel, how-
ever, achieves a much faster learning rate. The
scaled norm kernel achieved close to optimal per-
formance in 400 dialogues, with a much higher
convergence rate then the other methods.
3 Gaussian Process RL on a Real-world
Task
3.1 HIS Dialogue Manager on CamInfo
Domain
We investigate the use of GP-Sarsa in a real-
world task by extending the Hidden Information
State (HIS) dialogue manager (Young et al, 2010).
The application domain is tourist information for
Cambridge, whereby the user can ask for informa-
tion about a restaurant, hotel, museum or another
tourist attraction in the local area. The database
consists of more than 400 entities each of which
has up to 10 attributes that the user can query.
The HIS dialogue manager is a POMDP-based di-
alogue manager that can tractably maintain belief
states for large domains. The key feature of this
approach is the grouping of possible user goals
into partitions, using relationships between differ-
ent attributes from possible user goals. Partitions
are combined with possible user dialogue actions
from the N-best user input as well as with the di-
alogue history. This combination forms the state
space ? the set of hypotheses, the probability dis-
tribution over which is maintained during the di-
alogue. Since the number of states for any real-
world problem is too large, for tractable policy
learning, both the state and the action space are
mapped into smaller scale summary spaces. Once
an adequate summary action is found in the sum-
mary space, it is mapped back to form an action in
the original master space.
3.2 Kernel Choice for GP-Sarsa
The summary state in the HIS system is a four-
dimensional space consisting of two elements that
are continuous (the probability of the top two hy-
potheses) and two discrete elements (one relating
the portion of the database entries that matches the
top partition and the other relating to the last user
action type). The summary action space is discrete
and consists of eleven elements.
In order to apply the GP-Sarsa algorithm, a kernel
function needs to be specified for both the sum-
mary state space and the summary action space.
The nature of this space is quite different from the
one described in the toy problem. Therefore, ap-
plying a kernel that has negative correlations, such
as the scaled norm kernel (Table 1) might give un-
expected results. More specifically, for a given
summary action, the mapping procedure finds the
most appropriate action to perform if such an ac-
tion exists. This can lead to a lower reward if
the summary action is not adequate but would
rarely lead to negatively correlated rewards. Also,
parametrised kernels could not be used for this
task, since there was no corpus available for hyper-
parameter optimisation. The polynomial kernel
(Table 1) assumes that the elements of the space
are features. Due to the way the probability is
maintained over this very large state space, the
continuous variables potentially encode more in-
formation than in the simple toy problem. There-
fore, we used the polynomial kernel for the con-
tinuous elements. For discrete elements, we utilise
the ?-kernel (Eq. 2.3).
3.3 Active Learning GP-Sarsa
The GP RL framework enables modelling the un-
certainty of the approximation. The uncertainty
estimate can be used to decide which actions
to take during the exploration (Deisenroth et al,
203
2009). In detail, instead of a random action, the
action in which the Q-function for the current state
has the highest variance is taken.
3.4 Training Set-up and Evaluation
Policy optimisation is performed by interacting
with a simulated user on the dialogue act level.
The simulated user gives a reward at the final state
of the dialogue, and that is 20 if the dialogue was
successful, 0 otherwise, less the number of turns
taken to fulfil the user goal. The simulated user
takes a maximum of 100 turns in each dialogue,
terminating it when all the necessary information
has been obtained or if it looses patience.
A grid-based MCC algorithm provides the base-
line method. The distance metric used ensures
that the number of regions in the grid is small
enough for the learning to be tractable (Young et
al., 2010).
In order to measure how fast each algorithm
learns, a similar training set-up to the one pre-
sented in Section 2.7 was adopted and the aver-
aged results are plotted on the graph, Fig. 2.
200 400 600 800 1000 1200 1400 1600 1800 2000 2200 2400 2600 2800 3000
2
3
4
5
6
7
8
9
Training dialogues
Av
er
ag
e 
re
wa
rd
?  Grid?based Monte Carlo Control
?  GP?Sarsa with polynomial kernel
?  Active learning GP?Sarsa with polynomial kernel
Figure 2: Evaluation results on CamInfo task
The results show that in the very early stage of
learning, i.e., during the first 400 dialogues, the
GP-based method learns faster. Also, the learning
process can be accelerated by adopting the active
learning framework where the actions are selected
based on the estimated uncertainty.
After performing many iterations in an incremen-
tal noise learning set-up (Young et al, 2010) both
the GP-Sarsa and the grid-based MCC algorithms
converge to the same performance.
4 Conclusions
This paper has described how Gaussian Processes
in Reinforcement learning can be successfully ap-
plied to dialogue management. We implemented
a GP-Sarsa algorithm on a toy dialogue prob-
lem, showing that with an appropriate kernel func-
tion faster convergence can be achieved. We also
demonstrated how kernel parameters can be learnt
from a dialogue corpus, thus creating a bridge
between Supervised and Reinforcement learning
methods in dialogue management. We applied
GP-Sarsa to a real-world dialogue task showing
that, on average, this method can learn faster than
a grid-based algorithm. We also showed that the
variance that GP is estimating can be used in an
Active learning setting to further accelerate policy
optimisation.
Further research is needed in the area of kernel
function selection. The results here suggest that
the GP framework can facilitate faster learning,
which potentially allows the use of larger sum-
mary spaces. In addition, being able to learn ef-
ficiently from a small number of dialogues offers
the potential for learning from direct interaction
with real users.
Acknowledgements
The authors would like to thank Carl Rasmussen
for valuable discussions. This research was partly
funded by the UK EPSRC under grant agreement
EP/F013930/1 and by the EU FP7 Programme un-
der grant agreement 216594 (CLASSiC project).
References
RI Brafman. 1997. A Heuristic Variable Grid Solution
Method for POMDPs. In AAAI, Cambridge, MA.
AR Cassandra. 2005. POMDP solver.
http://www.cassandra.org/pomdp/
code/index.shtml.
MP Deisenroth, CE Rasmussen, and J Peters. 2009.
Gaussian Process Dynamic Programming. Neuro-
comput., 72(7-9):1508?1524.
Y Engel, S Mannor, and R Meir. 2005. Reinforcement
learning with Gaussian processes. In ICML ?05:
Proceedings of the 22nd international conference on
Machine learning, pages 201?208, New York, NY.
CE Rasmussen and CKI Williams. 2005. Gaussian
Processes for Machine Learning. MIT Press, Cam-
bridge, MA.
RS Sutton and AG Barto. 1998. Reinforcement Learn-
ing: An Introduction. Adaptive Computation and
Machine Learning. MIT Press, Cambridge, MA.
JD Williams. 2006. Partially Observable Markov De-
cision Processes for Spoken Dialogue Management.
Ph.D. thesis, University of Cambridge.
SJ Young, M Gas?ic?, S Keizer, F Mairesse, J Schatz-
mann, B Thomson, and K Yu. 2010. The Hid-
den Information State Model: a practical frame-
work for POMDP-based spoken dialogue manage-
ment. Computer Speech and Language, 24(2):150?
174.
204
Proceedings of the SIGDIAL 2013 Conference, pages 154?156,
Metz, France, 22-24 August 2013. c?2013 Association for Computational Linguistics
Demonstration of the Parlance system: a data-driven,
incremental, spoken dialogue system for interactive search
Helen Hastie, Marie-Aude Aufaure?, Panos Alexopoulos, Heriberto Cuay?huitl, Nina Dethlefs,
Milica Gasic, James Henderson, Oliver Lemon, Xingkun Liu, Peter Mika, Nesrine Ben Mustapha,
Verena Rieser, Blaise Thomson, Pirros Tsiakoulis, Yves Vanrompay, Boris Villazon-Terrazas, Steve Young
email: h.hastie@hw.ac.uk. See http://parlance-project.eu for full list of affiliations
Abstract
The Parlance system for interactive
search processes dialogue at a micro-
turn level, displaying dialogue phe-
nomena that play a vital role in hu-
man spoken conversation. These di-
alogue phenomena include more nat-
ural turn-taking through rapid sys-
tem responses, generation of backchan-
nels, and user barge-ins. The Par-
lance demonstration system differen-
tiates from other incremental systems
in that it is data-driven with an infras-
tructure that scales well.
1 Introduction
The Parlance system provides interactive
search through a Spoken Dialogue System
(SDS). This SDS aims to be incremental to al-
low for more natural spoken interaction. Tra-
ditionally, the smallest unit of speech process-
ing for interactive systems has been a full ut-
terance with strict, rigid turn-taking. The
Parlance architecture, however, is an incre-
mental framework that allows for processing
of smaller ?chunks? of user input, which en-
ables one to model dialogue phenomena such
as barge-ins and backchannels. This work is
carried out under the FP7 EC project Par-
lance 1, the goal of which is to develop inter-
active search through speech in multiple lan-
guages. The domain for the demonstration
system is interactive search for restaurants in
San Francisco. An example dialogue is given
in Table 1.
?Authors are in alphabetical order
1http://www.parlance-project.eu
SYS Thank you for calling the Parlance Restaurant
system. You may ask for information by cuisine
type, price range or area. How may I help you?
USR I want to find an Afghan restaurant.........which is
in the cheap price range.
SYS .......................................................[uhuhh]........
The Helmand Palace is a cheerful setting for au-
thentic Afghan cuisine.
USR What is the address and phone number?
SYS The address 2424 Van Ness Ave ....
Table 1: Example dialogue excerpt for restaurant in-
formation in San Francisco
2 Background
Previous work includes systems that can deal
with ?micro-turns? (i.e. sub-utterance process-
ing units), resulting in dialogues that are more
fluid and responsive. This has been backed up
by a large body of psycholinguistic literature
that indicates that human-human interaction
is in fact incremental (Levelt, 1989).
It has been shown that incremental dia-
logue behaviour can improve the user experi-
ence (Skantze and Schlangen, 2009; Baumann
et al, 2011; Selfridge et al, 2011) and en-
able the system designer to model several di-
alogue phenomena that play a vital role in
human discourse (Levelt, 1989) but have so
far been absent from systems. These dialogue
phenomena that will be demonstrated by the
Parlance system include more natural turn-
taking through rapid system responses, gener-
ation of backchannels and user barge-ins. The
system differentiates from other incremental
systems in that it is entirely data-driven with
an infrastructure that potentially scales well.
3 System Architecture
Figure 1 gives an overview of the Par-
lance system architecture, which maintains
154
LOCAL SEARCH ENGINE
AUTOMATIC SPEECH RECOGNITION
NLG
AUDIO I/O
TTS
BACKCHANNEL GENERATOR
IM
MIM
HUB
KNOWLEDGE BASE
WavePackets
1-Best Words
Segmentlabel
N-Best Phrase List
WavePackets
Micro-Turn Dialogue Act
System Dialogue Act
String Packets
StringPackets
VoIP Interface (PJSIP)
N-best Dialogue Act Units
 API call ( + metadata)
Search Response
Partial Dialogue Act (in case of interruption)
PartialString(in case of interruption)SPOKEN LANGUAGE UNDERSTANDING Decode from t0 to t1
Figure 1: Overview of the Parlance system
architecture
the modularity of a traditional SDS while at
the same time allowing for complex interaction
at the micro-turn level between components.
Each component described below makes use
of the PINC (Parlance INCremental) dialogue
act schema. In this scheme, a complete dia-
logue act is made up of a set of primitive di-
alogue acts which are defined as acttype-item
pairs. The PINC dialogue act scheme supports
incrementality by allowing SLU to incremen-
tally output primitive dialogue acts whenever
a complete acttype-item pair is recognised with
sufficient confidence. The complete dialogue
act is then the set of these primitive acts out-
put during the utterance.
3.1 Recognition and Understanding
The Automatic Speech Recogniser (ASR) and
Spoken Language Understanding (SLU) com-
ponents operate in two passes. The audio in-
put is segmented by a Voice Activity Detec-
tor and then coded into feature vectors. For
the first pass of the ASR2, a fast bigram de-
coder performs continuous traceback generat-
ing word by word output. During this pass,
while the user is speaking, an SLU module
called the ?segment decoder? is called incre-
2http://mi.eng.cam.ac.uk/research/dialogue/
ATK_Manual.pdf
mentally as words or phrases are recognised.
This module incrementally outputs the set of
primitive dialogue acts that can be detected
based on each utterance prefix. Here, the ASR
only provides the single best hypothesis, and
SLU only outputs a single set of primitive dia-
logue acts, without an associated probability.
On request from the Micro-turn Interaction
Manager (MIM), a second pass can be per-
formed to restore the current utterance using a
trigram language model, and return a full dis-
tribution over the complete phrase as a con-
fusion network. This is then passed to the
SLU module which outputs the set of alter-
native complete interpretations, each with its
associated probability, thus reflecting the un-
certainty in the ASR-SLU understanding pro-
cess.
3.2 Interaction Management
Figure 1 illustrates the role of the Micro-turn
Interaction Manager (MIM) component in the
overall Parlance architecture. In order to
allow for natural interaction, the MIM is re-
sponsible for taking actions such as listening to
the user, taking the floor, and generating back-
channels at the micro-turn level. Given various
features from different components, the MIM
selects a micro-turn action and sends it to the
IM and back-channel generator component to
generate a system response.
Micro-turn Interaction Manager A
baseline hand-crafted MIM was developed
using predefined rules. It receives turn-taking
information from the TTS, the audio-output
component, the ASR and a timer, and updates
turn-taking features. Based on the current
features and predefined rules, it generates
control signals and sends them to the TTS,
ASR, timer and HUB. In terms of micro-turn
taking, for example, if the user interrupts
the system utterance, the system will stop
speaking and listen to the user. The system
also outputs a short back-channel and stays in
user turn state if the user utterance provides
limited information.
Interaction Manager Once the MIM has
decided when the system should take the floor,
it is the task of the IM to decide what to say.
The IM is based on the partially observable
155
Markov decision process (POMDP) frame-
work, where the system?s decisions can be op-
timised via reinforcement learning. The model
adopted for Parlance is the Bayesian Update
of Dialogue State (BUDS) manager (Thom-
son and Young, 2010). This POMDP-based
IM factors the dialogue state into condition-
ally dependent elements. Dependencies be-
tween these elements can be derived directly
from the dialogue ontology. These elements
are arranged into a dynamic Bayesian network
which allows for their marginal probabilities
to be updated during the dialogue, compris-
ing the belief state. The belief state is then
mapped into a smaller-scale summary space
and the decisions are optimised using the nat-
ural actor critic algorithm.
HUB The HUB manages the high level flow
of information. It receives turn change infor-
mation from the MIM and sends commands
to the SLU/IM/NLG to ?take the floor? in the
conversation and generate a response.
3.3 Generation and TTS
We aim to automatically generate language,
trained from data, that is (1) grammatically
well formed, (2) natural, (3) cohesive and (4)
rapidly produced at runtime. Whilst the first
two requirements are important in any dia-
logue system, the latter two are key require-
ments for systems with incremental processing,
in order to be more responsive. This includes
generating back-channels, dynamic content re-
ordering (Dethlefs et al, 2012), and surface
generation that models coherent discourse phe-
nomena, such as pronominalisation and co-
reference (Dethlefs et al, 2013). Incremen-
tal surfacce generation requires rich context
awareness in order to keep track of all that has
been generated so far. We therefore treat sur-
face realisation as a sequence labelling task and
use Conditional Random Fields (CRFs), which
take semantically annotated phrase structure
trees as input, in order to represent long dis-
tance linguistic dependencies. This approach
has been compared with a number of compet-
itive state-of-the art surface realisers (Deth-
lefs et al, 2013), and can be trained from
minimally labelled data to reduce development
time and facilitate its application to new do-
mains.
The TTS component uses a trainable HMM-
based speech synthesizer. As it is a paramet-
ric model, HMM-TTS has more flexibility than
traditional unit-selection approaches and is es-
pecially useful for producing expressive speech.
3.4 Local Search and Knowledge Base
The domain ontology is populated by the local
search component and contains restaurants in
5 regional areas of San Francisco. Restaurant
search results are returned based on their lon-
gitude and latitude for 3 price ranges and 52
cuisine types.
4 Future Work
We intend to perform a task-based evaluation
using crowd-sourced users. Future versions
will use a dynamic Knowledge Base and User
Model for adapting to evolving domains and
personalised interaction respectively.
Acknowledgements
The research leading to this work was funded by the EC
FP7 programme FP7/2011-14 under grant agreement
no. 287615 (PARLANCE).
References
T. Baumann, O. Buss, and D. Schlangen. 2011. Eval-
uation and Optimisation of Incremental Processors.
Dialogue and Discourse, 2(1).
Nina Dethlefs, Helen Hastie, Verena Rieser, and Oliver
Lemon. 2012. Optimising Incremental Generation
for Spoken Dialogue Systems: Reducing the Need
for Fillers. In Proceedings of INLG, Chicago, USA.
N. Dethlefs, H. Hastie, H. Cuay?huitl, and O. Lemon.
2013. Conditional Random Fields for Responsive
Surface Realisation Using Global Features. In Pro-
ceedings of ACL, Sofia, Bulgaria.
W. Levelt. 1989. Speaking: From Intenion to Articu-
lation. MIT Press.
E. Selfridge, I. Arizmendi, P. Heeman, and J. Williams.
2011. Stability and Accuracy in Incremental Speech
Recognition. In Proceedings of SIGDIAL, Portland,
Oregon.
G. Skantze and D. Schlangen. 2009. Incremental Dia-
logue Processing in a Micro-Domain. In Proceedings
of EACL, Athens, Greece.
B Thomson and S Young. 2010. Bayesian update of
dialogue state: A POMDP framework for spoken
dialogue systems. Computer Speech and Language,
24(4):562?588.
156
Proceedings of the SIGDIAL 2013 Conference, pages 214?222,
Metz, France, 22-24 August 2013. c?2013 Association for Computational Linguistics
POMDP-based dialogue manager adaptation to extended domains
M. Gas?ic?, C. Breslin, M. Henderson, D. Kim, M. Szummer, B. Thomson, P. Tsiakoulis and S. Young
Cambridge University Engineering Department
{mg436,cb404,mh521,dk449,mos25,brmt2,pt344,sjy}@eng.cam.ac.uk
Abstract
Existing spoken dialogue systems are typ-
ically designed to operate in a static and
well-defined domain, and are not well
suited to tasks in which the concepts and
values change dynamically. To handle dy-
namically changing domains, techniques
will be needed to transfer and reuse ex-
isting dialogue policies and rapidly adapt
them using a small number of dialogues in
the new domain. As a first step in this di-
rection, this paper addresses the problem
of automatically extending a dialogue sys-
tem to include a new previously unseen
concept (or slot) which can be then used
as a search constraint in an information
query. The paper shows that in the con-
text of Gaussian process POMDP optimi-
sation, a domain can be extended through
a simple expansion of the kernel and then
rapidly adapted. As well as being much
quicker, adaptation rather than retraining
from scratch is shown to avoid subjecting
users to unacceptably poor performance
during the learning stage.
1 Introduction
Existing spoken dialogue systems are typically de-
signed to operate in a static and well-defined do-
main, and are not well suited to tasks in which
the concepts and values change dynamically. For
example, consider a spoken dialogue system in-
stalled in a car, which is designed to provide in-
formation about nearby hotels and restaurants. In
this case, not only will the data change as the
car moves around, but the concepts (or slots) that
a user might wish to use to frame a query will
also change. For example, a restaurant system de-
signed to be used within cities might not have the
concept of ?al fresco? dining and could not there-
fore handle a query such as ?Find me a French
restaurant where I can eat outside?. In order to
make this possible, techniques will be needed to
extend and adapt existing dialogue policies.
Adaptation can be viewed as a process of im-
proving action selection in a different condition to
the one in which the policy was originally trained.
While adaptation has been extensively studied in
speech recognition (see an overview in (Gales and
Young, 2007)), in spoken dialogue systems it is
still relatively novel and covers a wide range of
possible research topics (Litman and Pan, 1999;
Litman and Pan, 2002; Georgila and Lemon, 2004;
Janarthanam and Lemon, 2010).
A recent trend in statistical dialogue modelling
has been to model dialogue as a partially ob-
servable Markov decision process (POMDP). This
provides increased robustness to errors in speech
understanding and automatic dialogue policy op-
timisation via reinforcement learning (Roy et al,
2000; Zhang et al, 2001; Williams and Young,
2007; Young et al, 2010; Thomson and Young,
2010). A POMDP-based dialogue manager main-
tains a distribution over every possible dialogue
state at every dialogue turn. This is called the
belief state. Based on that distribution the sys-
tem chooses the action that gives the highest ex-
pected reward, measured by the Q-function. The
Q-function for a belief state and an action is the
expected cumulative reward that can be obtained
if that action is taken in that belief state. The opti-
misation typically requires O(105) to O(106) di-
alogues, so is normally done in interaction with a
simulated user (Jurc???c?ek et al, 2011b).
In reinforcement learning, policy adaptation has
been addressed in the context of transfer learn-
ing (Taylor and Stone, 2009). The core idea is to
exploit expertise gained in one domain (source do-
main) to improve learning in another domain (tar-
get domain). A number of techniques have been
developed but they have not been previously ap-
plied to dialogue management.
214
Gaussian process (GP) based reinforcement
learning (Engel, 2005) has been recently applied
to POMDP dialogue policy optimisation in or-
der to exploit the correlations between different
belief states and thus reduce the number of dia-
logues needed for the learning process (Gas?ic? et
al., 2010).
An important feature of a Gaussian process is
that it can incorporate a prior mean and variance
for the function it estimates, in this case the Q-
function. Setting these appropriately can signif-
icantly speed up the process of learning. If the
mean or the variance are estimated in one envi-
ronment, for example a particular user type or a
particular domain, they can be used as a prior for
adaptation in a different environment, i.e. another
user type or another domain. A Gaussian process
does not depend on the belief state but on the cor-
relation between two belief states encoded by the
kernel function. Therefore, if one defines a kernel
function for two belief states in one domain, the
policy can be used in a different domain, provided
that the correlations between belief states follow a
similar pattern.
This paper explores the problem of extending an
existing domain by introducing a previously un-
seen slot. Specifically, a simple restaurant system
is considered which allows a user to search for
restaurants based on food-type and area. This do-
main is then extended by introducing an additional
price-range slot. The policy is trained for the basic
two-slot domain and then reused in the extended
domain by defining a modified kernel function and
using adaptation. This strategy not only allows for
the knowledge of a previously trained policy to be
reused but it also guards against poor performance
in the early stages of learning. This is particularly
useful in a real-world situation where the adapta-
tion is performed in direct interaction with users.
In addition, a potential application of this tech-
nique to reduce the number of training dialogues
is examined. The domain is decomposed into a
series of simple domains and the policy is grad-
ually adapted to the final domain with a smaller
number of dialogues than are normally needed for
training.
The rest of the paper is organised as follows. In
Section 2 the background on Gaussian processes
in POMDP optimisation is given. Then Section 3
gives a description of the Bayesian Update of Di-
alogue State dialogue manager, which is used as
a test-bed for the experiments. In Section 4, a
simple method of kernel modification is described
which allows a policy trained in the basic domain
to be used in an extended domain. Methods of
fast adaptation are investigated in Section 5 and
this adaptation strategy is then tested via interac-
tion with humans using the Amazon Mechanical
Turk service in Section 6. Finally, the use of re-
peated adaptation to speed up the process of policy
optimisation by learning gradually from simple to
more complex domains is explored in Section 7,
before presenting conclusions in Section 8.
2 Gaussian processes in POMDPs
The role of a dialogue policy pi is to map each be-
lief state b ? B into an action a ? A so as to
maximise the expected cumulative reward, a mea-
sure of how good the dialogue is.
The expected cumulative reward is defined by
the Q-function as:
Q(b, a) = Epi
( T?
?=t+1
???t?1r? |bt = b, at = a
)
,
(1)
where r? is the reward obtained at time ? , T is
the dialogue length and ? is the discount factor,
0 < ? ? 1. Optimising the Q-function is then
equivalent to optimising the policy pi.
A Gaussian process (GP) is a non-parametric
Bayesian probabilistic model that can be used
for function regression (Rasmussen and Williams,
2005). It is fully defined by a mean and a kernel
function which defines prior function correlations.
GP-Sarsa is an on-line RL algorithm that mod-
els the Q-function as a Gaussian process (Engel
et al, 2005), Q(b, a) ? GP (0, k((b, a), (b, a)))
where the kernel k(?, ?) is factored into separate
kernels over the belief state and action spaces
kC(b,b?)kA(a, a?). For a sequence of belief state-
action pairs Bt = [(b0, a0), . . . , (bt, at)]T visited
in a dialogue and the corresponding observed im-
mediate rewards rt = [r1, . . . , rt]T, the posterior
of the Q-function for any belief state-action pair
(b, a) is defined by the following:
215
Q(b, a)|rt,Bt ? N (Q(b, a), cov((b, a), (b, a))),
Q(b, a) = kt(b, a)THTt (HtKtHTt + ?2HtHTt )?1rt,
cov((b, a), (b, a)) = k((b, a), (b, a))? kt(b, a)THTt (HtKtHTt + ?2HtHTt )?1Htkt(b, a)
Ht =
?
????
1 ?? ? ? ? 0 0
0 1 ? ? ? 0 0
... . . . . . . ... ...
0 ? ? ? 0 1 ??
?
???? ,
kt(b, a) = [k((b0, a0), (b, a)), . . . , k((bt, at), (b, a))]T,
Kt = [kt((b0, a0)), . . . ,kt((bt, at))]
(2)
where Kt is the Gram matrix ? the matrix of the
kernel function values for visited points Bt, Ht is
a linear operator that captures the reward looka-
head from the Q-function (see Eq. 1) and ?2 is
an additive noise parameter which controls how
much variability in theQ-function estimate we ex-
pect during the process of learning.
If we assume that the Gaussian process
places a prior mean on the Q-function,
Q(b, a) ? GP (m(b, a), k((b, a), (b, a)))
then the posterior mean Q(b, a) is given by (Ras-
mussen and Williams, 2005):
Q(b, a) = m(b, a) + kt(b, a)THTt (HtKtHTt + ?2HtHTt )?1(rt ?mt), (3)
where mt = [m(b0, a0), . . . ,m(bt, at)]T. The
estimate of the variance is same as in Eq. 2.
The Q-function posterior in Eqs. 2 and 3
defines a Gaussian distribution for every be-
lief state-action pair. Thus, when a new be-
lief state b is encountered, for each action a ?
A, there is a Gaussian distribution Q(b, a) ?
N (Q(b, a), cov((b, a), (b, a)))). Sampling from
these Gaussian distributions gives a set of Q-
values for each action {Q(b, a) : a ? A} from
which the action with the highest sampledQ-value
can be selected:
pi(b) = argmax
a
{Q(b, a) : a ? A} . (4)
In this way, the stochastic model of theQ-function
is effectively transformed into a stochastic policy
model, which can be optimised to maximise the re-
ward (Geist and Pietquin, 2011; Gas?ic? et al, 2011;
Gas?ic? et al, 2012).
Due to the matrix inversion in Eq. 2, the compu-
tational complexity of calculating the Q-function
posterior is O(t3), where t is the number of data
points in Bt, and this poses a serious computa-
tional problem. The algorithm used here to ap-
proximate the Gaussian process is the kernel span
sparsification method described in (Engel, 2005).
In this case, only a set of representative data points
is retained ? called the dictionary of visited points.
3 BUDS dialogue manager
The Bayesian Update of Dialogue State (BUDS)
dialogue manager is a POMDP-based dialogue
manager (Thomson and Young, 2010) which fac-
torises the dialogue state into conditionally de-
pendent elements. These elements are arranged
into a dynamic Bayesian network, which allows
for their marginal probability distributions to be
updated during the dialogue. Thus, the belief
state of the BUDS dialogue manager consists of
the marginal posterior probability distribution over
hidden nodes in the Bayesian network. The hidden
nodes in the BUDS system consist of the history
nodes and the goal nodes for each concept in the
dialogue. For instance in a restaurant information
domain these include area, food-type, address.
The history nodes define possible dialogue histo-
ries for a particular concept, eg. system-informed,
user-requested. The goal nodes define possible
values for a particular concept, eg. Chinese, In-
dian. The role of the policy pi is then to map each
216
belief state into a summary action a from the sum-
mary action space A. Once a summary action is
found it is heuristically mapped into the master
action that the system finally takes (Gas?ic? et al,
2012). The master actions are composed of dia-
logue act type and list of slot value pairs. There are
15 dialogue act types in the BUDS system that fa-
cilitate not only simple information providing sce-
narios but also more complex dialogues where the
user can change their mind and ask for alterna-
tives.
To apply GP policy optimisation, a kernel func-
tion must be defined on both the belief state space
B and the action space A. The kernel function
over the belief state b is constructed from the sum
of individual kernels over the hidden node distri-
butions, such that the kernel function of two cor-
responding nodes is based on the expected likeli-
hood kernel (Jebara et al, 2004), which is also a
simple linear inner product:
kB(b,b?) =
?
h
?bh,b?h?, (5)
where bh is the probability distribution encoded
in the hth hidden node. This kernel gives the ex-
pectation of one belief state distribution under the
other.
For history nodes, the kernel is a simple inner
product between the corresponding node distribu-
tions. While it is possible to calculate the kernel
function for the goal nodes in the same way as for
the history nodes, in this case, the choice of sys-
tem action, such as confirm or inform, does not
depend on the actual values. It rather depends on
the shape of the distribution and, in particular, it
depends on the probability of the most likely value
compared to the rest. Therefore, to exploit the cor-
relations further, the kernel over two goal nodes
is calculated as the dot product of vectors, where
each vector represents the corresponding distribu-
tion sorted into order of probability. The only ex-
ceptions are the goal for the method node and the
discourse act node. The former defines whether
the user is searching for a venue by name or by
constraints and the latter defines which discourse
act the user used, eg. acknowledgement, thank you.
Their kernels are calculated in the same way as for
the history nodes.
For the action space kernel, the ?-kernel is used
defined by:
kA(a, a?) = ?a(a?). (6)
where ?a(a?) = 1 iff a = a?.
3.1 TopTable domain
The TopTable domain consists of restaurants in
Cambridge, UK automatically extracted from the
TopTable web service (TopTable, 2012). There are
about 150 restaurants and each restaurant has 7 at-
tributes ? slots. This results in a belief space that
consists of 25 concepts where each concept takes
from 3 to 150 values and each value has a proba-
bility in [0, 1]. The summary action space consists
of 16 summary actions.
3.2 The agenda-based simulated user
In training and testing a simulated user was used.
The agenda-based user simulator (Schatzmann,
2008; Keizer et al, 2010) factorises the user state
into an agenda and a goal. The goal ensures
that the user simulator exhibits consistent, goal-
directed behaviour. The role of the agenda is to
elicit the dialogue acts that are needed for the user
simulator to fulfil the goal. In addition, an er-
ror model adds confusions to the simulated user
input such that it resembles those found in real
data (Thomson et al, 2012). The length of the N-
best list was set to 10 and the confusion rate was
set to 15% during training and testing.1 This error
rate means that 15% of time the true hypothesis is
not in the N-best list. Intermediate experimenta-
tion showed that these confusion rates are typical
of real data.
The reward function was set to give a reward
of 20 for successful dialogues, zero otherwise. In
addition, 1 is deducted for each dialogue turn to
encourage shorter dialogues. The discount factor
? is set to 1 and the dialogue length is limited to
30 turns.
4 Extended domains
Transfer learning is a reinforcement learning tech-
nique which address three problems:
? given a target domain, how to select the
most appropriate source domain from a set of
source domains,
? given a target and a source domain how to
find the relationship between them, and
? given a target and a source domain and the
relationship between them, how to effectively
transfer knowledge between them.
1Except of course where the system is explicitly tested on
varying noise levels.
217
Here we assume that we are given a source and
a target domain and that the relationship between
them is defined by mapping the kernel function.
Knowledge transfer is then effected by adapting
the source domain policy for use in the target do-
main. For the latter, two forms of adaptation are
investigated: one simply continues to update the
set of source data dictionary points with new dic-
tionary points, the second uses the source domain
posterior as a prior for the new target domain.
In this case, the source is a basic restaurant do-
main with slots name, area, food-type, phone, ad-
dress, and postcode. The extended target domain
has an additional price-range slot. We are inter-
ested primarily in training the policy on the ba-
sic domain and testing it on the extended domain.
However, since real applications may also require
a slot to be forgotten, we also investigate the re-
verse where the policy is trained in the extended
domain and tested on the basic domain.
In order to enable the required cross domain
portability, a kernel function defining the correla-
tion between belief states from differing domains
is needed. Since the extended domain has an ex-
tra slot and thus extra hidden nodes, we need to
define the correlations between the extra hidden
nodes and the hidden nodes in the belief state of
the basic domain. This can be performed in vari-
ous ways, but the simplest approach is to specify
which slot from the basic domain is most similar
to the new slot in the extended domain and then
match their corresponding hidden nodes. In that
way the belief state kernel function between two
belief states bB, bE for the basic B and the ex-
tended E domain becomes:
kB(bB,bE) =
?
h?B
?bBh ,bEh?+
?
e/?B
?bBl(e),bEe ?, (7)
where h are the hidden nodes in the basic domain,
e are the hidden nodes in the extended domain and
function l : E? B for each hidden node that does
not exist in the basic domain finds its appropriate
replacement. In the particular case studied here,
the slot area is most similar to the new price-range
slot since they both have a relatively small number
of values, about 5. Hence, l(price-range)? area.
If the cardinality of the mapped slots differ, the
shorter is padded with zeros though other forms of
normalisation are clearly possible.
The (summary) action space for the extended
domain has more actions than the basic domain.
For example, one action that exists in the extended
domain and does not exist in the basic domain is
request(price-range). To define the kernel func-
tion between these sets of actions, one can specify
for each extra action in the extended domain its
most similar action in the basic domain:
kA(aB, aE) =
{
?aB(aE) aE ? AB,
?aB(L(aE)) aE /? AB,
(8)
where function L : AE ? AB for each action
that does not exist in the basic domain finds its
replacement action.
Functions L and l are here defined manually.
However, a simple but effective heuristic would be
to find for each new slot in the extended domain, a
slot in the basic domain with similar cardinality.
Porting in the reverse direction from the ex-
tended to the basic domain is easier since one can
simply disregard the extra hidden nodes and ac-
tions in the kernel calculation.
To experimentally examine the extent to which
this method supports cross domain portability, we
trained policies for both domains until conver-
gence, using 105 dialogues on the simulated user.
We then cross tested them on the mismatching do-
mains at varying user input error rates. The results
are given in Fig. 1.
0 10 20 30 40 50ErrorRate2
0
2
4
6
8
10
12
Rewa
rd
bsc-trn&tstextd-trn&tstextd-trn&bsc-tstbsc-trn&extd-tst
Figure 1: Cross testing policies trained on differ-
ent domains. bsc refers to the basic domain, extd is
the extended domain, trn is training and tst is test-
ing.
From the results it can be seen that the policy
trained for the basic domain has a better perfor-
mance than the policy trained on the extended do-
main, when tested on the matching domain (com-
218
pare bsc-trn&tst with extd-trn&tst). The extended do-
main has more slots so it is more difficult for the
system to fulfil the user request, especially in noisy
conditions. Secondly, the performance of the pol-
icy trained on the extended domain and tested on
the basic domain is close to optimal (compare bsc-
trn&tst with extd-trn&bsc-tst). However, the pol-
icy trained on the basic domain and tested on the
extended domain has much worse performance
(compare bsc-trn&extd-tst with extd-trn&tst). It is
hard for the policy to adequately extrapolate from
the basic to the extended domain. This difference
in performance, however, motivates the need for
adaptation and this is investigated in the next sec-
tion.
5 Adaptation
Adaptation of a policy trained on one domain to
another can be performed in several ways. Here
we examine two adaptation strategies similar to
the method described in (Taylor et al, 2007),
where every action-value for each state in the tar-
get domain is initialised with learned source do-
main values.
The first strategy is to take the policy trained in
the source domain and simply continue training it
in the target domain until convergence. In Gaus-
sian process reinforcement learning, this means
that we assume a zero-mean prior on the Gaussian
process for theQ-function and let the dictionary of
visited points Bt from Eq. 2 consist of both points
visited in the source domain and the extended tar-
get domain, making sure that the Gram matrix
Kt uses extended domain kernel function where
necessary. However, the estimate of the variance
decreases with the number of visited points (see
Eq. 2). The danger therefore when performing
adaptation in this way is that the estimate of vari-
ances obtained in the source domain will be very
small since the policy has already been trained un-
til convergence with a large number of dialogues.
As a consequence, the rate of exploration defined
by sampling in Eq. 4 will be reduced and thus lead
to the subsequent optimisation in the new target
domain falling prematurely into a local optimum.
As an alternative, we propose another adapta-
tion strategy. The estimate of the posterior of the
mean for the Q-function, Q in Eq. 2, from the pol-
icy trained on the basic domain can be taken to be
the prior of the mean when the policy is trained on
the extended domain as in Eq. 3. More precisely, if
Qbsc is the posterior mean of the policy trained on
the basic domain then mextd = Qbsc. In this case
it is also important to make sure that the kernel
function used to calculateQbsc is redefined for the
extended domain where necessary. The prior on
the variance is the original kernel function renor-
malised:
k((b, a), (b?, a?))? k((b,a),(b?,a?))?
k((b,a),(b,a))k((b?,a?),(b?,a?))
.
(9)
Given that the estimate of the mean provides rea-
sonable performance, it is not necessary to place
a flat prior on the variance of the Q-function and
therefore the kernel is normalised as in Eq. 9.
When comparing adaptation strategies, we are
interested in two aspects of performance. The first
is the performance of the policy during training.
The second is how quickly the policy reaches the
optimal performance. For that reason we adopt
the following evaluation scheme. After every 100
adaptation dialogues we test the partially opti-
mised policy with 1000 simulated dialogues, dif-
ferent to the ones used in adaptation. These 1000
dialogues are the same for every test point on the
graph. The results are given in Fig. 2.
0 200 400 600 800 1000 1200 1400 1600Training dialogues20
15
10
5
0
5
10
Rewa
rd
PRIORADAPTTRAINbsc-trn&extd-tstextd-trn&tst
Figure 2: Different adaptation strategies
The lower horizontal line represents the perfor-
mance of the policy trained on the basic source
domain and tested on the extended target domain.
This is the baseline. The upper horizontal line
represents the policy trained until convergence on
the extended domain and also tested on the ex-
tended domain. This provides the gold standard.
The adaptation strategy that takes both the mean
and variance of the policy trained on the basic do-
main and retrains the policy on the extended do-
219
main is denoted as ADAPT in Fig. 2. The adap-
tation strategy that uses the posterior mean of the
policy trained on the source domain as the prior
mean for adaptation is denoted as PRIOR in Fig. 2.
Finally, for comparison purposes we show the per-
formance of the policy that is trained from scratch
on the extended domain. This is denoted as TRAIN
on the graph. It can be seen that both adapta-
tion strategies significantly reduce the number of
training dialogues and, more importantly, main-
tain the level of performance during adaptation.
The adaptation strategy that places the prior on the
mean has slightly worse performance in the begin-
ning but provides the best performance after 1500
dialogues. As already noted, this could be due
to overly confident variances in the ADAPT case
leading to a local optimum.
6 Human experiments
In order to adapt and evaluate policies with hu-
mans, we used crowd-sourcing via the Ama-
zon Mechanical Turk service in a set-up similar
to (Jurc???c?ek et al, 2011a; Gas?ic? et al, 2013).
The BUDS dialogue manager was incorporated
in a live telephone-based spoken dialogue system.
The Mechanical Turk users were assigned spe-
cific tasks in the extended TopTable domain. They
were asked to find restaurants that have particu-
lar features as defined by the given task. To elicit
more complex dialogues, the users were some-
times asked to find more than one restaurant, and
in cases where such a restaurant did not exist they
were required to seek an alternative, for example
find a Chinese restaurant instead of a Vietnamese
one. After each dialogue the users filled in a feed-
back form indicating whether they judged the di-
alogue to be successful or not. Based on that bi-
nary rating, the subjective success was calculated
as well as the average reward. An objective rat-
ing can also be obtained by comparing the system
outputs with the predefined task.
During policy adaptation, at the end of each
call, users were asked to press 1 if they were satis-
fied (i.e. believed that they had been successful in
fulfilling the assigned task) and 0 otherwise. The
objective success was also calculated. The dia-
logue was then only used for adaptation if the user
rating agreed with the objective measure of suc-
cess as in (Gas?ic? et al, 2013). The performance
based on user ratings during adaptation for both
adaptation strategies is given in Table 1.
Table 1: Policy performance during adaptation
#Diags Reward Success (%)
ADAPT 251 11.7? 0.5 92.0? 1.7
PRIOR 329 12.1? 0.4 96.7? 1.0
We then evaluated four policies with real users:
the policy trained on the basic domain, the pol-
icy trained on the extended domain and the pol-
icy adapted to the extended domain using the prior
and the policy adapted to the extended domain via
interaction with real users using retraining. The
results are given in Table 2.
Table 2: Human evaluation of four systems in the
extended domain: trained in the basic domain,
trained in the extended domain, trained in the ba-
sic and adapted in the extended domain using both
ADAPT and PRIOR methods.
Training #Diags Reward Success(%)
Basic 246 11.0? 0.5 91.9? 1.7
Extended 250 12.1? 0.4 94.4? 1.5
ADAPT 268 12.6? 0.4 94.4? 1.4
PRIOR 252 12.4? 0.4 95.6? 1.3
The results show two important features of
these adaptation strategies. The first is that it is
possible to adapt the policy from one domain to
another with a small number of dialogues. Both
adaptation techniques achieve results statistically
indistinguishable from the matched case where the
policy was trained directly in the extended do-
main. The second important feature is that both
adaptation strategies guarantee a minimum level
of performance during training, which is better
than the performance of the basic policy tested on
the extended domain. This is particularly impor-
tant when training with real users so that they are
not exposed to poor performance at any time dur-
ing training.
7 Application to fast learning
The above results show that transfer learning
through policy adaptation can be relatively fast.
Since complex domains can be decomposed into a
series of domains with gradually increasing com-
plexity, an alternative to training a system to con-
vergence starting from an uninformative prior is
220
to train a system in stages iteratively adapting to
successively more complex domains (Taylor and
Stone, 2009).
We explored this idea by training the extended
system in three stages. The first has only one slot
that the user can specify: food-type and additional
slots phone, address and postcode that can be re-
quested (initial in Fig. 3). The second has an ad-
ditional area slot (intermediate in Fig. 3) and the
final domain has a the price-range slot added (final
on the graph).
A policy for each of these domains was trained
until convergence and the average rewards of these
policies are the horizontal lines on Fig. 3. In addi-
tion, the following adaptation schedule was imple-
mented. An initial policy was trained from scratch
for the one-slot initial system using only 1500 dia-
logues. The resulting policy was then retrained for
the intermediate two-slot system using again just
1500 dialogues. Finally, the required three-slot
system was trained using 1500 dialogues. At each
stage the policy was tested every 100 training dia-
logues, and the resulting performances are shown
by the three graphs initial-train, intermediate-adapt
and final-adapt in Fig. 3. The policies were tested
on the domains they are trained on or adapted to.
It can be seen that after just 500 dialogues of
the third stage (i.e. after just 3500 dialogues in to-
tal) the policy reaches optimal performance. It has
been shown previously that Gaussian process re-
inforcement learning for this task normally takes
104 dialogues (Gas?ic? et al, 2012) so this schedule
halves the number of dialogues needed for train-
ing. Also it is important to note that when training
from scratch the average reward is less than 5 for
300 dialogues (see TRAIN in Fig. 2), in this case
that only happens for about 100 dialogues (see
initial-train in Fig. 3).
8 Conclusions
This paper has investigated the problem of ex-
tending a dialogue system to handle new previ-
ously unseen concepts (i.e. slots) using adapta-
tion based transfer learning. It has been shown that
a GP kernel can be mapped to establish a relation-
ship between a basic and an extended domain and
that GP-based adaptation can restore a system to
optimal performance within 200 to 300 adaptation
dialogues. A major advantage of this technique is
that it allows a minimum level of performance to
be guaranteed and hence guards against subject-
0 200 400 600 800 1000 1200 1400 1600Training dialogues15
10
5
0
5
10
15
Rewa
rd
initial-trainintermediate-adaptfinal-adaptintermediateinitialfinal
Figure 3: Application of transfer learning to fast
training. The target is to achieve the performance
of the fully trained 3 slot system as shown by the
lower horizontal line final. This is achieved in three
stages, with the target being achieved part way
through the 3rd stage using just 3500 dialogues in
total.
ing the user to poor performance during the early
stages of adaptation.
Two methods of adaptation have been studied ?
one based on augmenting the training points from
the source domain with new points from the tar-
get domain, and a second which treats the source
policy as a prior for the target policy. Results us-
ing the prior method were consistently better. In a
further experiment, it was also shown that starting
with a simple system and successively extending
and adapting it slot by slot, can achieve optimal
performance faster than one trained directly from
scratch.
These results suggest that it should be feasi-
ble to construct dialogue systems which can dy-
namically update and extend their domains of dis-
course automatically during direct conversations
with users. However, further investigation of
methods for learning the relationship between the
new and the old domains is needed. Also, the
scalability of these results to large-scale domain
expansion remains a topic for future work.
Acknowledgments
This work was partly supported by PAR-
LANCE (www.parlance-project.eu), an EU Sev-
enth Framework Programme project (grant num-
ber 287615).
221
References
Y Engel, S Mannor, and R Meir. 2005. Reinforcement
learning with Gaussian processes. In Proceedings of
ICML.
Y Engel. 2005. Algorithms and Representations for
Reinforcement Learning. PhD thesis, Hebrew Uni-
versity.
M Gales and S Young. 2007. The application of hid-
den Markov models in speech recognition. Found.
Trends Signal Process., 1:195?304.
M Gas?ic?, F Jurc???c?ek, S Keizer, F Mairesse, J Schatz-
mann, B Thomson, K Yu, and S Young. 2010.
Gaussian Processes for Fast Policy Optimisation of
POMDP-based Dialogue Managers. In Proceedings
of SIGDIAL.
M Gas?ic?, F Jurc???c?ek, B Thomson, K Yu, and S Young.
2011. On-line policy optimisation of spoken dia-
logue systems via live interaction with human sub-
jects. In Proceedings of ASRU.
M Gas?ic?, M Henderson, B Thomson, P Tsiakoulis, and
S Young. 2012. Policy optimisation of POMDP-
based dialogue systems without state space com-
pression. In Proceedings of SLT.
M Gas?ic?, C. Breslin, M. Henderson, Szummer M.,
B Thomson, P. Tsiakoulis, and S Young. 2013.
On-line policy optimisation of Bayesian Dialogue
Systems by human interaction. In Proceedings of
ICASSP.
M Geist and O Pietquin. 2011. Managing Uncertainty
within the KTD Framework. In Proceedings of the
Workshop on Active Learning and Experimental De-
sign, Sardinia (Italy).
K Georgila and O Lemon. 2004. Adaptive multimodal
dialogue management based on the information state
update approach. In W3C Workshop on Multimodal
Interaction.
S Janarthanam and O Lemon. 2010. Adaptive Re-
ferring Expression Generation in Spoken Dialogue
Systems: Evaluation with Real Users. In Proceed-
ings of SIGDIAL.
T Jebara, R Kondor, and A Howard. 2004. Probability
product kernels. J. Mach. Learn. Res., 5:819?844,
December.
F Jurc???c?ek, S Keizer, M Gas?ic?, F Mairesse, B Thomson,
K Yu, and S Young. 2011a. Real user evaluation of
spoken dialogue systems using Amazon Mechanical
Turk. In Proceedings of Interspeech.
F Jurc???c?ek, B Thomson, and S Young. 2011b. Natural
actor and belief critic: Reinforcement algorithm for
learning parameters of dialogue systems modelled as
POMDPs. ACM Transactions on Speech and Lan-
guage Processing.
S Keizer, M Gas?ic?, F Jurc???c?ek, F Mairesse, B Thomson,
K Yu, and S Young. 2010. Parameter estimation
for agenda-based user simulation. In Proceedings of
SIGDIAL.
DJ Litman and S Pan. 1999. Empirically evaluating
an adaptable spoken dialogue system. In Proceed-
ings of the seventh international conference on User
modelling.
DJ Litman and S Pan. 2002. Designing and evaluat-
ing an adaptive spoken dialogue system. User Mod-
elling and User-Adapted Interaction, 12:111?137.
CE Rasmussen and CKI Williams. 2005. Gaussian
Processes for Machine Learning. MIT Press, Cam-
bridge, Massachusetts.
N Roy, J Pineau, and S Thrun. 2000. Spoken dialogue
management using probabilistic reasoning. In Pro-
ceedings of ACL.
J Schatzmann. 2008. Statistical User and Error Mod-
elling for Spoken Dialogue Systems. Ph.D. thesis,
University of Cambridge.
ME Taylor and P Stone. 2009. Transfer learning for
reinforcement learning domains: A survey. J. Mach.
Learn. Res., 10:1633?1685, December.
ME Taylor, P Stone, and Y Liu. 2007. Transfer learn-
ing via inter-task mappings for temporal difference
learning. J. Mach. Learn. Res., 8:2125?2167, De-
cember.
B Thomson and S Young. 2010. Bayesian update of
dialogue state: A POMDP framework for spoken di-
alogue systems. Computer Speech and Language,
24(4):562?588.
B Thomson, M Gas?ic?, M Henderson, P Tsiakoulis, and
S Young. 2012. N-Best error simulation for training
spoken dialogue systems. In Proceedings of SLT.
TopTable. 2012. TopTable. https://www.
toptable.com.
JD Williams and SJ Young. 2007. Partially Observable
Markov Decision Processes for Spoken Dialog Sys-
tems. Computer Speech and Language, 21(2):393?
422.
S Young, M Gas?ic?, S Keizer, F Mairesse, J Schatz-
mann, B Thomson, and K Yu. 2010. The Hid-
den Information State model: A practical frame-
work for POMDP-based spoken dialogue manage-
ment. Computer Speech and Language, 24(2):150?
174.
B Zhang, Q Cai, J Mao, E Chang, and B Guo.
2001. Spoken Dialogue Management as Planning
and Acting under Uncertainty. In Proceedings of
Eurospeech.
222
