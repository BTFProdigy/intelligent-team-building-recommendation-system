Proceedings of the ACL-HLT 2011 System Demonstrations, pages 139?144,
Portland, Oregon, USA, 21 June 2011. c?2011 Association for Computational Linguistics
 An Interface for Rapid Natural Language  Processing Development in UIMA  Balaji R. Soundrarajan, Thomas Ginter, Scott L. DuVall VA Salt Lake City Health Care System and University of Utah balaji@cs.utah.edu, {thomas.ginter, scott.duvall}@utah.edu   Abstract 
This demonstration presents the Annotation Librarian, an application programming inter-face that supports rapid development of natu-ral language processing (NLP) projects built in Apache Unstructured Information Man-agement Architecture (UIMA). The flexibility of UIMA to support all types of unstructured data ? images, audio, and text ? increases the complexity of some of the most common NLP development tasks. The Annotation Librarian interface handles these common functions and allows the creation and management of anno-tations by mirroring Java methods used to manipulate Strings. The familiar syntax and NLP-centric design allows developers to adopt and rapidly develop NLP algorithms in UIMA. The general functionality of the inter-face is described in relation to the use cases that necessitated its creation.  1 Introduction In the days when public libraries were the center of information exchange, the job of the librarian was to serve as an interface between the complex li-brary system and the average user. The librarian made it possible for one to access specific sources of information without memorizing the Dewey Decimal System or flipping through the card cata-log. Analogous to the great librarians of yesteryear, the Annotation Librarian serves the average Java developer in the creation and management of anno-tations within natural language processing (NLP) projects built using the open source Apache Un-structured Information Management Architecture (UIMA)1.  Many NLP tasks are performed in processing steps that build upon one another. Systems de-signed in this fashion are called pipelines because                                                             1 Apache UIMA is available from http://uima.apache.org/ 
text is processed and then passed from one step to the next like water flowing through a pipe. Each step in the pipeline adds structured data on top of the text called annotations. An annotation can be as simple as a classification of a span of text or complex with attributes and mappings to coded values. As pipeline systems have caught on, the ability to standardize functionality in and even across pipelines has emerged. UIMA provides a powerful infrastructure for the storage, transport, and retrieval of document and annotation knowledge accumulated in NLP pipeline systems (Ferrucci 2004). UIMA provides tools that allow testing and visualizing system results, integration with Eclipse2, and use of standard XML descrip-tion files for maintainability and interoperability. Because UIMA provides the underlying data mod-el for storing meta-data and annotations with doc-ument text and the interface for interacting between processing steps, it has become a popular platform for the development of reusable NLP sys-tems (D?Avolio 2010, Coden 2009, Savova 2008). The most notable example of UIMA capabilities is Watson, the question-answering system that com-peted and won two Jeopardy! matches against the all-time-winning human champions (Ferrucci 2010).  In addition to its successful implementations in NLP, UIMA supports all types of unstructured in-formation ? video, audio, images, etc ? and so all UIMA constructs generalize beyond text. While handling multiple data types increases the utility of the framework, developers new to UIMA may feel they need to understand the entire framework be-fore being able to distinguish and focus solely on text. The Annotation Librarian aids both novice and experienced UIMA developers by providing intuitive and NLP-centric functionality. 
                                                            2 Eclipse Development Platform is available from http://www.eclipse.org 
139
2 System Overview The Annotation Librarian was developed as an in-terface that synthesizes many of the most frequent annotation management tasks encountered in NLP system development and presents them in a man-ner easily accessed for those familiar with general Java development methods. It provides conven-ience methods that mirror Java String manipula-tion, allowing developers to seamlessly combine document text and annotations with the same commands familiar to anyone who has parsed a String or written a regular expression. Advanced functionality allows developers to examine spatial relationships among annotations and perform an-notation pattern matching. In this demonstration, we present the general functionality of the Annota-tion Librarian in the context of the health care re-search projects that necessitated the creation of the interface. The interface does not replace the need for NLP algorithms ? developers have a plethora of patterns and decision rules, symbolic grammars, and ma-chine learning techniques to create annotations. The Annotation Toolkit, though, provides a con-venient way for developers to use existing annota-tions in their algorithms. This feeds the pipeline workflow that allows more complex annotations to be built in later processing steps using the annota-tions created in earlier steps. The Annotation Librarian was developed and modified in response to four research projects in the health care domain that relied on NLP extrac-tion of concepts from clinical text. The diversity of the different tasks in each of these use cases al-lowed the interface to include functionality com-mon to different types of NLP system development. Interface functionality will be de-scribed as groups of related methods in the context of the four research projects and cover pattern matching, span overlap, relative position, annota-tion modification, and retrieval. All projects re-ceived Institutional Review Board approval for data use and only synthetic documents, not real patient records, are shown in the examples present-ed in this paper. 3 Pattern Matching Name entity recognition and semantic classifica-tion tasks often require advanced concept identifi-
cation techniques. Identifying mentions of pre-scriptions in a document using regular expressions, for example, would require hundreds of thousands of patterns for names of medicines and have to ac-count for misspelling, abbreviations, and acro-nyms. Regular expressions are commonly used to solve simple NLP tasks, though, and can be uti-lized as part of a more complex information extrac-tion strategy, such as understanding the context in which a term is used in the text (Garvin 2011, McCrae 2008, Frenz 2007, Chapman 2001). Negex (Chapman 2001) is an algorithm for identifying words before or after a term that suggest, for ex-ample, that a particular symptom is not present in a patient: ?the patient has no fever.? Other methods for understanding the context around terms include the use of an inclusion and exclusion list (Akbar 2009), temporal locality search (Grouin 2009), window search (Li 2009), and combinations of the above techniques (Hamon 2009). The Annotation Librarian allows patterns to be built using existing annotations along with docu-ment text. This functionality combines the power of finding concepts that require complex means with the simplicity of regular expressions. The syn-tax mirrors that of the Java Pattern3 and Matcher4 classes, but allows for an extended regular expres-sion grammar to identify Annotations. Pattern matching is accomplished in three phases: the in-put pattern is compiled, the document and annota-tions are analyzed for matches, and matches are returned along with span information. A project identifying positive microbiology cul-tures will illustrate the use of pattern matching with the Annotation Librarian. Clinicians order microbiology cultures to determine whether a pa-tient has a bacterial infection and which antibiotics would be most effective at treating the infection. Susceptibility is the measure of whether an antibi-otic can effectively treat an organism or whether the organism is resistant to it. A sample of microbiology report text is shown in Figure 1 and visualized annotations for the same sample are shown in Figure 2.                                                              3 Documented at http://download.oracle.com/javase/6/docs/api/java/util/regex/ Pattern.html 4 Documented at http://download.oracle.com/javase/6/docs/api/java/util/regex/ Matcher.html 
140
 Figure 1: Microbiology Report Text  
 Figure 2: Annotated Report  To demonstrate pattern matching in this sample, the simple pattern of a drug annotation followed by an equals sign and then by a susceptibility annota-tion will be used.  3.1 Pattern Compilation The pattern matching process begins when a new instance of an AnnotationPattern is created from the static compile method. AnnotationPattern is analogous to the Java Pattern3 class.  AnnotationPattern susceptibilityPattern =   AnnotationPattern.compile(?pattern?);  The method takes advantage of the UIMA im-plementation of annotations. Each annotation is an instance of a class that inherits from the UIMA class Annotation5. UIMA allows developers to cre-ate new types of annotations (in this example Or-ganism, Antibiotic, and Susceptibility) that become Java classes. 
                                                            5 Documented at http://uima.apache.org/d/uimaj-2.3.1/api/index.html 
The compile method input string pattern uses XML tags to represent Annotation classes and tag attributes to denote the name of method calls and return values in the format of:   <AnnotationClass methodName=?expected value? />  When the extra constraint of matching on some method return values is not needed, the tag attrib-ute is left blank. Portions of the pattern that are not contained in XML tags are compiled as Java regu-lar expressions. For our example, the input pattern would be:   <Antibiotic /> = <Susceptibility />  or further constrained as:  <Antibiotic getMedName=?ciprofloxacin? /> =  <Susceptibility getValue=?S? />  which would only match if the particular medica-tion (ciprofloxacin) and susceptibility (S) matched as well. The pattern is converted into a finite state ma-chine (FSM) in a process described by Fegaras (2005). With our pattern, a four-state FSM would be generated. To arrive in State 1, an Antibiotic annotation must match. To arrive in State 2, a regular expression for ?=? must match. The Final State is reached when a matching Susceptibility annotation is found. Any other input would result in a transition back to the Start State.  
 Figure 3: FSM for Antibiotic Susceptibility  3.2  Match Analysis The second phase of pattern matching processes the document text and annotation set to determine if any matches can be found. This phase is trig-gered by a call to the static matcher method that returns a new instance of an AnnotationMatcher object. AnnotationMatcher is analogous to the Java Matcher4 class.  AnnotationMatcher suscMatcher =    susceptibilityPattern.matcher(cas);  This phase just checks to ensure that each anno-tation type has at least one instance in the docu-ment. Otherwise, a pattern match is not possible. Here, the cas parameter refers to the UIMA 
141
Common Analysis Structure, the object containing the document and annotation information. 3.3 Finding Matches The final phase of pattern matching involves a call to the AnnotationMatcher find method. This call results in a FSM traversal at the starting position parameter. Duplicate match candidates starting at the same point are pooled in each state. The candi-date pool in each state is traversed with a binary search algorithm, which reduces overall traversal time. Note the following example in which a rela-tionship is created through a new user-defined An-notation class type.   int position = 0 ; while(suscMatcher.find(position))  { AntibioticSusceptibility annotation =    new AntibioticSusceptibility(cas) ; annotation.setBegin(suscMatcher.start()) ;     annotation.setEnd(suscMatcher.end()) ;     annotation.addToIndexes() ;     position = matcher.end() ; }//while  Similar to the Java Matcher4 find method, the first match is found from the starting position. The start and end positions are also set within the An-notationMatcher instance object, which facilitates the creation of new annotations that span the com-plete pattern. The Annotation Librarian pattern matching functionality allows the inclusion of an-notations, which provides an added level of power beyond regular expressions on text data only. 4 Retrieval The retrieval methods allow developers to interact with annotations and metadata. This set of methods includes the ability to get the file name and path of the document, get al annotations in the document, and get al annotations of just a particular type.  getDocumentPath() getAllAnnotations() getAllAnnotationsOfType( int type )  Ejection fraction is a heart health measurement. An NLP system was developed to identify the ejection frac-tion from echocardiogram reports. In this project, the Annotation Librarian facilitated the extraction of specif-ic annotation types (the section the concept was found in) in order to discover relevant concept-value pairs. In Figure 4, ejection fraction annotations are shown in red and quantitative and qualitative values in blue. 
Because ?systolic function? can be used to report ejec-tion fraction, but only when referring to the left side of the heart, it was important to retrieve the section annota-tions and check the header.  
 Figure 4: Annotated Echocardiogram Report 5 Annotation Modification The annotation modification methods allow previ-ous annotations to be altered by trimming whitespace and removing punctuation. While these are trivial tasks performed on Java Strings, an an-notation is just a pointer to the text. Updating the annotation with the correct character span requires understanding of UIMA functions and can intro-duce errors if not done carefully. The Annotation Librarian ensures accuracy by handling these tasks with straightforward programmatic calls.  trim( Annotation annotation ) removePunctuation( Annotation annotation )  Identifying the organisms from the microbiolo-gy reports relied on splitting template text. The project described in Section 3 for pattern matching utilized the Annotation Librarian functionality to clean up spurious characters and whitespace in-cluded in annotations. 6 Span Overlap This set of methods describes how annotations re-late to each other spatially by answering questions such as: Does one annotation completely contain the other? Do the annotations overlap in the text? Do they both cover the same span of text?  overlaps( Annotation a1, Annotation a2 ) contains( Annotation a1, Annotation a2 ) coversSameSpan( Annotation a1, Annotation a2 )  
142
In a system built for identifying medications in discharge summaries, the brand and generic names would often both be listed. Name entity recogni-tion would end up mapping at multiple granulari-ties ? brand name only, generic name only, brand and generic name combinations, and even name and dose combinations. The span overlap methods were used to identify and combine overlapping names. Figure 5 shows the annotations that were found and resolved using span overlaps.  
 Figure 5: Medication Extraction Use Case 7 Relative Position The relative position methods allow developers to access annotations based on their position in the text to each other. These methods can determine the next or previous adjacent annotation or the text that exists between two annotations. Often, a task required determining which concepts were found in the same sentence or finding all concepts in a certain section. Methods in this set provide func-tionality to find annotations that covering the span of another annotations or all annotations contained within the span of another annotation.  getContainingAnnotations( Annotation a1 ) getNextClosest( Annotation a1 ) getPreviousClosest( Annotation a1 ) getTextBetween( Annotation a1, Annotation a2 )  As part of a project to determine coreference in dis-ease outbreak reports, the ability to determine relative position facilitated coreference resolution. It was also necessary to determine relationships between certain types of annotations from the window of the text. The Annotation Librarian simplified the task of determining co-location by providing the functionality within a sin-gle method call. Text between two Annotation objects was similarly identified with a single method call.  
 Figure 6: Disease Outbreak Reports Use Case 8 Conclusion The Annotation Librarian was developed and mod-ified over a number of different NLP use cases. Because of the diversity of tasks in each of these use cases, the toolkit includes functionality com-mon to various types of NLP system development. It includes over two-dozen functions that were used more than one hundred times in each of the four systems listed above. Use of this interface re-duced the amount of repeated code; it simplified common tasks, and provided an intuitive interface for NLP-centric annotation management without requiring the presence of an NLP developer who has intimate knowledge of the UIMA data struc-ture. The extended capability provided by the pat-tern matching methods allows system developers to capitalize on the pipeline approach to NLP de-velopment in determining patterns. The ability to use annotations along with text significantly in-creases the types of patterns that can be identified without complex regular expressions. 9 Future Plans The Annotation Librarian has been enhanced over the course of a number of biomedical NLP use cases and we plan to continue to enhance the inter-face as new use cases arise. Some planned en-hancements include performance improvements and expanding the AnnotationPattern input pattern syntax to include regular expressions for method return values and annotation class names. We plan to provide additional functionality such as pattern frequency counts. We see the ability for the Annotation Librarian to help identify patterns through active learning or 
143
unsupervised techniques. In this way, relationships between annotations could be inferred based on those existing in the document set. Such function-ality would also provide the ability for more intel-ligent analysis of future document sets or observation systems by allowing previously identi-fied relationships to be utilized in other use cases. Acknowledgments This work was supported using resources and facil-ities at the VA Salt Lake City Health Care System with funding support from the VA Informatics and Computing Infrastructure (VINCI), VA HSR HIR 08-204 and the Consortium for Healthcare Infor-matics Research (CHIR), VA HSR HIR 08-374. Views expressed are those of the authors and not necessarily those of the Department of Veterans Affairs. References  Annin Coden, Guergana K. Savova, Igor L. Sominsky, Michael A. Tanenblatt, James J. Masanz, Karin Schuler, James W. Cooper, Wei Guan, Piet C. de Groen. 2009. Automatically extracting cancer dis-ease characteristics from pathology reports into a Disease Knowledge Representation Model. J Bio-med Inform. 2009 Oct;42(5):937-49.  Christopher M. Frenz. 2007. Deafness mutation min-ing using regular expression based pattern match-ing. BMC Med Inform Decis Mak. 2007 Oct 25;7:32.  Cyril Grouin, Louise Del?ger, and Pierre Zweigen-baum. 2009. COKAINE, A Simple Rule-based Medication Extraction System. i2b2 Workshop in conjunction with the AMIA Annual Symposium, San Francisco, CA; November 13, 2009.  David Ferrucci and Adam Lally. 2004. UIMA: An Ar-chitectural Approach to Unstructured Information Processing in the Corporate Research Environment. Natural Langage Engineering 10(3?4): 327?348.  David Ferrucci, Eric Brown, Jennifer Chu-Carroll, James Fan, David Gondek, Aditya A. Kalyanpur, Adam Lally, J. William Murdock, Eric Nyberg, John Prager, Nico Schlaefer, and Chris Welty. 2010. Building Watson: An Overview of the DeepQA Project. AI Magazine. Vol 31. No 3.  Guergana K. Savova, Karin Kipper-Schuler, James D. Buntrock, Christopher G. Chute. 2008. UIMA-
based clinical information extraction system. LREC 2008: Towards enhanced interoperability for large HLT systems: UIMA for NLP. Jennifer H. Garvin, Brett R. South, Dan Bolton, Shuy-ing Shen, Scott L. DuVall, Bruce Bray, Paul Hei-denreich, Matthew H. Samore, and Mary K. Goldstein. 2011. Automated Extraction of Ejection Fraction (EF) for Heart Failure (HF) from VA Echocardiogram Reports. Department of Veterans Affairs Health Services Research and Development National Meeting. 2011 Feb 16.  John McCrae, Nigel Collier. 2008. Synonym set ex-traction from the biomedical literature by lexical pattern discovery. BMC Bioinformatics. 2008 Mar 24;9:159.  Leonard W. D'Avolio, Thien M. Nguyen, Wildon R. Farwell, Yong Chen, Felicia Fitzmeyer, Owen M. Harris, Louis D. Fiore. 2010. Evaluation of a gen-eralizable approach to clinical information retrieval using the automated retrieval console (ARC). J Am Med Inform Assoc. 2010 Jul-Aug;17(4):375-82.   Leonidas Fegaras. 2005. Converting a Regular Ex-pression into a Deterministic Finite Automaton. http://lambda.uta.edu/cse5317/notes/node9.html. Pulled February 2011.  Saiful Akbar, Thomas Brox R?st, Laura Slaughter, and ?ystein Nytr?. 2009. Extracting Medication In-formation from Patient Discharge Summaries. i2b2 Workshop in conjunction with the AMIA Annual Symposium, San Francisco, CA; November 13, 2009.  Thierry Hamon and Natalia Grabar. 2009 . Concurrent linguistic annotations for identifying medication names and the related information in discharge summaries. i2b2 Workshop in conjunction with the AMIA Annual Symposium, San Francisco, CA; November 13, 2009.  Wendy W. Chapman, Will Bridewell, Paul Hanbury, Gregory F. Cooper, and Bruce G. Buchanan. 2001. A Simple Algorithm for Identifying Negated Find-ings and Diseases in Discharge Summaries. Chap-man WW, Bridewell W, Hanbury P, Cooper GF, Buchanan BG. J Biomed Inform. 2001 Oct;34(5):301-10.  Zuofeng Li, Yonggang Cao, Lamont Antieau, Shashank Agarwal, Qing Zhang, and Hong Yu. 2009. Extracting Medication Information from Pa-tient Discharge Summaries. i2b2 Workshop in con-junction with the AMIA Annual Symposium, San Francisco, CA; November 13, 2009. 
144
Proceedings of the 2012 Workshop on Biomedical Natural Language Processing (BioNLP 2012), pages 130?139,
Montre?al, Canada, June 8, 2012. c?2012 Association for Computational Linguistics
A Prototype Tool Set to Support Machine-Assisted Annotation 
Brett R. South1,2, Shuying Shen1,2, Jianwei Leng2, Tyler B. Forbush4,  Scott L. DuVall3,4, Wendy W. Chapman5 Departments of 1Biomedical Informatics, 2Internal Medicine, and 3Radiology University of Utah, Salt Lake City, Utah, USA  4IDEAS Center SLCVA Healthcare System, Salt Lake City, Utah, USA  5University of California, San Diego, Division of Biomedical Informatics, La Jolla, California, USA brett.south@hsc.utah.edu,  shuying.shen@hsc.utah.edu, jianwei.leng@utah.edu,  tyler.forbush@utah.edu, scott.duvall@utah.edu,  wendy.w.chapman@gmail.com 
Abstract 
Manually annotating clinical document corpora to generate reference standards for Natural Language Processing (NLP) sys-tems or Machine Learning (ML) is a time-consuming and labor-intensive endeavor. Although a variety of open source annota-tion tools currently exist, there is a clear opportunity to develop new tools and assess functionalities that introduce efficiencies into the process of generating reference standards. These features include: man-agement of document corpora and batch as-signment, integration of machine-assisted verification functions, semi-automated cu-ration of annotated information, and sup-port of machine-assisted pre-annotation. The goals of reducing annotator workload and improving the quality of reference standards are important considerations for development of new tools. An infrastruc-ture is also needed that will support large-scale but secure annotation of sensitive clinical data as well as crowdsourcing which has proven successful for a variety of annotation tasks. We introduce the Ex-tensible Human Oracle Suite of Tools  (eHOST) http://code.google.com/p/ehost that provides such functionalities that when coupled with server integration offer an end-to-end solution to carry out small or large scale as well as crowd sourced anno-tation projects. 1 Introduction Supervised learning methods benefit from a ref-erence standard that is used to train and evaluate 
the performance of Natural Language Processing (NLP) or Machine Learning (ML) systems for information extraction and classification. Ideal-ly, generating a reference standard involves the review of more than one annotator with an ac-companying adjudication step to resolve dis-crepancies (Roberts et al, 2007; Roberts et al, 2009). However, manual annotation of clinical, texts is time-consuming, expensive, and requires considerable effort. Reducing the time and costs required for manual annotation could be achieved by developing new tools that integrate methods to more efficiently annotate clinical texts and integrate a management interface that allows administration of large or small scale an-notation projects. Such a tool could also inte-grate methods to pre-annotate entities such as noun phrases or clinical concepts mapped to a standard vocabulary. Efficiencies could be real-ized via reduction in human workload, modifica-tion of annotation tasks that could include crowd sourcing, and implementation of machine-assisted approaches.  Typically annotation of clinical texts requires human reviewers to identify information classes of interest called ?markables?. These tasks may also require reviewers to assign attributes to those information classes and build relations between spans of annotated text. For each anno-tation task there may be one or many types of markables and each markable class may be asso-ciated with one or more spans of text and may include single or even multiple tokens. These tasks may occur simultaneously, or may also be done in different steps and by multiple review-ers. Furthermore, these activities require written guidelines that clearly explicate what infor-
130
mation to annotate, specifics about each marka-ble class, such as how much information to in-clude in annotated spans, or syntactic rules to provide further guidance on annotated spans. Annotation tasks may benefit by incorporating rules or guidelines as part of the annotation task itself in the form of machine-assisted verifica-tion. There are many annotation tools available, and the majority of them were designed for lin-guistic or gene annotation. Linguistic annotation tools such as Callisto and WordFreak are stand-alone clients suitable for small to medium scale tasks where collaborative effort is not empha-sized. Functionality integrated with eHOST was inspired by existing features of these tools with the intent of providing a more efficient means of reference standard generation in a large collabo-rative environment. One annotation tool called Knowtator, a plug-in for Prot?g? (Musen, M.A., et al 1995) developed by Ogren (2006) has been widely used to annotate clinical texts and gener-ate reference standards. However, no stand-alone system exists that can provide end users with the ability to manually or semi-automatically edit, curate, and easily navigate annotated information. There are also specific functionalities that are missing from open source annotation tools in the clinical and biomedical domains that would introduce efficiencies into manual annotation tasks. These functionalities include: annotation of clinical texts along with database storage of stand-off annotations, the ability to interactively annotate texts in a way that allows users to react to either pre-annotations imported from NLP or ML systems or use exact string matching across an active corpus to identify similar spans of text to those already annotated. Additionally, these systems do not generally support crowd sourcing, ma-chine-assisted pre-annotation or verification ap-proaches integrated directly with the annotation tool. This paper discusses development of a proto-type open source system designed to provide functionality that supports these activities and offers an end-to-end solution when coupled with server integration to reduce both annotator and administrative workload associated with refer-ence standard. We introduce the Extensible Hu-
man Oracle Suite of Tools (eHOST) created with these expectations in mind.  2 Background Our goal for these development efforts was to build a prototype open source system that im-proves upon existing tools by including new functions and refining capabilities available in other annotation tools. The resulting GUI inter-face provides a means of visually representing annotated information, its attributes, and rela-tions between annotated mentions. These efforts also focused integrating various machine-assisted approaches that can be used to easily curate and navigate annotated information with-in a document corpus, pre-annotate information, and also verify annotations based on rules checks that correspond with annotation guide-lines or linguistic and syntactic cues.   The eHOST provides basic functionality in-cluding manual annotation of information repre-senting markable classes and assignment of information attributes and relationships between markable classes. Annotations exported from eHOST are written using the XML format as Knowtator thus allowing integration of inputs and outputs to and from Knowtator and indirect-ly to Prot?g? 3.3.1. Coupling eHOST with an integrated server package such as the one under development by the VA Informatics and Com-puting Infrastructure (VINCI) called the Chart Administration Server for Patient Review (CASPR) provides one method of increasing efficiencies for small or large-scale annotation efforts that could also include crowd sourcing.  2.1 System Features Development In the domains of computational linguistics and biomedical informatics various approaches that can be used to improve annotation efficiencies have been evaluated for a variety of tasks in-cluding information extraction and classifica-tion. While several methods may help reduce the time and costs required to create reference standards, one of the simplest approaches may include integrating machine-assisted methods to pre-annotate relevant spans of text allowing the annotator to add missing annotations, modify spans, or delete spurious annotations. Neveol (2011) evaluated use of automatic semantic pre-
131
annotation of PubMed queries. This study showed a significant reduction in the number of required annotations when using pre-annotations, reduction in annotation time with higher inter-annotator agreement. Pre-annotation using simple approaches such as regular expres-sions coupled with dictionaries (South et al, 2010a) based on the UMLS as a source of lexi-cal knowledge (Friedman, 2001) and  pre-annotation of information representing protected health information (South et al, 2010b). In both cases finding that annotators preferred particular types of pre-annotation over others, but im-provements in reference standard quality occur when pre-annotation was provided. Others have explored the use of third party tools for the pre-annotation task for UMLS concepts (Savova, 2008) and pre-annotation using an algorithmic approach (Chapman, et al, 2007) combined with domain expert annotations reused for temporal relation annotation (Mowery, 2008). Savova (2008) suggests limited utility when a third party tool is used for pre-annotation and Mowery (2008) suggest that even with domain expert pre-annotations, additional features are required to discern temporality. Finally, Fort and Sagot (2008) evaluated using pre-annotation for part-of-speech tagging on the Penn Tree bank corpus and demonstrate a gain in quality and annotation speed even with a not so accurate tagger. Semi-automated curation has been explored as a means to build custom dictionaries for in-formation extraction tasks (Riloff, 1993). More recently this approach was spurred on by the BioCreative II competition (Yeh et al, 2003). Alex et al, (2008), explored the use of NLP-assisted text mining to speed up curation of bi-omedical texts. Settles et al, (2008) estimates true labeling costs and provides a review of ac-tive and interactive learning approaches as a means of providing labels and reducing the cost of obtaining training data (Settles, 2010). Alt-hough eHOST does not yet include an active learning module it does provide one means of interactive annotation so these are important considerations for future development efforts.  In the biomedical informatics domain crowd sourcing has been evaluated as part of the 2009 i2b2 Medication Challenge (Uzuner, 2010). Nowak and Ruger (2010) provide estimates of annotation reliability from crowd sourcing of 
image annotation. Hsueh et al, (2009) provide estimates of the quality of crowd sourcing for sentiment classification using both experts and non-expert annotators. In all three cases the re-sulting annotation set was of comparable quality to that derived from expert annotators. Wang et al, (2008) make general recommendations for best approaches to crowd sourcing that include closer interactions between human and machine methods in ways that more efficiently connect domain expertise with the annotation task.  Subsequent sections in this paper walk the reader through the various basic and advanced features eHOST provides. These features have been developed in a way that provides flexibility to add additional modules that support im-provements in annotation workflow and effi-ciency for a variety of annotation scenarios applicable to computational linguistics and bio-medical informatics. Some of these features may be useful for crowd-sourced efforts whereas oth-ers may simply represent an improvement in the way annotation is visualized or how manual ef-fort can be reduced. Figures in this paper use a set of synthetic clinical documents and a demon-stration annotation project based on the 2010 and 2011 i2b2/VA annotation tasks as examples available from http://code.google.com/p/ehost. 2.2 Systems Architecture The eHOST is a client application that can run on most operating systems that supports Java including, most Microsoft Windows x86/x64 platforms, Apple Mac OS X, Sun Solaris, and Linux. The application uses standardized for-mats including a file folder system, and struc-tured XML inputs and outputs. These capabilities also support integration with other open source tools for annotation and knowledge management including Knowtator and Prot?g?. An Extract-Transform-Load process (ETL) is used by the system to import concept infor-mation from different sources, such as XML or Prot?g? PINS files. These inputs sources are normalized for loading into eHOST. All data that exists in the data pool can be transformed into various output formats. Raw input data doc-uments in a single text file or sequential text files in a file folder system. Information representing an annotation in-
132
cluding concept attributes such as the annotated span, attributes, and relationships between anno-tations are inserted into a common data pool us-ing a dynamic structured storage space. The data pool ensures that eHOST has capabilities to add new functions easily without making major changes to system architecture.  2.3 Annotation Project Workspace In eHOST each project has its own user assigned  workspace that includes an annotation schema and document corpus. Annotation schema can also be imported from an existing Prot?g? PINS file. Project settings can be inherited from exist-ing projects for similar annotations tasks using eHOST. Other workspace functions include quickly switching between up to five of the most recently used workspaces. A workspace can be assigned for each annotation layer or document batch. In these situations, an annotator would receive a pre-compiled project that specifies all settings including any text documents and the annotation schema. Defining a workspace is a particularly useful function in situations where annotations may be crowd sourced and there may be multiple layers of annotation that are potentially fielded to many annotators. 2.3.1 Corpus Management For any annotation task, the end user must man-age the document corpus, which can originate from a server or a file folder system that con-tains individual text files. Using the stand-alone eHOST client tool, corpus management is ac-complished via the current workspace (Figure 1). When the user initializes a new project, docu-ments are placed in a ?corpus? folder that is as-sociated with the newly created annotation project. All text files, are copied to the ?corpus? folder at the time of workspace assignment. Therefore, there is no risk of deleting the origi-nal documents associated with each new annota-tion project. This feature makes distribution of projects easier, because of the consistency be-tween the workspace, corpus assignment and annotation output folders. For crowd-sourced projects eHOST can be integrated with a backend server via web services using an admin-istrative module called CASPR.    
 Figure 1. eHOST corpus management  2.3.2 Viewer/Editor Panels Figure 2 shows an annotation for ?full body pain?, (shown with black bar above and below the active annotation) and information for that annotation including the annotated span, the class assignment and an assertion for the 2010 and 2011 i2b2/VA Challenge annotation tasks (Uzuner et al, 2011 and Uzuner et al, 2012). The result editor tab and its associated panels serve as the central place for basic annotation features. These functionalities include: assigning an annotator, creating new annotations or adjust-ing annotated spans of text and assignment of attributes or creating relationships between an-notated spans of text. Other functions in the re-sults editor tab include navigation between documents in the active corpus, resizing the text displayed in the document viewer, and ?save? and ?save as? functions that assigns a path for XML output files. The end user can easily re-move all annotations in a document or remove specific kinds of annotations by deleting a ?markable? class as well as remove attributes, and relationships between all annotations.  From the navigator screen in the stand-alone eHOST client tool a user can build annotation schema specifying markable classes, their asso-ciated attributes, and any allowed relationships. The navigator interface allows the user to review all annotated spans either within the current document or across the entire document corpus, toggle the view of each class on or off, see counts for all unique annotations and all annota-tions for each class, and choose a class for a fast annotate mode.  An annotation editor panel allows the user to view more detailed information for each selected 
133
annotation. This includes the time stamp of when the annotation was created, annotator as-signment, comments on the annotation and class, attribute and relationship information.  Annotations can be created using several ap-proaches from the result editor. In the normal mode, a class assignment window appears when the user selects a span of text, new annotations are generated by selecting any one of the marka-ble classes.  Activating a ?one click annotate? mode is possible by checking the box next to a class of markables. Under this mode, any text 
selected is automatically annotated as that mark-able class. This feature improves task efficien-cies when categories of markables are low or annotations of the same category cluster in small sections. Keyboard shortcuts have also been in-tegrated with eHOST to reduce annotator click burden and dependence on a mouse. These shortcuts are available for tasks such as modifi-cation of spans, deletion of annotations, and nav-igation between annotations.  
 
 Figure 2. Example annotations using the eHOST interface  2.3.3 Server Integration Annotation projects of any scale benefit from an automated means of building and distributing batches of texts to annotators, managing stand-off XML files generated from annotation tasks or written directly to a database and getting and submitting assignments with minimal user input. Coupling eHOST with server components that comply with the web services API defined for eHOST allows these functionalities. The CASPR module under development by VINCI provides a means to automate the administration of annotation efforts that could include crowd-sourced annotation projects.  Clicking on the sync assignments tab in the eHOST client (Figure 2) brings up a GUI that 
allows annotators to sync with a server location, enter credentials, see documents assigned, and designate documents as on hold, in process, or completed. When a user syncs and gets assign-ments from CASPR, a project folder is created that contains the annotation schema, text docu-ments, and annotations sent from the server.  The CASPR module allows an annotator to open the project and complete their task without need-ing to manage files or folders.  Once completed, annotations can be synced to the server, and the next assignment will be loaded.  The CASPR module allows iterative distribution of annota-tion batches without sending large sets of docu-ments to annotators that may contain sensitive data, decreasing the risk of breaches in privacy and data security. 
134
2.3.4 Additional Features The document viewer panel employs visual cues to display relationships between annotations us-ing color coding representing a parent and child node and line indicator between them showing the relationship. An ?annotation profiler? to the right of the scroll bar shows the density of anno-tations color-coded to their categories, as well as relative to their positions in the document. This type of data visualization is useful to see the rel-
ative location of annotations within a single document or across an en tire document corpus.  An adjudication mode is also included in the stand-alone eHOST client that allows difference matching and side-by-side comparison of anno-tations for efficient adjudication of discrepancies between annotations. Standard reporting metrics can be calculated including Inter-Annotator Agreement (IAA), Recall, Precision and F1-Measure.  
 Figure 3. eHOST adjudication mode showing discrepant annotations between annotators A7 and B4
In Adjudication mode discrepant annotations are shown using a wavy red underline in the editor window and by a red bolded outline in a side by side two panel view between the annotation edi-tor and comparator (Figure 3). These metrics and comparison tables between annotator results on the same documents can be output as HTML formatted reports that can be used by an adjudi-cator to quickly identify discrepancies between 
annotators (Figure 4). These reports and the edi-tor window display can also be used to quickly train annotators on new clinical domains using a reference standard created by domain experts for training purposes. Using these features error analysis can also be done by importing outputs from an NLP system that have been converted into the XML format used by eHOST. 
    
135
Figure 4. HTML Formatted report showing discrepant annotations between annotators A7 and B4  3 Advanced eHOST Features  There are also other more advanced features that have been integrated with eHOST. These in-clude an ?Oracle? mode that allows semi-automated annotation of similar spans of text across a document corpus, a means to easily and quickly curate annotated spans of text to create custom dictionaries, and machine-assisted pre-annotation integrated with the annotation tool itself.  3.1 Oracle Mode Also implemented with eHOST is an ?Oracle? mode which uses exact string matching allowing the user to annotate all spans of text that are 
identical to a new annotation. The oracle lists where these candidate annotations are found along with the surrounding context. The annota-tor can then accept or reject candidate spans an-notated with the same markable class. Oracle mode can run within the current document or across the entire document corpus. This type of functionality is useful for annotation tasks that may involve identifying and marking spans of text that are repetitive or follow the same format For example, the 2011 i2b2/VA annotation task in which annotation of pronominal information was required for co-reference resolution (Figure 5). 
 
 Figure 5. Example annotations generated using the eHOST ?Oracle? mode 
136
3.2 Semi-Automated Curation and    Dictionary Management Using the navigator window users can navigate to all annotations in either a single document or across an entire document corpus (Figure 6). The end user can curate annotations directly, create classes on the fly, or add attributes to an-notations found from the navigator pane. These functions also allow users to easily identify spu-rious annotations introduced from machine-assisted approaches correct misclassification errors, and quickly curate all annotations within a single document or across an entire document corpus. 
 Figure 6. Semi-Automated curation within the  document corpus  One task often associated with development of NLP systems involves manually creating or en-hancing some existing representation of lexical knowledge that can be used as a domain specific dictionary. Using eHOST users can export anno-tations to create a dictionary of terms, phrases, or individual tokens that have been identified by human annotators and assigned to markable in-formation classes. Once curated, annotated in-formation can be exported as a new dictionary. User created dictionaries can be integrated with 
a database or exported and used in the creation of some ontologic representation of information using Prot?g?. Output from a dictionary manager is in the form of a delimited text file and can therefore be modified to fit any standardized information model or used to pre-annotate sub-sequent document batches. 3.3 Machine-Assisted Pre-Annotation An interface is provided in eHOST that can be used for machine-assisted pre-annotation of documents in the active project corpus using either dictionaries or regular expressions based approaches. Users can import libraries of regular expressions or build their own regular expres-sions using a custom regular expression builder. Users can build and modify dictionaries created as part of annotation tasks that may include semi-automated curation steps. Dictionaries and regular expressions can also be coupled with the ConText algorithm (Chapman et al, 2007) to identify concept attributes such as negation, ex-periencer, and temporality. Pre-annotations de-rived from some external third party source such as an NLP system written as Knowtator XML outputs may also be imported into eHOST or passed to eHOST using CASPR. Computational speed required for pre-annotation can be improved by selecting an op-tion to use an internal statistical dictionary in-dexing function. This feature is particularly useful in situations where pre-annotation dic-tionaries are extremely large, such as where a subset of some standard vocabulary may be used to pre-annotate documents. Using the result edi-tor and its associated functions annotators can add missed annotations, modifying existing an-notations and delete spurious annotations. Han-dling pre-annotations in this way allows troubleshooting and error analysis of NLP sys-tem outputs imported into eHOST that can be shown to a reviewer in context and also facili-tates interactive annotator training.   3.4 Machine-Assisted Verification One of the more innovative features integrated with eHOST is the ability to verify and produce recommendations that help human annotators comply with syntactic and lexical rules that are specified by annotation task guidelines. Ma-
137
chine-Assisted verification is most useful when used on lexical or syntax rules to ensure that candidate phrases generated by automated sys-tems are similar to those marked by humans. These rules rely more on adherence to patterns than on decision-making, so the strengths of human review with machine approaches to semi-automated verification can be leveraged. When identifying medical concepts, it is common that noun phrases are marked as candidates. The de-termination of how much of a noun phrase to mark (inclusion of articles, adjectives, noun-modifiers, prepositional phrases) and at what granularity (simple nouns or complex noun phrases) may vary with each project. The verifier allows portions of an annotation guideline to be programmed into rules that check for consistency. Rules check whether a word appears within a user-defined window before and after an annotation. Each rule can be linked to text that describes why the annotation was flagged. Annotators are then provided sugges-tions on the correct span based on the rule. Us-ing the surrounding text, the guideline text, and the suggestion, the annotator can determine the final span for an annotation. These machine-assisted verifier functions help support reference standard generation by providing the context of annotations that seem to fail syntactic and lexi-cal rules while allowing human annotators to focus on domain expertise required to identify and classify information found in clinical texts.  Conclusion Our prototype system provides functionalities that have been created to more efficiently sup-port reference standard generation including ma-chine-assisted annotation approaches. It is our hope that these system features will serve as the basis for the further development efforts that will be part of an enterprise level system. Out-puts of such an annotation tool could be used as inputs for pipeline NLP systems or as one com-ponent of a common workbench of tools used for clinical NLP development tasks.  We have implemented and tested eHOST for the 2010 and 2011 i2b2/VA challenge annota-tion tasks and annotation projects for the Con-sortium for Healthcare Informatics Research (CHIR). The stand-alone eHOST client tool is 
available from http://code.google.com/p/ehost along with a demonstration project, a users guide, API documentation, and source code. The eHOST/CASPR interfaces will be used to sup-port a large-scale crowd sourced annotation task used for annotation of disorders, temporal ex-pressions, uncertainty, and negation along with data standardization. These efforts will include more rigorous analysis and usability assessment of eHOST/CASPR for crowd sourcing and other small and large-scale annotation projects.  Acknowledgments Support and funding was provided by the VA Salt Lake City HealthCare System and the VA Consortium for Healthcare Informatics Research (CHIR), VA HSR HIR 08-374, the VA Infor-matics and Computing Infrastructure (VINCI), VA HIR 08-204, and NIH Grant U54 HL 108460 for integrating Data for Analysis, An-nonymization and Sharing (iDASH), NIGMS 7R01GM090187.  References  Beatrice Alex, Claire Grover, Barry Haddow, Mijail Kabadjov, Ewan Klein, Michael Matthews, Stuart Roebuck, Richard Tobin, and Xinglong Wang. 2008. Assisted curation: does text mining really help? In: Proceedings of the Pacific Symposium on Biocomputing.  Wendy W. Chapman, David Chu, John N. Dowling. 2007. ConText: An Algorithm for Identifying Contextual Features from Clinical Text. In: ACL-07 2007.  Carol Friedman, Hongfang Liu, Lyudmila Shagina, Stephen Johnson, George Hripcsak. 2001. Evaluat-ing the UMLS as a source of lexical knowledge for medical language processing. In: Proc AMIA Symp, 2001: 189-93. Karen Fort and Saggot B. 2010. Influence of Pre-Annotation on POS-tagged Corpus Development. In: Proceedings of the Fourth Linguistic Annota-tion Workshop. ACL 2010: 56-63.  Pei-Yun Hsueh, Prem Melville, Vikas Sindhwani. 2009. Data Quality from Crowdsourcing: A study of Annotation Selection Criteria. In: Proceedings of the NAACL HLT Workshop on Active Learning for Natural Language Processing. June 2009: 27-35.  Danielle Mowery, Henk Harkema, Wendy W. Chap-man. 2008. Temporal Annotation of Clinical Text. In: ACL-08 2008. 
138
Mark A. Musen, John Gennari, Henrik Eriksson, Samson W. Tu, and Angel R. Puerta. 1995. PROTEGE-II: computer support for development of intelligent systems from libraries of compo-nents. In: Medinfo 1995.  Aur?lie N?v?ol, Rezarta Islamaj-Do?an, Zhiyong Lu. 2011. Semi-automatic semantic annotation of PubMed queries: a study on quality, efficiency, satisfaction. In: J Biomed Inform. 2011 Apr; 44(2):310-8.  Stefanie Nowak and Stefan Ruger. 2010. How Relia-ble are Annotations via Crowdsourcing? A Study about Inter-Annotator Agreement for Multi-label Image Annotation. In: MIR 10  2010. Philip V. Ogren. 2006. Knowtator a protege plug-in for annotated corpus construction. In: Proceedings of the 2006 Conference of the North American Chapter of the Association for Computational Lin-guistics on Human Language Technology, 2006: 273-5. Philip V. Ogren, Guergana K. Savova, Christopher G. Chute. 2008. Constructing Evaluation Corpora for Automated Clinical Named Entity Recogni-tion. In: Proceedings of the sixth international conference on Language Resources and Evalua-tion LREC 2008: 3143-3150. Angus Roberts, Robert Gaizauskas, Mark Hepple, Neil Davis, George Demetriou, Yikun Guo, Jay Kola, Ian Roberts, Andrea Setzer, Archana Tapuria, Bill Wheeldin. 2007. The CLEF corpus: semantic annotation of clinical text. In: AMIA An-nu Symp Proc, 625-9. Angus Roberts, Robert Gaizauskas, Mark Hepple, George Demetriou, Yikun Guo, Ian Roberts, An-drea Setzer. 2009. Building a semantically anno-tated corpus of clinical texts. In: J Biomed Inform, 42(5): 950-66.  Ellen Riloff. 1993. Automatically constructing a dic-tionary for information extraction tasks.  In: Pro-ceedings of the Eleventh National Conference on Artificial Intelligence, 811-816.  
Burr Settles, Mark Craven, and Lewis Friedland. 2008. Active Learning with Real Annotation Costs. In: Proceedings of the NIPS Workshop on Cost-Sensitive Learning. 2008. Burr Settles. 2009. Active Learning Literature Sur-vey. In: Computer Sciences Technical Report 1648. University of Wisconsin-Madison. 2009. Brett R. South, Shuying Shen, F. Jeff Friedlin, Mat-thew H. Samore, and Stephane M. Meystre. 2010. Enhancing Annotation of Clinical Text using Pre-Annotation of Common PHI. In: AMIA Annu Symp Proc. 2010.  Brett R. South, Shuying Shen, Robyn Barrus, Scott L. DuVall, Ozlem Uzuner, and Charlene Weir. 2011. Qualitative analysis of workflow modifications used to generate the reference standard for the 2010 i2b2/VA challenge. In: AMIA Annu Symp Proc. 2011.  ?zlem Uzuner, Imre Solti, Fei Xia, and Eithon Cadag. 2010. Community annotation experiment for ground truth generation for the i2b2 medica-tion challenge. In: J Am Med Inform Assoc, 2010. 17(5):519-23. ?zlem Uzuner, Brett R. South, Shuying Shen, and Scott L. DuVall. 2011. 2010 i2b2/VA challenge on concepts, assertions, and relations in clinical text. In: JAMIA 18(5): 552-556. ?zlem Uzuner, Andreea Bodnari, Shuying Shen, Tyler B. Forbush, John Pestian, and Brett R. South. 2012. Evaluating the state of the art in co-reference resolution for electronic medical records. In: JAMIA doi: 10.1136/amiajnl-2011-000784. Aobo Wang, Cong Duy Vu Hoang, and Min-Yen Kan. 2010. Perspectives on Crowdsourcing Anno-tations for Natural Language Processing. In: CSIDM Project No. CSIDM-200805. Alexander S. Yeh, Lynette Hirschman, and Alexan-der A. Morgan. 2003. Evaluation of text data min-ing for database curation: Lessons learned from the KDD challenge cup. In: Bioinformatics, 19(Suppl 1): i331?339, 2003. 
 
139
