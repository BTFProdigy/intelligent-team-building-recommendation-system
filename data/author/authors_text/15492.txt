Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 410?419,
MIT, Massachusetts, USA, 9-11 October 2010. c?2010 Association for Computational Linguistics
A Game-Theoretic Approach to Generating Spatial Descriptions
Dave Golland
UC Berkeley
Berkeley, CA 94720
dsg@cs.berkeley.edu
Percy Liang
UC Berkeley
Berkeley, CA 94720
pliang@cs.berkeley.edu
Dan Klein
UC Berkeley
Berkeley, CA 94720
klein@cs.berkeley.edu
Abstract
Language is sensitive to both semantic and
pragmatic effects. To capture both effects,
we model language use as a cooperative game
between two players: a speaker, who gener-
ates an utterance, and a listener, who responds
with an action. Specifically, we consider the
task of generating spatial references to ob-
jects, wherein the listener must accurately
identify an object described by the speaker.
We show that a speaker model that acts op-
timally with respect to an explicit, embedded
listener model substantially outperforms one
that is trained to directly generate spatial de-
scriptions.
1 Introduction
Language is about successful communication be-
tween a speaker and a listener. For example, if the
goal is to reference the target object O1 in Figure 1,
a speaker might choose one of the following two ut-
terances:
(a) right of O2 (b) on O3
Although both utterances are semantically correct,
(a) is ambiguous between O1 and O3, whereas (b)
unambiguously identifies O1 as the target object,
and should therefore be preferred over (a). In this
paper, we present a game-theoretic model that cap-
tures this communication-oriented aspect of lan-
guage interpretation and generation.
Successful communication can be broken down
into semantics and pragmatics. Most computational
Figure 1: An example of a 3D model of a room. The
speaker?s goal is to reference the target object O1 by de-
scribing its spatial relationship to other object(s). The
listener?s goal is to guess the object given the speaker?s
description.
work on interpreting language focuses on compo-
sitional semantics (Zettlemoyer and Collins, 2005;
Wong and Mooney, 2007; Piantadosi et al, 2008),
which is concerned with verifying the truth of a sen-
tence. However, what is missing from this truth-
oriented view is the pragmatic aspect of language?
that language is used to accomplish an end goal, as
exemplified by speech acts (Austin, 1962). Indeed,
although both utterances (a) and (b) are semantically
valid, only (b) is pragmatically felicitous: (a) is am-
biguous and therefore violates the Gricean maxim
of manner (Grice, 1975). To capture this maxim, we
develop a model of pragmatics based on game the-
ory, in the spirit of Ja?ger (2008) but extended to the
stochastic setting. We show that Gricean maxims
410
fall out naturally as consequences of the model.
An effective way to empirically explore the prag-
matic aspects of language is to work in the grounded
setting, where the basic idea is to map language to
some representation of the non-linguistic world (Yu
and Ballard, 2004; Feldman and Narayanan, 2004;
Fleischman and Roy, 2007; Chen and Mooney,
2008; Frank et al, 2009; Liang et al, 2009). Along
similar lines, past work has also focused on inter-
preting natural language instructions (Branavan et
al., 2009; Eisenstein et al, 2009; Kollar et al, 2010),
which takes into account the goal of the communi-
cation. This work differs from ours in that it does
not clarify the formal relationship between pragmat-
ics and the interpretation task. Pragmatics has also
been studied in the context of dialog systems. For
instance, DeVault and Stone (2007) present a model
of collaborative language between multiple agents
that takes into account contextual ambiguities.
We present our pragmatic model in a grounded
setting where a speaker must describe a target object
to a listener via spatial description (such as in the
example given above). Though we use some of the
techniques from work on the semantics of spatial de-
scriptions (Regier and Carlson, 2001; Gorniak and
Roy, 2004; Tellex and Roy, 2009), we empirically
demonstrate that having a model of pragmatics en-
ables more successful communication.
2 Language as a Game
To model Grice?s cooperative principle (Grice,
1975), we formulate the interaction between a
speaker S and a listener L as a cooperative game, that
is, one in which S and L share the same utility func-
tion. For simplicity, we focus on the production and
interpretation of single utterances, where the speaker
and listener have access to a shared context. To sim-
plify notation, we suppress writing the dependence
on the context.
The Communication Game
1. In order to communicate a target o to L, S pro-
duces an utterance w chosen according to a
strategy pS(w | o).
2. L interprets w and responds with a guess g ac-
cording to a strategy pL(g | w).
3. S and L collectively get a utility of U(o, g).
o w g
U
speaker listener
ps(w | o) pl(g | w)
target utterance guess
utility
Figure 2: Diagram representing the communication
game. A target, o, is given to the speaker that generates
an utterance w. Based on this utterance, the listener gen-
erates a guess g. If o = g, then both the listener and
speaker get a utility of 1, otherwise they get a utility of 0.
This communication game is described graphi-
on O3
1
near O3
0
right of O2
0
Figure 3: Three instances of the communication game on
the scenario in Figure 1. For each instance, the target o,
utterancew, guess g, and the resulting utilityU are shown
in their respective positions. A utility of 1 is awarded only
when the guess matches the target.
cally in Figure 2. Figure 3 shows several instances of
the communication game being played for the sce-
nario in Figure 1.
Grice?s maxim of manner encourages utterances
to be unambiguous, which motivates the following
utility, which we call (communicative) success:
U(o, g)
def
= I[o = g], (1)
where the indicator function I[o = g] is 1 if o =
g and 0 otherwise. Hence, a utility-maximizing
speaker will attempt to produce unambiguous utter-
ances because they increase the probability that the
listener will correctly guess the target.
411
Given a speaker strategy pS(w | o), a listener
strategy pL(g | w), and a prior distribution over tar-
gets p(o), the expected utility obtained by S and L is
as follows:
EU(S, L) =
?
o,w,g
p(o)pS(w|o)pL(g|w)U(o, g)
=
?
o,w
p(o)pS(w|o)pL(o|w). (2)
3 From Reflex Speaker to Rational
Speaker
Having formalized the language game, we now ex-
plore various speaker and listener strategies. First,
let us consider literal strategies. A literal speaker
(denoted S:LITERAL) chooses uniformly from the
set of utterances consistent with a target object, i.e.,
the ones which are semantically valid;1 a literal lis-
tener (denoted L:LITERAL) guesses an object con-
sistent with the utterance uniformly at random.
In the running example (Figure 1), where the tar-
get object is O1, there are two semantically valid ut-
terances:
(a) right of O2 (b) on O3
S:LITERAL selects (a) or (b) each with probability
1
2 . If S:LITERAL chooses (a), L:LITERAL will guess
the target object O1 correctly with probability 12 ; if
S:LITERAL chooses (b), L:LITERAL will guess cor-
rectly with probability 1. Therefore, the expected
utility EU(S:LITERAL, L:LITERAL) = 34 .
We say S:LITERAL is an example of a reflex
speaker because it chooses an utterance without
taking the listener into account. A general reflex
speaker is depicted in Figure 4(a), where each edge
represents a potential utterance.
Suppose we now have a model of some listener
L. Motivated by game theory, we would optimize
the expected utility (2) given pL(g | w). We call
the resulting speaker S(L) the rational speaker with
respect to listener L. Solving for this strategy yields:
pS(L)(w | o) = I[w = w?], where
w? = argmax
w?
pL(o | w
?). (3)
1Semantic validity is approximated by a set of heuristic rules
(e.g. left is all positions with smaller x-coordinates).
S
w1
o w2
w3
S(L)
w1
o
L
g1
w2 g2
g3
w3
(a) Reflex speaker (b) Rational speaker
Figure 4: (a) A reflex speaker (S) directly selects an ut-
terance based only on the target object. Each edge rep-
resents a different choice of utterance. (b) A rational
speaker (S(L)) selects an utterance based on an embed-
ded model of the listener (L). Each edge in the first layer
represents a different choice the speaker can make, and
each edge in the second layer represents a response of the
listener.
Intuitively, S(L) chooses an utterance, w?, such that,
if listener L were to interpret w?, the probability of
L guessing the target would be maximized.2 The ra-
tional speaker is depicted in Figure 4(b), where, as
before, each edge at the first level represents a possi-
ble choice for the speaker, but there is now a second
layer representing the response of the listener.
To see how an embedded model of the listener
improves communication, again consider our run-
ning example in Figure 1. A speaker can describe
the target object O1 using either w1 = on O3 or
w2 = right of O2. Suppose the embedded listener
is L:LITERAL, which chooses uniformly from the
set of objects consistent with the given utterance.
In this scenario, pL:LITERAL(O1 | w1) = 1 because
w1 unambiguously describes the target object, but
pL:LITERAL(O1 | w2) = 12 . The rational speaker
S(L:LITERAL) would therefore choose w1, achiev-
ing a utility of 1, which is an improvement over the
reflex speaker S:LITERAL?s utility of 34 .
2If there are ties, any distribution over the utterances having
the same utility is optimal.
412
4 From Literal Speaker to Learned
Speaker
In the previous section, we showed that a literal
strategy, one that considers only semantically valid
choices, can be used to directly construct a reflex
speaker S:LITERAL or an embedded listener in a
rational speaker S(L:LITERAL). This section fo-
cuses on an orthogonal direction: improving literal
strategies with learning. Specifically, we construct
learned strategies from log-linear models trained on
human annotations. These learned strategies can
then be used to construct reflex and rational speaker
variants?S:LEARNED and S(L:LEARNED), respec-
tively.
4.1 Training a Log-Linear Speaker/Listener
We train the speaker, S:LEARNED, (similarly, lis-
tener, L:LEARNED) on training examples which
comprise the utterances produced by the human an-
notators (see Section 6.1 for details on how this
data was collected). Each example consists of a 3D
model of a room in a house that specifies the 3D po-
sitions of each object and the coordinates of a 3D
camera. When training the speaker, each example is
a pair (o, w), where o is the input target object and
w is the output utterance. When training the listener,
each example is (w, g), where w is the input utter-
ance and g is the output guessed object.
For now, an utterance w consists of two parts:
? A spatial preposition w.r (e.g., right of) from a
set of possible prepositions.3
? A reference object w.o (e.g., O3) from the set
of objects in the room.
We consider more complex utterances in Section 5.
Both S:LEARNED and L:LEARNED are
parametrized by log-linear models:
pS:LEARNED(w|o; ?S) ? exp{?
>
S ?(o, w)} (4)
pL:LEARNED(g|w; ?L) ? exp{?
>
L ?(g, w)} (5)
where ?(?, ?) is the feature vector (see below), ?S
and ?L are the parameter vectors for speaker and lis-
tener. Note that the speaker and listener use the same
3We chose 10 prepositions commonly used by people to de-
scribe objects in a preliminary data gathering experiment. This
list includes multi-word units, which function equivalently to
prepositions, such as left of.
set of features, but they have different parameters.
Furthermore, the first normalization sums over pos-
sible utterances w while the second normalization
sums over possible objects g in the scene. The two
parameter vectors are trained to optimize the log-
likelihood of the training data under the respective
models.
Features We now describe the features ?(o, w).
These features draw inspiration from Landau and
Jackendoff (1993) and Tellex and Roy (2009).
Each object o in the 3D scene is represented by
its bounding box, which is the smallest rectangular
prism containing o. The following are functions of
the camera, target (or guessed object) o, and the ref-
erence object w.o in the utterance. The full set of
features is obtained by conjoining these functions
with indicator functions of the form I[w.r = r],
where r ranges over the set of valid prepositions.
? Proximity functions measure the distance be-
tween o and w.o. This is implemented as the
minimum over all the pairwise Euclidean dis-
tances between the corners of the bounding
boxes. We also have indicator functions for
whether o is the closest object, among the top
5 closest objects, and among the top 10 closest
objects to w.o.
? Topological functions measure containment be-
tween o and w.o: vol(o ? w.o)/vol(o) and
vol(o ? w.o)/vol(w.o). To simplify volume
computation, we approximate each object by a
bounding box that is aligned with the camera
axes.
? Projection functions measure the relative posi-
tion of the bounding boxes with respect to one
another. Specifically, let v be the vector from
the center of w.o to the center of o. There is a
function for the projection of v onto each of the
axes defined by the camera orientation (see Fig-
ure 5). Additionally, there is a set of indicator
functions that capture the relative magnitude of
these projections. For example, there is a indi-
cator function denoting whether the projection
of v onto the camera?s x-axis is the largest of
all three projections.
413
Figure 5: The projection features are computed by pro-
jecting a vector v extending from the center of the ref-
erence object to the center of the target object onto the
camera axes fx and fy .
5 Handling Complex Utterances
So far, we have only considered speakers and lis-
teners that deal with utterances consisting of one
preposition and one reference object. We now ex-
tend these strategies to handle more complex utter-
ances. Specifically, we consider utterances that con-
form to the following grammar:4
[noun] N ? something | O1 | O2 | ? ? ?
[relation] R ? in front of | on | ? ? ?
[conjunction] NP ? N RP?
[relativization] RP ? R NP
This grammar captures two phenomena of lan-
guage use, conjunction and relativization.
? Conjunction is useful when one spatial relation
is insufficient to disambiguate the target object.
For example, in Figure 1, right of O2 could re-
fer to the vase or the table, but using the con-
junction right of O2 and on O3 narrows down
the target object to just the vase.
? The main purpose of relativization is to refer
to objects without a precise nominal descrip-
tor. With complex utterances, it is possible to
chain relative prepositional phrases, for exam-
ple, using on something right of O2 to refer to
the vase.
4Naturally, we disallow direct reference to the target object.
Given an utterancew, we define its complexity |w|
as the number of applications of the relativization
rule, RP ? R NP, used to produce w. We had only
considered utterances of complexity 1 in previous
sections.
5.1 Example Utterances
To illustrate the types of utterances available under
the grammar, again consider the scene in Figure 1.
Utterances of complexity 2 can be generated ei-
ther using the relativization rule exclusively, or both
the conjunction and relativization rules. The rela-
tivization rule can be used to generate the following
utterances:
? on something that is right of O2
? right of something that is left of O3
Applying the conjunction rule leads to the following
utterances:
? right of O2 and on O3
? right of O2 and under O1
? left of O1 and left of O3
Note that we inserted the words that is after each N
and the word and between every adjacent pair of RPs
generated via the conjunction rule. This is to help a
human listener interpret an utterance.
5.2 Extending the Rational Speaker
Suppose we have a rational speaker S(L) defined in
terms of an embedded listener L which operates over
utterances of complexity 1. We first extend L to in-
terpret arbitrary utterances of our grammar. The ra-
tional speaker (defined in (2)) automatically inherits
this extension.
Compositional semantics allows us to define the
interpretation of complex utterances in terms of sim-
pler ones. Specifically, each node in the parse tree
has a denotation, which is computed recursively
in terms of the node?s children via a set of sim-
ple rules. Usually, denotations are represented as
lambda-calculus functions, but for us, they will be
distributions over objects in the scene. As a base
case for interpreting utterances of complexity 1, we
can use either L:LITERAL or L:LEARNED (defined
in Sections 3 and 4).
414
Given a subtree w rooted at u ? {N, NP, RP}, we
define the denotation of w, JwK, to be a distribution
over the objects in the scene in which the utterance
was generated. The listener strategy pL(g|w) = JwK
is recursively as follows:
? If w is rooted at N with a single child x, then JwK
is the uniform distribution over N (x), the set of
objects consistent with the word x.
? If w is rooted at NP, we recursively compute the
distributions over objects g for each child tree,
multiply the probabilities, and renormalize (Hin-
ton, 1999).
? Ifw is rooted at RP with relation r, we recursively
compute the distribution over objects g? for the
child NP tree. We then appeal to the base case
to produce a distribution over objects g which are
related to g? via relation r.
This strategy is defined formally as follows:
pL(g | w) ?
?
?????
?????
I[g ? N (x)] w = (N x)
k?
j=1
pL(g | wj) w = (NP w1 . . . wk)
?
g?
pL(g | (r, g?))pL(g? | w?) w = (RP (R r)w?)
(6)
Figure 6 shows an example of this bottom-
up denotation computation for the utterance
on something right of O2 with respect to the scene
in Figure 1. The denotation starts with the lowest
NP node JO2K, which places all the mass on O2
in the scene. Moving up the tree, we compute
the denotation of the RP, Jright of O2K, using the
RP case of (6), which results in a distribution that
places equal mass on O1 and O3.5 The denotation
of the N node JsomethingK is a flat distribution over
all the objects in the scene. Continuing up the tree,
the denotation of the NP is computed by taking a
product of the object distributions, and turns out
to be exactly the same split distribution as its RP
child. Finally, the denotation at the root is computed
by applying the base case to on and the resulting
distribution from the previous step.
5It is worth mentioning that this split distribution between
O1 and O3 represents the ambiguity mentioned in Section 3
when discussing the shortcomings of S:LITERAL.
Figure 6: The listener model maps an utterance to a dis-
tribution over objects in the room. Each internal NP or RP
node is a distribution over objects in the room.
Generation So far, we have defined the listener
strategy pL(g | w). Given target o, the rational
speaker S(L) with respect to this listener needs to
compute argmaxw pL(o | w) as dictated by (3). This
maximization is performed by enumerating all utter-
ances of bounded complexity.
5.3 Modeling Listener Confusion
One shortcoming of the previous approach for ex-
tending a listener is that it falsely assumes that a lis-
tener can reliably interpret a simple utterance just as
well as it can a complex utterance.
We now describe a more realistic speaker which
is robust to listener confusion. Let ? ? [0, 1] be
a focus parameter which determines the confusion
level. Suppose we have a listener L. When presented
with an utterance w, for each application of the rela-
tivization rule, we have a 1?? probability of losing
focus. If we stay focused for the entire utterance
(with probability ?|w|), then we interpret the utter-
ance according to pL. Otherwise (with probability
1 ? ?|w|), we guess an object at random according
to prnd(g | w). We then use (3) to define the rational
speaker S(L) with respect the following ?confused
listener? strategy:
p?L(g | w) = ?
|w|pL(g | w) + (1 ? ?
|w|)prnd(g | w).
(7)
As ? ? 0, the confused listener is more likely to
make a random guess, and thus there is a stronger
penalty against using more complex utterances. As
415
? ? 1, the confused listener converges to pL and the
penalty for using complex utterances vanishes.
5.4 The Taboo Setting
Notice that the rational speaker as defined so far
does not make full use of our grammar. Specifi-
cally, the rational speaker will never use the ?wild-
card? noun something nor the relativization rule in
the grammar because an NP headed by the wildcard
something can always be replaced by the object ID
to obtain a higher utility. For instance, in Figure 6,
the NP spanning something right of O2 can be re-
placed by O3.
However, it is not realistic to assume that all ob-
jects can be referenced directly. To simulate scenar-
ios where some objects cannot be referenced directly
(and to fully exercise our grammar), we introduce
the taboo setting. In this setting, we remove from
the lexicon some fraction of the object IDs which are
closest to the target object. Since the tabooed objects
cannot be referenced directly, a speaker must resort
to use of the wildcard something and relativization.
For example, in Figure 7, we enable tabooing
around the target O1. This prevents the speaker from
referring directly to O3, so the speaker is forced to
describe O3 via the relativization rule, for example,
producing something right of O2.
Figure 7: With tabooing enabled around O1, O3 can no
longer be referred to directly (represented by an X).
6 Experiments
We now present our empirical results, showing that
rational speakers, who have embedded models of lis-
Figure 8: Mechanical Turk speaker task: Given the tar-
get object (e.g., O1), a human speaker must choose an
utterance to describe the object (e.g., right of O2).
teners, can communicate more successfully than re-
flex speakers, who do not.
6.1 Setup
We collected 43 scenes (rooms) from the Google
Sketchup 3D Warehouse, each containing an aver-
age of 22 objects (household items and pieces of fur-
niture arranged in a natural configuration). For each
object o in a scene, we create a scenario, which rep-
resents an instance of the communication game with
o as the target object. There are a total of 2,860 sce-
narios, which we split evenly into a training set (de-
noted TR) and a test set (denoted TS).
We created the following two Amazon Mechani-
cal Turk tasks, which enable humans to play the lan-
guage game on the scenarios:
Speaker Task In this task, human annotators play
the role of speakers in the language game. They are
prompted with a target object o and asked to each
produce an utterance w (by selecting a preposition
w.r from a dropdown list and clicking on a reference
objectw.o) that best informs a listener of the identity
of the target object.
For each training scenario o, we asked three
speakers to produce an utterancew. The three result-
ing (o, w) pairs are used to train the learned reflex
speaker (S:LITERAL). These pairs were also used to
train the learned reflex listener (L:LITERAL), where
the target o is treated as the guessed object. See Sec-
tion 4.1 for the details of the training procedure.
Listener Task In this task, human annotators play
the role of listeners. Given an utterance generated by
a speaker (human or not), the human listener must
416
O2
O1
O3
Question: What object is right of           ?O2
Figure 9: Mechanical Turk listener task: a human listener
is prompted with an utterance generated by a speaker
(e.g., right of O2), and asked to click on an object (shown
by the red arrow).
guess the target object that the speaker saw by click-
ing on an object. The purpose of the listener task is
to evaluate speakers, as described in the next section.
6.2 Evaluation
Utility (Communicative Success) We primarily
evaluate a speaker by its ability to communicate suc-
cessfully with a human listener. For each test sce-
nario, we asked three listeners to guess the object.
We use pL:HUMAN(g | w) to denote the distribution
over guessed objects g given prompt w. For exam-
ple, if two of the three listeners guessed O1, then
pL:HUMAN(O1 | w) = 23 . The expected utility (2) is
then computed by averaging the utility (communica-
tive success) over the test scenarios TS:
SUCCESS(S) = EU(S, L:HUMAN) (8)
=
1
|TS|
?
o?TS
?
w
pS(w|o)pL:HUMAN(o|w).
Exact Match As a secondary evaluation metric,
we also measure the ability of our speaker to exactly
match an utterance produced by a human speaker.
Note that since there are many ways of describing
an object, exact match is neither necessary nor suffi-
cient for successful communication.
We asked three human speakers to each pro-
duce an utterance w given a target o. We use
pS:HUMAN(w | o) to denote this distribution; for ex-
ample, pS:HUMAN(right of O2 | o) = 13 if exactly one
of the three speakers uttered right of O2. We then
Speaker Success Exact Match
S:LITERAL [reflex] 4.62% 1.11%
S(L:LITERAL) [rational] 33.65% 2.91%
S:LEARNED [reflex] 38.36% 5.44%
S(L:LEARNED) [rational] 52.63% 14.03%
S:HUMAN 41.41% 19.95%
Table 1: Comparison of various speakers on communica-
tive success and exact match, where only utterances of
complexity 1 are allowed. The rational speakers (with
respect to both the literal listener L:LITERAL and the
learned listener L:LEARNED) perform better than their
reflex counterparts. While the human speaker (composed
of three people) has higher exact match (it is better at
mimicking itself), the rational speaker S(L:LEARNED)
actually achieves higher communicative success than the
human listener.
define the exact match of a speaker S as follows:
MATCH(S) =
1
|TS|
?
o?TS
?
w
pS:HUMAN(w | o)pS(w | o).
(9)
6.3 Reflex versus Rational Speakers
We first evaluate speakers in the setting where only
utterances of complexity 1 are allowed. Table 1
shows the results on both success and exact match.
First, our main result is that the two rational speak-
ers S(L:LITERAL) and S(L:LEARNED), which each
model a listener explicitly, perform significantly bet-
ter than the corresponding reflex speakers, both in
terms of success and exact match.
Second, it is natural that the speakers that in-
volve learning (S:LITERAL and S(L:LITERAL))
outperform the speakers that only consider the
literal meaning of utterances (S:LEARNED and
S(L:LEARNED)), as the former models capture sub-
tler preferences using features.
Finally, we see that in terms of exact match, the
human speaker S:HUMAN performs the best (this
is not surprising because human exact match is es-
sentially the inter-annotator agreement), but in terms
of communicative success, S(L:LEARNED) achieves
a higher success rate than S:HUMAN, suggesting
that the game-theoretic modeling undertaken by the
rational speakers is effective for communication,
which is ultimate goal of language.
Note that exact match is low even for the ?human
speaker?, since there are often many equally good
417
0.2 0.4 0.6 0.8 1.0?
0.49
0.5
0.51
0.52
suc
ces
s
Figure 10: Communicative success as a function of focus
parameter ? without tabooing on TSDEV. The optimal
value of ? is obtained at 0.79.
ways to evoke an object. At the same time, the suc-
cess rates for all speakers are rather low, reflecting
the fundamental difficulty of the setting: sometimes
it is impossible to unambiguously evoke the target
object via short utterances. In the next section, we
show that we can improve the success rate by al-
lowing the speakers to generate more complex utter-
ances.
6.4 Generating More Complex Utterances
We now evaluate the rational speaker
S(L:LEARNED) when it is allowed to generate
utterances of complexity 1 or 2. Recall from
Section 5.3 that the speaker depends on a focus
parameter ?, which governs the embedded listener?s
ability to interpret the utterance. We divided the test
set (TS) in two halves: TSDEV, which we used to
tune the value of ? and TSFINAL, which we used to
evaluate success rates.
Figure 10 shows the communicative success as
a function of ? on TSDEV. When ? is small, the
embedded listener is confused more easily by more
complex utterances; therefore the speaker tends to
choose mostly utterances of complexity 1. As ?
increases, the utterances increase in complexity, as
does the success rate. However, when ? approaches
1, the utterances are too complex and the success
rate decreases. The dependence between ? and av-
erage utterance complexity is shown in Figure 11.
Table 2 shows the success rates on TSFINAL for
? ? 0 (all utterances have complexity 1), ? = 1 (all
utterances have complexity 2), and ? tuned to max-
imize the success rate based on TSDEV. Setting ?
in this manner allows us to effectively balance com-
plexity and ambiguity, resulting in an improvement
in the success rate.
0.2 0.4 0.6 0.8 1.0?
1.2
1.4
1.6
1.8
2.0
ave
rag
e|w
|
Figure 11: Average utterance complexity as a function of
the focus parameter ? on TSDEV. Higher values of ?
yield more complex utterances.
Taboo Success Success Success
Amount (? ? 0) (? = 1) (? = ??) ??
0% 51.78% 50.99% 54.53% 0.79
5% 38.75% 40.83% 43.12% 0.89
10% 29.57% 29.69% 30.30% 0.80
30% 12.40% 13.04% 12.98% 0.81
Table 2: Communicative success (on TSFINAL) of the
rational speaker S(L:LEARNED) for various values of ?
across different taboo amounts. When the taboo amount
is small, small values of ? lead to higher success rates. As
the taboo amount increases, larger values of ? (resulting
in more complex utterances) are better.
7 Conclusion
Starting with the view that the purpose of language
is successful communication, we developed a game-
theoretic model in which a rational speaker gener-
ates utterances by explicitly taking the listener into
account. On the task of generating spatial descrip-
tions, we showed the rational speaker substantially
outperforms a baseline reflex speaker that does not
have an embedded model. Our results therefore sug-
gest that a model of the pragmatics of communica-
tion is an important factor to consider for generation.
Acknowledgements This work was supported by
the National Science Foundation through a Gradu-
ate Research Fellowship to the first two authors. We
also would like to acknowledge Surya Murali, the
designer of the 3D Google Sketchup models, and
thank the anonymous reviewers for their comments.
References
J. L. Austin. 1962. How to do Things with Words: The
William James Lectures delivered at Harvard Univer-
418
sity in 1955. Oxford, Clarendon, UK.
S. Branavan, H. Chen, L. S. Zettlemoyer, and R. Barzilay.
2009. Reinforcement learning for mapping instruc-
tions to actions. In Association for Computational Lin-
guistics and International Joint Conference on Natural
Language Processing (ACL-IJCNLP), Singapore. As-
sociation for Computational Linguistics.
D. L. Chen and R. J. Mooney. 2008. Learning to
sportscast: A test of grounded language acquisition.
In International Conference on Machine Learning
(ICML), pages 128?135. Omnipress.
David DeVault and Matthew Stone. 2007. Managing
ambiguities across utterances in dialogue.
J. Eisenstein, J. Clarke, D. Goldwasser, and D. Roth.
2009. Reading to learn: Constructing features from
semantic abstracts. In Empirical Methods in Natural
Language Processing (EMNLP), Singapore.
J. Feldman and S. Narayanan. 2004. Embodied meaning
in a neural theory of language. Brain and Language,
89:385?392.
M. Fleischman and D. Roy. 2007. Representing inten-
tions in a cognitive model of language acquisition: Ef-
fects of phrase structure on situated verb learning. In
Association for the Advancement of Artificial Intelli-
gence (AAAI), Cambridge, MA. MIT Press.
M. C. Frank, N. D. Goodman, and J. B. Tenenbaum.
2009. Using speakers? referential intentions to model
early cross-situational word learning. Psychological
Science, 20(5):578?585.
Peter Gorniak and Deb Roy. 2004. Grounded semantic
composition for visual scenes. In Journal of Artificial
Intelligence Research, volume 21, pages 429?470.
H. P. Grice. 1975. Syntax and Semantics; Logic and
Conversation. 3:Speech Acts:41?58.
G. Hinton. 1999. Products of experts. In International
Conference on Artificial Neural Networks (ICANN).
G. Ja?ger. 2008. Game theory in semantics and pragmat-
ics. Technical report, University of Tu?bingen.
T. Kollar, S. Tellex, D. Roy, and N. Roy. 2010. Toward
understanding natural language directions. In Human-
Robot Interaction, pages 259?266.
Barbara Landau and Ray Jackendoff. 1993. ?what?
and ?where? in spatial language and spatial cognition.
Behavioral and Brain Sciences, 16(2spatial preposi-
tions analysis, cross linguistic conceptual similarities;
comments/response):217?238.
P. Liang, M. I. Jordan, and D. Klein. 2009. Learning se-
mantic correspondences with less supervision. In As-
sociation for Computational Linguistics and Interna-
tional Joint Conference on Natural Language Process-
ing (ACL-IJCNLP), Singapore. Association for Com-
putational Linguistics.
S. T. Piantadosi, N. D. Goodman, B. A. Ellis, and J. B.
Tenenbaum. 2008. A Bayesian model of the acquisi-
tion of compositional semantics. In Proceedings of the
Thirtieth Annual Conference of the Cognitive Science
Society.
T Regier and LA Carlson. 2001. Journal of experimen-
tal psychology. general; grounding spatial language in
perception: an empirical and computational investiga-
tion. 130(2):273?298.
Stefanie Tellex and Deb Roy. 2009. Grounding spatial
prepositions for video search. In ICMI.
Y. W. Wong and R. J. Mooney. 2007. Learning syn-
chronous grammars for semantic parsing with lambda
calculus. In Association for Computational Linguis-
tics (ACL), pages 960?967, Prague, Czech Republic.
Association for Computational Linguistics.
C. Yu and D. H. Ballard. 2004. On the integration of
grounding language and learning objects. In Asso-
ciation for the Advancement of Artificial Intelligence
(AAAI), pages 488?493, Cambridge, MA. MIT Press.
L. S. Zettlemoyer and M. Collins. 2005. Learning to
map sentences to logical form: Structured classifica-
tion with probabilistic categorial grammars. In Uncer-
tainty in Artificial Intelligence (UAI), pages 658?666.
419
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 17?22,
Jeju, Republic of Korea, 8-14 July 2012. c?2012 Association for Computational Linguistics
A Feature-Rich Constituent Context Model for Grammar Induction
Dave Golland
University of California, Berkeley
dsg@cs.berkeley.edu
John DeNero
Google
denero@google.com
Jakob Uszkoreit
Google
uszkoreit@google.com
Abstract
We present LLCCM, a log-linear variant of the
constituent context model (CCM) of grammar
induction. LLCCM retains the simplicity of
the original CCM but extends robustly to long
sentences. On sentences of up to length 40,
LLCCM outperforms CCM by 13.9% brack-
eting F1 and outperforms a right-branching
baseline in regimes where CCM does not.
1 Introduction
Unsupervised grammar induction is a fundamental
challenge of statistical natural language processing
(Lari and Young, 1990; Pereira and Schabes, 1992;
Carroll and Charniak, 1992). The constituent con-
text model (CCM) for inducing constituency parses
(Klein and Manning, 2002) was the first unsuper-
vised approach to surpass a right-branching base-
line. However, the CCM only effectively models
short sentences. This paper shows that a simple re-
parameterization of the model, which ties together
the probabilities of related events, allows the CCM
to extend robustly to long sentences.
Much recent research has explored dependency
grammar induction. For instance, the dependency
model with valence (DMV) of Klein and Manning
(2004) has been extended to utilize multilingual in-
formation (Berg-Kirkpatrick and Klein, 2010; Co-
hen et al, 2011), lexical information (Headden III et
al., 2009), and linguistic universals (Naseem et al,
2010). Nevertheless, simplistic dependency models
like the DMV do not contain information present in
a constituency parse, such as the attachment order of
object and subject to a verb.
Unsupervised constituency parsing is also an ac-
tive research area. Several studies (Seginer, 2007;
Reichart and Rappoport, 2010; Ponvert et al, 2011)
have considered the problem of inducing parses
over raw lexical items rather than part-of-speech
(POS) tags. Additional advances have come from
more complex models, such as combining CCM
and DMV (Klein and Manning, 2004) and model-
ing large tree fragments (Bod, 2006).
The CCM scores each parse as a product of prob-
abilities of span and context subsequences. It was
originally evaluated only on unpunctuated sentences
up to length 10 (Klein and Manning, 2002), which
account for only 15% of the WSJ corpus; our exper-
iments confirm the observation in (Klein, 2005) that
performance degrades dramatically on longer sen-
tences. This problem is unsurprising: CCM scores
each constituent type by a single, isolated multino-
mial parameter.
Our work leverages the idea that sharing infor-
mation between local probabilities in a structured
unsupervised model can lead to substantial accu-
racy gains, previously demonstrated for dependency
grammar induction (Cohen and Smith, 2009; Berg-
Kirkpatrick et al, 2010). Our model, Log-Linear
CCM (LLCCM), shares information between the
probabilities of related constituents by expressing
them as a log-linear combination of features trained
using the gradient-based learning procedure of Berg-
Kirkpatrick et al (2010). In this way, the probabil-
ity of generating a constituent is informed by related
constituents.
Our model improves unsupervised constituency
parsing of sentences longer than 10 words. On sen-
tences of up to length 40 (96% of all sentences in
the Penn Treebank), LLCCM outperforms CCM by
13.9% (unlabeled) bracketing F1 and, unlike CCM,
outperforms a right-branching baseline on sentences
longer than 15 words.
17
2 Model
The CCM is a generative model for the unsuper-
vised induction of binary constituency parses over
sequences of part-of-speech (POS) tags (Klein and
Manning, 2002). Conditioned on the constituency or
distituency of each span in the parse, CCM generates
both the complete sequence of terminals it contains
and the terminals in the surrounding context.
Formally, the CCM is a probabilistic model that
jointly generates a sentence, s, and a bracketing,
B, specifying whether each contiguous subsequence
is a constituent or not, in which case the span is
called a distituent. Each subsequence of POS tags,
or SPAN, ?, occurs in a CONTEXT, ?, which is an
ordered pair of preceding and following tags. A
bracketing is a boolean matrix B, indicating which
spans (i, j) are constituents (Bij = true) and which
are distituents (Bij = false). A bracketing is con-
sidered legal if its constituents are nested and form a
binary tree T (B).
The joint distribution is given by:
P(s,B) = PT (B) ?
?
i,j?T (B)
PS (?(i, j, s)|true) PC (?(i, j, s)|true) ?
?
i,j 6?T (B)
PS (?(i, j, s)|false) PC (?(i, j, s)|false)
The prior over unobserved bracketings PT (B) is
fixed to be the uniform distribution over all legal
bracketings. The other distributions, PS (?) and
PC (?), are multinomials whose isolated parameters
are estimated to maximize the likelihood of a set of
observed sentences {sn} using EM (Dempster et al,
1977).1
2.1 The Log-Linear CCM
A fundamental limitation of the CCM is that it con-
tains a single isolated parameter for every span. The
number of different possible span types increases ex-
ponentially in span length, leading to data sparsity as
the sentence length increases.
1As mentioned in (Klein and Manning, 2002), the CCM
model is deficient because it assigns probability mass to yields
and spans that cannot consistently combine to form a valid sen-
tence. Our model does not address this issue, and hence it is
similarly deficient.
The Log-Linear CCM (LLCCM) reparameterizes
the distributions in the CCM using intuitive features
to address the limitations of CCM while retaining
its predictive power. The set of proposed features
includes a BASIC feature for each parameter of the
original CCM, enabling the LLCCM to retain the
full expressive power of the CCM. In addition, LL-
CCM contains a set of coarse features that activate
across distinct spans.
To introduce features into the CCM, we express
each of its local conditional distributions as a multi-
class logistic regression model. Each local distri-
bution, Pt(y|x) for t ? {SPAN,CONTEXT}, condi-
tions on label x ? {true, false} and generates an
event (span or context) y. We can define each lo-
cal distribution in terms of a weight vector, w, and
feature vector, fxyt, using a log-linear model:
Pt(y|x) =
exp ?w, fxyt?
?
y? exp
?
w, fxy?t
? (1)
This technique for parameter transformation was
shown to be effective in unsupervised models for
part-of-speech induction, dependency grammar in-
duction, word alignment, and word segmentation
(Berg-Kirkpatrick et al, 2010). In our case, replac-
ing multinomials via featurized models not only im-
proves model accuracy, but also lets the model apply
effectively to a new regime of long sentences.
2.2 Feature Templates
In the SPAN model, for each span y = [?1, . . . , ?n]
and label x, we use the following feature templates:
BASIC: I [y = ? ? x = ?]
BOUNDARY: I [?1 = ? ? ?n = ? ? x = ?]
PREFIX: I [?1 = ? ? x = ?]
SUFFIX: I [?n = ? ? x = ?]
Just as the external CONTEXT is a signal of con-
stituency, so too is the internal ?context.? For exam-
ple, there are many distinct noun phrases with differ-
ent spans that all begin with DT and end with NN; a
fact expressed by the BOUNDARY feature (Table 1).
In the CONTEXT model, for each context y =
[?1, ?2] and constituent/distituent decision x, we use
the following feature templates:
BASIC: I [y = ? ? x = ?]
L-CONTEXT: I [?1 = ? ? x = ?]
R-CONTEXT: I [?2 = ? ? x = ?]
18
Consider the following example extracted from
the WSJ:
0 The 1
DT
Venezuelan 2
JJ
currency 3
NN
NP-SBJ
plummeted 4
VBD
this 5
DT
year 6
NN
NP-TMP
VP
S
Both spans (0, 3) and (4, 6) are constituents corre-
sponding to noun phrases whose features are shown
in Table 1:
Feature Name (0,3) (4, 6)
sp
an
BASIC-DT-JJ-NN: 1 0
BASIC-DT-NN: 0 1
BOUNDARY-DT-NN: 1 1
PREFIX-DT: 1 1
SUFFIX-NN: 1 1
co
nt
ex
t
BASIC--VBD: 1 0
BASIC-VBD-: 0 1
L-CONTEXT-: 1 0
L-CONTEXT-VBD: 0 1
R-CONTEXT-VBD: 1 0
R-CONTEXT-: 0 1
Table 1: Span and context features for constituent spans (0, 3)
and (4, 6). The symbol  indicates a sentence boundary.
Notice that although the BASIC span features are
active for at most one span, the remaining features
fire for both spans, effectively sharing information
between the local probabilities of these events.
The coarser CONTEXT features factor the context
pair into its components, which allow the LLCCM
to more easily learn, for example, that a constituent
is unlikely to immediately follow a determiner.
3 Training
In the EM algorithm for estimating CCM parame-
ters, the E-Step computes posteriors over bracket-
ings using the Inside-Outside algorithm. The M-
Step chooses parameters that maximize the expected
complete log likelihood of the data.
The weights, w, of LLCCM are estimated to max-
imize the data log likelihood of the training sen-
tences {sn}, summing out all possible bracketings
B for each sentence:
L(w) =
?
sn
log
?
B
Pw(sn, B)
We optimize this objective via L-BFGS (Liu and
Nocedal, 1989), which requires us to compute the
objective gradient. Berg-Kirkpatrick et al (2010)
showed that the data log likelihood gradient is equiv-
alent to the gradient of the expected complete log
likelihood (the objective maximized in the M-step of
EM) at the point from which expectations are com-
puted. This gradient can be computed in three steps.
First, we compute the local probabilities of the
CCM, Pt(y|x), from the current w using Equa-
tion (1). We approximate the normalization over an
exponential number of terms by only summing over
spans that appeared in the training corpus.
Second, we compute posteriors over bracketings,
P(i, j|sn), just as in the E-step of CCM training,2 in
order to determine the expected counts:
exy,SPAN =
?
sn
?
ij
I [?(i, j, sn) = y] ?(x)
exy,CONTEXT =
?
sn
?
ij
I [?(i, j, sn) = y] ?(x)
where ?(true) = P(i, j|sn), and ?(false) = 1 ?
?(true).
We summarize these expected count quantities as:
exyt =
{
exy,SPAN if t = SPAN
exy,CONTEXT if t = CONTEXT
Finally, we compute the gradient with respect to
w, expressed in terms of these expected counts and
conditional probabilities:
?L(w) =
?
xyt
exytfxyt ?G(w)
G(w) =
?
xt
(
?
y
exyt
)
?
y?
Pt(y|x)fxy?t
Following (Klein and Manning, 2002), we initialize
the model weights by optimizing against posterior
probabilities fixed to the split-uniform distribution,
which generates binary trees by randomly choosing
a split point and recursing on each side of the split.3
2We follow the dynamic program presented in Appendix A.1
of (Klein, 2005).
3In Appendix B.2, Klein (2005) shows this posterior can be
expressed in closed form. As in previous work, we start the ini-
tialization optimization with the zero vector, and terminate after
10 iterations to regularize against achieving a local maximum.
19
3.1 Efficiently Computing the Gradient
The following quantity appears in G(w):
?t(x) =
?
y
exyt
Which expands as follows depending on t:
?SPAN(x) =
?
y
?
sn
?
ij
I [?(i, j, sn) = y] ?(x)
?CONTEXT(x) =
?
y
?
sn
?
ij
I [?(i, j, sn) = y] ?(x)
In each of these expressions, the ?(x) term can
be factored outside the sum over y. Each fixed
(i, j) and sn pair has exactly one span and con-
text, hence the quantities
?
y I [?(i, j, sn) = y] and?
y I [?(i, j, sn) = y] are both equal to 1.
?t(x) =
?
sn
?
ij
?(x)
This expression further simplifies to a constant.
The sum of the posterior probabilities, ?(true), over
all positions is equal to the total number of con-
stituents in the tree. Any binary tree over N ter-
minals contains exactly 2N ? 1 constituents and
1
2(N ? 2)(N ? 1) distituents.
?t(x) =
{?
sn (2|sn| ? 1) if x = true
1
2
?
sn(|sn| ? 2)(|sn| ? 1) if x = false
where |sn| denotes the length of sentence sn.
Thus, G(w) can be precomputed once for the en-
tire dataset at each minimization step. Moreover,
?t(x) can be precomputed once before all iterations.
3.2 Relationship to Smoothing
The original CCM uses additive smoothing in its M-
step to capture the fact that distituents outnumber
constituents. For each span or context, CCM adds
10 counts: 2 as a constituent and 8 as a distituent.4
We note that these smoothing parameters are tai-
lored to short sentences: in a binary tree, the number
of constituents grows linearly with sentence length,
whereas the number of distituents grows quadrati-
cally. Therefore, the ratio of constituents to dis-
tituents is not constant across sentence lengths. In
contrast, by virtue of the log-linear model, LLCCM
assigns positive probability to all spans or contexts
without explicit smoothing.
4These counts are specified in (Klein, 2005); Klein and
Manning (2002) added 10 constituent and 50 distituent counts.
Length
Baseline 
CCM
LLCCM Right 
branching
Upper 
bound
Initialization
10
15
20
25
30
35
40
71.9 72.0 61.7 88.1 49.8
53.0 64.6 53.1 86.8 39.8
46.6 60.0 48.2 86.3 34.2
42.7 56.2 44.9 85.9 30.6
39.9 50.3 42.6 85.7 28.5
37.5 49.2 41.3 85.6 27.3
33.7 47.6 40.5 85.5 26.8
0
25
50
75
100
10 15 20 25 30 35 40
72.0
64.6
60.0
56.2
50.3
49.2
47.6
71.9
53.0
46.6
42.7
39.9
37.5
33.7
Binary branching upper bound
Log-linear CCM
Standard CCM
Right branching
Maximum sentence length
B
r
a
c
k
e
t
i
n
g
 
F
1
Figure 1: CCM and LLCCM trained and tested on sentences of
a fixed length. LLCCM performs well on longer sentences. The
binary branching upper bound correponds to UBOUND from
(Klein and Manning, 2002).
4 Experiments
We train our models on gold POS sequences from
all sections (0-24) of the WSJ (Marcus et al, 1993)
with punctuation removed. We report bracketing
F1 scores between the binary trees predicted by the
models on these sequences and the treebank parses.
We train and evaluate both a CCM implementa-
tion (Luque, 2011) and our LLCCM on sentences up
to a fixed length n, for n ? {10, 15, . . . , 40}. Fig-
ure 1 shows that LLCCM substantially outperforms
the CCM on longer sentences. After length 15,
CCM accuracy falls below the right branching base-
line, whereas LLCCM remains significantly better
than right-branching through length 40.
5 Conclusion
Our log-linear variant of the CCM extends robustly
to long sentences, enabling constituent grammar in-
duction to be used in settings that typically include
long sentences, such as machine translation reorder-
ing (Chiang, 2005; DeNero and Uszkoreit, 2011;
Dyer et al, 2011).
Acknowledgments
We thank Taylor Berg-Kirkpatrick and Dan Klein
for helpful discussions regarding the work on which
this paper is based. This work was partially sup-
ported by the National Science Foundation through
a Graduate Research Fellowship to the first author.
20
References
Taylor Berg-Kirkpatrick and Dan Klein. 2010. Phyloge-
netic grammar induction. In Proceedings of the 48th
Annual Meeting of the Association for Computational
Linguistics, pages 1288?1297, Uppsala, Sweden, July.
Association for Computational Linguistics.
Taylor Berg-Kirkpatrick, Alexandre Bouchard-Co?te?,
John DeNero, and Dan Klein. 2010. Painless unsu-
pervised learning with features. In Human Language
Technologies: The 2010 Annual Conference of the
North American Chapter of the Association for Com-
putational Linguistics, pages 582?590, Los Angeles,
California, June. Association for Computational Lin-
guistics.
Rens Bod. 2006. Unsupervised parsing with U-DOP.
In Proceedings of the Conference on Computational
Natural Language Learning.
Glenn Carroll and Eugene Charniak. 1992. Two experi-
ments on learning probabilistic dependency grammars
from corpora. In Workshop Notes for Statistically-
Based NLP Techniques, AAAI, pages 1?13.
David Chiang. 2005. A hierarchical phrase-based model
for statistical machine translation. In Proceedings of
the 43rd Annual Meeting of the Association for Com-
putational Linguistics, pages 263?270, Ann Arbor,
Michigan, June. Association for Computational Lin-
guistics.
Shay B. Cohen and Noah A. Smith. 2009. Shared logis-
tic normal distributions for soft parameter tying in un-
supervised grammar induction. In Proceedings of Hu-
man Language Technologies: The 2009 Annual Con-
ference of the North American Chapter of the Asso-
ciation for Computational Linguistics, pages 74?82,
Boulder, Colorado, June. Association for Computa-
tional Linguistics.
Shay B. Cohen, Dipanjan Das, and Noah A. Smith. 2011.
Unsupervised structure prediction with non-parallel
multilingual guidance. In Proceedings of the 2011
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 50?61, Edinburgh, Scotland,
UK., July. Association for Computational Linguistics.
Arthur Dempster, Nan Laird, and Donald Rubin. 1977.
Maximum likelihood from incomplete data via the EM
algorithm. Journal of the Royal Statistical Society. Se-
ries B (Methodological), 39(1):1?38.
John DeNero and Jakob Uszkoreit. 2011. Inducing sen-
tence structure from parallel corpora for reordering.
In Proceedings of the 2011 Conference on Empirical
Methods in Natural Language Processing, pages 193?
203, Edinburgh, Scotland, UK., July. Association for
Computational Linguistics.
Chris Dyer, Kevin Gimpel, Jonathan H. Clark, and
Noah A. Smith. 2011. The CMU-ARK German-
English translation system. In Proceedings of the Sixth
Workshop on Statistical Machine Translation, pages
337?343, Edinburgh, Scotland, July. Association for
Computational Linguistics.
William P. Headden III, Mark Johnson, and David Mc-
Closky. 2009. Improving unsupervised dependency
parsing with richer contexts and smoothing. In Pro-
ceedings of Human Language Technologies: The 2009
Annual Conference of the North American Chapter of
the Association for Computational Linguistics, pages
101?109, Boulder, Colorado, June. Association for
Computational Linguistics.
Dan Klein and Christopher D. Manning. 2002. A gener-
ative constituent-context model for improved grammar
induction. In Proceedings of 40th Annual Meeting of
the Association for Computational Linguistics, pages
128?135, Philadelphia, Pennsylvania, USA, July. As-
sociation for Computational Linguistics.
Dan Klein and Christopher D. Manning. 2004. Corpus-
based induction of syntactic structure: Models of de-
pendency and constituency. In Proceedings of the
42nd Meeting of the Association for Computational
Linguistics, Main Volume, pages 478?485, Barcelona,
Spain, July.
Dan Klein. 2005. The Unsupervised Learning of Natural
Language Structure. Ph.D. thesis.
Karim Lari and Steve J. Young. 1990. The estimation
of stochastic context-free grammars using the inside-
outside algorithm. Computer Speech and Language,
4:35?56.
Dong C. Liu and Jorge Nocedal. 1989. On the limited
memory method for large scale optimization. Mathe-
matical Programming B, 45(3):503?528.
Franco Luque. 2011. Una implementacio?n del mod-
elo DMV+CCM para parsing no supervisado. In 2do
Workshop Argentino en Procesamiento de Lenguaje
Natural.
Mitchell P. Marcus, Beatrice Santorini, and Mary A.
Marcinkiewicz. 1993. Building a Large Annotated
Corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313?330.
Tahira Naseem and Regina Barzilay. 2011. Using se-
mantic cues to learn syntax. In AAAI.
Tahira Naseem, Harr Chen, Regina Barzilay, and Mark
Johnson. 2010. Using universal linguistic knowl-
edge to guide grammar induction. In Proceedings of
the 2010 Conference on Empirical Methods in Natural
Language Processing, pages 1234?1244, Cambridge,
MA, October. Association for Computational Linguis-
tics.
Fernando Pereira and Yves Schabes. 1992. Inside-
outside reestimation from partially bracketed corpora.
21
In Proceedings of the 30th Annual Meeting of the As-
sociation for Computational Linguistics, pages 128?
135, Newark, Delaware, USA, June. Association for
Computational Linguistics.
Elias Ponvert, Jason Baldridge, and Katrin Erk. 2011.
Simple unsupervised grammar induction from raw text
with cascaded finite state models. In Proceedings of
the 49th Annual Meeting of the Association for Com-
putational Linguistics: Human Language Technolo-
gies, pages 1077?1086, Portland, Oregon, USA, June.
Association for Computational Linguistics.
Roi Reichart and Ari Rappoport. 2010. Improved fully
unsupervised parsing with zoomed learning. In Pro-
ceedings of the 2010 Conference on Empirical Meth-
ods in Natural Language Processing, pages 684?693,
Cambridge, MA, October. Association for Computa-
tional Linguistics.
Yoav Seginer. 2007. Fast unsupervised incremental pars-
ing. In Proceedings of the 45th Annual Meeting of the
Association of Computational Linguistics, pages 384?
391, Prague, Czech Republic, June. Association for
Computational Linguistics.
22
