Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 160?167,
Prague, Czech Republic, June 2007. c?2007 Association for Computational Linguistics
Mildly Context-Sensitive Dependency Languages
Marco Kuhlmann
Programming Systems Lab
Saarland University
Saarbr?cken, Germany
kuhlmann@ps.uni-sb.de
Mathias M?hl
Programming Systems Lab
Saarland University
Saarbr?cken, Germany
mmohl@ps.uni-sb.de
Abstract
Dependency-based representations of natu-
ral language syntax require a fine balance
between structural flexibility and computa-
tional complexity. In previous work, several
constraints have been proposed to identify
classes of dependency structures that are well-
balanced in this sense; the best-known but
also most restrictive of these is projectivity.
Most constraints are formulated on fully spec-
ified structures, which makes them hard to in-
tegrate into models where structures are com-
posed from lexical information. In this paper,
we show how two empirically relevant relax-
ations of projectivity can be lexicalized, and
how combining the resulting lexicons with a
regular means of syntactic composition gives
rise to a hierarchy of mildly context-sensitive
dependency languages.
1 Introduction
Syntactic representations based on word-to-word de-
pendencies have a long tradition in descriptive lin-
guistics. Lately, they have also been used in many
computational tasks, such as relation extraction (Cu-
lotta and Sorensen, 2004), parsing (McDonald et al,
2005), and machine translation (Quirk et al, 2005).
Especially in recent work on parsing, there is a par-
ticular interest in non-projective dependency struc-
tures, in which a word and its dependents may be
spread out over a discontinuous region of the sen-
tence. These structures naturally arise in the syntactic
analysis of languages with flexible word order, such
as Czech (Vesel? et al, 2004). Unfortunately, most
formal results on non-projectivity are discouraging:
While grammar-driven dependency parsers that are
restricted to projective structures can be as efficient
as parsers for lexicalized context-free grammar (Eis-
ner and Satta, 1999), parsing is prohibitively expen-
sive when unrestricted forms of non-projectivity are
permitted (Neuhaus and Br?ker, 1997). Data-driven
dependency parsing with non-projective structures is
quadratic when all attachment decisions are assumed
to be independent of one another (McDonald et al,
2005), but becomes intractable when this assumption
is abandoned (McDonald and Pereira, 2006).
In search of a balance between structural flexibility
and computational complexity, several authors have
proposed constraints to identify classes of non-projec-
tive dependency structures that are computationally
well-behaved (Bodirsky et al, 2005; Nivre, 2006).
In this paper, we focus on two of these proposals:
the gap-degree restriction, which puts a bound on
the number of discontinuities in the region of a sen-
tence covered by a word and its dependents, and the
well-nestedness condition, which constrains the ar-
rangement of dependency subtrees. Both constraints
have been shown to be in very good fit with data from
dependency treebanks (Kuhlmann and Nivre, 2006).
However, like all other such proposals, they are for-
mulated on fully specified structures, which makes it
hard to integrate them into a generative model, where
dependency structures are composed from elemen-
tary units of lexicalized information. Consequently,
little is known about the generative capacity and com-
putational complexity of languages over restricted
non-projective dependency structures.
160
Contents of the paper In this paper, we show how
the gap-degree restriction and the well-nestedness
condition can be captured in dependency lexicons,
and how combining such lexicons with a regular
means of syntactic composition gives rise to an infi-
nite hierarchy of mildly context-sensitive languages.
The technical key to these results is a procedure
to encode arbitrary, even non-projective dependency
structures into trees (terms) over a signature of local
order-annotations. The constructors of these trees
can be read as lexical entries, and both the gap-de-
gree restriction and the well-nestedness condition
can be couched as syntactic properties of these en-
tries. Sets of gap-restricted dependency structures
can be described using regular tree grammars. This
gives rise to a notion of regular dependency lan-
guages, and allows us to establish a formal relation
between the structural constraints and mildly con-
text-sensitive grammar formalisms (Joshi, 1985): We
show that regular dependency languages correspond
to the sets of derivations of lexicalized Linear Con-
text-Free Rewriting Systems (lcfrs) (Vijay-Shanker
et al, 1987), and that the gap-degree measure is the
structural correspondent of the concept of ?fan-out?
in this formalism (Satta, 1992). We also show that
adding the well-nestedness condition corresponds
to the restriction of lcfrs to Coupled Context-Free
Grammars (Hotz and Pitsch, 1996), and that regu-
lar sets of well-nested structures with a gap-degree
of at most 1 are exactly the class of sets of deriva-
tions of Lexicalized Tree Adjoining Grammar (ltag).
This result generalizes previous work on the relation
between ltag and dependency representations (Ram-
bow and Joshi, 1997; Bodirsky et al, 2005).
Structure of the paper The remainder of this pa-
per is structured as follows. Section 2 contains some
basic notions related to trees and dependency struc-
tures. In Section 3 we present the encoding of depen-
dency structures as order-annotated trees, and show
how this encoding allows us to give a lexicalized re-
formulation of both the gap-degree restriction and the
well-nestedness condition. Section 4 introduces the
notion of regular dependency languages. In Section 5
we show how different combinations of restrictions
on non-projectivity in these languages correspond
to different mildly context-sensitive grammar for-
malisms. Section 6 concludes the paper.
2 Preliminaries
Throughout the paper, we write ?n? for the set of all
positive natural numbers up to and including n. The
set of all strings over a set A is denoted by A, the
empty string is denoted by ", and the concatenation
of two strings x and y is denoted either by xy, or,
where this is ambiguous, by x  y.
2.1 Trees
In this paper, we regard trees as terms. We expect the
reader to be familiar with the basic concepts related
to this framework, and only introduce our particular
notation. Let ? be a set of labels. The set of (finite,
unranked) trees over ? is defined recursively by the
equation T? ? f .x/ j  2 ?; x 2 T ? g. The set
of nodes of a tree t 2 T? is defined as
N..t1    tn//? f"g [ f iu j i 2 ?n?; u 2 N.ti / g :
For two nodes u; v 2 N.t/, we say that u governs v,
and write u E v, if v can be written as v D ux, for
some sequence x 2 N. Note that the governance
relation is both reflexive and transitive. The converse
of government is called dependency, so u E v can
also be read as ?v depends on u?. The yield of a
node u 2 N.t/, buc, is the set of all dependents of u
in t : buc ? f v 2 N.t/ j u E v g. We also use the
notations t .u/ for the label at the node u of t , and
t=u for the subtree of t rooted at u. A tree language
over ? is a subset of T? .
2.2 Dependency structures
For the purposes of this paper, a dependency structure
over ? is a pair d D .t; x/, where t 2 T? is a tree,
and x is a list of the nodes in t . We write D? to
refer to the set of all dependency structures over ? .
Independently of the governance relation in d , the
list x defines a total order on the nodes in t ; we
write u  v to denote that u precedes v in this order.
Note that, like governance, the precedence relation is
both reflexive and transitive. A dependency language
over ? is a subset of D? .
Example. The left half of Figure 1 shows how we
visualize dependency structures: circles represent
nodes, arrows represent the relation of (immediate)
governance, the left-to-right order of the nodes repre-
sents their order in the precedence relation, and the
dotted lines indicate the labelling. 
161
a b c d e f
2
11
1
1
hf; 0i
he; 01i
ha; 012i
hc ; 0i
hd ; 10i
hb ; 01i
Figure 1: A projective dependency structure
3 Lexicalizing the precedence relation
In this section, we show how the precedence relation
of dependency structures can be encoded as, and
decoded from, a collection of node-specific order
annotations. Under the assumption that the nodes of
a dependency structure correspond to lexemic units,
this result demonstrates how word-order information
can be captured in a dependency lexicon.
3.1 Projective structures
Lexicalizing the precedence relation of a dependency
structure is particularly easy if the structure under
consideration meets the condition of projectivity. A
dependency structure is projective, if each of its
yields forms an interval with respect to the prece-
dence order (Kuhlmann and Nivre, 2006).
In a projective structure, the interval that corre-
sponds to a yield buc decomposes into the singleton
interval ?u; u?, and the collection of the intervals that
correspond to the yields of the immediate dependents
of u. To reconstruct the global precedence relation,
it suffices to annotate each node u with the relative
precedences among the constituent parts of its yield.
We represent this ?local? order as a string over the
alphabet N0, where the symbol 0 represents the sin-
gleton interval ?u; u?, and a symbol i ? 0 represents
the interval that corresponds to the yield of the i th
direct dependent of u. An order-annotated tree is a
tree labelled with pairs h; !i, where  is the label
proper, and ! is a local order annotation. In what
follows, we will use the functional notations .u/
and !.u/ to refer to the label and order annotation
of u, respectively.
Example. Figure 1 shows a projective dependency
structure together with its representation as an order-
annotated tree. 
We now present procedures for encoding projec-
tive dependency structures into order-annotated trees,
and for reversing this encoding.
Encoding The representation of a projective depen-
dency structure .t; x/ as an order-annotated tree can
be computed in a single left-to-right sweep over x.
Starting with a copy of the tree t in which every
node is annotated with the empty string, for each new
node u in x, we update the order annotation of u
through the assignment !.u/? !.u/ 0 . If u D vi
for some i 2 N (that is, if u is an inner node), we
also update the order annotation of the parent v of u
through the assignment !.v/? !.v/  i .
Decoding To decode an order-annotated tree t , we
first linearize the nodes of t into a sequence x, and
then remove all order annotations. Linearization pro-
ceeds in a way that is very close to a pre-order traver-
sal of the tree, except that the relative position of
the root node of a subtree is explicitly specified in
the order annotation. Specifically, to linearize an or-
der-annotated tree, we look into the local order !.u/
annotated at the root node of the tree, and concatenate
the linearizations of its constituent parts. A symbol i
in !.u/ represents either the singleton interval ?u; u?
(i D 0), or the interval corresponding to some direct
dependent ui of u (i ? 0), in which case we pro-
ceed recursively. Formally, the linearization of u is
captured by the following three equations:
lin.u/ D lin0.u; !.u//
lin0.u; i1    in/ D lin00.u; i1/    lin00.u; in/
lin00.u; i/ D if i D 0 then u else lin.ui/
Both encoding and decoding can be done in time
linear in the number of nodes of the dependency
structure or order-annotated tree.
3.2 Non-projective structures
It is straightforward to see that our representation of
dependency structures is insufficient if the structures
under consideration are non-projective. To witness,
consider the structure shown in Figure 2. Encoding
this structure using the procedure presented above
yields the same order-annotated tree as the one shown
in Figure 1, which demonstrates that the encoding is
not reversible.
162
a b c de f
1
2
1
1
1
ha; h01212ii
hc; h0ii
he; h0; 1ii
hf ; h0ii
hb ; h01; 1ii
hd ; h1; 0ii
Figure 2: A non-projective dependency structure
Blocks In a non-projective dependency structure,
the yield of a node may be spread out over more than
one interval; we will refer to these intervals as blocks.
Two nodes v;w belong to the same block of a node u,
if all nodes between v and w are governed by u.
Example. Consider the nodes b; c; d in the struc-
tures depicted in Figures 1 and 2. In Figure 1, these
nodes belong to the same block of b. In Figure 2,
the three nodes are spread out over two blocks of b
(marked by the boxes): c and d are separated by a
node (e) not governed by b. 
Blocks have a recursive structure that is closely re-
lated to the recursive structure of yields: the blocks of
a node u can be decomposed into the singleton ?u; u?,
and the blocks of the direct dependents of u. Just as
a projective dependency structure can be represented
by annotating each yield with an order on its con-
stituents, an unrestricted structure can be represented
by annotating each block.
Extended order annotations To represent orders
on blocks, we extend our annotation scheme as fol-
lows. First, instead of a single string, an annotation
!.u/ now is a tuple of strings, where the kth com-
ponent specifies the order among the constituents of
the kth block of u. Second, instead of one, the an-
notation may now contain multiple occurrences of
the same dependent; the kth occurrence of i in !.u/
represents the kth block of the node ui .
We write !.u/k to refer to the kth component of
the order annotation of u. We also use the notation
.i#k/u to refer to the kth occurrence of i in !.u/,
and omit the subscript when the node u is implicit.
Example. In the annotated tree shown in Figure 2,
!.b/1 D .0#1/.1#1/, and !.b/2 D .1#2/. 
Encoding To encode a dependency structure .t; x/
as an extended order-annotated tree, we do a post-
order traversal of t as follows. For a given node u, let
us represent a constituent of a block of u as a triple
i W ?vl ; vr ?, where i denotes the node that contributes
the constituent, and vl and vr denote the constituent?s
leftmost and rightmost elements. At each node u, we
have access to the singleton block 0 W ?u; u?, and the
constituent blocks of the immediate dependents of u.
We say that two blocks i W ?vl ; vr ?; j W ?wl ; wr ? can
be merged, if the node vr immediately precedes the
node wl . The result of the merger is a new block ij W
?vl ; wr ? that represents the information that the two
merged constituents belong to the same block of u.
By exhaustive merging, we obtain the constituent
structure of all blocks of u. From this structure, we
can read off the order annotation !.u/.
Example. The yield of the node b in Figure 2 de-
composes into 0 W ?b; b?, 1 W ?c; c?, and 1 W ?d; d ?.
Since b and c are adjacent, the first two of these con-
stituents can be merged into a new block 01 W ?b; c?;
the third constituent remains unchanged. This gives
rise to the order annotation h01; 1i for b. 
When using a global data-structure to keep track
of the constituent blocks, the encoding procedure can
be implemented to run in time linear in the number
of blocks in the dependency structure. In particular,
for projective dependency structures, it still runs in
time linear in the number of nodes.
Decoding To linearize the kth block of a node u,
we look into the kth component of the order anno-
tated at u, and concatenate the linearizations of its
constituent parts. Each occurrence .i#k/ in a com-
ponent of !.u/ represents either the node u itself
(i D 0), or the kth block of some direct dependent ui
of u (i ? 0), in which case we proceed recursively:
lin.u; k/ D lin0.u; !.u/k/
lin0.u; i1    in/ D lin00.u; i1/    lin00.u; in/
lin00.u; .i#k/u/ D if i D 0 then u else lin.ui; k/
The root node of a dependency structure has only
one block. Therefore, to linearize a tree t , we only
need to linearize the first block of the tree?s root node:
lin.t/ D lin."; 1/.
163
Consistent order annotations Every dependency
structure over? can be encoded as a tree over the set
? ?, where ? is the set of all order annotations.
The converse of this statement does not hold: to be
interpretable as a dependency structure, tree structure
and order annotation in an order-annotated tree must
be consistent, in the following sense.
Property C1: Every annotation !.u/ in a tree t
contains all and only the symbols in the collection
f0g [ f i j ui 2 N.t/ g, i.e., one symbol for u, and
one symbol for every direct dependent of u.
Property C2: The number of occurrences of a
symbol i ? 0 in !.u/ is identical to the number of
components in the annotation of the node ui . Further-
more, the number of components in the annotation
of the root node is 1.
With this notion of consistency, we can prove the
following technical result about the relation between
dependency structures and annotated trees. We write
? .s/ for the tree obtained from a tree s 2 T??
by re-labelling every node u with .u/.
Proposition 1. For every dependency structure
.t; x/ over ? , there exists a tree s over ? ? such
that ? .s/ D t and lin.s/ D x. Conversely, for
every consistently order-annotated tree s 2 T?? ,
there exists a uniquely determined dependency struc-
ture .t; x/ with these properties. 
3.3 Local versions of structural constraints
The encoding of dependency structures as order-an-
notated trees allows us to reformulate two constraints
on non-projectivity originally defined on fully speci-
fied dependency structures (Bodirsky et al, 2005) in
terms of syntactic properties of the order annotations
that they induce:
Gap-degree The gap-degree of a dependency
structure is the maximum over the number of dis-
continuities in any yield of that structure.
Example. The structure depicted in Figure 2 has
gap-degree 1: the yield of b has one discontinuity,
marked by the node e, and this is the maximal number
of discontinuities in any yield of the structure. 
Since a discontinuity in a yield is delimited by two
blocks, and since the number of blocks of a node u
equals the number of components in the order anno-
tation of u, the following result is obvious:
Proposition 2. A dependency structure has gap-de-
gree k if and only if the maximal number of compo-
nents among the annotations !.u/ is k C 1. 
In particular, a dependency structure is projective iff
all of its annotations consist of just one component.
Well-nestedness The well-nestedness condition
constrains the arrangement of subtrees in a depen-
dency structure. Two subtrees t=u1; t=u2 interleave,
if there are nodes v1l ; v
1
r 2 t=u1 and v
2
l ; v
2
r 2 t=u2
such that v1l  v
2
l  v
1
r  v
2
r . A dependency struc-
ture is well-nested, if no two of its disjoint subtrees
interleave. We can prove the following result:
Proposition 3. A dependency structure is well-
nested if and only if no annotation !.u/ contains
a substring i    j    i    j , for i; j 2 N. 
Example. The dependency structure in Figure 1 is
well-nested, the structure depicted in Figure 2 is not:
the subtrees rooted at the nodes b and e interleave.
To see this, notice that b  e  d  f . Also notice
that !.a/ contains the substring 1212. 
4 Regular dependency languages
The encoding of dependency structures as order-an-
notated trees gives rise to an encoding of dependency
languages as tree languages. More specifically, de-
pendency languages over a set ? can be encoded
as tree languages over the set ?  ?, where ? is
the set of all order annotations. Via this encoding,
we can study dependency languages using the tools
and results of the well-developed formal theory of
tree languages. In this section, we discuss depen-
dency languages that can be encoded as regular tree
languages.
4.1 Regular tree grammars
The class of regular tree languages, REGT for short,
is a very natural class with many characterizations
(G?cseg and Steinby, 1997): it is generated by regular
tree grammars, recognized by finite tree automata,
and expressible in monadic second-order logic. Here
we use the characterization in terms of grammars.
Regular tree grammars are natural candidates for the
formalization of dependency lexicons, as each rule
in such a grammar can be seen as the specification of
a word and the syntactic categories or grammatical
functions of its immediate dependents.
164
Formally, a (normalized) regular tree grammar is
a construct G D .NG ; ?G ; SG ; PG/, in which NG
and ?G are finite sets of non-terminal and termi-
nal symbols, respectively, SG 2 NG is a dedicated
start symbol, and PG is a finite set of productions
of the form A ! .A1   An/, where  2 ?G ,
A 2 NG , and Ai 2 NG , for every i 2 ?n?. The (di-
rect) derivation relation associated to G is the binary
relation)G on the set T?G[NG defined as follows:
t 2 T?G[NG t=u D A .A! s/ 2 PG
t )G t ?u 7! s?
Informally, each step in a derivation replaces a non-
terminal-labelled leaf by the right-hand side of a
matching production. The tree language generated
by G is the set of all terminal trees that can eventu-
ally be derived from the trivial tree formed by its start
symbol: L.G/ D f t 2 T?G j SG )

G t g.
4.2 Regular dependency grammars
We call a dependency language regular, if its encod-
ing as a set of trees over ? ? forms a regular tree
language, and write REGD for the class of all regular
dependency languages. For every regular dependency
language L, there is a regular tree grammar with ter-
minal alphabet ? ? that generates the encoding
of L. Similar to the situation with individual struc-
tures, the converse of this statement does not hold:
the consistency properties mentioned above impose
corresponding syntactic restrictions on the rules of
grammars G that generate the encoding of L.
Property C10: The !-component of every pro-
ductionA! h; !i.A1   An/ inG contains all and
only symbols in the set f0g [ f i j i 2 ?n? g.
Property C20: For every non-terminal X 2 NG ,
there is a uniquely determined integer dX such that
for every production A ! h; !i.A1   An/ in G,
dAi gives the number of occurrences of i in !, dA
gives the number of components in !, and dSG D 1.
It turns out that these properties are in fact sufficient
to characterize the class of regular tree grammars that
generate encodings of dependency languages. In but
slight abuse of terminology, we will refer to such
grammars as regular dependency grammars.
Example. Figure 3 shows a regular tree grammar
that generates a set of non-projective dependency
structures with string language f anbn j n  1 g. 
a b b baa
B
B
B
S
A
A
S ! ha; h01ii.B/ j ha; h0121ii.A;B/
A ! ha; h0; 1ii.B/ j ha; h01; 21ii.A;B/
B ! hb; h0ii
Figure 3: A grammar for a language in REGD.1/
5 Structural constraints and formal power
In this section, we present our results on the genera-
tive capacity of regular dependency languages, link-
ing them to a large class of mildly context-sensitive
grammar formalisms.
5.1 Gap-restricted dependency languages
A dependency language L is called gap-restricted, if
there is a constant cL  0 such that no structure in L
has a gap-degree higher than cL. It is plain to see that
every regular dependency language is gap-restricted:
the gap-degree of a structure is directly reflected in
the number of components of its order annotations,
and every regular dependency grammar makes use of
only a finite number of these annotations. We write
REGD.k/ to refer to the class of regular dependency
languages with a gap-degree bounded by k.
Linear Context-Free Rewriting Systems Gap-re-
stricted dependency languages are closely related
to Linear Context-Free Rewriting Systems (lcfrs)
(Vijay-Shanker et al, 1987), a class of formal sys-
tems that generalizes several mildly context-sensitive
grammar formalisms. An lcfrs consists of a regular
tree grammar G and an interpretation of the terminal
symbols of this grammar as linear, non-erasing func-
tions into tuples of strings. By these functions, each
tree in L.G/ can be evaluated to a string.
Example. Here is an example for a function:
f .hx11 ; x
2
1i; hx
1
2i/ D hax
1
1 ; x
1
2x
2
1i
This function states that in order to compute the pair
of strings that corresponds to a tree whose root node
is labelled with the symbol f , one first has to com-
pute the pair of strings corresponding to the first child
165
of the root node (hx11 ; x
2
1i) and the single string cor-
responding to the second child (hx12i), and then con-
catenate the individual components in the specified
order, preceded by the terminal symbol a. 
We call a function lexicalized, if it contributes ex-
actly one terminal symbol. In an lcfrs in which all
functions are lexicalized, there is a one-to-one cor-
respondence between the nodes in an evaluated tree
and the positions in the string that the tree evaluates
to. Therefore, tree and string implicitly form a depen-
dency structure, and we can speak of the dependency
language generated by a lexicalized lcfrs.
Equivalence We can prove that every regular de-
pendency grammar can be transformed into a lexi-
calized lcfrs that generates the same dependency
language, and vice versa. The basic insight in this
proof is that every order annotation in a regular de-
pendency grammar can be interpreted as a compact
description of a function in the corresponding lcfrs.
The number of components in the order-annotation,
and hence, the gap-degree of the resulting depen-
dency language, corresponds to the fan-out of the
function: the highest number of components among
the arguments of the function (Satta, 1992).1 A tech-
nical difficulty is caused by the fact that lcfrs can
swap components: f .hx11 ; x
2
1i/ D hax
2
1 ; x
1
1i. This
commutativity needs to be compiled out during the
translation into a regular dependency grammar.
We write LLCFRL.k/ for the class of all depen-
dency languages generated by lexicalized lcfrs with
a fan-out of at most k.
Proposition 4. REGD.k/ D LLCFRL.k C 1/ 
In particular, the class REGD.0/ of regular depen-
dency languages over projective structures is exactly
the class of dependency languages generated by lexi-
calized context-free grammars.
Example. The gap-degree of the language generated
by the grammar in Figure 3 is bounded by 1. The
rules for the non-terminal A can be translated into
the following functions of an equivalent lcfrs:
fha;h0;1ii.hx
1
1i/ D ha; x
1
1i
fha;h01;21ii.hx
1
1 ; x
2
1i; hx
1
2i/ D hax
1
1 ; x
1
2x
2
1i
The fan-out of these functions is 2. 
1More precisely, gap-degree D fan-out   1.
5.2 Well-nested dependency languages
The absence of the substring i    j    i    j in the
order annotations of well-nested dependency struc-
tures corresponds to a restriction to ?well-bracketed?
compositions of sub-structures. This restriction is
central to the formalism of Coupled-Context-Free
Grammar (ccfg) (Hotz and Pitsch, 1996).
It is straightforward to see that every ccfg can
be translated into an equivalent lcfrs. We can also
prove that every lcfrs obtained from a regular depen-
dency grammar with well-nested order annotations
can be translated back into an equivalent ccfg. We
write REGDwn.k/ for the well-nested subclass of
REGD.k/, and LCCFL.k/ for the class of all depen-
dency languages generated by lexicalized ccfgs with
a fan-out of at most k.
Proposition 5. REGDwn.k/ D LCCFL.k C 1/ 
As a special case, Coupled-Context-Free Grammars
with fan-out 2 are equivalent to Tree Adjoining Gram-
mars (tags) (Hotz and Pitsch, 1996). This enables
us to generalize a previous result on the class of de-
pendency structures generated by lexicalized tags
(Bodirsky et al, 2005) to the class of generated de-
pendency languages, LTAL.
Proposition 6. REGDwn.1/ D LTAL 
6 Conclusion
In this paper, we have presented a lexicalized refor-
mulation of two structural constraints on non-pro-
jective dependency representations, and shown that
combining dependency lexicons that satisfy these
constraints with a regular means of syntactic com-
position yields classes of mildly context-sensitive
dependency languages. Our results make a signif-
icant contribution to a better understanding of the
relation between the phenomenon of non-projectivity
and notions of formal power.
The close link between restricted forms of non-
projective dependency languages and mildly context-
sensitive grammar formalisms provides a promising
starting point for future work. On the practical side,
it should allow us to benefit from the experience
in building parsers for mildly context-sensitive for-
malisms when addressing the task of efficient non-
projective dependency parsing, at least in the frame-
166
work of grammar-driven parsing. This may even-
tually lead to a better trade-off between structural
flexibility and computational efficiency than that ob-
tained with current systems. On a more theoretical
level, our results provide a basis for comparing a va-
riety of formally rather distinct grammar formalisms
with respect to the sets of dependency structures that
they can generate. Such a comparison may be empir-
ically more adequate than one based on traditional
notions of generative capacity (Kallmeyer, 2006).
Acknowledgements We thank Guido Tack, Stefan
Thater, and the anonymous reviewers of this paper
for their detailed comments. The work of the authors
is funded by the German Research Foundation.
References
Manuel Bodirsky, Marco Kuhlmann, and Mathias M?hl.
2005. Well-nested drawings as models of syntactic
structure. In Tenth Conference on Formal Grammar
and Ninth Meeting on Mathematics of Language, Edin-
burgh, Scotland, UK.
Aron Culotta and Jeffrey Sorensen. 2004. Dependency
tree kernels for relation extraction. In 42nd Annual
Meeting of the Association for Computational Linguis-
tics (ACL), pages 423?429, Barcelona, Spain.
Jason Eisner and Giorgio Satta. 1999. Efficient parsing
for bilexical context-free grammars and head automa-
ton grammars. In 37th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL), pages
457?464, College Park, Maryland, USA.
Ferenc G?cseg and Magnus Steinby. 1997. Tree lan-
guages. In Grzegorz Rozenberg and Arto Salomaa,
editors, Handbook of Formal Languages, volume 3,
pages 1?68. Springer-Verlag, New York, USA.
G?nter Hotz and Gisela Pitsch. 1996. On parsing coupled-
context-free languages. Theoretical Computer Science,
161:205?233.
Aravind K. Joshi. 1985. Tree adjoining grammars: How
much context-sensitivity is required to provide reason-
able structural descriptions? In David R. Dowty, Lauri
Karttunen, and Arnold M. Zwicky, editors, Natural Lan-
guage Parsing, pages 206?250. Cambridge University
Press, Cambridge, UK.
Laura Kallmeyer. 2006. Comparing lexicalized grammar
formalisms in an empirically adequate way: The notion
of generative attachment capacity. In International
Conference on Linguistic Evidence, pages 154?156,
T?bingen, Germany.
Marco Kuhlmann and Joakim Nivre. 2006. Mildly non-
projective dependency structures. In 21st International
Conference on Computational Linguistics and 44th An-
nual Meeting of the Association for Computational Lin-
guistics (COLING-ACL) Main Conference Poster Ses-
sions, pages 507?514, Sydney, Australia.
Ryan McDonald and Fernando Pereira. 2006. On-
line learning of approximate dependency parsing al-
gorithms. In Eleventh Conference of the European
Chapter of the Association for Computational Linguis-
tics (EACL), pages 81?88, Trento, Italy.
Ryan McDonald, Fernando Pereira, Kiril Ribarov, and Jan
Hajic?. 2005. Non-projective dependency parsing using
spanning tree algorithms. In Human Language Technol-
ogy Conference (HLT) and Conference on Empirical
Methods in Natural Language Processing (EMNLP),
pages 523?530, Vancouver, British Columbia, Canada.
Peter Neuhaus and Norbert Br?ker. 1997. The complexity
of recognition of linguistically adequate dependency
grammars. In 35th Annual Meeting of the Association
for Computational Linguistics (ACL), pages 337?343,
Madrid, Spain.
Joakim Nivre. 2006. Constraints on non-projective depen-
dency parsing. In Eleventh Conference of the European
Chapter of the Association for Computational Linguis-
tics (EACL), pages 73?80, Trento, Italy.
Chris Quirk, Arul Menezes, and Colin Cherry. 2005.
Dependency treelet translation: Syntactically informed
phrasal smt. In 43rd Annual Meeting of the Association
for Computational Linguistics (ACL), pages 271?279,
Ann Arbor, USA.
Owen Rambow and Aravind K. Joshi. 1997. A for-
mal look at dependency grammars and phrase-structure
grammars. In Leo Wanner, editor, Recent Trends in
Meaning-Text Theory, volume 39 of Studies in Lan-
guage, Companion Series, pages 167?190. John Ben-
jamins, Amsterdam, The Netherlands.
Giorgio Satta. 1992. Recognition of linear context-free
rewriting systems. In 30th Annual Meeting of the As-
sociation for Computational Linguistics (ACL), pages
89?95, Newark, Delaware, USA.
Katerina Vesel?, Jir?i Havelka, and Eva Hajic?ova. 2004.
Condition of projectivity in the underlying depen-
dency structures. In 20th International Conference on
Computational Linguistics (COLING), pages 289?295,
Geneva, Switzerland.
K. Vijay-Shanker, David J. Weir, and Aravind K. Joshi.
1987. Characterizing structural descriptions produced
by various grammatical formalisms. In 25th Annual
Meeting of the Association for Computational Linguis-
tics (ACL), pages 104?111, Stanford, California, USA.
167
Proceedings of the 8th International Workshop on Tree Adjoining Grammar and Related Formalisms, pages 121?126,
Sydney, July 2006. c?2006 Association for Computational Linguistics
Extended cross-serial dependencies in Tree Adjoining Grammars
Marco Kuhlmann and Mathias M?hl
Programming Systems Lab
Saarland University
Saarbr?cken, Germany
{kuhlmann|mmohl}@ps.uni-sb.de
Abstract
The ability to represent cross-serial depen-
dencies is one of the central features of
Tree Adjoining Grammar (TAG). The class
of dependency structures representable by
lexicalized TAG derivations can be captured
by two graph-theoretic properties: a bound
on the gap degree of the structures, and a
constraint called well-nestedness. In this
paper, we compare formalisms from two
strands of extensions to TAG in the context
of the question, how they behave with re-
spect to these constraints. In particular, we
show that multi-component TAG does not
necessarily retain the well-nestedness con-
straint, while this constraint is inherent to
Coupled Context-Free Grammar (Hotz and
Pitsch, 1996).
1 Introduction
The ability to assign ?limited cross-serial depen-
dencies? to the words in a sentence is a hallmark
of mildly context-sensitive grammar formalisms
(Joshi, 1985). In the case of TAG, an exact def-
inition of this ability can be given in terms of
two graph-theoretic properties of the dependency
structures induced by TAG derivations: the gap de-
gree restriction and the well-nestedness constraint
(Bodirsky et al, 2005).
Gap degree and well-nestedness can be seen as
the formal correspondents of what Joshi (1985)
refers to as ?a limited amount of cross-serial depen-
dencies? and ?the nesting properties as in the case
of context-free grammars.? More specifically, the
gap degree of a dependency structure counts the
number of discontinuities in a dependency subtree,
while well-nestedness constrains the positions of
disjoint subtrees relative to one another. The depen-
dency structures that correspond to the derivations
in a lexicalized TAG are well-nested, and their gap
degree is at most 1.
In the present paper, we compare formalisms
from two strands of extensions to TAG in the con-
text of the question, what classes of dependency
structures they are able to induce.
We are particularly interested in formalisms that
induce only well-nested dependency structures.
This interest is motivated by two observations:
First, well-nestedness is interesting as a generaliza-
tion of projectivity (Marcus, 1967)?while more
than 23% of the 73 088 dependency structures in
the Prague Dependency Treebank of Czech (Ha-
jic? et al, 2001) are non-projective, only 0.11%
are not well-nested (Kuhlmann and Nivre, 2006).
Second, well-nestedness is interesting for process-
ing. Specifically, parsers for well-nested grammar
formalisms are not confronted with the ?crossing
configurations? that make the universal recogni-
tion problem of Linear Context-Free Rewriting Sys-
tems NP-complete (Satta, 1992). In summary, it
appears that well-nestedness can strike a successful
balance between empirical coverage and computa-
tional tractability. If this is true, then a formalism
that has the well-nestedness constraint hardwired
is preferable over one that has not.
The results of this paper can be summarized
as follows: Derivations in lexicalized multi-com-
ponent TAGs (Weir, 1988; Kallmeyer, 2005), in
which a single adjunction adds a set of elemen-
tary trees, either induce exactly the same depen-
dency structures as TAG, or induce all structures
of bounded gap degree, even non-well-nested ones.
This depends on the decision whether one takes
?lexicalized? to mean ?one lexical anchor per tree?,
or ?one lexical anchor per tree set?. In contrast,
multi-foot extensions of TAG (Abe, 1988; Hotz
and Pitsch, 1996), where a single elementary tree
may have more than one foot node, only induce
well-nested dependency structures of bounded gap
degree. Thus, from the dependency point of view,
they constitute the structurally more conservative
extension of TAG.
121
2 Dependency structures for TAG
We start with a presentation of the dependency
view on TAG that constitutes the basis for our work,
and introduce the relevant terminology. The main
objective of this section is to provide intuitions; for
the formal details, see Bodirsky et al (2005).
2.1 The dependency view on TAG
Let s D w1   wn be a sentence (a sequence of
tokens). By a dependency structure for s, we mean
a tuple .W;!;/, where W D fw1; : : : ; wng, and
! D f .wi ; wj / 2 W W j wj depends on wi g
 D f .wi ; wj / 2 W W j i < j g
To interpret a grammar formalism as a specifica-
tion for a set of dependency structures, we need to
assign meaning to the relation ?depends? in terms
of this formalism. For TAG, this can be done based
on the Fundamental Hypothesis that ?every syntac-
tic dependency is expressed locally within a single
elementary tree? (Frank, 2002). More specifically,
a derivation in a (strongly) lexicalized TAG can
be viewed as a dependency structure as follows:
The set W contains the (occurences of) lexical an-
chors involved in the derivation. For two anchors
wi ; wj 2 W , wi ! wj if the elementary tree an-
chored at wj was substituted or adjoined into the
tree anchored at wi . We then have wi  wj if wi
precedes wj in the yield of the derived tree cor-
responding to the derivation. Notice that the rela-
tion ! in such a dependency structure is almost
exactly the derivation tree of the underlying TAG
derivation; the only difference is that elementary
trees have been replaced by their lexical anchors.
Figure 1 shows a TAG grammar together with a
dependency structure induced by a derivation of
this grammar. Tokens in the derived string are rep-
resented by labelled nodes; the solid arcs between
the nodes represent the dependencies.
2.2 Gap degree and well-nestedness
An interesting feature of the dependency structure
shown in Figure 1 is that it violates a standard
constraint on dependency structures known as pro-
jectivity (Marcus, 1967). We introduce some termi-
nology for non-projective dependency structures:
A set T  W is convex, if for no two tokens
w1; w2 2 T , there exists a token w from W   T
such that w1  w  w2. The cover of T , C.T /,
is the smallest convex set that contains T . For
w 2 W , we write #w for the set of tokens in the
S;
a T D
B C
T ;
a T D
B ? C
B;
b
C ;
c
D;
d
.
a1 a2 b2 b1 c1 c2 d2 d1
Figure 1: TAG grammar for anbncndn, and a de-
pendency structure induced by this grammar
subtree rooted at w (including w itself). A gap in
#w is a largest convex set in C.#w/ #w. The gap
degree of w, gd.w/, is the number of gaps in #w.
The gaps in #w partition #w into gd.w/ 1 largest
convex blocks; we write #iw to refer to the i-th
of these blocks, counted from left to right (with
respect to ). The gap degree of a dependency
structure is the maximum over the gap degrees of its
subtrees; we writeDg for the set of all dependency
structures with a gap degree of at most g.
The gap degree provides a quantitative measure
for the non-projectivity of dependency structures.
Well-nestedness is a qualitative property: it con-
strains the relative positions of disjoint subtrees.
Let w1; w2 2 W such that #w1 and #w2 are dis-
joint. Four tokens w11 ; w
2
1 2 #w1, w
1
2 ; w
2
2 2 #w2
interleave, if w11  w
1
2  w
2
1  w
2
2 . A depen-
dency structure is well-nested, if it does not contain
interleaving tokens. We write Dwn for the set of all
well-nested dependency structures.
For illustration, consider again the dependency
structure shown in Figure 1. It has gap degree 1:
a2 is the only token w for which #w is not convex;
the set fb1; c1g forms a gap in #a2. The structure
is also well-nested. In contrast, the structure shown
in the right half of Figure 2 is not well-nested; the
tokens b; c; d; e interleave. Bodirsky et al (2005)
show that TAG induces precisely the set Dwn \D1.
3 Multi-component extensions
Multi-component TAG (MCTAG) extends TAG with
the ability to adjoin a whole set of elementary trees
(components) simultaneously. To answer the ques-
tion, whether this extension also leads to an ex-
tended class of dependency structures, we first need
to decide how we want to transfer the Fundamental
Hypothesis (Frank, 2002) to MCTAGs.
122
A;
a B1 C1 B2 C2
8
?
?
<
?
?
:
B;1
b
B;2
D
9
>
>
=
>
>
;
8
?
?
<
?
?
:
C ;1
c
C ;2
E
9
>
>
=
>
>
;
D;
d
E;
e a b c d e
Figure 2: An MCTAG and a not well-nested dependency structure derived by it.
3.1 One anchor per component
If we commit to the view that each component of
a tree set introduces a separate lexical anchor and
its syntactic dependencies, the dependency struc-
tures induced by MCTAG are exactly the structures
induced by TAG. In particular, each node in the
derivation tree, and therefore each token in the
dependency tree, corresponds to a single elemen-
tary tree. As Kallmeyer (2005) puts it, one can
then consider an MCTAG as a TAG G ?where cer-
tain derivation trees in G are disallowed since they
do not satisfy certain constraints.? The ability of
MCTAG to perform multiple adjunctions simultane-
ously allows one to induce more complex sets of
dependency structures?each individual structure
is limited as in the case of standard TAG.
3.2 One anchor per tree set
If, on the other hand, we take a complete tree set
as the level on which syntactic dependencies are
specified, MCTAGs can induce a larger class of de-
pendency structures. Under this perspective, tokens
in the dependency structure correspond not to in-
dividual components, but to tree sets (Weir, 1988).
For each token w, #w then contains the lexical an-
chors of all the subderivations starting in the tree set
corresponding to w. As there can be a gap between
each two of these subderivations, the gap degree
of the induced dependency structures is bounded
only by the maximal number of components per
tree set. At the same time, even non-well-nested
structures can be induced; an example is shown in
Figure 2. Here, #b is distributed over the compo-
nents rooted at B1 and B2, and #c is distributed
over C1 and C2. The elementary tree rooted at A
arranges the substitution sites such that b; c; d; e in-
terleave. Note that the MCTAG used in this example
is heavily restricted: it is tree-local and does not
even use adjunction. This restricted form suffices
to induce non-well-nested dependency structures.
4 Multi-foot extensions
A second way to extend TAG, orthogonal to the
multi-component approach, is to allow a single el-
ementary tree to have more than one foot node.
For this kind of extension, the Fundamental Hy-
pothesis does not need to be re-interpreted. Prob-
ably the most prominent multi-foot extension of
TAG is Ranked Node Rewriting Grammar (RNRG)
(Abe, 1988); however, the properties that we are
interested in here can be easier investigated in a
notational variant of RNRG, Coupled Context-Free
Grammar (Hotz and Pitsch, 1996).
Terminology Multi-foot formalisms require a
means to specify which foot node gets what ma-
terial in an adjunction. To do so, they use ranked
symbols. A ranked alphabet is a pair ? D .?; 