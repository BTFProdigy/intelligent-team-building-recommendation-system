Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 127?135,
Suntec, Singapore, 2-7 August 2009. c?2009 ACL and AFNLP
Reducing the Annotation Effort for Letter-to-Phoneme Conversion
Kenneth Dwyer and Grzegorz Kondrak
Department of Computing Science
University of Alberta
Edmonton, AB, Canada, T6G 2E8
{dwyer,kondrak}@cs.ualberta.ca
Abstract
Letter-to-phoneme (L2P) conversion is the
process of producing a correct phoneme
sequence for a word, given its letters. It
is often desirable to reduce the quantity of
training data ? and hence human anno-
tation ? that is needed to train an L2P
classifier for a new language. In this pa-
per, we confront the challenge of building
an accurate L2P classifier with a minimal
amount of training data by combining sev-
eral diverse techniques: context ordering,
letter clustering, active learning, and pho-
netic L2P alignment. Experiments on six
languages show up to 75% reduction in an-
notation effort.
1 Introduction
The task of letter-to-phoneme (L2P) conversion
is to produce a correct sequence of phonemes,
given the letters that comprise a word. An ac-
curate L2P converter is an important component
of a text-to-speech system. In general, a lookup
table does not suffice for L2P conversion, since
out-of-vocabulary words (e.g., proper names) are
inevitably encountered. This motivates the need
for classification techniques that can predict the
phonemes for an unseen word.
Numerous studies have contributed to the de-
velopment of increasingly accurate L2P sys-
tems (Black et al, 1998; Kienappel and Kneser,
2001; Bisani and Ney, 2002; Demberg et al, 2007;
Jiampojamarn et al, 2008). A common assump-
tion made in these works is that ample amounts of
labelled data are available for training a classifier.
Yet, in practice, this is the case for only a small
number of languages. In order to train an L2P clas-
sifier for a new language, we must first annotate
words in that language with their correct phoneme
sequences. As annotation is expensive, we would
like to minimize the amount of effort that is re-
quired to build an adequate training set. The ob-
jective of this work is not necessarily to achieve
state-of-the-art performance when presented with
large amounts of training data, but to outperform
other approaches when training data is limited.
This paper proposes a system for training an ac-
curate L2P classifier while requiring as few an-
notated words as possible. We employ decision
trees as our supervised learning method because of
their transparency and flexibility. We incorporate
context ordering into a decision tree learner that
guides its tree-growing procedure towards gener-
ating more intuitive rules. A clustering over letters
serves as a back-off model in cases where individ-
ual letter counts are unreliable. An active learning
technique is employed to request the phonemes
(labels) for the words that are expected to be the
most informative. Finally, we apply a novel L2P
alignment technique based on phonetic similarity,
which results in impressive gains in accuracy with-
out relying on any training data.
Our empirical evaluation on several L2P
datasets demonstrates that significant reductions
in annotation effort are indeed possible in this do-
main. Individually, all four enhancements improve
the accuracy of our decision tree learner. The com-
bined system yields savings of up to 75% in the
number of words that have to be labelled, and re-
ductions of at least 52% are observed on all the
datasets. This is achieved without any additional
tuning for the various languages.
The paper is organized as follows. Section 2 ex-
plains how supervised learning for L2P conversion
is carried out with decision trees, our classifier of
choice. Sections 3 through 6 describe our four
main contributions towards reducing the annota-
tion effort for L2P: context ordering (Section 3),
clustering letters (Section 4), active learning (Sec-
tion 5), and phonetic alignment (Section 6). Our
experimental setup and results are discussed in
127
Sections 7 and 8, respectively. Finally, Section 9
offers some concluding remarks.
2 Decision tree learning of L2P classifiers
In this work, we employ a decision tree model
to learn the mapping from words to phoneme se-
quences. Decision tree learners are attractive be-
cause they are relatively fast to train, require little
or no parameter tuning, and the resulting classifier
can be interpreted by the user. A number of prior
studies have applied decision trees to L2P data and
have reported good generalization accuracy (An-
dersen et al, 1996; Black et al, 1998; Kienappel
and Kneser, 2001). Also, the widely-used Festi-
val Speech Synthesis System (Taylor et al, 1998)
relies on decision trees for L2P conversion.
We adopt the standard approach of using the
letter context as features. The decision tree pre-
dicts the phoneme for the focus letter based on
the m letters that appear before and after it in
the word (including the focus letter itself, and be-
ginning/end of word markers, where applicable).
The model predicts a phoneme independently for
each letter in a given word. In order to keep our
model simple and transparent, we do not explore
the possibility of conditioning on adjacent (pre-
dicted) phonemes. Any improvement in accuracy
resulting from the inclusion of phoneme features
would also be realized by the baseline that we
compare against, and thus would not materially in-
fluence our findings.
We employ binary decision trees because they
substantially outperformed n-ary trees in our pre-
liminary experiments. In L2P, there are many
unique values for each attribute, namely, the let-
ters of a given alphabet. In a n-ary tree each de-
cision node partitions the data into n subsets, one
per letter, that are potentially sparse. By contrast,
a binary tree creates one branch for the nominated
letter, and one branch grouping the remaining let-
ters into a single subset. In the forthcoming exper-
iments, we use binary decision trees exclusively.
3 Context ordering
In the L2P task, context letters that are adjacent
to the focus letter tend to be more important than
context letters that are further away. For exam-
ple, the English letter c is usually pronounced as
[s] if the following letter is e or i. The general
tree-growing algorithm has no notion of the letter
distance, but instead chooses the letters on the ba-
sis of their estimated information gain (Manning
and Sch?tze, 1999). As a result, it will sometimes
query a letter at position +3 (denoted l3), for ex-
ample, before examining the letters that are closer
to the center of the context window.
We propose to modify the tree-growing proce-
dure to encourage the selection of letters near the
focus letter before those at greater offsets are ex-
amined. In its strictest form, which resembles
the ?dynamically expanding context? search strat-
egy of Davel and Barnard (2004), li can only be
queried after l0, . . . , li?1 have been queried. How-
ever, this approach seems overly rigid for L2P. In
English, for example, l2 can directly influence the
pronunciation of a vowel regardless of the value of
l1 (c.f., the difference between rid and ride).
Instead, we adopt a less intrusive strategy,
which we refer to as ?context ordering,? that biases
the decision tree toward letters that are closer to
the focus, but permits gaps when the information
gain for a distant letter is relatively high. Specif-
ically, the ordering constraint described above is
still applied, but only to letters that have above-
average information gain (where the average is
calculated across all letters/attributes). This means
that a letter with above-average gain that is eligi-
ble with respect to the ordering will take prece-
dence over an ineligible letter that has an even
higher gain. However, if all the eligible letters
have below-average gain, the ineligible letter with
the highest gain is selected irrespective of its posi-
tion. Our only strict requirement is that the focus
letter must always be queried first, unless its infor-
mation gain is zero.
Kienappel and Kneser (2001) also worked on
improving decision tree performance for L2P, and
devised tie-breaking rules in the event that the tree-
growing procedure ranked two or more questions
as being equally informative. In our experience
with L2P datasets, exact ties are rare; our context
ordering mechanism will have more opportunities
to guide the tree-growing process. We expect this
change to improve accuracy, especially when the
amount of training data is very limited. By biasing
the decision tree learner toward questions that are
intuitively of greater utility, we make it less prone
to overfitting on small data samples.
4 Clustering letters
A decision tree trained on L2P data bases its pho-
netic predictions on the surrounding letter context.
128
Yet, when making predictions for unseen words,
contexts will inevitably be encountered that did
not appear in the training data. Instead of rely-
ing solely on the particular letters that surround
the focus letter, we postulate that the learner could
achieve better generalization if it had access to
information about the types of letters that appear
before and after. That is, instead of treating let-
ters as abstract symbols, we would like to encode
knowledge of the similarity between certain letters
as features. One way of achieving this goal is to
group the letters into classes or clusters based on
their contextual similarity. Then, when a predic-
tion has to be made for an unseen (or low probabil-
ity) letter sequence, the letter classes can provide
additional information.
Kienappel and Kneser (2001) report accuracy
gains when applying letter clustering to the L2P
task. However, their decision tree learner incorpo-
rates neighboring phoneme predictions, and em-
ploys a variety of different pruning strategies; the
portion of the gains attributable to letter clustering
are not evident. In addition to exploring the effect
of letter clustering on a wider range of languages,
we are particularly concerned with the impact that
clustering has on decision tree performance when
the training set is small. The addition of letter class
features to the data may enable the active learner
to better evaluate candidate words in the pool, and
therefore make more informed selections.
To group the letters into classes, we employ
a hierarchical clustering algorithm (Brown et al,
1992). One advantage of inducing a hierarchy is
that we need not commit to a particular level of
granularity; in other words, we are not required to
specify the number of classes beforehand, as is the
case with some other clustering algorithms.1
The clustering algorithm is initialized by plac-
ing each letter in its own class, and then pro-
ceeds in a bottom-up manner. At each step, the
pair of classes is merged that leads to the small-
est loss in the average mutual information (Man-
ning and Sch?tze, 1999) between adjacent classes.
The merging process repeats until a single class
remains that contains all the letters in the alpha-
bet. Recall that in our problem setting we have
access to a (presumably) large pool of unanno-
tated words. The unigram and bigram frequen-
cies required by the clustering algorithm are cal-
1This approach is inspired by the work of Miller et al
(2004), who clustered words for a named-entity tagging task.
Letter Bit String Letter Bit String
a 01000 n 1111
b 10000000 o 01001
c 10100 p 10001
d 11000 q 1000001
e 0101 r 111010
f 100001 s 11010
g 11001 t 101010
h 10110 u 0111
i 0110 v 100110
j 10000001 w 100111
k 10111 x 111011
l 11100 y 11011
m 10010 z 101011
# 00
Table 1: Hierarchical clustering of English letters
culated from these words; hence, the letters can
be grouped into classes prior to annotation. The
letter classes only need to be computed once for
a given language. We implemented a brute-force
version of the algorithm that examines all the pos-
sible merges at each step, and generates a hierar-
chy within a few hours. However, when dealing
with a larger number of unique tokens (e.g., when
clustering words instead of letters), additional op-
timizations are needed in order to make the proce-
dure tractable.
The resulting hierarchy takes the form of a bi-
nary tree, where the root node/cluster contains all
the letters, and each leaf contains a single let-
ter. Hence, each letter can be represented by a bit
string that describes the path from the root to its
leaf. As an illustration, the clustering in Table 1
was automatically generated from the words in the
English CMU Pronouncing Dictionary (Carnegie
Mellon University, 1998). It is interesting to note
that the first bit distinguishes vowels from con-
sonants, meaning that these were the last two
groups that were merged by the clustering algo-
rithm. Note also that the beginning/end of word
marker (#) is included in the hierarchy, and is the
last character to be absorbed into a larger clus-
ter. This indicates that # carries more informa-
tion than most letters, as is to be expected, in light
of its distinct status. We also experimented with
a manually-constructed letter hierarchy, but ob-
served no significant differences in accuracy vis-
?-vis the automatic clustering.
129
5 Active learning
Whereas a passive supervised learning algorithm
is provided with a collection of training exam-
ples that are typically drawn at random, an active
learner has control over the labelled data that it ob-
tains (Cohn et al, 1992). The latter attempts to se-
lect its training set intelligently by requesting the
labels of only those examples that are judged to be
the most useful or informative. Numerous studies
have demonstrated that active learners can make
more efficient use of unlabelled data than do pas-
sive learners (Abe and Mamitsuka, 1998; Miller
et al, 2004; Culotta and McCallum, 2005). How-
ever, relatively few researchers have applied active
learning techniques to the L2P domain. This is
despite the fact that annotated data for training an
L2P classifier is not available in most languages.
We briefly review two relevant studies before pro-
ceeding to describe our active learning strategy.
Maskey et al (2004) propose a bootstrapping
technique that iteratively requests the labels of the
n most frequent words in a corpus. A classifier is
trained on the words that have been annotated thus
far, and then predicts the phonemes for each of the
n words being considered. Words for which the
prediction confidence is above a certain threshold
are immediately added to the lexicon, while the re-
maining words must be verified (and corrected, if
necessary) by a human annotator. The main draw-
back of such an approach lies in the risk of adding
erroneous entries to the lexicon when the classifier
is overly confident in a prediction.
Kominek and Black (2006) devise a word se-
lection strategy based on letter n-gram coverage
and word length. Their method slightly outper-
forms random selection, thereby establishing pas-
sive learning as a strong baseline. However, only a
single Italian dataset was used, and the results do
not necessarily generalize to other languages.
In this paper, we propose to apply an ac-
tive learning technique known as Query-by-
Bagging (Abe and Mamitsuka, 1998). We con-
sider a pool-based active learning setting, whereby
the learner has access to a pool of unlabelled ex-
amples (words), and may obtain labels (phoneme
sequences) at a cost. This is an iterative proce-
dure in which the learner trains a classifier on the
current set of labelled training data, then selects
one or more new examples to label, according to
the classifier?s predictions on the pool data. Once
labelled, these examples are added to the training
set, the classifier is re-trained, and the process re-
peats until some stopping criterion is met (e.g., an-
notation resources are exhausted).
Query-by-Bagging (QBB) is an instance of the
Query-by-Committee algorithm (Freund et al,
1997), which selects examples that have high clas-
sification variance. At each iteration, QBB em-
ploys the bagging procedure (Breiman, 1996) to
create a committee of classifiers C. Given a train-
ing set T containing k examples (in our setting,
k is the total number of letters that have been la-
belled), bagging creates each committee member
by sampling k times from T (with replacement),
and then training a classifier Ci on the resulting
data. The example in the pool that maximizes the
disagreement among the predictions of the com-
mittee members is selected.
A crucial question is how to calculate the
disagreement among the predicted phoneme se-
quences for a word in the pool. In the L2P domain,
we assume that a human annotator specifies the
phonemes for an entire word, and that the active
learner cannot query individual letters. We require
a measure of confidence at the word level; yet, our
classifiers make predictions at the letter level. This
is analogous to the task of estimating record confi-
dence using field confidence scores in information
extraction (Culotta and McCallum, 2004).
Our solution is as follows. Let w be a word in
the pool. Each classifier Ci predicts the phoneme
for each letter l ? w. These ?votes? are aggre-
gated to produce a vector vl for letter l that indi-
cates the distribution of the |C| predictions over its
possible phonemes. We then compute the margin
for each letter: If {p, p?} ? vl are the two highest
vote totals, then the margin is M(vl) = |p ? p?|.
A small margin indicates disagreement among the
constituent classifiers. We define the disagreement
score for the entire word as the minimum margin:
score(w) = min
l?w
{M(vl)} (1)
We also experimented with maximum vote en-
tropy and average margin/entropy, where the av-
erage is taken over all the letters in a word. The
minimum margin exhibited the best performance
on our development data; hence, we do not pro-
vide a detailed evaluation of the other measures.
6 L2P alignment
Before supervised learning can take place, the
letters in each word need to be aligned with
130
phonemes. However, a lexicon typically provides
just the letter and phoneme sequences for each
word, without specifying the specific phoneme(s)
that each letter elicits. The sub-task of L2P that
pairs letters with phonemes in the training data is
referred to as alignment. The L2P alignments that
are specified in the training data can influence the
accuracy of the resulting L2P classifier. In our set-
ting, we are interested in mapping each letter to
either a single phoneme or the ?null? phoneme.
The standard approach to L2P alignment is de-
scribed by Damper et al (2005). It performs an
Expectation-Maximization (EM) procedure that
takes a (preferably large) collection of words as
input and computes alignments for them simul-
taneously. However, since in our active learning
setting the data is acquired incrementally, we can-
not count on the initial availability of a substantial
set of words accompanied by their phonemic tran-
scriptions.
In this paper, we apply the ALINE algorithm
to the task of L2P alignment (Kondrak, 2000;
Inkpen et al, 2007). ALINE, which performs
phonetically-informed alignment of two strings of
phonemes, requires no training data, and so is
ideal for our purposes. Since our task requires the
alignment of phonemes with letters, we wish to re-
place every letter with a phoneme that is the most
likely to be produced by that letter. On the other
hand, we would like our approach to be language-
independent. Our solution is to simply treat ev-
ery letter as an IPA symbol (International Phonetic
Association, 1999). The IPA is based on the Ro-
man alphabet, but also includes a number of other
symbols. The 26 IPA letter symbols tend to cor-
respond to the usual phonetic value that the letter
represents in the Latin script.2 For example, the
IPA symbol [m] denotes ?voiced bilabial nasal,?
which is the phoneme represented by the letter m
in most languages that utilize Latin script.
The alignments produced by ALINE are of high
quality. The example below shows the alignment
of the Italian word scianchi to its phonetic tran-
scription [SaNki]. ALINE correctly aligns not only
identical IPA symbols (i:i), but also IPA symbols
that represent similar sounds (s:S, n:N, c:k).
s c i a n c h i
| | | | |
S a N k i
2ALINE can also be applied to non-Latin scripts by re-
placing every grapheme with the IPA symbol that is phoneti-
cally closest to it (Jiampojamarn et al, 2009).
7 Experimental setup
We performed experiments on six datasets, which
were obtained from the PRONALSYL letter-
to-phoneme conversion challenge.3 They are:
English CMUDict (Carnegie Mellon University,
1998); French BRULEX (Content et al, 1990),
Dutch and German CELEX (Baayen et al, 1996),
the Italian Festival dictionary (Cosi et al, 2000),
and the Spanish lexicon. Duplicate words and
words containing punctuation or numerals were
removed, as were abbreviations and acronyms.
The resulting datasets range in size from 31,491
to 111,897 words. The PRONALSYL datasets are
already divided into 10 folds; we used the first fold
as our test set, and the other folds were merged to-
gether to form the learning set. In our preliminary
experiments, we randomly set aside 10 percent of
this learning set to serve as our development set.
Since the focus of our work is on algorithmic
enhancements, we simulate the annotator with an
oracle and do not address the potential human in-
terface factors. During an experiment, 100 words
were drawn at random from the learning set; these
constituted the data on which an initial classifier
was trained. The rest of the words in the learning
set formed the unlabelled pool for active learning;
their phonemes were hidden, and a given word?s
phonemes were revealed if the word was selected
for labelling. After training a classifier on the
100 annotated words, we performed 190 iterations
of active learning. On each iteration, 10 words
were selected according to Equation 1, labelled by
an oracle, and added to the training set. In or-
der to speed up the experiments, a random sam-
ple of 2000 words was drawn from the pool and
presented to the active learner each time. Hence,
QBB selected 10 words from the 2000 candidates.
We set the QBB committee size |C| to 10.
At each step, we measured word accuracy with
respect to the holdout set as the percentage of test
words that yielded no erroneous phoneme predic-
tions. Henceforth, we use accuracy to refer to
word accuracy. Note that although we query ex-
amples using a committee, we train a single tree on
these examples in order to produce an intelligible
model. Prior work has demonstrated that this con-
figuration performs well in practice (Dwyer and
Holte, 2007). Our results report the accuracy of
the single tree grown on each iteration, averaged
3Available at http://pascallin.ecs.soton.ac.uk/Challenges/
PRONALSYL/Datasets/
131
over 10 random draws of the initial training set.
For our decision tree learner, we utilized the J48
algorithm provided by Weka (Witten and Frank,
2005). We also experimented with Wagon (Taylor
et al, 1998), an implementation of CART, but J48
performed better during preliminary trials. We ran
J48 with default parameter settings, except that bi-
nary trees were grown (see Section 2), and subtree
raising was disabled.4
Our feature template was established during de-
velopment set experiments with the English CMU
data; the data from the other five languages did not
influence these choices. The letter context con-
sisted of the focus letter and the 3 letters appear-
ing before and after the focus (or beginning/end of
word markers, where applicable). For letter class
features, bit strings of length 1 through 6 were
used for the focus letter and its immediate neigh-
bors. Bit strings of length at most 3 were used
at positions +2 and ?2, and no such features were
added at?3.5 We experimented with other config-
urations, including using bit strings of up to length
6 at all positions, but they did not produce consis-
tent improvements over the selected scheme.
8 Results
We first examine the contributions of the indi-
vidual system components, and then compare our
complete system to the baseline. The dashed
curves in Figure 1 represent the baseline perfor-
mance with no clustering, no context ordering,
random sampling, and ALINE, unless otherwise
noted. In all plots, the error bars show the 99%
confidence interval for the mean. Because the av-
erage word length differs across languages, we re-
port the number of words along the x-axis. We
have verified that our system does not substantially
alter the average number of letters per word in the
training set for any of these languages. Hence, the
number of words reported here is representative of
the true annotation effort.
4Subtree raising is an expensive pruning operation that
had a negligible impact on accuracy during preliminary ex-
periments. Our pruning performs subtree replacement only.
5The idea of lowering the specificity of letter class ques-
tions as the context length increases is due to Kienappel and
Kneser (2001), and is intended to avoid overfitting. However,
their configuration differs from ours in that they use longer
context lengths (4 for German and 5 for English) and ask let-
ter class questions at every position. Essentially, the authors
tuned the feature set in order to optimize performance on each
problem, whereas we seek a more general representation that
will perform well on a variety of languages.
8.1 Context ordering
Our context ordering strategy improved the ac-
curacy of the decision tree learner on every lan-
guage (see Figure 1a). Statistically significant im-
provements were realized on Dutch, French, and
German. Our expectation was that context order-
ing would be particularly helpful during the early
rounds of active learning, when there is a greater
risk of overfitting on the small training sets. For
some languages (notably, German and Spanish)
this was indeed the case; yet, for Dutch, context
ordering became more effective as the training set
increased in size.
It should be noted that our context ordering
strategy is sufficiently general that it can be im-
plemented in other decision tree learners that grow
binary trees, such as Wagon/CART (Taylor et al,
1998). An n-ary implementation is also feasible,
although we have not tried this variation.
8.2 Clustering letters
As can be seen in Figure 1b, clustering letters into
classes tended to produce a steady increase in ac-
curacy. The only case where it had no statistically
significant effect was on English. Another benefit
of clustering is that it reduces variance. The confi-
dence intervals are generally wider when cluster-
ing is disabled, meaning that the system?s perfor-
mance was less sensitive to changes in the initial
training set when letter classes were used.
8.3 Active learning
On five of the six datasets, Query-by-Bagging re-
quired significantly fewer labelled examples to
reach the maximum level of performance achieved
by the passive learner (see Figure 1c). For in-
stance, on the Spanish dataset, random sampling
reached 97% word accuracy after 1420 words had
been annotated, whereas QBB did so with only
510 words ? a 64% reduction in labelling ef-
fort. Similarly, savings ranging from 30% to 63%
were observed for the other languages, with the
exception of English, where a statistically insignif-
icant 4% reduction was recorded. Since English is
highly irregular in comparison with the other five
languages, the active learner tends to query exam-
ples that are difficult to classify, but which are un-
helpful in terms of generalization.
It is important to note that empirical compar-
isons of different active learning techniques have
shown that random sampling establishes a very
132
0 5 10 15 20Number of training words (x100)
10
20
30
40
50
60
70
80
90
100
Wo
rd a
ccu
rac
y (%
)
 
Context OrderingNo Context Ordering
(a) Context Ordering
0 5 10 15 20Number of training words (x100)
10
20
30
40
50
60
70
80
90
100
Wo
rd a
ccu
rac
y (%
)
 
ClusteringNo Clustering
(b) Clustering
0 5 10 15 20Number of training words (x100)
10
20
30
40
50
60
70
80
90
100
Wo
rd a
ccu
rac
y (%
)
 
Query-by-BaggingRandom Sampling
(c) Active learning
0 5 10 15 20Number of training words (x100)
10
20
30
40
50
60
70
80
90
100
Wo
rd a
ccu
rac
y (%
)
 
ALINEEM
(d) L2P alignment
Spanish Italian +French Dutch + German English
Figure 1: Performance of the individual system components
strong baseline on some datasets (Schein and Un-
gar, 2007; Settles and Craven, 2008). It is rarely
the case that a given active learning strategy is
able to unanimously outperform random sampling
across a range of datasets. From this perspective,
to achieve statistically significant improvements
on five of six L2P datasets (without ever being
beaten by random) is an excellent result for QBB.
8.4 L2P alignment
The ALINE method for L2P alignment outper-
formed EM on all six datasets (see Figure 1d). As
was mentioned in Section 6, the EM aligner de-
pends on all the available training data, whereas
ALINE processes words individually. Only on
Spanish and Italian, languages which have highly
regular spelling systems, was the EM aligner com-
petitive with ALINE. The accuracy gains on the
remaining four datasets are remarkable, consider-
ing that better alignments do not necessarily trans-
late into improved classification.
We hypothesized that EM?s inferior perfor-
mance was due to the limited quantities of data
that were available in the early stages of active
learning. In a follow-up experiment, we allowed
EM to align the entire learning set in advance,
and these aligned entries were revealed when re-
quested by the learner. We compared this with the
usual procedure whereby EM is applied to the la-
belled training data at each iteration of learning.
The learning curves (not shown) were virtually in-
distinguishable, and there were no statistically sig-
nificant differences on any of the languages. EM
appears to produce poor alignments regardless of
the amount of available data.
133
0 5 10 15 20Number of training words (x100)
10
20
30
40
50
60
70
80
90
100
Wo
rd a
ccu
rac
y (%
)
 
Complete SystemBaseline
Spanish Italian +French Dutch + German English
Figure 2: Performance of the complete system
8.5 Complete system
The complete system consists of context order-
ing, clustering, Query-by-Bagging, and ALINE;
the baseline represents random sampling with EM
alignment and no additional enhancements. Fig-
ure 2 plots the word accuracies for all six datasets.
Although the absolute word accuracies varied
considerably across the different languages, our
system significantly outperformed the baseline in
every instance. On the French dataset, for ex-
ample, the baseline labelled 1850 words before
reaching its maximum accuracy of 64%, whereas
the complete system required only 480 queries to
reach 64% accuracy. This represents a reduction
of 74% in the labelling effort. The savings for the
other languages are: Spanish, 75%; Dutch, 68%;
English, 59%; German, 59%; and Italian, 52%.6
Interestingly, the savings are the highest on Span-
ish, even though the corresponding accuracy gains
are the smallest. This demonstrates that our ap-
proach is also effective on languages with rela-
tively transparent orthography.
At first glance, the performance of both sys-
tems appears to be rather poor on the English
dataset. To put our results into perspective, Black
et al (1998) report 57.8% accuracy on this dataset
with a similar alignment method and decision tree
learner. Our baseline system achieves 57.3% ac-
curacy when 90,000 words have been labelled.
Hence, the low values in Figure 2 simply reflect
the fact that many more examples are required to
6The average savings in the number of labelled words
with respect to the entire learning curve are similar, ranging
from 50% on Italian to 73% on Spanish.
learn an accurate classifier for the English data.
9 Conclusions
We have presented a system for learning a letter-
to-phoneme classifier that combines four distinct
enhancements in order to minimize the amount
of data that must be annotated. Our experiments
involving datasets from several languages clearly
demonstrate that unlabelled data can be used more
efficiently, resulting in greater accuracy for a given
training set size, without any additional tuning
for the different languages. The experiments also
show that a phonetically-based aligner may be
preferable to the widely-used EM alignment tech-
nique, a discovery that could lead to the improve-
ment of L2P accuracy in general.
While this work represents an important step
in reducing the cost of constructing an L2P train-
ing set, we intend to explore other active learners
and classification algorithms, including sequence
labelling strategies (Settles and Craven, 2008).
We also plan to incorporate user-centric enhance-
ments (Davel and Barnard, 2004; Culotta and Mc-
Callum, 2005) with the aim of reducing both the
effort and expertise that is required to annotate
words with their phoneme sequences.
Acknowledgments
We would like to thank Sittichai Jiampojamarn for
helpful discussions and for providing an imple-
mentation of the Expectation-Maximization align-
ment algorithm. This research was supported by
the Natural Sciences and Engineering Research
Council of Canada (NSERC) and the Informatics
Circle of Research Excellence (iCORE).
References
Naoki Abe and Hiroshi Mamitsuka. 1998. Query
learning strategies using boosting and bagging. In
Proc. International Conference on Machine Learn-
ing, pages 1?9.
Ove Andersen, Ronald Kuhn, Ariane Lazarid?s, Paul
Dalsgaard, J?rgen Haas, and Elmar N?th. 1996.
Comparison of two tree-structured approaches for
grapheme-to-phoneme conversion. In Proc. Inter-
national Conference on Spoken Language Process-
ing, volume 3, pages 1700?1703.
R. Harald Baayen, Richard Piepenbrock, and Leon Gu-
likers, 1996. The CELEX2 lexical database. Lin-
guistic Data Consortium, Univ. of Pennsylvania.
134
Maximilian Bisani and Hermann Ney. 2002. Investi-
gations on joint-multigram models for grapheme-to-
phoneme conversion. In Proc. International Confer-
ence on Spoken Language Processing, pages 105?
108.
Alan W. Black, Kevin Lenzo, and Vincent Pagel. 1998.
Issues in building general letter to sound rules. In
ESCA Workshop on Speech Synthesis, pages 77?80.
Leo Breiman. 1996. Bagging predictors. Machine
Learning, 24(2):123?140.
Peter F. Brown, Vincent J. Della Pietra, Peter V. deS-
ouza, Jennifer C. Lai, and Robert L. Mercer. 1992.
Class-based n-gram models of natural language.
Computational Linguistics, 18(4):467?479.
Carnegie Mellon University. 1998. The Carnegie Mel-
lon pronouncing dictionary.
David A. Cohn, Les E. Atlas, and Richard E. Ladner.
1992. Improving generalization with active learn-
ing. Machine Learning, 15(2):201?221.
Alain Content, Phillppe Mousty, and Monique Radeau.
1990. Brulex: Une base de donn?es lexicales in-
formatis?e pour le fran?ais ?crit et parl?. L?ann?e
Psychologique, 90:551?566.
Piero Cosi, Roberto Gretter, and Fabio Tesser. 2000.
Festival parla Italiano. In Proc. Giornate del
Gruppo di Fonetica Sperimentale.
Aron Culotta and Andrew McCallum. 2004. Con-
fidence estimation for information extraction. In
Proc. HLT-NAACL, pages 109?114.
Aron Culotta and Andrew McCallum. 2005. Reduc-
ing labeling effort for structured prediction tasks. In
Proc. National Conference on Artificial Intelligence,
pages 746?751.
Robert I. Damper, Yannick Marchand, John-David S.
Marsters, and Alexander I. Bazin. 2005. Align-
ing text and phonemes for speech technology appli-
cations using an EM-like algorithm. International
Journal of Speech Technology, 8(2):147?160.
Marelie Davel and Etienne Barnard. 2004. The effi-
cient generation of pronunciation dictionaries: Hu-
man factors during bootstrapping. In Proc. Interna-
tional Conference on Spoken Language Processing,
pages 2797?2800.
Vera Demberg, Helmut Schmid, and Gregor M?hler.
2007. Phonological constraints and morphologi-
cal preprocessing for grapheme-to-phoneme conver-
sion. In Proc. ACL, pages 96?103.
Kenneth Dwyer and Robert Holte. 2007. Decision tree
instability and active learning. In Proc. European
Conference on Machine Learning, pages 128?139.
Yoav Freund, H. Sebastian Seung, Eli Shamir, and Naf-
tali Tishby. 1997. Selective sampling using the
query by committee algorithm. Machine Learning,
28(2-3):133?168.
Diana Inkpen, Rapha?lle Martin, and Alain
Desrochers. 2007. Graphon: un outil pour
la transcription phon?tique des mots fran?ais.
Unpublished manuscript.
International Phonetic Association. 1999. Handbook
of the International Phonetic Association: A Guide
to the Use of the International Phonetic Alphabet.
Cambridge University Press.
Sittichai Jiampojamarn, Colin Cherry, and Grzegorz
Kondrak. 2008. Joint processing and discriminative
training for letter-to-phoneme conversion. In Proc.
ACL, pages 905?913.
Sittichai Jiampojamarn, Aditya Bhargava, Qing Dou,
Kenneth Dwyer, and Grzegorz Kondrak. 2009. Di-
recTL: a language-independent approach to translit-
eration. In Named Entities Workshop (NEWS):
Shared Task on Transliteration. Submitted.
Anne K. Kienappel and Reinhard Kneser. 2001. De-
signing very compact decision trees for grapheme-
to-phoneme transcription. In Proc. European Con-
ference on Speech Communication and Technology,
pages 1911?1914.
John Kominek and Alan W. Black. 2006. Learn-
ing pronunciation dictionaries: Language complex-
ity and word selection strategies. In Proc. HLT-
NAACL, pages 232?239.
Grzegorz Kondrak. 2000. A new algorithm for the
alignment of phonetic sequences. In Proc. NAACL,
pages 288?295.
Christopher D. Manning and Hinrich Sch?tze. 1999.
Foundations of Statistical Natural Language Pro-
cessing. MIT Press.
Sameer R. Maskey, Alan W. Black, and Laura M.
Tomokiya. 2004. Boostrapping phonetic lexicons
for new languages. In Proc. International Confer-
ence on Spoken Language Processing, pages 69?72.
Scott Miller, Jethran Guinness, and Alex Zamanian.
2004. Name tagging with word clusters and dis-
criminative training. In Proc. HLT-NAACL, pages
337?342.
Andrew I. Schein and Lyle H. Ungar. 2007. Active
learning for logistic regression: an evaluation. Ma-
chine Learning, 68(3):235?265.
Burr Settles and Mark Craven. 2008. An analysis
of active learning strategies for sequence labeling
tasks. In Proc. Conference on Empirical Methods
in Natural Language Processing, pages 1069?1078.
Paul A. Taylor, Alan Black, and Richard Caley. 1998.
The architecture of the Festival Speech Synthesis
System. In ESCA Workshop on Speech Synthesis,
pages 147?151.
Ian H. Witten and Eibe Frank. 2005. Data Mining:
Practical Machine Learning Tools and Techniques.
Morgan Kaufmann, 2nd edition.
135
Proceedings of the 2009 Named Entities Workshop, ACL-IJCNLP 2009, pages 28?31,
Suntec, Singapore, 7 August 2009. c?2009 ACL and AFNLP
DIRECTL: a Language-Independent Approach to Transliteration
Sittichai Jiampojamarn, Aditya Bhargava, Qing Dou, Kenneth Dwyer, Grzegorz Kondrak
Department of Computing Science
University of Alberta
Edmonton, AB, T6G 2E8, Canada
{sj,abhargava,qdou,dwyer,kondrak}@cs.ualberta.ca
Abstract
We present DIRECTL: an online discrimi-
native sequence prediction model that em-
ploys a many-to-many alignment between
target and source. Our system incorpo-
rates input segmentation, target charac-
ter prediction, and sequence modeling in
a unified dynamic programming frame-
work. Experimental results suggest that
DIRECTL is able to independently dis-
cover many of the language-specific reg-
ularities in the training data.
1 Introduction
In the transliteration task, it seems intuitively im-
portant to take into consideration the specifics of
the languages in question. Of particular impor-
tance is the relative character length of the source
and target names, which vary widely depending on
whether languages employ alphabetic, syllabic, or
ideographic scripts. On the other hand, faced with
the reality of thousands of potential language pairs
that involve transliteration, the idea of a language-
independent approach is highly attractive.
In this paper, we present DIRECTL: a translit-
eration system that, in principle, can be applied to
any language pair. DIRECTL treats the transliter-
ation task as a sequence prediction problem: given
an input sequence of characters in the source lan-
guage, it produces the most likely sequence of
characters in the target language. In Section 2,
we discuss the alignment of character substrings
in the source and target languages. Our transcrip-
tion model, described in Section 3, is based on
an online discriminative training algorithm that
makes it possible to efficiently learn the weights
of a large number of features. In Section 4, we
provide details of alternative approaches that in-
corporate language-specific information. Finally,
in Section 5 and 6, we compare the experimental
results of DIRECTL with its variants that incor-
porate language-specific pre-processing, phonetic
alignment, and manual data correction.
2 Transliteration alignment
In the transliteration task, training data consist of
word pairs that map source language words to
words in the target language. The matching be-
tween character substrings in the source word and
target word is not explicitly provided. These hid-
den relationships are generally known as align-
ments. In this section, we describe an EM-based
many-to-many alignment algorithm employed by
DIRECTL. In Section 4, we discuss an alternative
phonetic alignment method.
We apply an unsupervised many-to-many align-
ment algorithm (Jiampojamarn et al, 2007) to the
transliteration task. The algorithm follows the ex-
pectation maximization (EM) paradigm. In the
expectation step shown in Algorithm 1, partial
counts ? of the possible substring alignments are
collected from each word pair (xT , yV ) in the
training data; T and V represent the lengths of
words x and y, respectively. The forward prob-
ability ? is estimated by summing the probabili-
ties of all possible sequences of substring pairings
from left to right. The FORWARD-M2M procedure
is similar to lines 5 through 12 of Algorithm 1, ex-
cept that it uses Equation 1 on line 8, Equation 2
on line 12, and initializes ?0,0 := 1. Likewise, the
backward probability ? is estimated by summing
the probabilities from right to left.
?t,v += ?(xtt?i+1, ?)?t?i,v (1)
?t,v += ?(xtt?i+1, yvv?j+1)?t?i,v?j (2)
The maxX and maxY variables specify the
maximum length of substrings that are permitted
when creating alignments. Also, for flexibility, we
allow a substring in the source word to be aligned
with a ?null? letter (?) in the target word.
28
Algorithm 1: Expectation-M2M alignment
Input: xT , yV ,maxX,maxY, ?
Output: ?
? := FORWARD-M2M (xT , yV ,maxX,maxY )1
? := BACKWARD-M2M (xT , yV ,maxX,maxY )2
if (?T,V = 0) then3
return4
for t = 0 . . . T , v = 0 . . . V do5
if (t > 0) then6
for i = 1 . . .maxX st t? i ? 0 do7
?(xtt?i+1, ?) +=
?t?i,v?(xtt?i+1,?)?t,v
?T,V8
if (v > 0 ? t > 0) then9
for i = 1 . . .maxX st t? i ? 0 do10
for j = 1 . . . maxY st v ? j ? 0 do11
?(xtt?i+1, yvv?j+1) +=
?t?i,v?j?(xtt?i+1,y
v
v?j+1)?t,v
?T,V12
In the maximization step, we normalize the par-
tial counts ? to the alignment probability ? using
the conditional probability distribution. The EM
steps are repeated until the alignment probability
? converges. Finally, the most likely alignment for
each word pair in the training data is computed
with the standard Viterbi algorithm.
3 Discriminative training
We adapt the online discriminative training frame-
work described in (Jiampojamarn et al, 2008) to
the transliteration task. Once the training data has
been aligned, we can hypothesize that the ith let-
ter substring xi ? x in a source language word
is transliterated into the ith substring yi ? y in
the target language word. Each word pair is rep-
resented as a feature vector ?(x,y). Our feature
vector consists of (1) n-gram context features, (2)
HMM-like transition features, and (3) linear-chain
features. The n-gram context features relate the
letter evidence that surrounds each letter xi to its
output yi. We include all n-grams that fit within
a context window of size c. The c value is deter-
mined using a development set. The HMM-like
transition features express the cohesion of the out-
put y in the target language. We make a first order
Markov assumption, so that these features are bi-
grams of the form (yi?1, yi). The linear-chain fea-
tures are identical to the context features, except
that yi is replaced with a bi-gram (yi?1, yi).
Algorithm 2 trains a linear model in this fea-
ture space. The procedure makes k passes over
the aligned training data. During each iteration,
the model produces the nmost likely output words
Y?j in the target language for each input word xj
in the source language, based on the current pa-
Algorithm 2: Online discriminative training
Input: Data {(x1,y1), (x2,y2), . . . , (xm,ym)},
number of iterations k, size of n-best list n
Output: Learned weights ?
? := ~01
for k iterations do2
for j = 1 . . .m do3
Y?j = {y?j1, . . . , y?jn} = argmaxy[? ? ?(xj ,y)]4
update ? according to Y?j and yj5
return ?6
rameters ?. The values of k and n are deter-
mined using a development set. The model param-
eters are updated according to the correct output
yj and the predicted n-best outputs Y?j , to make
the model prefer the correct output over the in-
correct ones. Specifically, the feature weight vec-
tor ? is updated by using MIRA, the Margin In-
fused Relaxed Algorithm (Crammer and Singer,
2003). MIRA modifies the current weight vector
?o by finding the smallest changes such that the
new weight vector ?n separates the correct and in-
correct outputs by a margin of at least ?(y, y?), the
loss for a wrong prediction. We define this loss to
be 0 if y? = y; otherwise it is 1 + d, where d is
the Levenshtein distance between y and y?. The
update operation is stated as a quadratic program-
ming problem in Equation 3. We utilize a function
from the SVMlight package (Joachims, 1999) to
solve this optimization problem.
min?n ? ?n ? ?o ?
subject to ?y? ? Y? :
?n ? (?(x,y) ? ?(x, y?)) ? ?(y, y?)
(3)
The argmax operation is performed by an exact
search algorithm based on a phrasal decoder (Zens
and Ney, 2004). This decoder simultaneously
finds the l most likely substrings of letters x that
generate the most probable output y, given the
feature weight vector ? and the input word xT .
The search algorithm is based on the following dy-
namic programming recurrence:
Q(0, $) = 0
Q(t, p) = max
p?,p,
t?maxX?t?<t
{? ? ?(xtt?+1, p?, p) +Q(t?, p?)}
Q(T+1, $) = max
p?
{? ? ?($, p?, $) +Q(T, p?)}
To find the n-best predicted outputs, the table
Q records the top n scores for each output sub-
string that has the suffix p substring and is gen-
erated by the input letter substring xt1; here, p? is
29
a sub-output generated during the previous step.
The notation ?(xtt?+1, p?, p) is a convenient way
to describe the components of our feature vector
?(x,y). The n-best predicted outputs Y? can be
discovered by backtracking from the end of the ta-
ble, which is denoted by Q(T + 1, $).
4 Beyond DIRECTL
4.1 Intermediate phonetic representation
We experimented with converting the original Chi-
nese characters to Pinyin as an intermediate repre-
sentation. Pinyin is the most commonly known
Romanization system for Standard Mandarin. Its
alphabet contains the same 26 letters as English.
Each Chinese character can be transcribed pho-
netically into Pinyin. Many resources for Pinyin
conversion are available online.1 A small percent-
age of Chinese characters have multiple pronunci-
ations represented by different Pinyin representa-
tions. For those characters (about 30 characters in
the transliteration data), we manually selected the
pronunciations that are normally used for names.
This preprocessing step significantly reduces the
size of target symbols from 370 distinct Chinese
characters to 26 Pinyin symbols which enables our
system to produce better alignments.
In order to verify whether the addition of
language-specific knowledge can improve the
overall accuracy, we also designed intermediate
representations for Russian and Japanese. We
focused on symbols that modify the neighbor-
ing characters without producing phonetic output
themselves: the two yer characters in Russian,
and the long vowel and sokuon signs in Japanese.
Those were combined with the neighboring char-
acters, creating new ?super-characters.?
4.2 Phonetic alignment with ALINE
ALINE (Kondrak, 2000) is an algorithm that
performs phonetically-informed alignment of two
strings of phonemes. Since our task requires
the alignment of characters representing different
writing scripts, we need to first replace every char-
acter with a phoneme that is the most likely to be
produced by that character.
We applied slightly different methods to the
test languages. In converting the Cyrillic script
into phonemes, we take advantage of the fact
that the Russian orthography is largely phonemic,
which makes it a relatively straightforward task.
1For example, http://www.chinesetopinyin.com/
In Japanese, we replace each Katakana character
with one or two phonemes using standard tran-
scription tables. For the Latin script, we simply
treat every letter as an IPA symbol (International
Phonetic Association, 1999). The IPA contains a
subset of 26 letter symbols that tend to correspond
to the usual phonetic value that the letter repre-
sents in the Latin script. The Chinese characters
are first converted to Pinyin, which is then handled
in the same way as the Latin script.
Similar solutions could be engineered for other
scripts. We observed that the transcriptions do not
need to be very precise in order for ALINE to pro-
duce high quality alignments.
4.3 System combination
The combination of predictions produced by sys-
tems based on different principles may lead to im-
proved prediction accuracy. We adopt the follow-
ing combination algorithm. First, we rank the in-
dividual systems according to their top-1 accuracy
on the development set. To obtain the top-1 pre-
diction for each input word, we use simple voting,
with ties broken according to the ranking of the
systems. We generalize this approach to handle n-
best lists by first ordering the candidate translitera-
tions according to the highest rank assigned by any
of the systems, and then similarly breaking ties by
voting and system ranking.
5 Evaluation
In the context of the NEWS 2009 Machine
Transliteration Shared Task (Li et al, 2009), we
tested our system on six data sets: from English to
Chinese (EnCh) (Li et al, 2004), Hindi (EnHi),
Russian (EnRu) (Kumaran and Kellner, 2007),
Japanese Katakana (EnJa), and Korean Hangul
(EnKo); and from Japanese Name to Japanese
Kanji (JnJk)2. We optimized the models? param-
eters by training on the training portion of the
provided data and measuring performance on the
development portion. For the final testing, we
trained the models on all the available labeled data
(training plus development data). For each data
set, we converted any uppercase letters to lower-
case. Our system outputs the top 10 candidate an-
swers for each input word.
Table 1 reports the performance of our system
on the development and final test sets, measured
in terms of top-1 word accuracy (ACC). For cer-
tain language pairs, we tested variants of the base
2http://www.cjk.org/
30
Task Model Dev Test
EnCh DIRECTL 72.4 71.7
INT(M2M) 73.9 73.4
INT(ALINE) 73.8 73.2
COMBINED 74.8 74.6
EnHi DIRECTL 41.4 49.8
DIRECTL+MC 42.3 50.9
EnJa DIRECTL 49.9 50.0
INT(M2M)? 49.6 49.2
INT(ALINE) 48.3 51.0
COMBINED? 50.6 50.5
EnKo DIRECTL 36.7 38.7
EnRu DIRECTL 80.2 61.3
INT(M2M) 80.3 60.8
INT(ALINE) 80.0 60.7
COMBINED? 80.3 60.8
JnJk DIRECTL 53.5 56.0
Table 1: Top-1 word accuracy on the development
and test sets. The asterisk denotes the results ob-
tained after the test reference sets were released.
system described in Section 4. DIRECTL refers
to our language-independent model, which uses
many-to-many alignments. The INT abbreviation
denotes the models operating on the language-
specific intermediate representations described in
Section 4.1. The alignment algorithm (ALINE or
M2M) is given in brackets.
In the EnHi set, many names consisted of mul-
tiple words: we assumed a one-to-one correspon-
dence between consecutive English words and
consecutive Hindi words. In Table 1, the results in
the first row (DIRECTL) were obtained with an au-
tomatic cleanup script that replaced hyphens with
spaces, deleted the remaining punctuation and nu-
merical symbols, and removed 43 transliteration
pairs with a disagreement between the number of
source and target words. The results in the sec-
ond row (DIRECTL+MC) were obtained when the
cases with a disagreement were individually ex-
amined and corrected by a Hindi speaker.
We did not incorporate any external resources
into the models presented in Table 1. In order
to emphasize the performance of our language-
independent approach, we consistently used the
DIRECTL model for generating our ?standard?
runs on all six language pairs, regardless of its rel-
ative performance on the development sets.
6 Discussion
DIRECTL, our language-independent approach to
transliteration achieves excellent results, espe-
cially on the EnCh, EnRu, and EnHi data sets,
which represent a wide range of language pairs
and writing scripts. Both the many-to-many
and phonetic alignment algorithms produce high-
quality alignments. The former can be applied di-
rectly to the training data without the need for an
intermediate representation, while the latter does
not require any training. Surprisingly, incorpo-
ration of language-specific intermediate represen-
tations does not consistently improve the perfor-
mance of our system, which indicates that DI-
RECTL may be able to discover the structures im-
plicit in the training data without additional guid-
ance. The EnHi results suggest that manual clean-
ing of noisy data can yield noticeable gains in ac-
curacy. On the other hand, a simple method of
combining predictions from different systems pro-
duced clear improvement on the EnCh set, but
mixed results on two other sets. More research on
this issue is warranted.
Acknowledgments
This research was supported by the Alberta Inge-
nuity, Informatics Circle of Research Excellence
(iCORE), and Natural Sciences of Engineering
Research Council of Canada (NSERC).
References
Koby Crammer and Yoram Singer. 2003. Ultracon-
servative online algorithms for multiclass problems.
Journal of Machine Learning Research, 3:951?991.
International Phonetic Association. 1999. Handbook
of the International Phonetic Association. Cam-
bridge University Press.
Sittichai Jiampojamarn, Grzegorz Kondrak, and Tarek
Sherif. 2007. Applying many-to-many alignments
and Hidden Markov Models to letter-to-phoneme
conversion. In Proc. HLT-NAACL, pages 372?379.
Sittichai Jiampojamarn, Colin Cherry, and Grzegorz
Kondrak. 2008. Joint processing and discriminative
training for letter-to-phoneme conversion. In Proc.
ACL, pages 905?913.
Thorsten Joachims. 1999. Making large-scale SVM
learning practical. Advances in kernel methods:
support vector learning, pages 169?184. MIT Press.
Grzegorz Kondrak. 2000. A new algorithm for the
alignment of phonetic sequences. In Proc. NAACL,
pages 288?295.
A. Kumaran and Tobias Kellner. 2007. A generic
framework for machine transliteration. In Proc. SI-
GIR, pages 721?722.
Haizhou Li, Min Zhang, and Jian Su. 2004. A joint
source channel model for machine transliteration. In
Proc. ACL, pages 159?166.
Haizhou Li, A Kumaran, Min Zhang, and Vladimir
Pervouchine. 2009. Whitepaper of NEWS 2009
machine transliteration shared task. In Proc. ACL-
IJCNLP Named Entities Workshop.
Richard Zens and Hermann Ney. 2004. Improvements
in phrase-based statistical machine translation. In
Proc. HLT-NAACL, pages 257?264.
31
Proceedings of the 2010 Named Entities Workshop, ACL 2010, pages 39?47,
Uppsala, Sweden, 16 July 2010. c?2010 Association for Computational Linguistics
Transliteration Generation and Mining with Limited Training Resources
Sittichai Jiampojamarn, Kenneth Dwyer, Shane Bergsma, Aditya Bhargava,
Qing Dou, Mi-Young Kim, Grzegorz Kondrak
Department of Computing Science
University of Alberta
Edmonton, AB, T6G 2E8, Canada
{sj,dwyer,bergsma,abhargava,qdou,miyoung2,kondrak}@cs.ualberta.ca
Abstract
We present DIRECTL+: an online dis-
criminative sequence prediction model
based on many-to-many alignments,
which is further augmented by the in-
corporation of joint n-gram features.
Experimental results show improvement
over the results achieved by DIRECTL in
2009. We also explore a number of diverse
resource-free and language-independent
approaches to transliteration mining,
which range from simple to sophisticated.
1 Introduction
Many out-of-vocabulary words in statistical ma-
chine translation and cross-language information
retrieval are named entities. If the languages in
question use different writing scripts, such names
must be transliterated. Transliteration can be de-
fined as the conversion of a word from one writ-
ing script to another, which is usually based on the
phonetics of the original word.
DIRECTL+ is our current approach to name
transliteration which is an extension of the DI-
RECTL system (Jiampojamarn et al, 2009). We
augmented the feature set with joint n-gram fea-
tures which allow the discriminative model to uti-
lize long dependencies of joint information of
source and target substrings (Jiampojamarn et al,
2010). Experimental results suggest an improve-
ment over the results achieved by DIRECTL in
2009.
Transliteration mining aims at automatically
obtaining bilingual lists of names written in differ-
ent scripts. We explore a number of different ap-
proaches to transliteration mining in the context of
the NEWS 2010 Shared Task.1 The sole resource
that is provided for each language pair is a ?seed?
1http://translit.i2r.a-star.edu.sg/
news2010
dataset that contains 1K transliteration word pairs.
The objective is then to mine transliteration pairs
from a collection of Wikipedia titles/topics that are
given in both languages.
We explore a number of diverse resource-free
and language-independent approaches to translit-
eration mining. One approach is to bootstrap the
seed data by generating pseudo-negative exam-
ples, which are combined with the positives to
form a dataset that can be used to train a clas-
sifier. We are particularly interested in achiev-
ing good performance without utilizing language-
specific resources, so that the same approach can
be applied with minimal or no modifications to an
array of diverse language pairs.
This paper is divided in two main parts that cor-
respond to the two tasks of transliteration genera-
tion and transliteration mining.
2 Transliteration generation
The structure of this section is as follows. In Sec-
tion 2.1, we describe the pre-processing steps that
were applied to all datasets. Section 2.2 reviews
two methods for aligning the source and target
symbols in the training data. We provide details
on the DIRECTL+ systems in Section 2.3. In Sec-
tion 2.4, we discuss extensions of DIRECTL+ that
incorporate language-specific information. Sec-
tion 2.5 summarizes our results.
2.1 Pre-processing
For all generation tasks, we pre-process the pro-
vided data as follows. First, we convert all char-
acters in the source word to lower case. Then,
we remove non-alphabetic characters unless they
appear in both the source and target words. We
normalize whitespace that surrounds a comma, so
that there are no spaces before the comma and ex-
actly one space following the comma. Finally, we
separate multi-word titles into single words, using
whitespace as the separator. We assume a mono-
39
tonic matching and ignore the titles that have a dif-
ferent number of words on both sides.
We observed that in the ArAe task there are
cases where an extra space is added to the target
when transliterating from Arabic names to their
English equivalents; e.g., ?Al Riyad?, ?El Sayed?,
etc. In order to prevent the pre-processing from
removing too many title pairs, we allow non-equal
matching if the source title is a single word.
For the English-Chinese (EnCh) task, we con-
vert the English letter ?x? to ?ks? to facilitate bet-
ter matching with its Chinese targets.
During testing, we pre-process test data in the
same manner, except that we do not remove non-
alphabetic characters. After the pre-processing
steps, our system proposes 10-best lists for single
word titles in the test data. For multi-word titles,
we construct 10-best lists by ranking the combina-
tion scores of single words that make up the test
titles.
2.2 Alignment
In the transliteration tasks, training data consist
of pairs of names written in source and target
scripts without explicit character-level alignment.
In our experiments, we applied two different algo-
rithms to automatically generate alignments in the
training data. The generated alignments provide
hypotheses of substring mappings in the training
data. Given aligned training data, a transliteration
model is trained to generate names in the target
language given names in the source language.
The M2M-aligner (Jiampojamarn et al, 2007)
is based on the expectation maximization (EM)
algorithm. It allows us to create alignments be-
tween substrings of various lengths. We opti-
mized the maximum substring sizes for the source
and target based on the performance of the end
task on the development sets. We allowed empty
strings (nulls) only on the target side. We used the
M2M-aligner for all alignment tasks, except for
English-Pinyin alignment. The source code of the
M2M-aligner is publicly available.2
An alternative alignment algorithm is based on
the phonetic similarity of graphemes. The key idea
of this approach is to represent each grapheme by a
phoneme or a sequence of phonemes that is likely
to be represented by the grapheme. The sequences
of phonemes on the source side and the target
side can then be aligned on the basis of phonetic
2http://code.google.com/p/m2m-aligner/
b a r c - l a y
| | | | | | | |
b a - k u r - i
Figure 1: An alignment example.
similarity between phonemes. The main advan-
tage of the phonetic alignment is that it requires
no training data. We use the ALINE phonetic
aligner (Kondrak, 2000), which aligns two strings
of phonemes. The example in Figure 1 shows
the alignment of the word Barclay to its Katakana
transliteration ba-ku-ri. The one-to-one alignment
can then be converted to a many-to-many align-
ment by grouping the Japanese phonemes that cor-
respond to individual Katakana symbols.
2.3 DIRECTL+
We refer to our present approach to transliteration
as DIRECTL+. It is an extension of our DIRECTL
system (Jiampojamarn et al, 2009). It includes ad-
ditional ?joint n-gram? features that allow the dis-
criminative model to correlate longer source and
target substrings. The additional features allow
our discriminative model to train on information
that is present in generative joint n-gram models,
and additionally train on rich source-side context,
transition, and linear-chain features that have been
demonstrated to be important in the transliteration
task (Jiampojamarn et al, 2010).
Our model is based on an online discriminative
framework. At each training iteration, the model
generates an m-best list for each given source
name based on the current feature weights. The
feature weights are updated according to the gold-
standard answers and the generated m-best an-
swer lists using the Margin Infused Relaxed Algo-
rithm (MIRA) (Crammer and Singer, 2003). This
training process iterates over the training examples
until the model converges. For m-best and n-gram
parameters, we set m = 10 and n = 6 for all lan-
guage pairs. These parameters as well as others
were optimized on the development sets.
We trained our models directly on the data
that were provided by the organizers, with three
exceptions. In order to improve performance,
we gave special treatment to English-Korean
(EnKo), English-Chinese (EnCh), and English-
Hindi (EnHi). These special cases are described
in the next section.
40
2.4 Beyond DIRECTL+
2.4.1 Korean Jaso
A Korean syllable can be decomposed into two
or three components called Jaso: an initial con-
sonant, a middle vowel, and optionally a final con-
sonant. The Korean generation for EnKo involves
the following three steps: (1) English-to-Jaso gen-
eration, (2) correction of illegal Jaso sequences,
and (3) Jaso-to-Korean conversion.
In order to correct illegal Jaso sequences that
cannot be combined into Korean syllables in step
2, we consider both vowel and consonant rules.
A Korean vowel can be either a simple vowel or
a complex vowel that combines two simple vow-
els. We can use this information in order to replace
double vowels with one complex vowel. We also
use the silent consonant o (i-eung) when we need
to insert a consonant between double vowels. A
Korean vowel - (eu) is most commonly inserted
between two English consonants in transliteration.
In order to resolve three consecutive consonants, it
can be placed into the most probable position ac-
cording to the probability distribution of the train-
ing data.
2.4.2 Japanese Katakana
In the Japanese Katakana generation task, we re-
place each Katakana symbol with one or two let-
ters using standard romanization tables. This has
the effect of expressing the target side in Latin let-
ters, which facilitates the alignment. DIRECTL+
is trained on the converted data to generate the tar-
get from the source. A post-processing program
then attempts to convert the generated letters back
into Katakana symbols. Sequences of letters that
cannot be converted into Katakana are removed
from the output m-best lists and replaced by lower
scoring sequences that pass the back-conversion
filter. Otherwise, there is usually a single valid
mapping because most Katakana symbols are rep-
resented by single vowels or a consonant-vowel
pair. The only apparent ambiguity involves the
letter n, which can either stand by itself or clus-
ter with the following vowel letter. We resolve the
ambiguity by always assuming the latter case un-
less the letter n occurs at the end of the word.
2.4.3 Chinese Pinyin
Following (Jiampojamarn et al, 2009), we experi-
mented with converting the original Chinese char-
acters to Pinyin as an intermediate representation.
Pinyin is the most commonly known romanization
system for Standard Mandarin and many free tools
are available for converting Chinese characters to
Pinyin. Its alphabet contains the same 26 letters
as English. Each Chinese character can be tran-
scribed phonetically into Pinyin. A small percent-
age of Chinese characters have multiple pronunci-
ations, and are thus represented by different Pinyin
sequences. For those characters, we manually se-
lected the pronunciations that are normally used
for names. This pre-processing step significantly
reduces the size of the target symbols: from 370
distinct Chinese characters to 26 Pinyin symbols.
This allows our system to produce better align-
ments.
We developed three models: (1) trained on the
original Chinese characters, (2) trained on Pinyin,
and (3) the model that incorporates the phonetic
alignment described in Section 2.2. The combi-
nation of the predictions of the different systems
was performed using the following simple algo-
rithm (Jiampojamarn et al, 2009). First, we rank
the individual systems according to their top-1 ac-
curacy on the development set. To obtain the top-
1 prediction for each input word, we use simple
voting, with ties broken according to the ranking
of the systems. We generalize this approach to
handle n-best lists by first ordering the candidate
transliterations according to the rank assigned by
each individual system, and then similarly break-
ing ties by voting and using the ranking of the sys-
tems.
2.4.4 Language identification for Hindi
Bhargava and Kondrak (2010) apply support vec-
tor machines (SVMs) to the task of identifying
the language of names. The intuition here is that
language information can inform transliteration.
Bhargava and Kondrak (2010) test this hypothe-
sis on the NEWS 2009 English-Hindi transliter-
ation data by training language identification on
data manually tagged as being of either Indian or
non-Indian origin. It was found that splitting the
data disjointly into two sets and training separate
transliteration models yields no performance in-
crease due to the decreased size of the data for the
models.
We adopt this approach for the NEWS 2010
task, but here we do not use disjoint splits. In-
stead, we use the SVMs to generate probabilities,
and then we apply a threshold to these probabili-
ties to generate two datasets. For example, if we
set the threshold to be 0.05, then we determine the
41
probabilities of a given name being of Indian ori-
gin (phi) and of being of non-Indian origin (pen).
If phi < 0.05 then the name is excluded from the
Indian set, and if pen < 0.05 then the name is
excluded from the non-Indian set. Using the two
obtained non-disjoint sets, we then train a translit-
eration model for each set using DIRECTL+.
Since the two sets are not disjoint, we must de-
cide how to combine the two results. Given that a
name occurs in both sets, and both models provide
a ranked list of possible targets for that name, we
obtain a combined ranking using a linear combi-
nation over the mean reciprocal ranks (MRRs) of
the two lists. The weights used are phi and pen so
that the more likely a name is considered to be of
Indian origin, the more strongly the result from the
Indian set is considered relative to the result from
the non-Indian set.
2.5 Evaluation
In the context of the NEWS 2010 Machine
Transliteration Shared Task we tested our sys-
tem on all twelve datasets: from English to Chi-
nese (EnCh), Thai (EnTh), Hindi (EnHi), Tamil
(EnTa), Bangla (EnBa), Kannada (EnKa), Ko-
rean Hangul (EnKo), Japanese Katakana (EnJa),
Japanese Kanji (JnJk); and, in the opposite di-
rection, to English from Arabic (ArAe), Chi-
nese (ChEn), and Thai (ThEn). For all datasets,
we trained transliteration models on the provided
training and development sets without additional
resources.
Table 1 shows our best results obtained on the
datasets in terms of top-1 accuracy and mean F-
score. We also include the rank in standard runs
ordered by top-1 word accuracy. The EnCh re-
sult presented in the table refers to the output of
the three-system combination, using the combi-
nation algorithm described in Section 2.4.3. The
respective results for the three component EnCh
systems were: 0.357, 0.360, and 0.363. The
EnJa result in the table refers the system described
in Section 2.4.2 that applied specific treatment
to Japanese Katakana. Based on our develop-
ment results, this specific treatment improves as
much as 2% top-1 accuracy over the language-
independent model. The EnHi system that in-
corporates language identification obtained ex-
actly the same top-1 accuracy as the language-
independent model. However, the EnKo system
with Jaso correction produced the top-1 accu-
Task top-1 F-score Rank
EnCh 0.363 0.707 2
ChEn 0.137 0.740 1
EnTh 0.378 0.866 2
ThEn 0.352 0.861 2
EnHi 0.456 0.884 1
EnTa 0.390 0.891 2
EnKa 0.341 0.867 2
EnJa 0.398 0.791 1
EnKo 0.554 0.770 1
JnJk 0.126 0.426 1
ArAe 0.464 0.924 1
EnBa 0.395 0.877 2
Table 1: Transliteration generation results
racy of 0.554, which is a significant improvement
over 0.387 achieved by the language-independent
model.
3 Transliteration mining
This section is structured as follows. In Sec-
tion 3.1, we describe the method of extracting
transliteration candidates that serves as the input
to the subsequently presented mining approaches.
Two techniques for generating negative exam-
ples are discussed in Section 3.2. Our language-
independent approaches to transliteration mining
are described in Section 3.3, and a technique for
mining English-Chinese pairs is proposed in Sec-
tion 3.4. In Section 3.5, we address the issue of
overlapping predictions. Finally, Section 3.6 and
Section 3.7 summarize our results.
3.1 Extracting transliteration candidates
We cast the transliteration mining task as a bi-
nary classification problem. That is, given a word
in the source language and a word in the target
language, a classifier predicts whether or not the
pair constitutes a valid transliteration. As a pre-
processing step, we extract candidate translitera-
tions from the pairs of Wikipedia titles. Word seg-
mentation is performed based on sequences of one
or more spaces and/or punctuation symbols, which
include hyphens, underscores, brackets, and sev-
eral other non-alphanumeric characters. Apostro-
phes and single quotes are not used for segmenta-
tion (and therefore remain in a given word); how-
ever, all single quote-like characters are converted
into a generic apostrophe. Once an English ti-
tle and its target language counterpart have been
42
segmented into words, we form the candidate set
for this title as the cross product of the two sets
of words after discarding any words that contain
fewer than two characters.
After the candidates have been extracted, indi-
vidual words are flagged for certain attributes that
may be used by our supervised learner as addi-
tional features. Alternatively, the flags may serve
as criteria for filtering the list of candidate pairs
prior to classification. We identify words that are
capitalized, consist of all lowercase (or all capital)
letters, and/or contain one or more digits. We also
attempt to encode each word in the target language
as an ASCII string, and flag that word if the opera-
tion succeeds. This can be used to filter out words
that are written in English on both the source and
target side, which are not transliterations by defi-
nition.
3.2 Generating negative training examples
The main issue with applying a supervised learn-
ing approach to the NEWS 2010 Shared Task is
that annotated task-specific data is not available
to train the system. However, the seed pairs do
provide example transliterations, and these can be
used as positive training examples. The remaining
issue is how to select the negative examples.
We adopt two approaches for selecting nega-
tives. First, we generate all possible source-target
pairs in the seed data, and take as negatives those
pairs which are not transliterations but have a
longest common subsequence ratio (LCSR) above
0.58; this mirrors the approach used by Bergsma
and Kondrak (2007). The method assumes that
the source and target words are written in the same
script (e.g., the foreign word has been romanized).
A second possibility is to generate all seed pair-
ings as above, but then randomly select negative
examples, thus mirroring the approach in Klemen-
tiev and Roth (2006). In this case, the source and
target scripts do not need to be the same. Com-
pared with the LCSR technique, random sampling
in this manner has the potential to produce nega-
tive examples that are very ?easy? (i.e., clearly not
transliterations), and which may be of limited util-
ity when training a classifier. On the other hand, at
test time, the set of candidates extracted from the
Wikipedia data will include pairs that have very
low LCSR scores; hence, it can be argued that dis-
similar pairs should also appear as negative exam-
ples in the training set.
3.3 Language-independent approaches
In this section, we describe methods for transliter-
ation mining that can, in principle, be applied to a
wide variety of language pairs without additional
modification. For the purposes of the Shared Task,
however, we convert all source (English) words to
ASCII by removing diacritics and making appro-
priate substitutions for foreign letters. This is done
to mitigate sparsity in the relatively small seed sets
when training our classifiers.
3.3.1 Alignment-derived romanization
We developed a simple method of performing ro-
manization of foreign scripts. Initially, the seed set
of transliterations is aligned using the one-to-one
option of the M2M-aligner approach (Jiampoja-
marn et al, 2007). We allow nulls on both the
source and target sides. The resulting alignment
model contains pairs of Latin letters and foreign
script symbols (graphemes) sorted by their con-
ditional probability. Then, for each grapheme,
we select a letter (or a null symbol) that has the
highest conditional probability. The process pro-
duces an approximate romanization table that can
be obtained without any knowledge of the target
script. This method of romanization was used by
all methods described in the remainder of Sec-
tion 3.3.
3.3.2 Normalized edit distance
Normalized edit distance (NED) is a measure of
the similarity of two strings. We define a uniform
edit cost for each of the three operations: substitu-
tion, insertion, and deletion. NED is computed by
dividing the minimum edit distance by the length
of the longer string, and subtracting the resulting
fraction from 1. Thus, the extreme values of NED
are 1 for identical strings, and 0 for strings that
have no characters in common.
Our baseline method, NED+ is simply the NED
measure augmented with filtering of the candidate
pairs described in Section 3.1. In order to address
the issue of morphological variants, we also fil-
ter out the pairs in which the English word ends
in a consonant and the foreign word ends with a
vowel. With no development set provided, we set
the similarity thresholds for individual languages
on the basis of the average word length in the seed
sets. The values were 0.38, 0.48, 0.52, and 0.58
for Hindi, Arabic, Tamil, and Russian, respec-
tively, with the last number taken from Bergsma
and Kondrak (2007).
43
3.3.3 Alignment-based string similarity
NED selects transliteration candidates when the
romanized foreign strings have high character
overlap with their English counterparts. The mea-
sure is independent of the language pair. This
is suboptimal for several reasons. First of all,
phonetically unrelated words can share many in-
cidental character matches. For example, the
French word ?recettes? and the English word
?proceeds? share the letters r,c,e,e,s as a com-
mon subsequence, but the words are phonetically
unrelated. Secondly, many reliable, recurrent,
language-specific substring matches are prevalent
in true transliterations. These pairings may or may
not involve matching characters. NED can not
learn or adapt to these language-specific patterns.
In light of these drawbacks, researchers have
proposed string similarity measures that can learn
from provided example pairs and adapt the simi-
larity function to a specific task (Ristad and Yiani-
los, 1998; Bilenko and Mooney, 2003; McCallum
et al, 2005; Klementiev and Roth, 2006).
One particularly successful approach is by
Bergsma and Kondrak (2007), who use discrim-
inative learning with an improved feature repre-
sentation. The features are substring pairs that are
consistent with a character-level alignment of the
two strings. This approach strongly improved per-
formance on cognate identification, while varia-
tions of it have also proven successful in transliter-
ation discovery (Goldwasser and Roth, 2008). We
therefore adopted this approach for the translitera-
tion mining task.
We produce negative training examples using
the LCSR threshold approach described in Sec-
tion 3.2. For features, we extract from the aligned
word pairs all substring pairs up to a maximum
length of three. We also append characters mark-
ing the beginning and end of words, as described
in Bergsma and Kondrak (2007). For our clas-
sifier, we use a Support Vector Machine (SVM)
training with the very efficient LIBLINEAR pack-
age (Fan et al, 2008). We optimize the SVM?s
regularization parameter using 10-fold cross vali-
dation on the generated training data. At test time,
we apply our classifier to all the transliteration
candidates extracted from the Wikipedia titles,
generating transliteration pairs whenever there is
a positive classification.
3.3.4 String kernel classifier
The alignment-based classifier described in the
preceding section is limited to using substring fea-
tures that are up to (roughly) three or four letters
in length, due to the combinatorial explosion in the
number of unique features as the substring length
increases. It is natural to ask whether longer sub-
strings can be utilized to learn a more accurate pre-
dictor.
This question inspired the development of a sec-
ond SVM-based learner that uses a string kernel,
and therefore does not have to explicitly repre-
sent feature vectors. Our kernel is a standard n-
gram (or spectrum) kernel that implicitly embeds
a string in a feature space that has one co-ordinate
for each unique n-gram (see, e.g., (Shawe-Taylor
and Cristianini, 2004)). Let us denote the alphabet
over input strings as A. Given two input strings x
and x?, this kernel function computes:
k(x, x?) =
?
s?An
#(s, x)#(s, x?)
where s is an n-gram and #(a, b) counts the num-
ber of times a appears as a substring of b.
An extension of the n-gram kernel that we em-
ploy here is to consider all n-grams of length
1 ? n ? k, and weight each n-gram as a func-
tion of its length. In particular, we specify a value
? and weight each n-gram by a factor of ?n. We
implemented this kernel in the LIBSVM software
package (Chang and Lin, 2001). Optimal values
for k, ?, and the SVM?s regularization parame-
ter were estimated for each dataset using 5-fold
cross-validation. The values of (k, ?) that we ul-
timately used were: EnAr (3, 0.8), EnHi (8, 0.8),
EnRu (5, 1.2), and EnTa (5, 1.0).
Our input string representation for a candidate
pair is formed by first aligning the source and tar-
get words using M2M-aligner (Jiampojamarn et
al., 2007). Specifically, an alignment model is
trained on the seed examples, which are subse-
quently aligned and used as positive training ex-
amples. We then generate 20K negative examples
by random sampling (cf. Section 3.2) and apply
the alignment model to this set. Not all of these
20K word pairs will necessarily be aligned; we
randomly select 10K of the successfully aligned
pairs to use as negative examples in the training
set.
Each aligned pair is converted into an ?align-
ment string? by placing the letters that appear in
44
Word pair zubtsov z u b ov
Aligned pair z|u|b|t|s|o|v| z|u|b|| |o|v|
Align?t string zz|uu|bb|t|s |oo|vv
Table 2: An example showing how an alignment
string (the input representation for the string ker-
nel) is created from a word pair.
the same position in the source and target next to
one another, while retaining the separator charac-
ters (see Table 2). We also appended beginning
and end of word markers. Note that no romaniza-
tion of the target words is necessary for this pro-
cedure.
At test time, we apply the alignment model to
the candidate word pairs that have been extracted
from the train data, and retain all the successfully
aligned pairs. Here, M2M-aligner also acts as a
filter, since we cannot form alignment strings from
unaligned pairs ? these yield negative predictions
by default. We also filter out pairs that met any of
the following conditions: 1) the English word con-
sists of all all capital or lowercase letters, 2) the
target word can be converted to ASCII (cf. Sec-
tion 3.1), or 3) either word contains a digit.
3.3.5 Generation-based approach
In the mining tasks, we are interested in whether a
candidate pair (x, y) is a transliteration pair. One
approach is to determine if the generated translit-
erations of a source word y? = ?(x) and a target
word x? = ?(y) are similar to the given candi-
date pair. We applied DIRECTL+ to the mining
tasks by training transliteration generation models
on the provided seed data in forward and back-
ward transliteration directions, creating ?(x) and
?(y) models. We now define a transliteration
score function in Eq. 1. N(x?, x) is the normal-
ized edit distance between string x? and x, and w1
and w2 are combination weights to favor forward
and backward transliteration models.
S(x, y) = w1 ? N(y?, y) + w2 ? N(x?, x)w1 + w2
(1)
A candidate pair is considered a transliteration
pair if its S(x, y) > ? . Ideally, we would like
to optimize these parameters, ?, w1, w2 based on
a development set for each language pair. Unfor-
tunately, no development sets were provided for
the Shared Task. Therefore, following Bergsma
and Kondrak (2007), we adopt the threshold of
? = 0.58. We experimented with three sets of val-
ues for w1 and w2: (1, 0), (0.5, 0.5), and (0, 1).
Our final predictions were made using w0 = 0
and w1 = 1, which appeared to produce the best
results. Thus, only the backward transliteration
model was ultimately employed.
3.4 English-Chinese string matching
Due to the fact that names transliterated into Chi-
nese consist of multiple Chinese characters and
that the Chinese text provided in this shared task
is not segmented, we have to adopt a different ap-
proach to the English-Chinese mining task (Unlike
many other languages, there are no clear bound-
aries between Chinese words). We first train a
generation model using the seed data and then ap-
ply a greedy string matching algorithm to extract
transliteration pairs.
The generation model is built using the discrim-
inative training framework described in (Jiampoja-
marn et al, 2008). Two models are learned: one
is trained using English and Chinese characters,
while the other is trained on English and Pinyin (a
standard phonetic representation of Chinese char-
acters). In order to mine transliteration pairs from
Wikipedia titles, we first use the generation model
to produce transliterations for each English token
on the source side as both Chinese characters and
Pinyin. The generated Chinese characters are ul-
timately converted to Pinyin during string match-
ing. We also convert all the Chinese characters on
the target side to their Pinyin representations when
performing string matching.
The transliteration pairs are then mined by com-
bining two different strategies. First of all, we ob-
serve that most of the titles that contain a separa-
tion symbol ? ? ? on the target side are translit-
erations. In this case, the number of tokens on
both sides is often equal. Therefore, the mining
task can be formulated as a matching problem.
We use a competitive linking approach (Melamed,
2000) to find the best match. First, we select
links between all possible pairs if similarity of
strings on both sides is above a threshold (0.6 ?
length(Pinyin)). We then greedily extract the
pairs with highest similarity until the number of
unextracted segments on either side becomes zero.
The problem becomes harder when there is no
indication of word segmentation for Chinese. In-
stead of trying to segment the Chinese characters
first, we use an incremental string matching strat-
45
egy. For each token on the source side, the algo-
rithm calculates its similarity with all possible n-
grams (2 ? n ? L) on the target side, where L
is the length of the Chinese title (i.e., the number
of characters). If the similarity score of n-gram
with the highest similarity surpasses a threshold
(0.5 ? length(Pinyin)), the n-gram sequence is
proposed as a possible transliteration for the cur-
rent source token.
3.5 Resolving overlapping predictions
Given a set of candidate word pairs that have been
extracted from a given Wikipedia title according to
the procedure described in Section 3.1, our clas-
sifiers predict a class label for each pair inde-
pendently of the others. Pairs that receive neg-
ative predictions are discarded immediately and
are never reported as mined pairs. However, it
is sometimes necessary to arbitrate between pos-
itive predictions, since it is possible for a classifier
to mark as transliterations two or more pairs that
involve the same English word or the same target
word in the title. Clearly, mining multiple overlap-
ping pairs will lower the system?s precision, since
there is (presumably) at most one correct translit-
eration in the target language version of the title
for each English word.3
Our solution is to apply a greedy algorithm that
sorts the word pair predictions for a given title
in descending order according to the scores that
were assigned by the classifier. We make one pass
through the sorted list and report a pair of words as
a mined pair unless the English word or the target
language word has already been reported (for this
particular title).4
3.6 Results
In the context of the NEWS 2010 Shared Task
on Transliteration Generation we tested our sys-
tem on all five data sets: from English to Rus-
sian (EnRu), Hindi (EnHi), Tamil (EnTa), Arabic
(EnAr), and Chinese (EnCh). The EnCh set dif-
fers from the remaining sets in the lack of transpar-
ent word segmentation on the Chinese side. There
were no development sets provided for any of the
language pairs.
3On the other hand, mining all such pairs might improve
recall.
4A bug was later discovered in our implementation of this
algorithm, which had failed to add the words in a title?s first
mined pair to the ?already reported? list. This sometimes
caused up to two additional mined pairs per title to be re-
ported in the prediction files that were submitted.
Task System F P R
EnRu NED+ .875 .880 .869
BK-2007 .778 .684 .902
StringKernel* .811 .746 .889
DIRECTL+ .786 .778 .795
EnHi NED+ .907 .875 .941
BK-2007 .882 .883 .880
StringKernel .924 .954 .895
DIRECTL+ .904 .945 .866
EnTa NED+ .791 .916 .696
BK-2007 .829 .808 .852
StringKernel .914 .923 .906
DIRECTL+ .801 .919 .710
EnAr NED+ .800 .818 .783
BK-2007 .816 .834 .798
StringKernel* .827 .917 .753
DIRECTL+ .742 .861 .652
EnCh GreedyMatch .530 .698 .427
DIRECTL+ .009 .045 .005
Table 3: Transliteration mining results. An aster-
isk (*) indicates an unofficial result.
Table 3 shows the results obtained by our var-
ious systems on the final test sets, measured in
terms of F-score (F), precision (P), and recall
(R). The systems referred to as NED+, BK-2007,
StringKernel, DIRECTL+, and GreedyMatch are
described in Section 3.3.2, Section 3.3.3, Sec-
tion 3.3.4, Section 3.3.5, and Section 3.4 respec-
tively. The runs marked with an asterisk (*)
were produced after the Shared Task deadline, and
therefore are not included in the official results.
3.7 Discussion
No fixed ranking of the four approaches emerges
across the four alphabetic language pairs (all ex-
cept EnCh). However, StringKernel appears to be
the most robust, achieving the highest F-score on
three language pairs. This suggests that longer
substring features are indeed useful for classifying
candidate transliteration pairs. The simple NED+
method is a clear winner on EnRu, and obtains de-
cent scores on the remaining alphabetic language
pairs. The generation-based DIRECTL+ approach
ranks no higher than third on any language pair,
and it fails spectacularly on EnCh because of the
word segmentation ambiguity.
Finally, we observe that there are a number of
cases where the results for our discriminatively
trained classifiers, BK-2007 and StringKernel, are
46
not significantly better than those of the simple
NED+ approach. We conjecture that automatically
generating training examples is suboptimal for this
task. A more effective strategy may be to filter all
possible word pairs in the seed data to only those
with NED above a fixed threshold. We would then
apply the same threshold to the Wikipedia candi-
dates, only passing to the classifier those pairs that
surpass the threshold. This would enable a better
match between the training and test operation of
the system.
4 Conclusion
The results obtained in the context of the NEWS
2010 Machine Transliteration Shared Task con-
firm the effectiveness of our discriminative ap-
proaches to transliteration generation and mining.
Acknowledgments
This research was supported by the Alberta Inge-
nuity Fund, Informatics Circle of Research Excel-
lence (iCORE), and the Natural Sciences and En-
gineering Research Council of Canada (NSERC).
References
Shane Bergsma and Grzegorz Kondrak. 2007.
Alignment-based discriminative string similarity. In
Proc. ACL.
Aditya Bhargava and Grzegorz Kondrak. 2010. Lan-
guage identification of names with SVMs. In Proc.
NAACL-HLT.
Mikhail Bilenko and Raymond J. Mooney. 2003.
Adaptive duplicate detection using learnable string
similarity measures. In Proc. KDD.
Chih-Chung Chang and Chih-Jen Lin. 2001. LIB-
SVM: a library for support vector machines.
Software available at http://www.csie.ntu.
edu.tw/?cjlin/libsvm.
Koby Crammer and Yoram Singer. 2003. Ultracon-
servative online algorithms for multiclass problems.
Journal of Machine Learning Research, 3:951?991.
Rong-En Fan, Kai-Wei Chang, Cho-Jui Hsieh, Xiang-
Rui Wang, and Chih-Jen Lin. 2008. LIBLIN-
EAR: A library for large linear classification. JMLR,
9:1871?1874.
Dan Goldwasser and Dan Roth. 2008. Transliteration
as constrained optimization. In Proc. EMNLP.
Sittichai Jiampojamarn, Grzegorz Kondrak, and Tarek
Sherif. 2007. Applying many-to-many alignments
and Hidden Markov Models to letter-to-phoneme
conversion. In Proc. HLT-NAACL.
Sittichai Jiampojamarn, Colin Cherry, and Grzegorz
Kondrak. 2008. Joint processing and discriminative
training for letter-to-phoneme conversion. In Proc.
ACL.
Sittichai Jiampojamarn, Aditya Bhargava, Qing Dou,
Kenneth Dwyer, and Grzegorz Kondrak. 2009. Di-
recTL: a language-independent approach to translit-
eration. In NEWS ?09: Proceedings of the 2009
Named Entities Workshop: Shared Task on Translit-
eration, pages 28?31.
Sittichai Jiampojamarn, Colin Cherry, and Grzegorz
Kondrak. 2010. Integrating joint n-gram features
into a discriminative training framework. In Proc.
NAACL-HLT.
Alexandre Klementiev and Dan Roth. 2006. Named
entity transliteration and discovery from multilin-
gual comparable corpora. In Proc. HLT-NAACL.
Grzegorz Kondrak. 2000. A new algorithm for the
alignment of phonetic sequences. In Proc. NAACL,
pages 288?295.
Andrew McCallum, Kedar Bellare, and Fernando
Pereira. 2005. A conditional random field for
discriminatively-trained finite-state string edit dis-
tance. In Proc. UAI.
I. Dan Melamed. 2000. Models of translational equiv-
alence among words. Computational Linguistics,
26(2):221?249.
Eric Sven Ristad and Peter N. Yianilos. 1998. Learn-
ing string-edit distance. IEEE Trans. Pattern Analy-
sis and Machine Intelligence, 20(5).
John Shawe-Taylor and Nello Cristianini. 2004. Ker-
nel Methods for Pattern Analysis. Cambridge Uni-
versity Press.
47
