Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 55?63,
Suntec, Singapore, 2-7 August 2009. c?2009 ACL and AFNLP
Cross Language Dependency Parsing using a Bilingual Lexicon?
Hai Zhao(??)??, Yan Song(??)?, Chunyu Kit?, Guodong Zhou?
?Department of Chinese, Translation and Linguistics
City University of Hong Kong
83 Tat Chee Avenue, Kowloon, Hong Kong, China
?School of Computer Science and Technology
Soochow University, Suzhou, China 215006
{haizhao,yansong,ctckit}@cityu.edu.hk, gdzhou@suda.edu.cn
Abstract
This paper proposes an approach to en-
hance dependency parsing in a language
by using a translated treebank from an-
other language. A simple statistical ma-
chine translation method, word-by-word
decoding, where not a parallel corpus but
a bilingual lexicon is necessary, is adopted
for the treebank translation. Using an en-
semble method, the key information ex-
tracted from word pairs with dependency
relations in the translated text is effectively
integrated into the parser for the target lan-
guage. The proposed method is evaluated
in English and Chinese treebanks. It is
shown that a translated English treebank
helps a Chinese parser obtain a state-of-
the-art result.
1 Introduction
Although supervised learning methods bring state-
of-the-art outcome for dependency parser infer-
ring (McDonald et al, 2005; Hall et al, 2007), a
large enough data set is often required for specific
parsing accuracy according to this type of meth-
ods. However, to annotate syntactic structure, ei-
ther phrase- or dependency-based, is a costly job.
Until now, the largest treebanks1 in various lan-
guages for syntax learning are with around one
million words (or some other similar units). Lim-
ited data stand in the way of further performance
enhancement. This is the case for each individual
language at least. But, this is not the case as we
observe all treebanks in different languages as a
whole. For example, of ten treebanks for CoNLL-
2007 shared task, none includes more than 500K
?The study is partially supported by City University of
Hong Kong through the Strategic Research Grant 7002037
and 7002388. The first author is sponsored by a research fel-
lowship from CTL, City University of Hong Kong.
1It is a tradition to call an annotated syntactic corpus as
treebank in parsing community.
tokens, while the sum of tokens from all treebanks
is about two million (Nivre et al, 2007).
As different human languages or treebanks
should share something common, this makes it
possible to let dependency parsing in multiple lan-
guages be beneficial with each other. In this pa-
per, we study how to improve dependency parsing
by using (automatically) translated texts attached
with transformed dependency information. As a
case study, we consider how to enhance a Chinese
dependency parser by using a translated English
treebank. What our method relies on is not the
close relation of the chosen language pair but the
similarity of two treebanks, this is the most differ-
ent from the previous work.
Two main obstacles are supposed to confront in
a cross-language dependency parsing task. The
first is the cost of translation. Machine translation
has been shown one of the most expensive lan-
guage processing tasks, as a great deal of time and
space is required to perform this task. In addition,
a standard statistical machine translation method
based on a parallel corpus will not work effec-
tively if it is not able to find a parallel corpus that
right covers source and target treebanks. How-
ever, dependency parsing focuses on the relations
of word pairs, this allows us to use a dictionary-
based translation without assuming a parallel cor-
pus available, and the training stage of translation
may be ignored and the decoding will be quite fast
in this case. The second difficulty is that the out-
puts of translation are hardly qualified for the pars-
ing purpose. The most challenge in this aspect is
morphological preprocessing. We regard that the
morphological issue should be handled aiming at
the specific language, our solution here is to use
character-level features for a target language like
Chinese.
The rest of the paper is organized as follows.
The next section presents some related existing
work. Section 3 describes the procedure on tree-
55
bank translation and dependency transformation.
Section 4 describes a dependency parser for Chi-
nese as a baseline. Section 5 describes how a
parser can be strengthened from the translated
treebank. The experimental results are reported in
Section 6. Section 7 looks into a few issues con-
cerning the conditions that the proposed approach
is suitable for. Section 8 concludes the paper.
2 The Related Work
As this work is about exploiting extra resources to
enhance an existing parser, it is related to domain
adaption for parsing that has been draw some in-
terests in recent years. Typical domain adaptation
tasks often assume annotated data in new domain
absent or insufficient and a large scale unlabeled
data available. As unlabeled data are concerned,
semi-supervised or unsupervised methods will be
naturally adopted. In previous works, two basic
types of methods can be identified to enhance an
existing parser from additional resources. The first
is usually focus on exploiting automatic generated
labeled data from the unlabeled data (Steedman
et al, 2003; McClosky et al, 2006; Reichart and
Rappoport, 2007; Sagae and Tsujii, 2007; Chen
et al, 2008), the second is on combining super-
vised and unsupervised methods, and only unla-
beled data are considered (Smith and Eisner, 2006;
Wang and Schuurmans, 2008; Koo et al, 2008).
Our purpose in this study is to obtain a further
performance enhancement by exploiting treebanks
in other languages. This is similar to the above
first type of methods, some assistant data should
be automatically generated for the subsequent pro-
cessing. The differences are what type of data are
concerned with and how they are produced. In our
method, a machine translation method is applied
to tackle golden-standard treebank, while all the
previous works focus on the unlabeled data.
Although cross-language technique has been
used in other natural language processing tasks,
it is basically new for syntactic parsing as few
works were concerned with this issue. The rea-
son is straightforward, syntactic structure is too
complicated to be properly translated and the cost
of translation cannot be afforded in many cases.
However, we empirically find this difficulty may
be dramatically alleviated as dependencies rather
than phrases are used for syntactic structure repre-
sentation. Even the translation outputs are not so
good as the expected, a dependency parser for the
target language can effectively make use of them
by only considering the most related information
extracted from the translated text.
The basic idea to support this work is to make
use of the semantic connection between different
languages. In this sense, it is related to the work of
(Merlo et al, 2002) and (Burkett and Klein, 2008).
The former showed that complementary informa-
tion about English verbs can be extracted from
their translations in a second language (Chinese)
and the use of multilingual features improves clas-
sification performance of the English verbs. The
latter iteratively trained a model to maximize the
marginal likelihood of tree pairs, with alignments
treated as latent variables, and then jointly parsing
bilingual sentences in a translation pair. The pro-
posed parser using features from monolingual and
mutual constraints helped its log-linear model to
achieve better performance for both monolingual
parsers and machine translation system. In this
work, cross-language features will be also adopted
as the latter work. However, although it is not es-
sentially different, we only focus on dependency
parsing itself, while the parsing scheme in (Bur-
kett and Klein, 2008) based on a constituent rep-
resentation.
Among of existing works that we are aware of,
we regard that the most similar one to ours is (Ze-
man and Resnik, 2008), who adapted a parser to a
new language that is much poorer in linguistic re-
sources than the source language. However, there
are two main differences between their work and
ours. The first is that they considered a pair of suf-
ficiently related languages, Danish and Swedish,
and made full use of the similar characteristics of
two languages. Here we consider two quite dif-
ferent languages, English and Chinese. As fewer
language properties are concerned, our approach
holds the more possibility to be extended to other
language pairs than theirs. The second is that a
parallel corpus is required for their work and a
strict statistical machine translation procedure was
performed, while our approach holds a merit of
simplicity as only a bilingual lexicon is required.
3 Treebank Translation and Dependency
Transformation
3.1 Data
As a case study, this work will be conducted be-
tween the source language, English, and the tar-
get language, Chinese, namely, we will investigate
56
how a translated English treebank enhances a Chi-
nese dependency parser.
For English data, the Penn Treebank (PTB) 3
is used. The constituency structures is converted
to dependency trees by using the same rules as
(Yamada and Matsumoto, 2003) and the standard
training/development/test split is used. However,
only training corpus (sections 2-21) is used for
this study. For Chinese data, the Chinese Treebank
(CTB) version 4.0 is used in our experiments. The
same rules for conversion and the same data split
is adopted as (Wang et al, 2007): files 1-270 and
400-931 as training, 271-300 as testing and files
301-325 as development. We use the gold stan-
dard segmentation and part-of-speech (POS) tags
in both treebanks.
As a bilingual lexicon is required for our task
and none of existing lexicons are suitable for trans-
lating PTB, two lexicons, LDC Chinese-English
Translation Lexicon Version 2.0 (LDC2002L27),
and an English to Chinese lexicon in StarDict2,
are conflated, with some necessary manual exten-
sions, to cover 99% words appearing in the PTB
(the most part of the untranslated words are named
entities.). This lexicon includes 123K entries.
3.2 Translation
A word-by-word statistical machine translation
strategy is adopted to translate words attached
with the respective dependency information from
the source language to the target one. In detail, a
word-based decoding is used, which adopts a log-
linear framework as in (Och and Ney, 2002) with
only two features, translation model and language
model,
P (c|e) = exp[
?2
i=1 ?ihi(c, e)]?
c exp[
?2
i=1 ?ihi(c, e)]
Where
h1(c, e) = log(p?(c|e))
is the translation model, which is converted from
the bilingual lexicon, and
h2(c, e) = log(p?(c))
is the language model, a word trigram model
trained from the CTB. In our experiment, we set
two weights ?1 = ?2 = 1.
2StarDict is an open source dictionary software, available
at http://stardict.sourceforge.net/.
The conversion process of the source treebank
is completed by three steps as the following:
1. Bind POS tag and dependency relation of a
word with itself;
2. Translate the PTB text into Chinese word by
word. Since we use a lexicon rather than a parallel
corpus to estimate the translation probabilities, we
simply assign uniform probabilities to all transla-
tion options. Thus the decoding process is actu-
ally only determined by the language model. Sim-
ilar to the ?bag translation? experiment in (Brown
et al, 1990), the candidate target sentences made
up by a sequence of the optional target words are
ranked by the trigram language model. The output
sentence will be generated only if it is with maxi-
mum probability as follows,
c = argmax{p?(c)p?(c|e)}
= argmax p?(c)
= argmax
?
p?(wc)
A beam search algorithm is used for this process
to find the best path from all the translation op-
tions; As the training stage, especially, the most
time-consuming alignment sub-stage, is skipped,
the translation only includes a decoding procedure
that takes about 4.5 hours for about one million
words of the PTB in a 2.8GHz PC.
3. After the target sentence is generated, the at-
tached POS tags and dependency information of
each English word will also be transferred to each
corresponding Chinese word. As word order is of-
ten changed after translation, the pointer of each
dependency relationship, represented by a serial
number, should be re-calculated.
Although we try to perform an exact word-by-
word translation, this aim cannot be fully reached
in fact, as the following case is frequently encoun-
tered, multiple English words have to be translated
into one Chinese word. To solve this problem,
we use a policy that lets the output Chinese word
only inherits the attached information of the high-
est syntactic head in the original multiple English
words.
4 Dependency Parsing: Baseline
4.1 Learning Model and Features
According to (McDonald and Nivre, 2007), all
data-driven models for dependency parsing that
have been proposed in recent years can be de-
scribed as either graph-based or transition-based.
57
Table 1: Feature Notations
Notation Meaning
s The word in the top of stack
s? The first word below the top of stack.
s?1,s1... The first word before(after) the word
in the top of stack.
i, i+1,... The first (second) word in the
unprocessed sequence, etc.
dir Dependent direction
h Head
lm Leftmost child
rm Rightmost child
rn Right nearest child
form word form
pos POS tag of word
cpos1 coarse POS: the first letter of POS tag of word
cpos2 coarse POS: the first two POS tags of word
lnverb the left nearest verb
char1 The first character of a word
char2 The first two characters of a word
char?1 The last character of a word
char?2 The last two characters of a word
. ?s, i.e., ?s.dprel? means dependent label
of character in the top of stack
+ Feature combination, i.e., ?s.char+i.char?
means both s.char and i.char work as a
feature function.
Although the former will be also used as compari-
son, the latter is chosen as the main parsing frame-
work by this study for the sake of efficiency. In de-
tail, a shift-reduce method is adopted as in (Nivre,
2003), where a classifier is used to make a parsing
decision step by step. In each step, the classifier
checks a word pair, namely, s, the top of a stack
that consists of the processed words, and, i, the
first word in the (input) unprocessed sequence, to
determine if a dependent relation should be estab-
lished between them. Besides two dependency arc
building actions, a shift action and a reduce ac-
tion are also defined to maintain the stack and the
unprocessed sequence. In this work, we adopt a
left-to-right arc-eager parsing model, that means
that the parser scans the input sequence from left
to right and right dependents are attached to their
heads as soon as possible (Hall et al, 2007).
While memory-based and margin-based learn-
ing approaches such as support vector machines
are popularly applied to shift-reduce parsing, we
apply maximum entropy model as the learning
model for efficient training and adopting over-
lapped features as our work in (Zhao and Kit,
2008), especially, those character-level ones for
Chinese parsing. Our implementation of maxi-
mum entropy adopts L-BFGS algorithm for pa-
rameter optimization as usual.
With notations defined in Table 1, a feature set
as shown in Table 2 is adopted. Here, we explain
some terms in Tables 1 and 2. We used a large
scale feature selection approach as in (Zhao et al,
2009) to obtain the feature set in Table 2. Some
feature notations in this paper are also borrowed
from that work.
The feature curroot returns the root of a par-
tial parsing tree that includes a specified node.
The feature charseq returns a character sequence
whose members are collected from all identified
children for a specified word.
In Table 2, as for concatenating multiple sub-
strings into a feature string, there are two ways,
seq and bag. The former is to concatenate all sub-
strings without do something special. The latter
will remove all duplicated substrings, sort the rest
and concatenate all at last.
Note that we systemically use a group of
character-level features. Surprisingly, as to our
best knowledge, this is the first report on using this
type of features in Chinese dependency parsing.
Although (McDonald et al, 2005) used the pre-
fix of each word form instead of word form itself
as features, character-level features here for Chi-
nese is essentially different from that. As Chinese
is basically a character-based written language.
Character plays an important role in many means,
most characters can be formed as single-character
words, and Chinese itself is character-order free
rather than word-order free to some extent. In ad-
dition, there is often a close connection between
the meaning of a Chinese word and its first or last
character.
4.2 Parsing using a Beam Search Algorithm
In Table 2, the feature preactn returns the previous
parsing action type, and the subscript n stands for
the action order before the current action. These
are a group of Markovian features. Without this
type of features, a shift-reduce parser may directly
scan through an input sequence in linear time.
Otherwise, following the work of (Duan et al,
2007) and (Zhao, 2009), the parsing algorithm is
to search a parsing action sequence with the max-
imal probability.
Sdi = argmax
?
i
p(di|di?1di?2...),
where Sdi is the object parsing action sequence,
p(di|di?1...) is the conditional probability, and di
58
Figure 1: A comparison before and after translation
Table 2: Features for Parsing
in.form, n = 0, 1
i.form + i1.form
in.char2 + in+1.char2, n = ?1, 0
i.char?1 + i1.char?1
in.char?2 n = 0, 3
i1.char?2 + i2.char?2 +i3.char?2
i.lnverb.char?2
i3.pos
in.pos + in+1.pos, n = 0, 1
i?2.cpos1 + i?1.cpos1
i1.cpos1 + i2.cpos1 + i3.cpos1
s?2.char1
s?.char?2 + s?1.char?2
s??2.cpos2
s??1.cpos2 + s?1.cpos2
s?.cpos2 + s?1.cpos2
s?.children.cpos2.seq
s?.children.dprel.seq
s?.subtree.depth
s?.h.form + s?.rm.cpos1
s?.lm.char2 + s?.char2
s.h.children.dprel.seq
s.lm.dprel
s.char?2 + i1.char?2
s.charn + i.charn, n = ?1, 1
s?1.pos + i1.pos
s.pos + in.pos, n = ?1, 0, 1
s : i|linePath.form.bag
s?.form + i.form
s?.char2 + in.char2, n = ?1, 0, 1
s.curroot.pos + i.pos
s.curroot.char2 + i.char2
s.children.cpos2.seq + i.children.cpos2.seq
s.children.cpos2.seq + i.children.cpos2.seq
+ s.cpos2 + i.cpos2
s?.children.dprel.seq + i.children.dprel.seq
preact?1
preact?2
preact?2+preact?1
is i-th parsing action. We use a beam search algo-
rithm to find the object parsing action sequence.
5 Exploiting the Translated Treebank
As we cannot expect too much for a word-by-word
translation, only word pairs with dependency rela-
tion in translated text are extracted as useful and
reliable information. Then some features based
on a query in these word pairs according to the
current parsing state (namely, words in the cur-
rent stack and input) will be derived to enhance
the Chinese parser.
A translation sample can be seen in Figure 1.
Although most words are satisfactorily translated,
to generate effective features, what we still have to
consider at first is the inconsistence between the
translated text and the target text.
In Chinese, word lemma is always its word form
itself, this is a convenient characteristic in com-
putational linguistics and makes lemma features
unnecessary for Chinese parsing at all. However,
Chinese has a special primary processing task, i.e.,
word segmentation. Unfortunately, word defini-
tions for Chinese are not consistent in various lin-
guistical views, for example, seven segmentation
conventions for computational purpose are for-
mally proposed since the first Bakeoff3.
Note that CTB or any other Chinese treebank
has its own word segmentation guideline. Chi-
nese word should be strictly segmented according
to the guideline before POS tags and dependency
relations are annotated. However, as we say the
3Bakeoff is a Chinese processing share task held by
SIGHAN.
59
English treebank is translated into Chinese word
by word, Chinese words in the translated text are
exactly some entries from the bilingual lexicon,
they are actually irregular phrases, short sentences
or something else rather than words that follows
any existing word segmentation convention. If the
bilingual lexicon is not carefully selected or re-
fined according to the treebank where the Chinese
parser is trained from, then there will be a serious
inconsistence on word segmentation conventions
between the translated and the target treebanks.
As all concerned feature values here are calcu-
lated from the searching result in the translated
word pair list according to the current parsing
state, and a complete and exact match cannot be
always expected, our solution to the above seg-
mentation issue is using a partial matching strat-
egy based on characters that the words include.
Above all, a translated word pair list, L, is ex-
tracted from the translated treebank. Each item in
the list consists of three elements, dependant word
(dp), head word (hd) and the frequency of this pair
in the translated treebank, f .
There are two basic strategies to organize the
features derived from the translated word pair list.
The first is to find the most matching word pair
in the list and extract some properties from it,
such as the matched length, part-of-speech tags
and so on, to generate features. Note that a
matching priority serial should be defined afore-
hand in this case. The second is to check every
matching models between the current parsing state
and the partially matched word pair. In an early
version of our approach, the former was imple-
mented. However, It is proven to be quite inef-
ficient in computation. Thus we adopt the sec-
ond strategy at last. Two matching model fea-
ture functions, ?(?) and ?(?), are correspondingly
defined as follows. The return value of ?(?) or
?(?) is the logarithmic frequency of the matched
item. There are four input parameters required
by the function ?(?). Two parameters of them
are about which part of the stack(input) words is
chosen, and other two are about which part of
each item in the translated word pair is chosen.
These parameters could be set to full or charn as
shown in Table 1, where n = ...,?2,?1, 1, 2, ....
For example, a possible feature could be
?(s.full, i.char1, dp.full, hd.char1), it tries to
find a match in L by comparing stack word and
dp word, and the first character of input word
Table 3: Features based on the translated treebank
?(i.char3, s?.full, dp.char3, hd.full)+i.char3
+s?.form
?(i.char3, s.char2, dp.char3, hd.char2)+s.char2
?(i.char3, s.full, dp.char3, hd.char2)+s.form
?(s?.char?2, hd.char?2, head)+i.pos+s?.pos
?(i.char3, s.full, dp.char3, hd.char2)+s.full
?(s?.full, i.char4, dp.full, hd.char4)+s?.pos+i.pos
?(i.full, hd.char2, root)+i.pos+s.pos
?(i.full, hd.char2, root)+i.pos+s?.pos
?(s.full, dp.full, dependant)+i.pos
pairscore(s?.pos, i.pos)+s?.form+i.form
rootscore(s?.pos)+s?.form+i.form
rootscore(s?.pos)+i.pos
and the first character of hd word. If such
a match item in L is found, then ?(?) returns
log(f). There are three input parameters required
by the function ?(?). One parameter is about
which part of the stack(input) words is chosen,
and the other is about which part of each item
in the translated word pair is chosen. The third
is about the matching type that may be set to
dependant, head, or root. For example, the
function ?(i.char1, hd.full, root) tries to find a
match in L by comparing the first character of in-
put word and the whole dp word. If such a match
item in L is found, then ?(?) returns log(f) as hd
occurs as ROOT f times.
As having observed that CTB and PTB share a
similar POS guideline. A POS pair list from PTB
is also extract. Two types of features, rootscore
and pairscore are used to make use of such infor-
mation. Both of them returns the logarithmic value
of the frequency for a given dependent event. The
difference is, rootscore counts for the given POS
tag occurring as ROOT, and pairscore counts for
two POS tag combination occurring for a depen-
dent relationship.
A full adapted feature list that is derived from
the translated word pairs is in Table 3.
6 Evaluation Results
The quality of the parser is measured by the pars-
ing accuracy or the unlabeled attachment score
(UAS), i.e., the percentage of tokens with correct
head. Two types of scores are reported for compar-
ison: ?UAS without p? is the UAS score without
all punctuation tokens and ?UAS with p? is the one
with all punctuation tokens.
The results with different feature sets are in Ta-
ble 4. As the features preactn are involved, a
60
beam search algorithm with width 5 is used for
parsing, otherwise, a simple shift-reduce decoding
is used. It is observed that the features derived
from the translated text bring a significant perfor-
mance improvement as high as 1.3%.
Table 4: The results with different feature sets
features with p without p
baseline -d 0.846 0.858
+da 0.848 0.860
+Tb -d 0.859 0.869
+d 0.861 0.870
a+d: using three Markovian features preact and
beam search decoding.
b+T: using features derived from the translated text
as in Table 3.
To compare our parser to the state-of-the-art
counterparts, we use the same testing data as
(Wang et al, 2005) did, selecting the sentences
length up to 40. Table 5 shows the results achieved
by other researchers and ours (UAS with p), which
indicates that our parser outperforms any other
ones 4. However, our results is only slightly better
than that of (Chen et al, 2008) as only sentences
whose lengths are less than 40 are considered. As
our full result is much better than the latter, this
comparison indicates that our approach improves
the performance for those longer sentences.
Table 5: Comparison against the state-of-the-art
full up to 40
(McDonald and Pereira, 2006)a - 0.825
(Wang et al, 2007) - 0.866
(Chen et al, 2008) 0.852 0.884
Ours 0.861 0.889
aThis results was reported in (Wang et al, 2007).
The experimental results in (McDonald and
Nivre, 2007) show a negative impact on the pars-
ing accuracy from too long dependency relation.
For the proposed method, the improvement rela-
tive to dependency length is shown in Figure 2.
From the figure, it is seen that our method gives
observable better performance when dependency
lengths are larger than 4. Although word order is
changed, the results here show that the useful in-
formation from the translated treebank still help
those long distance dependencies.
4There is a slight exception: using the same data splitting,
(Yu et al, 2008) reported UAS without p as 0.873 versus ours,
0.870.
1 4 7 10 13 16 19
0.4
0.5
0.6
0.7
0.8
0.9
1
 Dependency Length
 
F1
basline: +d
+T: +d
Figure 2: Performance vs. dependency length
7 Discussion
If a treebank in the source language can help im-
prove parsing in the target language, then there
must be something common between these two
languages, or more precisely, these two corre-
sponding treebanks. (Zeman and Resnik, 2008)
assumed that the morphology and syntax in the
language pair should be very similar, and that is
so for the language pair that they considered, Dan-
ish and Swedish, two very close north European
languages. Thus it is somewhat surprising that
we show a translated English treebank may help
Chinese parsing, as English and Chinese even be-
long to two different language systems. However,
it will not be so strange if we recognize that PTB
and CTB share very similar guidelines on POS and
syntactics annotation. Since it will be too abstract
in discussing the details of the annotation guide-
lines, we look into the similarities of two treebanks
from the matching degree of two word pair lists.
The reason is that the effectiveness of the proposed
method actually relies on how many word pairs at
every parsing states can find their full or partial
matched partners in the translated word pair list.
Table 6 shows such a statistics on the matching
degree distribution from all training samples for
Chinese parsing. The statistics in the table suggest
that most to-be-check word pairs during parsing
have a full or partial hitting in the translated word
pair list. The latter then obtains an opportunity to
provide a great deal of useful guideline informa-
tion to help determine how the former should be
tackled. Therefore we have cause for attributing
the effectiveness of the proposed method to the
similarity of these two treebanks. From Table 6,
61
we also find that the partial matching strategy de-
fined in Section 5 plays a very important role in
improving the whole matching degree. Note that
our approach is not too related to the characteris-
tics of two languages. Our discussion here brings
an interesting issue, which difference is more im-
portant in cross language processing, between two
languages themselves or the corresponding anno-
tated corpora? This may be extensively discussed
in the future work.
Table 6: Matching degree distribution
dependant-match head-match Percent (%)
None None 9.6
None Partial 16.2
None Full 9.9
Partial None 12.4
Partial Partial 42.6
Partial Full 7.3
Full None 3.7
Full Partial 7.0
Full Full 0.2
Note that only a bilingual lexicon is adopted in
our approach. We regard it one of the most mer-
its for our approach. A lexicon is much easier to
be obtained than an annotated corpus. One of the
remained question about this work is if the bilin-
gual lexicon should be very specific for this kind
of tasks. According to our experiences, actually, it
is not so sensitive to choose a highly refined lexi-
con or not. We once found many words, mostly
named entities, were outside the lexicon. Thus
we managed to collect a named entity translation
dictionary to enhance the original one. However,
this extra effort did not receive an observable per-
formance improvement in return. Finally we re-
alize that a lexicon that can guarantee two word
pair lists highly matched is sufficient for this work,
and this requirement may be conveniently satis-
fied only if the lexicon consists of adequate high-
frequent words from the source treebank.
8 Conclusion and Future Work
We propose a method to enhance dependency
parsing in one language by using a translated tree-
bank from another language. A simple statisti-
cal machine translation technique, word-by-word
decoding, where only a bilingual lexicon is nec-
essary, is used to translate the source treebank.
As dependency parsing is concerned with the re-
lations of word pairs, only those word pairs with
dependency relations in the translated treebank are
chosen to generate some additional features to en-
hance the parser for the target language. The ex-
perimental results in English and Chinese tree-
banks show the proposed method is effective and
helps the Chinese parser in this work achieve a
state-of-the-art result.
Note that our method is evaluated in two tree-
banks with a similar annotation style and it avoids
using too many linguistic properties. Thus the
method is in the hope of being used in other simi-
larly annotated treebanks 5. For an immediate ex-
ample, we may adopt a translated Chinese tree-
bank to improve English parsing. Although there
are still something to do, the remained key work
has been as simple as considering how to deter-
mine the matching strategy for searching the trans-
lated word pair list in English according to the
framework of our method. .
Acknowledgements
We?d like to give our thanks to three anonymous
reviewers for their insightful comments, Dr. Chen
Wenliang for for helpful discussions and Mr. Liu
Jun for helping us fix a bug in our scoring pro-
gram.
References
Peter F. Brown, John Cocke, Stephen A. Della Pietra,
Vincent J. Della Pietra, Fredrick Jelinek, John D.
Lafferty, Robert L. Mercer, and Paul S. Roossin.
1990. A statistical approach to machine translation.
Computational Linguistics, 16(2):79?85.
David Burkett and Dan Klein. 2008. Two lan-
guages are better than one (for syntactic parsing). In
EMNLP-2008, pages 877?886, Honolulu, Hawaii,
USA.
Wenliang Chen, Daisuke Kawahara, Kiyotaka Uchi-
moto, Yujie Zhang, and Hitoshi Isahara. 2008. De-
pendency parsing with short dependency relations
in unlabeled data. In Proceedings of IJCNLP-2008,
Hyderabad, India, January 8-10.
Xiangyu Duan, Jun Zhao, and Bo Xu. 2007. Proba-
bilistic parsing action models for multi-lingual de-
pendency parsing. In Proceedings of the CoNLL
Shared Task Session of EMNLP-CoNLL 2007, pages
940?946, Prague, Czech, June 28-30.
Johan Hall, Jens Nilsson, Joakim Nivre,
Gu?lsen Eryig?it, Bea?ta Megyesi, Mattias Nils-
son, and Markus Saers. 2007. Single malt or
5For example, Catalan and Spanish treebanks from the
AnCora(-Es/Ca) Multilevel Annotated Corpus that are an-
notated by the Universitat de Barcelona (CLiC-UB) and the
Universitat Polit?cnica de Catalunya (UPC).
62
blended? a study in multilingual parser optimiza-
tion. In Proceedings of the CoNLL Shared Task
Session of EMNLP-CoNLL 2007, pages 933?939,
Prague, Czech, June.
Terry Koo, Xavier Carreras, and Michael Collins.
2008. Simple semi-supervised dependency parsing.
In Proceedings of ACL-08: HLT, pages 595?603,
Columbus, Ohio, USA, June.
David McClosky, Eugene Charniak, and Mark John-
son. 2006. Reranking and self-training for parser
adaptation. In Proceedings of ACL-COLING 2006,
pages 337?344, Sydney, Australia, July.
Ryan McDonald and Joakim Nivre. 2007. Charac-
terizing the errors of data-driven dependency pars-
ing models. In Proceedings of the 2007 Joint Con-
ference on Empirical Methods in Natural Language
Processing and Computational Natural Language
Learning (EMNLP-CoNLL 2007), pages 122?131,
Prague, Czech, June 28-30.
Ryan McDonald and Fernando Pereira. 2006. Online
learning of approximate dependency parsing algo-
rithms. In Proceedings of EACL-2006, pages 81?88,
Trento, Italy, April.
Ryan McDonald, Koby Crammer, and Fernando
Pereira. 2005. Online large-margin training of de-
pendency parsers. In Proceedings of ACL-2005,
pages 91?98, Ann Arbor, Michigan, USA, June 25-
30.
Paola Merlo, Suzanne Stevenson, Vivian Tsang, and
Gianluca Allaria. 2002. A multilingual paradigm
for automatic verb classification. In ACL-2002,
pages 207?214, Philadelphia, Pennsylvania, USA.
Joakim Nivre, Johan Hall, Sandra Ku?bler, Ryan Mc-
Donald, Jens Nilsson, Sebastian Riedel, and Deniz
Yuret. 2007. The conll 2007 shared task on de-
pendency parsing. In Proceedings of the CoNLL
Shared Task Session of EMNLP-CoNLL 2007, page
915?932, Prague, Czech, June.
Joakim Nivre. 2003. An efficient algorithm for projec-
tive dependency parsing. In Proceedings of IWPT-
2003), pages 149?160, Nancy, France, April 23-25.
Franz Josef Och and Hermann Ney. 2002. Discrimina-
tive training and maximum entropy models for sta-
tistical machine translation. In Proceedings of ACL-
2002, pages 295?302, Philadelphia, USA, July.
Roi Reichart and Ari Rappoport. 2007. Self-training
for enhancement and domain adaptation of statistical
parsers trained on small datasets. In Proceedings of
ACL-2007, pages 616?623, Prague, Czech Republic,
June.
Kenji Sagae and Jun?ichi Tsujii. 2007. Dependency
parsing and domain adaptation with lr models and
parser ensembles. In Proceedings of the CoNLL
Shared Task Session of EMNLP-CoNLL 2007, page
1044?1050, Prague, Czech, June 28-30.
Noah A. Smith and Jason Eisner. 2006. Annealing
structural bias in multilingual weighted grammar in-
duction. In Proceedings of ACL-COLING 2006,
page 569?576, Sydney, Australia, July.
Mark Steedman, Miles Osborne, Anoop Sarkar,
Stephen Clark, Rebecca Hwa, Julia Hockenmaier,
Paul Ruhlen, Steven Baker, and Jeremiah Crim.
2003. Bootstrapping statistical parsers from small
datasets. In Proceedings of EACL-2003, page
331?338, Budapest, Hungary, April.
Qin Iris Wang and Dale Schuurmans. 2008. Semi-
supervised convex training for dependency parsing.
In Proceedings of ACL-08: HLT, pages 532?540,
Columbus, Ohio, USA, June.
Qin Iris Wang, Dale Schuurmans, and Dekang Lin.
2005. Strictly lexical dependency parsing. In Pro-
ceedings of IWPT-2005, pages 152?159, Vancouver,
BC, Canada, October.
Qin Iris Wang, Dekang Lin, and Dale Schuurmans.
2007. Simple training of dependency parsers via
structured boosting. In Proceedings of IJCAI 2007,
pages 1756?1762, Hyderabad, India, January.
Hiroyasu Yamada and Yuji Matsumoto. 2003. Sta-
tistical dependency analysis with support vector
machines. In Proceedings of IWPT-2003), page
195?206, Nancy, France, April.
Kun Yu, Daisuke Kawahara, and Sadao Kurohashi.
2008. Chinese dependency parsing with large
scale automatically constructed case structures. In
Proceedings of COLING-2008, pages 1049?1056,
Manchester, UK, August.
Daniel Zeman and Philip Resnik. 2008. Cross-
language parser adaptation between related lan-
guages. In Proceedings of IJCNLP 2008 Workshop
on NLP for Less Privileged Languages, pages 35?
42, Hyderabad, India, January.
Hai Zhao and Chunyu Kit. 2008. Parsing syntactic and
semantic dependencies with two single-stage max-
imum entropy models. In Proceeding of CoNLL-
2008, pages 203?207, Manchester, UK.
Hai Zhao, Wenliang Chen, Chunyu Kit, and Guodong
Zhou. 2009. Multilingual dependency learning:
A huge feature engineering method to semantic de-
pendency parsing. In Proceedings of CoNLL-2009,
Boulder, Colorado, USA.
Hai Zhao. 2009. Character-level dependencies in
chinese: Usefulness and learning. In EACL-2009,
pages 879?887, Athens, Greece.
63
Proceedings of the 2009 Named Entities Workshop, ACL-IJCNLP 2009, pages 57?60,
Suntec, Singapore, 7 August 2009. c?2009 ACL and AFNLP
Transliteration of Name Entity via Improved Statistical Translation on
Character Sequences
Yan Song Chunyu Kit Xiao Chen
Department of Chinese, Translation and Linguistics
City University of Hong Kong
83 Tat Chee Ave., Kowloon, Hong Kong
Email: {yansong, ctckit}@cityu.edu.hk, cxiao2@student.cityu.edu.hk
Abstract
Transliteration of given parallel name en-
tities can be formulated as a phrase-based
statistical machine translation (SMT) pro-
cess, via its routine procedure compris-
ing training, optimization and decoding.
In this paper, we present our approach to
transliterating name entities using the log-
linear phrase-based SMT on character se-
quences. Our proposed work improves the
translation by using bidirectional models,
plus some heuristic guidance integrated in
the decoding process. Our evaluated re-
sults indicate that this approach performs
well in all standard runs in the NEWS2009
Machine Transliteration Shared Task.
1 Introduction
To transliterate a foreign name into a target lan-
guage, a direct instrument is to make use of ex-
isting rules for converting text to syllabus, or
at least a phoneme base to support such trans-
formation. Following this path, the well devel-
oped noisy channel model used for transliteration
usually set an intermediate layer to represent the
source and target names by phonemes or phonetic
tags (Knight and Graehl, 1998; Virga and Khu-
danpur, 2003; Gao et al, 2004). Having been
studied extensively though, the phonemes-based
approaches cannot break its performance ceiling
for two reasons (Li et al, 2004): (1) Language-
dependent phoneme representation is not easy to
obtain; (2) The phonemic representation to source
and target names usually causes error spread.
Several approaches have been proposed for di-
rect use of parallel texts for performance enhance-
ment (Li et al, 2004; Li et al, 2007; Gold-
wasser and Roth, 2008). There is no straight-
forward mean for grouping characters or letters in
the source or target language into better transliter-
ation units for a better correspondence. There is
no consistent deterministic mapping between two
languages either, especially when they belong to
different language families, such as English and
Chinese. Usually, a single character in a source
name is not enough to form a phonetic pattern
in a target name. Thus a better way to model
transliteration is to map character sequences be-
tween source and target name entities. The map-
ping is actually an alignment process. If a cer-
tain quantity of bilingual transliterated entities are
available for training, it is a straight-forward idea
to tackle this transliteration problem with a ma-
ture framework such as phrase-based SMT. It can
be considered a general statistical translation task
if the character sequences involved are treated like
phrases.
In so doing, however, a few points need to be
highlighted. Firstly, only parallel data are required
for generating transliteration outputs via SMT, and
this SMT translation process can be easily in-
tegrated as a component into a general-purpose
SMT system. Secondly, on character sequences,
the mapping between source and target name en-
tities can be performed on even larger units. Con-
sequently, contextual information can be exploited
to facilitate the alignment, for a string can be used
as a context for every one of its own characters.
It is reasonable to expect such relevant informa-
tion to produce more precisely statistical results
for finding corresponding transliterations. Thirdly,
transliteration as a monotonic word ordering trans-
formation problem allows the alignment to be per-
formed monotonously from the beginning to the
end of a text. Thus its decoding is easy to perform
as its search space shrinks this way, for re-ordering
is considered not to be involved, in contrast to the
general SMT process.
This paper is intended to present our work
on applying phrased-based SMT technologies to
tackle transliteration. The following sections will
report how we have carried out our experiments
57
for the NEWS2009 task (Li et al, 2009) and
present the experimented results.
2 Transliteration as SMT
In order to transliterate effectively via a phrase
based SMT process for our transliteration task, we
opt for the log-linear framework (Och and Ney,
2002), a straight-forward architecture to have sev-
eral feature models integrated together as
P (t|s) = exp[
?n
i=1 ?ihi(s, t)]?
t exp[
?n
i=1 ?ihi(s, t)]
(1)
Then the transliteration task is to find the proper
source and corresponding target chunks to maxi-
mize P (t|s) as
t = argmax
t
P (t|s) (2)
In (1), hi(s, t) is a feature model formulated as a
probability functions on a pair of source and target
texts in logarithmic form, and ?i is a parameter to
optimize its contribution. The two most important
models in this framework are the translation model
(i.e., the transliteration model in our case), and the
target language model. The former is defined as
hi(s, t) = log p(s, t) (3)
where p(s, t) is p(s|t) or p(t|s) according to the
direction of training corresponding phrases. (Och
and Ney, 2002) show that p(t|s) gives a result
comparable to p(s|t), as in the source-channel
framework. (Gao et al, 2004) also confirm on
transliteration that the direct model with p(t|s)
performs well while working on the phonemic
level. For our task, we have tested these choices
for p(s, t) on all our development data, arriving
at a similar result. However, we opt to use both
p(s|t) and p(t|s) if they give similar transliter-
ation quality in some language pairs. Thus we
take p(t|s) for our primary transliteration model
for searching candidate corresponding character
sequences, and p(s|t) as a supplement.
In addition to the translation model feature, an-
other feature for the language model can be de-
scribed as
hi(s, t) = log p(t) (4)
Usually the n-gram language model is used for its
effectiveness and simplicity.
2.1 Training
For the purpose of modeling the training data, the
characters from both the source and target name
entities for training are split up for alignment, and
then phrase extraction is conducted to find the
mapping pairs of character sequence.
The alignment is performed by expectation-
maximization (EM) iterations in the IBM model-4
SMT training using the GIZA++ toolkit1. In some
runs, however, e.g., English to Chinese and En-
glish to Korean transliteration, the character num-
ber of the source text is always more than that
of the target text, the training conducted only on
characters may lead to many abnormal fertilities
and then affect the character sequence alignment
later. To alleviate this, a pre-processing step before
GIZA++ training applies unsupervised learning to
identify many frequently co-occurring characters
as fixed patterns in the source texts, including all
available training, development and testing data.
All possible tokens of the source names are con-
sidered.
Afterwards, the extraction and probability esti-
mation of corresponding sequences of characters
or pre-processed small tokens aligned in the prior
step is performed by ?diag-growth-final? (Koehn
et al, 2003), with maximum length 10, which is
tuned on development data, for both the source-
to-target and the target-to-source character align-
ment. Then two transliteration models, namely
p(t|s) and p(s|t), are generated by such extraction
for each transliteration run.
Another component involved in the training is
an n-gram language model. We set n = 3 and
have it trained with the available data of the target
language in question.
2.2 Optimization
Using the development sets for the NEWS2009
task, a minimum error rate training (MERT) (Och,
2003) is applied to tune the parameters for the cor-
responding feature models in (1). The training is
performed with regard to the mean F-score, which
is also called fuzziness in top-1, measuring on av-
erage how different the top transliteration candi-
date is from its closest reference. It is worth noting
that a high mean F-score indicates a high accuracy
of top candidates, thus a high mean reciprocal rank
(MRR), which is used to quantify the overall per-
formance of transliteration.
1http://code.google.com/p/giza-pp/
58
Table 1: Comparison: baseline v.s. optimized
performance on EnCh and EnRu development
sets.
?1a ?2 ?3 Mean F MRR
EnChb B
c 1 1 1 0.803 0.654
O 2.38 0.33 0.29 0.837 0.709
EnRu B 1 1 1 0.845 0.485O 2.52 0.27 0.21 0.927 0.687
a The subscripts 1, 2 and 3 refer to the two transliter-
ation models p(t|s) and p(s|t) and another language
model respectively, and normalized asP3i=1 ?i = 3.b EnCh stands for English to Chinese run and EnRu for
English to Russian run.
c B stands for baseline configuration and O for opti-
mized case.
As shown in Table 1, the optimization of the
three major models leads to a significant per-
formance improvement, especially when training
data is limited, such as the EnRu run, only 5977
entries of name entities are provided for train-
ing. And, it is also found that the optimized fea-
ture weights for other language pairs are similar to
these for the two runs as shown in the table above2.
Note for the optimization of the parameters, that
only the training data is used for construction of
models. For the test, both the training and the de-
velopment sets are used for training.
2.3 Decoding
The trained source-to-target and target-to-source
transliteration models are integrated with the lan-
guage model as given in (1) for our decoding.
We implement a beam-search decoder to deal
with these multiple transliteration models, which
takes both the forward- and backward-directional
aligned character sequences as factors to con-
tribute to the transliteration probability. Consid-
ering the monotonic transformation order, the de-
coding is performed sequentially from the begin-
ning to the end of a source text. No re-ordering
is needed for such transliteration. As the search
space is restricted in this way, the accuracy of
matching possible transliteration pairs is not af-
fected when the decoding is maintained at a faster
speed than that for ordinary translation. In ad-
dition, another heuristic condition is also used to
guide this monotonic decoding. For those tar-
get character sequences found in the training data,
their positions in a name entity can help the decod-
2Interestingly, the first model contributes much more than
others. It can achieve a comparable result even without model
2 and 3, according to our experiments.
Table 3: Numbers of name entities in NEWS2009
training data6.
EnCh 34857 EnHi 10990
EnJa 29811 EnTa 9031
EnKo 5838 EnKa 9040
JnJk 19891 EnRu 6920
ing to find better corresponding transliterations,
for some texts appear more frequently at the be-
ginning of a name entity and others at the end. We
use the probabilities for all aligned target charac-
ter sequences in different positions, and exploit the
data as an auxiliary feature model for the gener-
ation. Finally, all possible target candidates are
generated by (2) for source names.
3 Evaluation Results
For NEWS2009, we participated in all 8 standard
runs of transliteration task, namely, EnCh (Li et
al., 2004), EnJa, EnKo, JnJk3, EnHi, EnTa, EnKa
and EnRu (Kumaran and Kellner, 2007). Ten best
candidates generated for each source name are
submitted for each run. The transliteration per-
formance is evaluated by the official script4, using
six metrics5. The official evaluation results for our
system are presented in Table 2.
The effectiveness of our approach is revealed by
the fact that many of our Mean F-scores are above
0.8 for various tasks. These high scores suggest
that our top candidates are close to the given ref-
erences. Besides, it is also interesting to look into
how well the desired targets are generated under
a certain recall rate, by examining if the best an-
swers are among the ten candidates produced for
each source name. If the recall rate goes far be-
yond MRR, it can be a reliable indication that the
desired targets are found for most source names,
but just not put at the top of the ten-best. From the
last column in Table 2, we can see a great chance
to improve our performance, especially for EnCh,
JnJk and EnRu runs.
3http://www.cjk.org
4https://translit.i2r.a-star.edu.sg/news2009/evaluation/
5The six metrics are Word Accuracy in Top-1 (ACC),
Fuzziness in Top-1 (Mean F-score), Mean Reciprocal Rank
(MRR), Precision in the n-best candidates (Map ref), Prece-
sion in the 10-best candidates (Map 10) and Precision in the
system produced candidates (Map sys).
6Note that in some of the runs, when a source name has
multiple corresponding target names, the numbers are calcu-
lated according to the total target names in both the training
and development data.
59
Table 2: Evaluation result of NEWS2009 task.
Task Source Target ACC Mean F MRR Map ref Map 10 Map sys Recall
EnCh English Chinese 0.643 0.854 0.745 0.643 0.228 0.229 0.917
EnJa English Katakana 0.406 0.800 0.529 0.393 0.180 0.180 0.786
EnKo English Hangul 0.332 0.648 0.425 0.331 0.134 0.135 0.609
JnJk Japanese Kanji 0.555 0.708 0.653 0.538 0.261 0.261 0.852
EnHi English Hindi 0.349 0.829 0.455 0.341 0.151 0.151 0.681
EnTa English Tamil 0.316 0.848 0.451 0.307 0.154 0.154 0.724
EnKa English Kannada 0.177 0.799 0.307 0.178 0.109 0.109 0.576
EnRu English Russian 0.500 0.906 0.613 0.500 0.192 0.192 0.828
But still, since SMT is a data-driven approach,
the amount of training data could affect the
transliteration results significantly. Table 3 shows
the training data size in our task. It gives a hint
on the connections between the performance, es-
pecially Mean F-score, and the data size. In spite
of the low ACC, EnKa test has a Mean F-score
close to other two runs, namely EnHi and EnTa,
of similar data size. For EnRu test, although the
training data is limited, the highest Mean F-score
is achieved thanks to the nice correspondence be-
tween English and Russian characters.
4 Conclusion
In this paper we have presented our recent work to
apply the phrase-based SMT technology to name
entity transliteration on character sequences. For
training, the alignment is carried out on characters
and on those frequently co-occurring character se-
quences identified by unsupervised learning. The
extraction of bi-directional corresponding source
and target sequence pairs is then performed for
the construction of our transliteration models. In
decoding, a beam search decoder is applied to
generate transliteration candidates using both the
source-to-target and target-to-source translitera-
tion models, the target language model and some
heuristic guidance integrated. The MERT is ap-
plied to tune the optimum feature weights for these
models. Finally, ten best candidates are submitted
for each source name. The experimental results
confirm that our approach is effective and robust
in the eight runs of the NEWS2009 transliteration
task.
Acknowledgments
The research described in this paper was sup-
ported by City University of Hong Kong through
the Strategic Research Grants (SRG) 7002267 and
7002388.
References
W. Gao, K. F. Wong, and W. Lam. 2004. Improving
transliteration with precise alignment of phoneme
chunks and using context features. In Proceedings
of AIRS-2004.
Dan Goldwasser and Dan Roth. 2008. Translitera-
tion as constrained optimization. In Proceedings of
EMNLP-2008, pages 353?362, Honolulu, USA, Oc-
tober.
Kevin Knight and Jonathan Graehl. 1998. Ma-
chine transliteration. Computational Linguistics,
24(4):599?612.
Philipp Koehn, Franz Josef Och, and Daniel Marcu.
2003. Pharaoh: A beam search decoder for phrase-
base statistical machine translation models. In Pro-
ceedings of the 6th AMTA, Edomonton, Canada.
A Kumaran and Tobias Kellner. 2007. A generic
framework for machine transliteration. In Proceed-
ings of the 30th SIGIR.
Haizhou Li, Min Zhang, and Jian Su. 2004. A
joint source-channel model for machine transliter-
ation. In Proceedings of ACL-04, pages 159?166,
Barcelona, Spain, July.
Haizhou Li, Khe Chai Sim, Jin-Shea Kuo, and Minghui
Dong. 2007. Semantic transliteration of personal
names. In Proceedings of ACL-07, pages 120?127,
Prague, Czech Republic, June.
Haizhou Li, A Kumaran, Vladimir Pervouchine, and
Min Zhang. 2009. Report on news 2009 machine
transliteration shared task. In Proceedings of ACL-
IJCNLP 2009 Named Entities Workshop, Singapore.
Franz Josef Och and Hermann Ney. 2002. Discrimina-
tive training and maximum entropy models for sta-
tistical machine translation. In Proceedings of ACL-
02, pages 295?302, Philadelphia, USA, July.
Franz Josef Och. 2003. Minimum error rate training
in statistical machine translation. In Proceedings of
ACL-03, pages 160?167, Sapporo, Japan, July.
Paola Virga and Sanjeev Khudanpur. 2003. Translit-
eration of proper names in cross-lingual information
retrieval. In Proceedings of the ACL 2003 Workshop
on Multilingual and Mixed-language Named Entity
Recognition, pages 57?64, Sapporo, Japan, July.
60
Proceedings of the Fifth SIGHAN Workshop on Chinese Language Processing, pages 201?204,
Sydney, July 2006. c?2006 Association for Computational Linguistics
Chinese Word Segmentation based on an Approach of Maximum Entropy
Modeling
Yan Song1 Jiaqing Guo1 Dongfeng Cai2
Natural Language Processing Lab
Shenyang Institute of Aeronautical Engineering
Shenyang, 110034, China
1.{mattsure,guojiaqing}@gmail.com
2.cdf@ge-soft.com
Abstract
In this paper, we described our Chinese
word segmentation system for the 3rd
SIGHAN Chinese Language Processing
Bakeoff Word Segmentation Task. Our
system deal with the Chinese character se-
quence by using the Maximum Entropy
model, which is fully automatically gen-
erated from the training data by analyz-
ing the character sequences from the train-
ing corpus. We analyze its performance
on both closed and open tracks on Mi-
crosoft Research (MSRA) and University
of Pennsylvania and University of Col-
orado (UPUC) corpus. It is shown that we
can get the results just acceptable without
using dictionary. The conclusion is also
presented.
1 Introduction
In the 3rd SIGHAN Chinese Language Process-
ing Bakeoff Word Segmentation Task, we partici-
pated in both closed and open tracks on Microsoft
Research corpus (MSRA for short) and University
of Pennsylvania and University of Colorado cor-
pus (UPUC for short). The following sections de-
scribed how our system works and presented the
results and analysis. Finally, the conclusion is pre-
sented with discussions of the system.
2 System Overview
Using Maximum Entropy approach for Chinese
Word Segmentation is not a fresh idea, some pre-
vious works (Xue and Shen, 2003; Low, Ng and
Guo, 2005) have got good performance in this
field. But what we consider in the process of
Segmentation is another way. We treat the input
text which need to be segmented as a sequence of
the Chinese characters, The segment process is, in
fact, to find where we should split the character se-
quence. The point is to get the segment probability
between 2 Chinese characters, which is different
from dealing with the character itself.
In this section, training and segmentation pro-
cess of the system is described to show how our
system works.
2.1 Pre-Process of Training
For the first step we find the Minimal Segment
Unit (MSU for short) of a text fragment in the
training corpus. A MSU is a character or a string
which is the minimal unit in a text fragment that
cannot be segmented any more. According to the
corpus, all of the MSUs can be divided into 5
type classes: ?C? - Chinese Character (such as
/\0 and /?0), ?AB? - alphabetic string
(such as ?SIGHAN?), ?EN? - digit string (such
as ?1234567?), ?CN? - Chinese number string
(such as /?z?0) and ?P? - punctua-
tion (/?0,/"0,/?0, etc). Besides the
classes above, we define a tag ?NL? as a special
MSU, which refers to the beginning or ending of a
text fragment. So, any MSU u can be described
as: u?C?AB?EN?CN?P?{NL}. In order
to check the capability of the pure Maximum En-
tropy model, in closed tracks, we didn?t have any
type of classes, the MSU here is every character
of the text fragment, u?C ??{NL}. For instance,
/???\
SIGHAN2006?c?m"0
is segmented into these MSUs: /?/?/?/\/

/S/I/G/H/A/N/2/0/0/6/?/c/?/m/"0.
Once we get al the MSUs of a text fragment,
we can get the value of the Nexus Coefficient (NC
for short) of any 2 adjacent MSUs according to
the training corpus. The set of NC value can be
201
described as: NC ? {0, 1}, where 0 means those
2 MSUs are segmented and 1 means they are not
segmented (Roughly, we appoint r = 0 if either
one of the 2 adjacent MSUs is NL). For example,
the NC value of these 2 MSUs/\0 and/?0
in the text fragment /\?0 is 0 since these 2
characters is segmented according to the training
corpus.
2.2 Training
Since the segmentation is to obtain NC value of
any 2 adjacent MSUs (here we call the interspace
of the 2 adjacent MSUs a check point, illustrated
below),
. . .U?3 U?2 U?1 U+1 U+2 U+3 . . .
6
Check Point of U?1 and U+1
we built a tool to extract the feature as follows:
(?) U?3, U?2, U?1, U+1, U+2, U+3
(?) U?1U+1
(?) r?2r?1
(?) U?3r?2, U?2r?1
() r?2U?2, r?1U?1
In these features above, U+n (U?n) refers to
the following (previous) n MSU of the check
point with the information of relative position
(Intuitively, We consider the same MSU has
different effect on the NC value of the check point
when its relative position is different to check
point). And U?1U+1 is the 2 adjacent MSUs of
the check point. r?2r?1 is the NC value of the
previous 2 check points. Similarly, the (?) and ()
features represent the MSUs with their adjacent
r. For instance, in the sentence?????I<,
we can extract these features for the check point
between the MSU? and?:
(?) NL?3,NL?2,??1,?+1,?+2,?+3,
(?)??1?+1
(?) 00 (because ? is the boundary of the sen-
tence)
(?) NL?30,NL?20
() 0NL?2,0??1
and also these features for the check point be-
tween the MSU? and?:
(?)??3,??2,??1,?+1,I+2,<+3
(?)??1?+1
Figure 1: MSRA training curve
Figure 2: UPUC training curve
(?) 01 (for UPUC corpus, here the value is 00
since ?? is segmented into 2 characters, but in
MSRA corpus,?? is treated as a word)
(?)??30,??21
() 0??2,1??1
After the extraction of the features, we use the
ZhangLe?s Maximum Entropy Toolkit1 to train the
model with a feature cutoff of 1. In order to get
the best number of iteration, 9/10 of the training
data is used to train the model, and the other 1/10
portion of the training data is used to evaluate the
model. Figure 1 and 2 show the results of the eval-
uation on MSRA and UPUC corpus.
From the figures we can see the best iteration
number range from 555 to 575 for MSRA corpus,
and 360 to 375 for UPUC corpus. So we decide
the iteration for 560 rounds for MSRA tracks and
365 rounds for UPUC tracks, respectively.
2.3 Segmentation
As we mentioned in the beginning of this section,
the segmentation is the process to obtain the value
1Download from http://maxent.sourceforge.net
202
of every NC in a text fragment. This process is
similar to the training process. Firstly, We scan
the text fragment from start to end to get al of
the MSUs. Then we can extract all of the features
from the text fragment and decide which check
point we should tag as r = 0 by this equation:
p(r|c) =
1
Z
K?
j=1
?
fj(r|c)
j (1)
where K is the number of features, Z is the nor-
malization constant used to ensure that a probabil-
ity distribution results, and c represents the con-
text of the check point. ?j is the weight for fea-
ture fj , here {?1?2 . . . ?K} is generated by the
training data. We then compute P (r = 0|c) and
P (r = 1|c) by the equation (1).
After one check point is treated with value of
r, the system shifts backward to the next check
point until all of the check point in the whole text
fragment are treated. And by calculating:
P =
n?1?
i=1
p(ri|ci) =
n?1?
i=1
1
Z
K?
j=1
?fk(ri|ci)j (2)
to get an r sequence which can maximize P . From
this process we can see that the sequence is, in fact,
a second-order Markov Model. Thus it is easily to
think about more tags prior to the check point (as
an nth-order Markov Model) to get more accuracy,
but in this paper we only use the previous 2 tags
from the check point.
2.4 Identification of New words
We perform the new word(s) identification as a
post-process by check the word formation power
(WFP) of characters. The WFP of a character is
defined as: WFP (c) = Nwc/Nc, where Nwc is
the number of times that the character c appears
in a word of at least 2 characters in the training
corpus, Nc is the number of times the character c
occurs in the training corpus. After a text fragment
is segmented by our system, we extract all consec-
utive single characters. If at least 2 consecutive
characters have the WFP larger than our threshold
of 0.88, we polymerize them together as a word.
For example,/???0 is a new word which is
segmented as /?/?/?0 by our system, WFP
of these 3 characters is 0.9517,0.9818 and 1.0 re-
spectively, then they are polymerized as one word.
Besides the WFP, during the experiments, we
find that the Maximum Entropy model can poly-
merize someMSUs as a newword (We call it poly-
merization characteristic of the model), such as?
?? in the training corpus, we can extract ?
? as the previous context feature of the check
point after, in another stringS,?, we can
extract the backward context? of the check point
after with r = 1. Then in the test, a new word
??? is recognized by the model since ?
? and ? are polymerized if ? appears to-
gether a large number of times in the training cor-
pus.
3 Performance analysis
Here Table 1 illustrates the results of all 4 tracks
we participate. The first column is the track name,
and the 2nd column presents the Recall (R), the
3rd column the Precision (P), the 4th column is
F-measure (F). The Roov refers to the recall of the
out-of-vocabulary words and the Riv refers to the
recall of the words in training corpus.
Track R P F Roov Riv
MSRA Closed 0.923 0.929 0.926 0.554 0.936
MSRA Open 0.938 0.946 0.942 0.706 0.946
UPUC Closed 0.902 0.887 0.895 0.568 0.934
UPUC Open 0.926 0.906 0.917 0.660 0.954
Table 1: Results of our system in 4 tracks.
3.1 Closed tracks
For all of the closed tracks, we perform the seg-
mentation as we mentioned in the section above,
without any class defined. Every MSU we extract
from the training data is a character, which may be
a Chinese character, an English letter or a single
digit. We extract the features based on this kind of
MSUs to generate the models. The results show
these models are not precise.
For the UPUC closed track, the official released
training data is rather small. Then the capability
of the model is limited, this is the most reasonable
negative effect on our F-measure 0.895.
3.2 Open tracks
The primary change between open tracks and
closed tracks is that we have classified 5 classes
(?C?,?AB?,?EN?,?CN? and ?P?) to MSUs in or-
der to improve the accuracy of the model. The
classification really works and affects the perfor-
mance of the system in a great deal. As this text
fragment 1998c can be recognized as (EN)(C),
which can also presents 1644c, thus 1644c can
203
be easily recognized though there is no 1664c in
the training data.
The training corpus we used in UPUC open
track is the same as in UPUC closed track. With
those 5 classes, it is easily seen that the F-measure
increased by 2.2% in the open tracks.
For the MSRA open track, we adjust the class
?P? by removing the punctuation ?!? from the
class, because in the MSRA corpus, ?!? can be
a part of a organization name, such as ?!? in
/?l?!???u??
?0. Besides,
we add the Microsoft Research training data of
SIGHAN bakeoff 2005 as extended training cor-
pus. The larger training data cooperate with the
classification method, the F-measure of the open
track increased to 0.942 as comparison with 0.926
of closed track.
3.3 Discussion of the tracks
Through the tracks, we tested the performance by
using the pure Maximum Entropy model in closed
tracks and run with the improved model with clas-
sified MSUs in open tracks. It is shown that the
pure model without any additional methods can
hardly make us satisfied, for the open tracks, the
model with classes are just acceptable in segmen-
tation.
In both closed and open tracks, we use the
same new word identification process, and with
the polymerization characteristic of the model, we
find the Roov is better than we expected.
On the other hand, in our system, there is no dic-
tionary used as we described in the sections above,
the Riv of each track shows that affects the system
performance.
Another factor affects our system in the UPUC
tracks is the wrongly written characters. Consider
that our system is based on the sequence of char-
acters, this kind of mistake is fatal. For example,
in the sentence ???#u??Off<ff{?,
where{? is written as{?. The model cannot
recognize it since {? didn?t occur in the train-
ing corpus. In the step of new word identification,
the WFPs of the 2 characters {?? are 0.8917
and 0.8310, thus they are wrongly segmented into
2 single characters while they are treated as a word
in the gold standard corpus. Therefore, we believe
the results can increase if there are no such mis-
takes in the test data.
4 Conclusion
We propose an approach to Chinese word seg-
mentation by using Maximum Entropy model,
which focuses on the nexus relationship of any
2 adjacent MSUs in a text fragment. We tested
our system with pure Maximum Entropy models
and models with simplex classification method.
Compare with the pure models, the models with
classified MSUs show us better performances.
However, the Maximum Entropy models of our
system still need improvement if we want to
achieve higher performance. In future works,
we will consider using more training data and
add some hybrid methods with pre- and post-
processes to improve the system.
Acknowledgements
We would like to thank all the colleagues of our
Lab. Without their encouragement and help, this
work cannot be accomplished in time.
This is our first time to participate such an in-
ternational bakeoff. There are a lot of things we
haven?t experienced ever before, but with the en-
thusiastic help from the organizers, we can come
through the task. Especially, We wish to thank
Gina-Anne Levow for her patience and immediate
reply for any of our questions, and we also thank
Olivia Kwong for the advice of paper submission.
References
Nianwen Xue and Libin Shen. 2003. Chinese Word
Segmentation as LMR tagging. In Proceedings of
the Second SIGHAN Workshop on Chinese Lan-
guage Processing, p176-179.
Maosong Sun, Ming Xiao, B K Tsou. 2004. Chinese
Word Segmentation without Using Dictionary Based
on Unsupervised Learning Strategy. Chinese Jour-
nal of Computers, Vol.27, #6, p736-742.
Jin Kiat Low, Hwee Tou Ng and Wenyuan Guo.
2005. A Maximum Entropy Approach to Chinese
Word Segmentation. In Proceedings of the Fourth
SIGHAN Workshop on Chinese Language Process-
ing, p161-164.
204
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 622?630,
Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics
Non-Monotonic Sentence Alignment via Semisupervised Learning
Xiaojun Quan, Chunyu Kit and Yan Song
Department of Chinese, Translation and Linguistics
City University of Hong Kong, HKSAR, China
{xiaoquan,ctckit,[yansong]}@[student.]cityu.edu.hk
Abstract
This paper studies the problem of non-
monotonic sentence alignment, motivated
by the observation that coupled sentences
in real bitexts do not necessarily occur
monotonically, and proposes a semisuper-
vised learning approach based on two as-
sumptions: (1) sentences with high affinity
in one language tend to have their counter-
parts with similar relatedness in the other;
and (2) initial alignment is readily avail-
able with existing alignment techniques.
They are incorporated as two constraints
into a semisupervised learning framework
for optimization to produce a globally op-
timal solution. The evaluation with real-
world legal data from a comprehensive
legislation corpus shows that while exist-
ing alignment algorithms suffer severely
from non-monotonicity, this approach can
work effectively on both monotonic and
non-monotonic data.
1 Introduction
Bilingual sentence alignment is a fundamental
task to undertake for the purpose of facilitating
many important natural language processing ap-
plications such as statistical machine translation
(Brown et al, 1993), bilingual lexicography (Kla-
vans et al, 1990), and cross-language informa-
tion retrieval (Nie et al, 1999). Its objective is to
identify correspondences between bilingual sen-
tences in given bitexts. As summarized by Wu
(2010), existing sentence alignment techniques
rely mainly on sentence length and bilingual lex-
ical resource. Approaches based on the former
perform effectively on cognate languages but not
on the others. For instance, the statistical cor-
relation of sentence length between English and
Chinese is not as high as that between two Indo-
European languages (Wu, 1994). Lexicon-based
approaches resort to word correspondences in a
bilingual lexicon to match bilingual sentences. A
few sentence alignment methods and tools have
also been explored to combine the two. Moore
(2002) proposes a multi-pass search procedure us-
ing both sentence length and an automatically-
derived bilingual lexicon. Hunalign (Varga et al,
2005) is another sentence aligner that combines
sentence length and a lexicon. Without a lexicon,
it backs off to a length-based algorithm and then
automatically derives a lexicon from the align-
ment result. Soon after, Ma (2006) develops the
lexicon-based aligner Champollion, assuming that
different words have different importance in align-
ing two sentences.
Nevertheless, most existing approaches to sen-
tence alignment follow the monotonicity assump-
tion that coupled sentences in bitexts appear in
a similar sequential order in two languages and
crossings are not entertained in general (Langlais
et al, 1998; Wu, 2010). Consequently the task of
sentence alignment becomes handily solvable by
means of such basic techniques as dynamic pro-
gramming. In many scenarios, however, this pre-
requisite monotonicity cannot be guaranteed. For
example, bilingual clauses in legal bitexts are of-
ten coordinated in a way not to keep the same
clause order, demanding fully or partially crossing
pairings. Figure 1 shows a real excerpt from a leg-
islation corpus. Such monotonicity seriously im-
pairs the existing alignment approaches founded
on the monotonicity assumption.
This paper is intended to explore the problem of
non-monotonic alignment within the framework
of semisupervised learning. Our approach is mo-
tivated by the above observation and based on
the following two assumptions. First, monolin-
gual sentences with high affinity are likely to have
their translations with similar relatedness. Follow-
ing this assumption, we propose the conception
of monolingual consistency which, to the best of
622
British Overseas citizen" (??????) means a person who has the
status of a British Overseas citizen under the British Nationality Act
1981 (1981 c. 61 U.K.)
British protected person" (???????) means a person who has
the status of a British protected person under the British Nationality Act
1981 (1981 c. 61 U.K.)
...
1. Interpretation of words and expressions
British citizen" (???? ) means a person who has the status of a
British citizen under the British Nationality Act 1981 (1981 c. 61 U.K.)
British Dependent Territories citizen" (??????) means a person
who has or had the status of a British Dependent Territories citizen
under the British Nationality Act 1981 (1981 c. 61 U.K.)
British enactment" and "imperial enactment" (??????) Mean-
(a) any Act of Parliament; (b) any Order in Council; and (c) any rule,
regulation, proclamation, order, notice, rule of court, by-law or other
instrument made under or by virtue of any such Act or Order in Council
???????(British Overseas citizen)????1981?????
???(1981 c. 61 U.K.)????????????
???????(British Dependent Territories citizen)????1981
????????(1981 c. 61 U.K.)?????????????
???
1.????????
???????????????????????????????????????????????
??????????????????????????????????
?????(British citizen)????1981????????(1981
c. 61 U.K.)??????????
???????(British enactment, imperial enactment)??(a)??
????????(b)?????????(c)?????????
???????????????????????????
??????????????
...
"
"
"
"
"
?
?
?
?
?
Figure 1: A real example of non-monotonic sentence alignment from BLIS corpus.
our knowledge, has not been taken into account in
any previous work of alignment. Second, initial
alignment of certain quality can be obtained by
means of existing alignment techniques. Our ap-
proach attempts to incorporate both monolingual
consistency of sentences and bilingual consistency
of initial alignment into a semisupervised learning
framework to produce an optimal solution. Ex-
tensive evaluations are performed using real-world
legislation bitexts from BLIS, a comprehensive
legislation database maintained by the Depart-
ment of Justice, HKSAR. Our experimental results
show that the proposed method can work effec-
tively while two representatives of existing align-
ers suffer severely from the non-monotonicity.
2 Methodology
2.1 The Problem
An alignment algorithm accepts as input a bi-
text consisting of a set of source-language sen-
tences, S = {s1, s2, . . . , sm}, and a set of target-
language sentences, T = {t1, t2, . . . , tn}. Dif-
ferent from previous works relying on the mono-
tonicity assumption, our algorithm is generalized
to allow the pairings of sentences in S and T
to cross arbitrarily. Figure 2(a) illustrates mono-
tonic alignment with no crossing correspondences
in a bipartite graph and 2(b) non-monotonic align-
ment with scrambled pairings. Note that it is rela-
tively straightforward to identify the type of many-
to-many alignment in monotonic alignment using
techniques such as dynamic programming if there
is no scrambled pairing or the scrambled pairings
are local, limited to a short distance. However,
the situation of non-monotonic alignment is much
more complicated. Sentences to be merged into a
bundle for matching against another bundle in the
other language may occur consecutively or discon-
tinuously. For the sake of simplicity, we will not
consider non-monotonic alignment with many-to-
many pairings but rather assume that each sen-
tence may align to only one or zero sentence in
the other language.
Let F represent the correspondence relation be-
tween S and T , and therefore F ? S ? T . Let
matrix F denote a specific alignment solution of
F , where Fij is a real score to measure the likeli-
hood of matching the i-th sentence si in S against
the j-th sentence tj in T . We then define an align-
ment function A : F ? A to produce the final
alignment, where A is the alignment matrix for S
and T , with Aij = 1 for a correspondence be-
tween si and tj and Aij = 0 otherwise.
2.2 Semisupervised Learning
A semisupervised learning framework is intro-
duced to incorporate the monolingual and bilin-
gual consistency into alignment scoring
Q(F ) = Qm(F ) + ?Qb(F ), (1)
where Qm(F ) is the term for monolingual con-
straint to control the consistency of sentences with
high affinities, Qb(F ) for the constraint of initial
alignment obtained with existing techniques, and
? is the weight between them. Then, the optimal
alignment solution is to be derived by minimizing
the cost function Q(F ), i.e.,
F ? = argmin
F
Q(F ). (2)
623
s1
s2
s3
s4
s5
s6
t1
t2
t3
t4
t5
t6
(a)
s1
s2
s3
s4
s5
s6
t1
t2
t3
t4
t5
t6
(b)
Figure 2: Illustration of monotonic (a) and non-monotonic alignment (b), with a line representing the
correspondence of two bilingual sentences.
In this paper, Qm(F ) is defined as
1
4
m?
i,j=1
Wij
n?
k,l=1
Vkl
(
Fik?
DiiEkk
? Fjl?
DjjEll
)2
, (3)
whereW and V are the symmetric matrices to rep-
resent the monolingual sentence affinity matrices
in S and T , respectively, and D and E are the di-
agonal matrices with entries Dii = ?jWij and
Eii =
?
j Vij . The idea behind (3) is that to min-
imize the cost function, the translations of those
monolingual sentences with close relatedness re-
flected inW and V should also keep similar close-
ness. The bilingual constraint term Qb(F ) is de-
fined as
Qb(F ) =
m?
i=1
n?
j=1
(
Fij ? A?ij
)2
, (4)
where A? is the initial alignment matrix obtained
by A : F? ? A?. Note that F? is the initial relation
matrix between S and T .
The monolingual constraint term Qm(F ) de-
fined above corresponds to the smoothness con-
straint in the previous semisupervised learning
work by Zhou et al (2004) that assigns higher
likelihood to objects with larger similarity to share
the same label. On the other hand, Qb(F ) corre-
sponds to their fitting constraint, which requires
the final alignment to maintain the maximum con-
sistency with the initial alignment.
Taking the derivative of Q(F ) with respect to
F , we have
?Q(F )
?F = 2F ? 2SFT + 2?F ? 2?A?, (5)
where S and T are the normalized matrices of W
and V , calculated by S = D?1/2WD?1/2 and
T = E?1/2V E?1/2. Then, the optimal F ? is to
be found by solving the equation
(1 + ?)F ? ? SF ?T = ?A?, (6)
which is equivalent to ?F ? ? F ?? = ? with
? = (1 + ?)S?1, ? = T and ? = ?S?1A?.
This is in fact a Sylvester equation (Barlow et al,
1992), whose numerical solution can be found by
many classical algorithms. In this research, it is
solved using LAPACK,1 a software library for nu-
merical linear algebra. Non-positive entries in F ?
indicate unrealistic correspondences of sentences
and are thus set to zero before applying the align-
ment function.
2.3 Alignment Function
Once the optimal F ? is acquired, the remaining
task is to design an alignment function A to con-
vert it into an alignment solution. An intuitive ap-
proach is to use a heuristic search for local op-
timization (Kit et al, 2004), which produces an
alignment with respect to the largest scores in
each row and each column. However, this does not
guarantee a globally optimal solution. Figure 3 il-
lustrates a mapping relation matrix onto an align-
ment matrix, which also shows that the optimal
alignment cannot be achieved by heuristic search.
Banding is another approach frequently used to
convert a relation matrix to alignment (Kay and
Ro?scheisen, 1993). It is founded on the observa-
tion that true monotonic alignment paths usually
lie close to the diagonal of a relation matrix. How-
ever, it is not applicable to our task due to the non-
monotonicity involved. We opt for converting a
relation matrix into specific alignment by solving
1http://www.netlib.org/lapack/
624
al
ig
nm
en
t
m
at
ri
x
re
la
ti
on
m
at
ri
x
2
1 2 43 5 6 7
1
3
4
5
6
00.4 0 0.5 0 00
0.30 0 0.6 0 00
00 0 0 0 00
0.40 0 0 0.2 00
0.50 0 0 0 00.6
00.1 0 0 0 00.8
2
1 2 43 5 6 7
1
3
4
5
6
01 0 0 0 00
00 0 1 0 00
00 0 0 0 00
00 0 0 1 00
10 0 0 0 00
00 0 0 0 01
Figure 3: Illustration of sentence alignment from relation matrix to alignment matrix. The scores marked
with arrows are the best in each row/column to be used by the heuristic search. The right matrix repre-
sents the corresponding alignment matrix by our algorithm.
the following optimization
A =argmax
X
m?
i=1
n?
j=1
XijFij (7)
s.t.
m?
i=1
Xij ? 1,
n?
j=1
Xij ? 1, Xij ? {0, 1}
This turns sentence alignment into a problem to
be resolved by binary linear programming (BIP),
which has been successfully applied to word align-
ment (Taskar et al, 2005). Given a scoring matrix,
it guarantees an optimal solution.
2.4 Alignment Initialization
Once the above alignment function is available,
the initial alignment matrix A? can be derived from
an initial relation matrix F? obtained by an avail-
able alignment method. This work resorts to an-
other approach to initializing the relation matrix.
In many genres of bitexts, such as government
transcripts or legal documents, there are a certain
number of common strings on the two sides of bi-
texts. In legal documents, for example, transla-
tions of many key terms are usually accompanied
with their source terms. Also, common number-
ings can be found in enumerated lists in bitexts.
These kinds of anchor strings provide quite reli-
able information to link bilingual sentences into
pairs, and thus can serve as useful cues for sen-
tence alignment. In fact, they can be treated as a
special type of highly reliable ?bilexicon?.
The anchor strings used in this work are derived
by searching the bitexts using word-level inverted
indexing, a basic technique widely used in infor-
mation retrieval (Baeza-Yates and Ribeiro-Neto,
2011). For each index term, a list of postings is
created. Each posting includes a sentence identi-
fier, the in-sentence frequency and positions of this
term. The positions of terms are intersected to find
common anchor strings. The anchor strings, once
found, are used to calculate the initial affinity F?ij
of two sentences using Dice?s coefficient
F?ij =
2|C1i ? C2j |
|C1i|+ |C2j |
(8)
where C1i and C2j are the anchor sets in si and tj ,
respectively, and | ? | is the cardinality of a set.
Apart from using anchor strings, other avenues
for the initialization are studied in the evaluation
section below, i.e., using another aligner and an
existing lexicon.
2.5 Monolingual Affinity
Although various kinds of information from a
monolingual corpus have been exploited to boost
statistical machine translation models (Liu et al,
2010; Su et al, 2012), we have not yet been
exposed to any attempt to leverage monolingual
sentence affinity for sentence alignment. In our
framework, an attempt to this can be made through
the computation of W and V . Let us take W as an
example, where the entry Wij represents the affin-
ity of sentence si and sentence sj , and it is set to
0 for i = j in order to avoid self-reinforcement
during optimization (Zhou et al, 2004).
When two sentences in S or T are not too short,
or their content is not divergent in meaning, their
semantic similarity can be estimated in terms of
common words. Motivated by this, we define Wij
(for i 6= j) based on the Gaussian kernel as
Wij = exp
(
? 12?2
(
1? v
T
i vj
?vi? ?vj?
)2)
(9)
625
where ? is the standard deviation parameter, vi
and vj are vectors of si and sj with each com-
ponent corresponding to the tf-idf value of a par-
ticular term in S (or T ), and ??? is the norm of
a vector. The underlying assumption here is that
words appearing frequently in a small number of
sentences but rarely in the others are more signifi-
cant in measuring sentence affinity.
Although semantic similarity estimation is a
straightforward approach to deriving the two affin-
ity matrices, other approaches are also feasible. An
alternative approach can be based on sentence
length under the assumption that two sentences
with close lengths in one language tend to have
their translations also with close lengths.
2.6 Discussion
The proposed semisupervised framework for non-
monotonic alignment is in fact generalized be-
yond, and can also be applied to, monotonic align-
ment. Towards this, we need to make use of sen-
tence sequence information. One way to do it is
to incorporate sentence positions into Equation (1)
by introducing a position constraint Qp(F ) to en-
force that bilingual sentences in closer positions
should have a higher chance to match one another.
For example, the new constraint can be defined as
Qp(F ) =
m?
i=1
n?
j=1
|pi ? qj |F 2ij ,
where pi and qj are the absolute (or relative) posi-
tions of two bilingual sentences in their respective
sequences. Another way follows the banding as-
sumption that the actual couplings only appear in
a narrow band along the main diagonal of relation
matrix. Accordingly, all entries of F ? outside this
band are set to zero before the alignment function
is applied. Kay and Ro?scheisen (1993) illustrate
that this can be done by modeling the maximum
deviation of true couplings from the diagonal as
O(?n).
3 Evaluation
3.1 Data Set
Our data set is acquired from the Bilingual
Laws Information System (BLIS),2 an electronic
database of Hong Kong legislation maintained
by the Department of Justice, HKSAR. BLIS
2http://www.legislation.gov.hk
provides Chinese-English bilingual texts of ordi-
nances and subsidiary legislation in effect on or af-
ter 30 June 1997. It organizes the legal texts into a
hierarchy of chapters, sections, subsections, para-
graphs and subparagraphs, and displays the con-
tent of a such hierarchical construct (usually a sec-
tion) on a single web page.
By web crawling, we have collected in total
31,516 English and 31,405 Chinese web pages,
forming a bilingual corpus of 31,401 bitexts after
filtering out null pages. A text contains several to
two hundred sentences. Many bitexts exhibit par-
tially non-monotonic order of sentences. Among
them, 175 bitexts are randomly selected for man-
ual alignment. Sentences are identified based on
punctuations. OpenNLP Tokenizer3 is applied to
segment English sentences into tokens. For Chi-
nese, since there is no reliable segmenter for this
genre of text, we have to treat each Chinese char-
acter as a single token. In addition, to calculate the
monolingual sentence affinity, stemming of En-
glish words is performed with the Porter Stemmer
(Porter, 1980) after anchor string mining.
The manual alignment of the evaluation data set
is performed upon the initial alignment by Hu-
nalign (Varga et al, 2005), an effective sentence
aligner that uses both sentence length and a bilex-
icon (if available). For this work, Hunalign re-
lies solely on sentence length. Its output is then
double-checked and corrected by two experts in
bilingual studies, resulting in a data set of 1747
1-1 and 70 1-0 or 0-1 sentence pairs.
The standard deviation ? in (9) is an important
parameter for the Gaussian kernel that has to be
determined empirically (Zhu et al, 2003; Zhou et
al., 2004). In addition, theQ function also involves
another parameter ? to adjust the weight of the
bilingual constraint. This work seeks an approach
to deriving the optimal parameters without any ex-
ternal training data beyond the initial alignment. A
three-fold cross-validation is thus performed on
the initial 1-1 alignment and the parameters that
give the best average performance are chosen.
3.2 Monolingual Consistency
To demonstrate the validity of the monolingual
consistency, the semantic similarity defined by
vTi vj
?vi??vj? is evaluated as follows. 500 pairs of En-glish sentences with the highest similarities are se-
lected, excluding null pairings (1-0 or 0-1 type).
3http://opennlp.apache.org/
626
0.6 0.65 0.7 0.75 0.8 0.85 0.9 0.95 10.6
0.65
0.7
0.75
0.8
0.85
0.9
0.95
1
Similarity of English sentence pair
Simi
larity
 of C
hine
se s
ente
nce 
pair
Figure 4: Demonstration of monolingual consis-
tency. The horizontal axis is the similarity of En-
glish sentence pairs and the vertical is the similar-
ity of the corresponding pairs in Chinese.
Type Total initAlign NonmoAlignPred Corr Pred Corr
1-0 70 662 66 70 50
1-1 1747 1451 1354 1747 1533
Table 1: Performance of the initial alignment and
our aligner, where the Pred and Corr columns are
the numbers of predicted and correct pairings.
All of these high-affinity pairs have a similarity
score higher than 0.72. A number of duplicate
sentences (e.g., date) with exceptionally high sim-
ilarity 1.0 are dropped. Also, the similarity of the
corresponding translations of each selected pair
is calculated. These two sets of similarity scores
are then plotted in a scatter plot, as in Figure 4.
If the monolingual consistency assumption holds,
the plotted points would appear nearby the diag-
onal. Figure 4 confirms this, indicating that sen-
tence pairs with high affinity in one language do
have their counterparts with similarly high affinity
in the other language.
3.3 Impact of Initial Alignment
The 1-1 initial alignment plays the role of labeled
instances for the semisupervised learning. It is
of critical importance to the learning performance.
As shown in Table 1, our alignment function pre-
dicts 1451 1-1 pairings by virtue of anchor strings,
among which 1354 pairings are correct, yielding
a relatively high precision in the non-monotonic
circumstance. It also predicts null alignment for
many sentences that contain no anchor. This ex-
plains why it outputs 662 1-0 pairings when there
20 % 30 % 40 % 50 % 60 % 70 % 80 % 90 % 100%0
200
400
600
800
1000
1200
1400
1600
Percentage of initial 1?1 alignment
Corr
ectly
 dete
cted
 1?1
 pair
ings
 
 
NonmoAligninitAlign
Figure 5: Performance of non-monotonic align-
ment along the percentage of initial 1-1 alignment.
are only 70 1-0 true ones. Starting from this initial
alignment, our aligner (let us call it NonmoAlign)
discovers 179 more 1-1 pairings.
A question here is concerned with how the scale
of initial alignment affects the final alignment. To
examine this, we randomly select 20%, 40%, 60%
and 80% of the 1451 1-1 detected pairings as the
initial alignments for a series of experiments. The
random selection for each proportion is performed
ten times and their average alignment performance
is taken as the final result and plotted in Figure 5.
An observation from this figure is that the aligner
consistently discovers significantly more 1-1 pair-
ings on top of an initial 1-1 alignment, which has
to be accounted for by the monolingual consis-
tency. Another observation is that the alignment
performance goes up along the increase of the
percentage of initial alignment while performance
gain slows down gradually. When the percentage
is very low, the aligner still works quite effectively.
3.4 Non-Monotonic Alignment
To test our aligner with non-monotonic sequences
of sentences, we have them randomly scrambled
in our experimental data. This undoubtedly in-
creases the difficulty of sentence alignment, espe-
cially for the traditional approaches critically rely-
ing on monotonicity.
The baseline methods used for comparison are
Moore?s aligner (Moore, 2002) and Hunalign
(Varga et al, 2005). Hunalign is configured with
the option [-realign], which triggers a three-step
procedure: after an initial alignment, Hunalign
heuristically enriches its dictionary using word co-
occurrences in identified sentence pairs; then, it
re-runs the alignment process using the updated
627
Type Moore Hunalign NonmoAlignP R F1 P R F1 P R F1
1-1 0.104 0.104 0.104 0.407 0.229 0.293 0.878 0.878 0.878
1-0 0.288 0.243 0.264 0.033 0.671 0.062 0.714 0.714 0.714
Micro 0.110 0.110 0.110 0.184 0.246 0.210 0.871 0.871 0.871
Table 2: Performance comparison with the baseline methods.
dictionary. According to Varga et al(2005), this
setting gives a higher alignment quality than oth-
erwise. In addition, Hunalign can use an external
bilexicon. For a fair comparison, the identified an-
chor set is fed to Hunalign as a special bilexicon.
The performance of alignment is measured by pre-
cision (P), recall (R) and F-measure (F1). Micro-
averaged performance scores of precision, recall
and F-measure are also computed to measure the
overall performance on 1-1 and 1-0 alignment.
The final results are presented in Table 2, show-
ing that both Moore?s aligner and Hunalign under-
perform ours on non-monotonic alignment. The
particularly poor performance of Moore?s aligner
has to be accounted for by its requirement of more
than thousands of sentences in bitext input for re-
liable estimation of its parameters. Unfortunately,
our available data has not reached that scale yet.
3.5 Partially Non-Monotonic Alignment
Full non-monotonic bitexts are rare in practice.
But partial non-monotonic ones are not. Unlike
traditional alignment approaches, ours does not
found its performance on the degree of monotonic-
ity. To test this, we construct five new versions of
the data set for a series of experiments by ran-
domly choosing and scrambling 0%, 10%, 20%,
40%, 60% and 80% sentence parings. In the-
ory, partial non-monotonicity of various degrees
should have no impact on the performance of our
aligner. It is thus not surprised that it achieves
the same result as reported in last subsection.
NonmoAlign initialized with Hunalign (marked
as NonmoAlign Hun) is also tested. The experi-
mental results are presented in Figure 6. It shows
that both Moore?s aligner and Hunalign work rel-
atively well on bitexts with a low degree of non-
monotonicity, but their performance drops dra-
matically when the non-monotonicity is increased.
Despite the improvement at low non-monotonicity
by seeding our aligner with Hunalign, its per-
formance decreases likewise when the degree of
non-monotonicity increases, due to the quality de-
0 % 10% 20% 30% 40% 50% 60% 70% 80%0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
Non?monotonic ratio
Micr
o?F
1
 
 
NonmoAlignHunalignMooreNonmoAlign_Hun
Figure 6: Performance of alignment approaches at
different degrees of non-monotonicity.
crease of the initial alignment by Hunalign.
3.6 Monotonic Alignment
The proposed alignment approach is also expected
to work well on monotonic sentence alignment.
An evaluation is conducted for this using a mono-
tonic data set constructed from our data set by
discarding all its 126 crossed pairings. Of the
two strategies discussed above, banding is used
to help our aligner incorporate the sequence in-
formation. The initial relation matrix is built with
the aid of a dictionary automatically derived by
Hunalign. Entries of the matrix are derived by
employing a similar strategy as in Varga et al
(2005). The evaluation results are presented in Ta-
ble 3, which shows that NonmoAlign still achieves
very competitive performance on monotonic sen-
tence alignment.
4 Related Work
The research of sentence alignment originates in
the early 1990s. Gale and Church (1991) and
Brown (1991) report the early works using length
statistics of bilingual sentences. The general idea
is that the closer two sentences are in length, the
more likely they are to align. A notable difference
of their methods is that the former uses sentence
628
Type Moore Hunalign NonmoAlignP R F1 P R F1 P R F1
1-1 0.827 0.828 0.827 0.999 0.972 0.986 0.987 0.987 0.987
1-0 0.359 0.329 0.343 0.330 0.457 0.383 0.729 0.729 0.729
Micro 0.809 0.807 0.808 0.961 0.951 0.956 0.976 0.976 0.976
Table 3: Performance of monotonic alignment in comparison with the baseline methods.
length in number of characters while the latter in
number of tokens. Both use dynamic program-
ming to search for the best alignment. As shown in
Chen (1993) and Wu (1994), however, sentence-
length based methods suffer when the texts to be
aligned contain small passages, or the languages
involved share few cognates. The subsequent stage
of sentence alignment research is accompanied by
the advent of a handful of well-designed alignment
tools. Moore (2002) proposes a three-pass proce-
dure to find final alignment. Its bitext input is ini-
tially aligned based on sentence length. This step
generates a set of strictly-selected sentence pairs
for use to train an IBM translation model 1 (Brown
et al, 1993). Its final step realigns the bitext using
both sentence length and the discovered word cor-
respondences. Hunalign (Varga et al, 2005), orig-
inally proposed as an ingredient for building paral-
lel corpora, has demonstrated an outstanding per-
formance on sentence alignment. Like many other
aligners, it employs a similar strategy of combin-
ing sentence length and lexical data. In the ab-
sence of a lexicon, it first performs an initial align-
ment wholly relying on sentence length and then
automatically builds a lexicon based on this align-
ment. Using an available lexicon, it produces a
rough translation of the source text by converting
each token to the one of its possible counterparts
that has the highest frequency in the target corpus.
Then, the relation matrix of a bitext is built of sim-
ilarity scores for the rough translation and the ac-
tual translation at sentence level. The similarity of
two sentences is calculated in terms of their com-
mon pairs and length ratio.
To deal with noisy input, Ma (2006) proposes
a lexicon-based sentence aligner - Champollion.
Its distinctive feature is that it assigns different
weights to words in terms of their tf-idf scores,
assuming that words with low sentence frequen-
cies in a text but high occurrences in some local
sentences are more indicative of alignment. Un-
der this assumption, the similarity of any two sen-
tences is calculated accordingly and then a dy-
namic programming algorithm is applied to pro-
duce final alignment. Following this work, Li et
al. (2010) propose a revised version of Champol-
lion, attempting to improve its speed without per-
formance loss. For this purpose, the input bitexts
are first divided into smaller aligned fragments be-
fore applying Champollion to derive finer-grained
sentence pairs. In another related work by Deng et
al. (2007), a generative model is proposed, accom-
panied by two specific alignment strategies, i.e.,
dynamic programming and divisive clustering. Al-
though a non-monotonic search process that toler-
ates two successive chunks in reverse order is in-
volved, their work is essentially targeted at mono-
tonic alignment.
5 Conclusion
In this paper we have proposed and tested
a semisupervised learning approach to non-
monotonic sentence alignment by incorporating
both monolingual and bilingual consistency. The
utility of monolingual consistency in maintain-
ing the consonance of high-affinity monolingual
sentences with their translations has been demon-
strated. This work also exhibits that bilingual con-
sistency of initial alignment of certain quality is
useful to boost alignment performance. Our eval-
uation using real-world data from a legislation
corpus shows that the proposed approach outper-
forms the baseline methods significantly when the
bitext input is composed of non-monotonic sen-
tences. Working on partially non-monotonic data,
this approach also demonstrates a superior per-
formance. Although initially proposed for non-
monotonic alignment, it works well on monotonic
alignment by incorporating the constraint of sen-
tence sequence.
Acknowledgments
The research described in this paper was substan-
tially supported by the Research Grants Council
(RGC) of Hong Kong SAR, China, through the
GRF grant 9041597 (CityU 144410).
629
References
Ricardo Baeza-Yates and Berthier Ribeiro-Neto. 2011.
Modern Information Retrieval: The Concepts
and Technology Behind Search, 2nd ed., Harlow:
Addison-Wesley.
Jewel B. Barlow, Moghen M. Monahemi, and Dianne P.
O?Leary. 1992. Constrained matrix Sylvester equa-
tions. In SIAM Journal on Matrix Analysis and Ap-
plications, 13(1):1-9.
Peter F. Brown, Jennifer C. Lai, Robert L. Mercer.
1991. Aligning sentences in parallel corpora. In
Proceedings of ACL?91, pages 169-176.
Peter F. Brown, Vincent J. Della Pietra, Stephen A.
Della Pietra and Robert L. Mercer. 1993. The math-
ematics of statistical machine translation: Parameter
estimation. Computational Linguistics, 19(2):263-
311.
Stanley F. Chen. 1993. Aligning sentences in bilingual
corpora using lexical information. In Proceedings of
ACL?93, pages 9-16.
Yonggang Deng, Shankar Kumar, and William Byrne.
2007. Segmentation and alignment of parallel text
for statistical machine translation. Natural Lan-
guage Engineering, 13(3): 235-260.
William A. Gale, Kenneth Ward Church. 1991. A Pro-
gram for aligning sentences in bilingual corpora. In
Proceedings of ACL?91, pages 177-184.
Martin Kay and Martin Ro?scheisen. 1993. Text-
translation alignment. Computational Linguistics,
19(1):121-142.
Chunyu Kit, Jonathan J. Webster, King Kui Sin, Haihua
Pan, and Heng Li. 2004. Clause alignment for bilin-
gual HK legal texts: A lexical-based approach. In-
ternational Journal of Corpus Linguistics, 9(1):29-
51.
Chunyu Kit, Xiaoyue Liu, King Kui Sin, and Jonathan
J. Webster. 2005. Harvesting the bitexts of the laws
of Hong Kong from the Web. In The 5th Workshop
on Asian Language Resources, pages 71-78.
Judith L. Klavans and Evelyne Tzoukermann. 1990.
The bicord system: Combining lexical information
from bilingual corpora and machine readable dictio-
naries. In Proceedings of COLING?90, pages 174-
179.
Philippe Langlais, Michel Simard, and Jean Ve?ronis.
1998. Methods and practical issues in evaluating
alignment techniques. In Proceedings of COLING-
ACL?98, pages 711-717.
Zhanyi Liu, Haifeng Wang, Hua Wu, and Sheng Li.
2010. Improving statistical machine translation with
monolingual collocation. In Proceedings of ACL
2010, pages 825-833.
Xiaoyi Ma. 2006. Champollion: A robust parallel text
sentence aligner. In LREC 2006, pages 489-492.
Peng Li, Maosong Sun, Ping Xue. 2010. Fast-
Champollion: a fast and robust sentence alignment
algorithm. In Proceedings of ACL 2010: Posters,
pages 710-718.
Robert C. Moore. 2002. Fast and accurate sentence
alignment of bilingual corpora. In Proceedings of
AMTA 2002, page 135-144.
Jian-Yun Nie, Michel Simard, Pierre Isabelle and
Richard Durand. 1999. Cross-language information
retrieval based on parallel texts and automatic min-
ing of parallel texts from the Web. In Proceedings
of SIGIR?99, pages 74-81.
Martin F. Porter. 1980. An algorithm for suffix strip-
ping. Program, 14(3): 130-137.
Jinsong Su, Hua Wu, Haifeng Wang, Yidong Chen, Xi-
aodong Shi, Huailin Dong, Qun Liu. 2012. Transla-
tion model adaptation for statistical machine trans-
lation with monolingual topic information. In Pro-
ceedings of ACL 2012, Vol. 1, pages 459-468.
Ben Taskar, Simon Lacoste-Julien and Dan Klein.
2005. A discriminative matching approach to word
alignment. In Proceedings of HLT/EMNLP 2005,
pages 73-80.
Da?niel Varga, Pe?ter Hala?csy, Andra?s Kornai, Viktor
Nagy, La?szlo? Ne?meth, Viktor Tro?n. 2005. Parallel
corpora for medium density languages. In Proceed-
ings of RANLP 2005, pages 590-596.
Dekai Wu. 1994. Aligning a parallel English-Chinese
corpus statistically with lexical criteria. In Proceed-
ings of ACL?94, pages 80-87.
Dekai Wu. 2010. Alignment. Handbook of Natural
Language Processing, 2nd ed., CRC Press.
Dengyong Zhou, Olivier Bousquet, Thomas N. Lal, Ja-
son Weston, Bernhard Schlkopf. 2004. Learning
with local and global consistency. Advances in Neu-
ral Information Processing Systems, 16:321-328.
Xiaojin Zhu, Zoubin Ghahramani and John Lafferty.
2003. Semi-supervised learning using Gaussian
fields and harmonic functions. In Proceedings of
ICML 2003, pages 912-919.
630
Proceedings of the Joint 5th Workshop on Statistical Machine Translation and MetricsMATR, pages 67?71,
Uppsala, Sweden, 15-16 July 2010. c?2010 Association for Computational Linguistics
An Empirical Study on Development Set Selection Strategy
for Machine Translation Learning?
Cong Hui12, Hai Zhao12?, Yan Song3, Bao-Liang Lu12
1Center for Brain-Like Computing and Machine Intelligence
Department of Computer Science and Engineering, Shanghai Jiao Tong University
2MOE-Microsoft Key Laboratory for Intelligent Computing and Intelligent Systems
Shanghai Jiao Tong University, 800 Dong Chuan Rd., Shanghai 200240, China
3Department of Chinese, Translation and Linguistics, City University of Hong Kong
huicong@sjtu.edu.cn, {zhaohai,blu}@cs.sjtu.edu.cn
Abstract
This paper describes a statistical machine
translation system for our participation
for the WMT10 shared task. Based on
MOSES, our system is capable of translat-
ing German, French and Spanish into En-
glish. Our main contribution in this work
is about effective parameter tuning. We
discover that there is a significant perfor-
mance gap as different development sets
are adopted. Finally, ten groups of devel-
opment sets are used to optimize the model
weights, and this does help us obtain a sta-
ble evaluation result.
1 Introduction
We present a machine translation system that rep-
resents our participation for the WMT10 shared
task from Brain-like Computing and Machine In-
telligence Lab of Shanghai Jiao Tong University
(SJTU-BCMI Lab). The system is based on the
state-of-the-art SMT toolkit MOSES (Koehn et al,
2007). We use it to translate German, French and
Spanish into English. Though different develop-
ment sets used for training parameter tuning will
certainly lead to quite different performance, we
empirically find that the more sets we combine to-
gether, the more stable the performance is, and a
development set similar with test set will help the
performance improvement.
2 System Description
The basic model of the our system is a log-linear
model (Och and Ney, 2002). For given source lan-
?This work was partially supported by the National Natu-
ral Science Foundation of China (Grant No. 60903119, Grant
No. 60773090 and Grant No. 90820018), the National Basic
Research Program of China (Grant No. 2009CB320901), and
the National High-Tech Research Program of China (Grant
No.2008AA02Z315).
?corresponding author
guage strings, the target language string t will be
obtained by the following equation,
t?I1 =argmaxtI1
{p?m1 (tI1 | sJ1 )}
=argmax
tI1
{ exp[
?M
m=1 ?mhm(tI1, sJ1 )]?
t?I1 exp[
?M
m=1 ?mhm(t?I1, sJ1 )]
},
where hm is the m-th feature function and ?m is
the m-th model weight. There are four main parts
of features in the model: translation model, lan-
guage model, reordering model and word penalty.
The whole model has been well implemented by
the state-of-the-art statistical machine translation
toolkit MOSES.
For each language that is required to translated
into English, two sets of bilingual corpora are pro-
vided by the shared task organizer. The first set
is the new release (version 5) of Europarl cor-
pus which is the smaller. The second is a com-
bination of other available data sets which is the
larger. In detail, two corpora, europarl-v5 and
news-commentary10 are for German, europarl-v5
and news-commentary10 plus undoc for French
and Spanish, respectively. Details of training data
are in Table 1. Only sentences with length 1 to 40
are acceptable for our task. We used the larger set
for our primary submission.
We adopt word alignment toolkit GIZA++ (Och
and Ney, 2003) to learn word-level alignment with
its default setting and grow-diag-final-and param-
eters. Given a sentence pair and its corresponding
word-level alignment, phrases will be extracted by
using the approach in (Och and Ney, 2004). Phrase
probability is estimated by its relative frequency
in the training corpus. Lexical reordering is deter-
mined by using the default setting of MOSES with
msd-bidirectional parameter.
For training the only language model (English),
the data sets are extracted from monolingual parts
of both europarl-v5 and news-commentary10,
67
sentences words(s) words(t)
de small 1540549 35.76M 38.53M
large 1640818 37.95M 40.64M
fr small 1683156 44.02M 44.20M
large 8997997 251.60M 228.50M
es small 1650152 43.17M 41.25M
large 7971200 236.24M 207.79M
Table 1: Bilingual training corpora from Ger-
man(de), French(fr) and Spanish(es) to English.
which include 1968914 sentences and 47.48M
words. And SRILM is adopted with 5-gram, in-
terpolate and kndiscount settings (Stolcke, 2002)
.
The next step is to estimate feature weights by
optimizing translation performance on a develop-
ment set. We consider various combinations of 10
development sets with 18207 sentences to get a
stable performance in our primary submission.
We use the default toolkits which are provided
by WMT10 organizers for preprocessing (i.e., to-
kenize) and postprocessing (i.e., detokenize, re-
caser).
3 Development Set Selection
3.1 Motivation
Given the previous feature functions, the model
weights will be obtained by optimizing the follow-
ing maximum mutual information criterion, which
can be derived from the maximum entropy princi-
ple:
??M1 = argmax?M1
{
S?
i=1
log p?M1 (ti | si)}
As usual, minimum error rate training (MERT) is
adopted for log-linear model parameter estimation
(Och, 2003). There are many improvements on
MERT in existing work (Bertoldi et al, 2009; Fos-
ter and Kuhn, 2009), but there is no demonstration
that the weights with better performance on the
development set would lead to a better result on
the unseen test set. In our experiments, we found
that different development sets will cause signifi-
cant BLEU score differences, even as high as one
percent. Thus the remained problem will be how
to effectively choose the development set to obtain
a better and more stable performance.
3.2 Experimental Settings
Our empirical study will be demonstrated through
German to English translation on the smaller cor-
pus. The development sets are all development
sets and test sets from the previous WMT shared
translation task as shown in Table 2, and labeled
as dev-0 to dev-9. Meanwhile, we denote 10 batch
sets from batch-0 to batch-9 where the batch-i set
is the combination of dev- sets from dev-0 to dev-i.
The test set is newstest2009, which includes 2525
sentences, 54K German words and 58K English
words, and news-test2008, which includes 2051
sentences, 41K German words and 43K English
words.
id name sent w(de) w(en)
dev-0 dev2006 2000 49K 53K
dev-1 devtest2006 2000 48K 52K
dev-2 nc-dev2007 1057 23K 23K
dev-3 nc-devtest2007 1064 24K 23K
dev-4 nc-test2007 2007 45K 44K
dev-5 nc-test2008 2028 45K 44K
dev-6 news-dev2009 2051 41K 43K
dev-7 test2006 2000 49K 54K
dev-8 test2007 2000 49K 54K
dev-9 test2008 2000 50K 54K
Table 2: Development data.
3.3 On the Scale of Development Set
Having 20 different development sets (10 dev- sets
and batch- sets), 20 models are correspondingly
trained.The decode results on the test set are sum-
marized in Table 3 and Figure 1. The dotted lines
are the performances of 10 different development
sets on the two test sets, we will see that there
is a huge gap between the highest and the lowest
score, and there is not an obvious rule to follow. It
will bring about unsatisfied results if a poor devel-
opment set is chosen. The solid lines represents
the performances of 10 incremental batch sets on
the two test sets, the batch processing still gives a
poor performance at the beginning, but the results
become better and more stable when the develop-
ment sets are continuously enlarged. This sort of
results suggest that a combined development set
may produce reliable results in the worst case. Our
primary submission used the combined develop-
ment set and the results as Table 4.
68
id 09-dev 09-batch 08-dev 08-batch
0 16.46 16.46 16.38 16.38
1 16.67 16.25 16.66 16.44
2 16.74 16.20 16.94 16.22
3 16.15 16.83 16.18 17.02
4 16.44 16.73 16.64 16.89
5 16.50 16.97 16.75 17.13
6 17.15 17.03 17.67 17.24
7 16.51 17.00 16.34 17.09
8 17.03 16.97 17.15 17.22
9 16.25 16.99 16.24 17.26
Table 3: BLEU scores on the two test
sets(newstest2009 & news-test2008), which use
two data set sequences(dev- sequence & batch- se-
quence) to optimize model weights.
de-en fr-en es-en
18.90 24.30 26.40
Table 4: BLEU scores of our primary submission.
3.4 On BLEU Score Difference
To compare BLEU score differences between test
set and development set, we consider two groups
of BLEU score differences, For each development
set, dev-i, the BLEU score difference will be com-
puted between b1 from which adopts itself as the
development set and b2 from which adopts test
set as the development set. For the test set, the
BLEU score difference will be computed between
b?1 from which adopts each development set, dev-i,
as the development set and b?2 from which adopts
itself as the development set.
These two groups of results are illustrated in
Figure 2 (the best score of the test set under self
tuning, newstest2009 is 17.91). The dotted lines
have the inverse trend with the dotted in Figure
1(because the addition of these two values is con-
stant), and the solid lines have the same trend
with the dotted, which means that the good per-
formance is mutual between test set and develop-
ment sets: if tuning using A set could make a good
result over B set, then vice versa.
3.5 On the Similarity between Development
Set and Test Set
This experiment is motivated by (Utiyama et al,
2009), where they used BLEU score to measure
the similarity of a sentences pair and then ex-
tracted sentences similar with those in test set to
0 1 2 3 4 5 6 7 8 90
0.5
1
1.5
2
2.5
DATA SET ID
DIF
F of
 BLE
U S
COR
E
 
 
09?Ddev09?Dtest
Figure 2: The trend of BLEU score differences
construct a specific tuning set. In our experiment,
we will try to measure data set similarity instead.
Given two sets of sentences, one is called as candi-
date(cnd) set and the other reference(ref) set. For
any cnd sentence, we let the whole ref set to be its
reference and then multi-references BLEU score is
computed for cnd set. There comes a problem that
the sentence penalty will be constant for any cnd
sentence, we turn to calculate the average length
of whose sentences which have common n-gram
with the given cnd sentence.
Now we may define three measures. The mea-
sure which uses dev- and batch- sets as cnd sets
and news-test2009 set as ref set is defined as
precision-BLEU , and the measure which uses the
above sets on the contrary way is defined as recall-
BLEU. Then F1-BLEU is defined as the harmonic
mean of precision-BLEU and recall-BLEU. These
results are illustrated in Figure 3. From the fig-
ure, we find that F1-BLEU plays an important
role to predict the goodness of a development set,
F1-BLEU scores of batch- sets have an ascending
curve and batch data set sequence will cause a sta-
ble good test performance, the point on dev- sets
which has high F1-BLEU(eg, dev-0,4,5) would
also has a good test performance.
3.6 Related Work
The special challenge of the WMT shared task is
domain adaptation, which is a hot topic in recent
years and more relative to our experiments. Many
existing works are about this topic (Koehn and
Schroeder, 2007; Nakov, 2008; Nakov and Ng,
2009; Paul et al, 2009; Haque et al, 2009). How-
ever, most of previous works focus on language
69
model, translation phrase table, lexicons model
and factored translation model, few of them pay
attention to the domain adaptation on the develop-
ment set. For future work we consider to use some
machine learning approaches to select sentences in
development sets more relevant with the test set in
order to further improve translation performance.
4 Conclusion
In this paper, we present our machine translation
system for the WMT10 shared task and perform an
empirical study on the development set selection.
According to our experimental results, Choosing
different development sets would play an impor-
tant role for translation performance. We find that
a development set with higher F1-BLEU yields
better and more stable results.
References
Nicola Bertoldi, Barry Haddow, and Jean Baptiste
Fouet. 2009. Improved Minimum Error Rate Train-
ing in Moses. The Prague Bulletin of Mathematical
Linguistics, 91:7?16.
George Foster and Roland Kuhn. 2009. Stabiliz-
ing minimum error rate training. In Proceedings
of the 4th Workshop on Statistical Machine Trans-
lation(WMT), Boulder, Colorado, USA.
Rejwanul Haque, Sudip Kumar Naskar, Josef Van Gen-
abith, and Andy Way. 2009. Experiments on Do-
main Adaptation for English?Hindi SMT. In 7th In-
ternational Conference on Natural Language Pro-
cessing(ICNLP), Hyderabad, India.
Philipp Koehn and Josh Schroeder. 2007. Experiments
in domain adaptation for statistical machine transla-
tion. In Proceedings of the 2nd Workshop on Sta-
tistical Machine Translation(WMT), Prague, Czech
Republic.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexan-
dra Constantin, and Evan Herbst. 2007. Moses:
Open source toolkit for statistical machine trans-
lation. In Proceedings of the 45th Annual Meet-
ing of the Association for Computational Linguis-
tics(ACL), Prague, Czech Republic.
Preslav Nakov and Hwee Tou Ng. 2009. NUS
at WMT09: domain adaptation experiments for
English-Spanish machine translation of news com-
mentary text. In Proceedings of the 4th Workshop on
Statistical Machine Translation(WMT), Singapore.
Preslav Nakov. 2008. Improving English-Spanish sta-
tistical machine translation: Experiments in domain
adaptation, sentence paraphrasing, tokenization, and
recasing. In Proceedings of the 3rd Workshop on
Statistical Machine Translation(WMT), Columbus,
Ohio, USA.
Franz Josef Och and Hermann Ney. 2002. Discrimina-
tive training and maximum entropy models for sta-
tistical machine translation. In Proceedings of the
40th Annual Meeting of the Association for Compu-
tational Linguistics(ACL), Philadelphia, Pennsylva-
nian, USA.
Franz Josef Och and Hermann Ney. 2003. A sys-
tematic comparison of various statistical alignment
models. Computational Linguistics, 29(1):19?51.
Franz Josef Och and Hermann Ney. 2004. The align-
ment template approach to statistical machine trans-
lation. Computational Linguistics, 30(4):417?449.
Franz Josef Och. 2003. Minimum error rate training in
statistical machine translation. In Proceedings of the
41th Annual Meeting of the Association for Compu-
tational Linguistics(ACL), Sapporo, Japan.
Michael Paul, Andrew Finch, and Eiichiro Sumita.
2009. NICT@ WMT09: model adaptation and
transliteration for Spanish-English SMT. In Pro-
ceedings of the 4th Workshop on Statistical Machine
Translation(WMT), Singapore.
Andreas Stolcke. 2002. SRILM: an extensible lan-
guage modeling toolkit. In 7th International Con-
ference on Spoken Language Processing(ICSLP),
Denver, Colorado, USA.
Masao Utiyama, Hirofumi Yamamoto, and Eiichiro
Sumita. 2009. Two methods for stabilizing MERT:
NICT at IWSLT 2009. In Proceedings of Inter-
national Workshop on Spoken Language Transla-
tion(IWSLT), Tokyo, Japan.
70
0 1 2 3 4 5 6 7 8 915
15.5
16
16.5
17
17.5
18
DATA SET ID
BL
EU
 SC
OR
E
 
 
09?dev
09?batch
08?dev
08?batch
Figure 1: The BLEU score trend in Tabel 3, we will see that the batch lines output a stable and good
performance.
0 1 2 3 4 5 6 7 8 910
15
20
25
30
DATA SET ID
BL
EU
 VA
LU
E
 
 
pDev
pBatch
rDev
rBatch
fDev
fBatch
Figure 3: The precision(p), recall(r) and F1(f) BLEU score on the dev(Dev) and batch(Batch) sets based
on the comparison with news-test2009 set.
71
Proceedings of the 2010 Named Entities Workshop, ACL 2010, pages 62?65,
Uppsala, Sweden, 16 July 2010. c?2010 Association for Computational Linguistics
Reranking with Multiple Features for Better Transliteration
Yan Song? Chunyu Kit? Hai Zhao??
?Department of Chinese, Translation and Linguistics
City University of Hong Kong, 83 Tat Chee Ave., Kowloon, Hong Kong
?Department of Computer Science and Engineering
Shanghai Jiao Tong University, #800, Dongchuan Rd, Shanghai, China
{yansong,ctckit}@cityu.edu.hk, zhaohai@cs.sjtu.edu.cn
Abstract
Effective transliteration of proper names
via grapheme conversion needs to find
transliteration patterns in training data,
and then generate optimized candidates
for testing samples accordingly. However,
the top-1 accuracy for the generated candi-
dates cannot be good if the right one is not
ranked at the top. To tackle this issue, we
propose to rerank the output candidates for
a better order using the averaged percep-
tron with multiple features. This paper de-
scribes our recent work in this direction for
our participation in NEWS2010 transliter-
ation evaluation. The official results con-
firm its effectiveness in English-Chinese
bidirectional transliteration.
1 Introduction
Since transliteration can be considered a direct or-
thographic mapping process, one may adopt gen-
eral statistical machine translation (SMT) proce-
dures for its implementation. Aimed at finding
phonetic equivalence in another language for a
given named entity, however, different translitera-
tion options with different syllabification may gen-
erate multiple choices with the symphonic form
for the same source text. Consequently, even the
overall results by SMT output are acceptable, it
is still unreliable to rank the candidates simply by
their statistical translation scores for the purpose
of selecting the best one. In order to make a proper
choice, the direct orthographic mapping requires a
precise alignment and a better transliteration op-
tion selection. Thus, powerful algorithms for ef-
fective use of the parallel data is indispensable, es-
pecially when the available data is limited in vol-
ume.
Interestingly, although an SMT based approach
could not achieve a precise top-1 transliteration re-
sult, it is found in (Song et al, 2009) that, in con-
trast to the ordinary top-1 accuracy (ACC) score,
its recall rate, which is defined in terms of whether
the correct answer is generated in the n-best output
list, is rather high. This observation suggests that
if we could rearrange those outputs into a better
order, especially, push the correct one to the top,
the overall performance could be enhanced signif-
icantly, without any further refinement of the orig-
inal generation process. This reranking strategy is
proved to be efficient in transliteration generation
with a multi-engine approach (Oh et al, 2009).
In this paper, we present our recent work on
reranking the transliteration candidates via an on-
line discriminative learning framework, namely,
the averaged perceptron. Multiple features are in-
corporated into it for performance enhancement.
The following sections will give the technical de-
tails of our method and present its results for
NEWS2010 shared task for named entity translit-
eration.
2 Generation
For the generation of transliteration candidates,
we follow the work (Song et al, 2009), using a
phrase-based SMT procedure with the log-linear
model
P (t|s) = exp[
?n
i=1 ?ihi(s, t)]?
t exp[
?n
i=1 ?ihi(s, t)]
(1)
for decoding. Originally we use two directional
phrase1 tables, which are learned for both direc-
tions of source-to-target and target-to-source, con-
taining different entries of transliteration options.
In order to facilitate the decoding by exploiting all
possible choices in a better way, we combine the
forward and backward directed phrase tables to-
gether, and recalculate the probability for each en-
1It herein refers to a character sequence as described in
(Song et al, 2009).
62
try in it. After that, we use a phoneme resource2 to
refine the phrase table by filtering out the wrongly
extracted phrases and cleaning up the noise in it.
In the decoding process, a dynamic pruning is per-
formed when generating the hypothesis in each
step, in which the threshold is variable according
to the current searching space, for we need to ob-
tain a good candidate list as precise as possible
for the next stage. The parameter for each fea-
ture function in log-linear model is optimized by
MERT training (Och, 2003). Finally, a maximum
number of 50 candidates are generated for each
source name.
3 Reranking
3.1 Learning Framework
For reranking training and prediction, we adopt
the averaged perceptron (Collins, 2002) as our
learning framework, which has a more stable per-
formance than the non-averaged version. It is pre-
sented in Algorithm 1. Where ~? is the vector of
parameters we want to optimize, x, y are the cor-
responding source (with different syllabification)
and target graphemes in the candidate list, and ?
represents the feature vector in the pair of x and
y. In this algorithm, reference y?i is the most ap-
propriate output in the candidate list according to
the true target named entity in the training data.
We use the Mean-F score to identify which candi-
date can be the reference, by locating the one with
the maximum Mean-F score value. This process
updates the parameters of the feature vector and
also relocate all of the candidates according to the
ranking scores, which are calculated in terms of
the resulted parameters in each round of training
as well as in the testing process. The number of
iteration for the final model is determined by the
development data.
3.2 Multiple Features
The following features are used in our reranking
process:
Transliteration correspondence feature, f(si, ti);
This feature describes the mapping between
source and target graphemes, similar to the
transliteration options in the phrase table in
our previous generation process, where s and
2In this work, we use Pinyin as the phonetic representa-
tion for Chinese.
Algorithm 1 Averaged perceptron training
Input: Candidate list with reference
{LIST (xj , yj)nj=1, y?i }Ni=1
Output: Averaged parameters
1: ~? ? 0, ~?a ? 0, c? 1
2: for t = 1 to T do
3: for i = 1 to N do
4: y?i ? argmaxy?LIST (xj ,yj)~? ? ?(xi, yi)
5: if y?i 6= y?i then
6: ~? ? ~? +?(x?i , y?i )? ?(x?i, y?i)
7: ~?a ? ~?a+ c ? {?(x?i , y?i )??(x?i, y?i)}
8: end if
9: c? c+ 1
10: end for
11: end for
12: return ~? ? ~?a/c
t refer to the source and target language re-
spectively, and i to the current position.
Source grapheme chain feature, f(sii?1);
It measures the syllabification for a given
source text. There are two types of units
in different levels. One is on syllable level,
e.g., ?aa/bye?, ?aa/gaar/d?, reflecting the
segmentation of the source text, and the other
on character level, such as ?a/b?, ?a/g?,
?r/d?, showing the combination power of
several characters. These features on differ-
ent source grapheme levels can help the sys-
tem to achieve a more reliable syllabification
result from the candidates. We only consider
bi-grams when using this feature.
Target grapheme chain feature, f(tii?2);
This feature measures the appropriateness of
the generated target graphemes on both char-
acter and syllables level. It performs in a
similar way as the language model for SMT
decoding. We use tri-gram syllables in this
learning framework.
Paired source-to-target transition feature, f(<
s, t >ii?1);
This type of feature is firstly proposed in
(Li et al, 2004), aiming at generating source
and target graphemes simultaneously under
a suitable constraint. We use this feature
to restrict the synchronous transition of both
source and target graphemes, measuring how
well are those transitions, such as for ?st?,
63
whether ?s? transliterated by ??? is followed
by ?t? transliterated by ???. In order to deal
with the data sparseness, only bi-gram transi-
tion relations are considered in this feature.
Hidden Markov model (HMM) style features;
There are a group of features with HMM
style constraint for evaluating the candi-
dates generated in previous SMT process,
including, previous syllable HMM features,
f(sii?n+1, ti), posterior syllable HMM fea-
tures, f(si+n?1i , ti), and posterior character
HMM features, f(si, l, ti), where l denotes
the character following the previous syllable
in the source language. For the last feature,
it is effective to use both the current sylla-
ble and the first letter of the next syllable
to bound the current target grapheme. The
reason for applying this feature in our learn-
ing framework is that, empirically, the letters
following many syllables strongly affect the
transliteration for them, e.g., Aves ? ??
?, ?a? followed by ?v? is always translated
into ??? rather than ???.
Target grapheme position feature, f(ti, p);
This feature is an improved version of that
proposed in (Song et al, 2009), where p
refers to the position of ti. We have a mea-
sure for the target graphemes according to
their source graphemes and the current posi-
tion of their correspondent target characters.
There are three categories of such position,
namely, start (S), mediate (M) and end (E). S
refers to the first character in a target name, E
to the final, and the others belong to M. This
feature is used to exploit the observation that
some characters are more likely to appear at
certain positions in the target name. Some are
always found at the beginning of a named en-
tity while others only at the middle or the end.
For example, ?re? associated to first charac-
ter in a target name is always transliterated as
???, such as Redd ???. When ?re? ap-
pears at the end of a source name, however,
its transliteration will be ??? in most cases,
just like Gore ???.
Target tone feature;
This feature is only applied to the translit-
eration task with Chinese as the target lan-
guage. It can be seen as a combination
of a target grapheme chain with some posi-
tion features, using tone instead of the target
grapheme itself for evaluation. There are 5
tones (0,1,2,3,4) for Chinese characters. It is
easy to conduct a comprehensive analysis for
the use of a higher ordered transition chain as
a better constraint. Many fixed tone patterns
can be identified in the Chinese translitera-
tion training data. The tone information can
also be extracted from the Pinyin resource we
used in the previous stage.
Besides the above string features, we also have
some numeric features, as listed below.
Transliteration score;
This score is the joint probabilities of all
transliteration options, included in the output
candidates generated by our decoder.
Target language model score;
This score is calculated from the probabilistic
tri-gram language model.
Source/target Pinyin feature;
This feature uses Pinyin representation for a
source or target name, depending on what
side the Chinese language is used. It mea-
sures how good the output candidates can be
in terms of the comparison between English
text and Pinyin representation. The resulted
score is updated according to the Levenshtein
distance for the two input letter strings of En-
glish and Pinyin.
For a task with English as the target language,
we add the following two additional features into
the learning framework.
Vowel feature;
It is noticed that when English is the target
language, vowels can sometimes be missing
in the generated candidates. This feature is
thus used to punish those outputs unqualified
to be a valid English word for carrying no
vowel.
Syllable consistent feature;
This feature measures whether an English tar-
get name generated in the previous step has
the same number of syllables as the source
name. In Chinese-to-English transliteration,
Chinese characters are single-syllabled, thus
64
Table 1: Evaluation results for our NEWS2010 task.
Task Source Target ACC Mean F MRR Map ref Recall ACCSMT
EnCh English Chinese 0.477 0.740 0.506 0.455 0.561 0.381
ChEn Chinese English 0.227 0.749 0.269 0.226 0.371 0.152
we can easily identify their number. For syl-
labification, we have an independent segmen-
tation process for calculating the syllables.
4 Results
For NEWS2010, we participated in all two
Chinese related transliteration tasks, namely,
EnCh (English-to-Chinese) and ChEn (Chinese-
to-English back transliteration). The official eval-
uation scores for our submissions are presented
in Table 1 with recall rate, and the ACC score
(ACCSMT ) for original SMT outputs. It is easy
to see the performance gain for the reranking, and
also from the recall rate that there is still some
room for improvement, in spite of the high ratio of
ACC/Recall3 calculated from Table 1. However, it
is also worth noting that, some of the source texts
cannot be correctly transliterated, due to many
multiple-word name entities with semantic com-
ponents in the test data, e.g., ?MANCHESTER
BRIDGE?, ?BRIGHAM CITY? etc. These seman-
tic parts are beyond our transliteration system?s ca-
pability to tackle, especially when the training data
is limited and the only focus of the system is on the
phonetic equivalent correspondence.
Compared to the EnCh transliteration, we get a
rather low ACC score for the ChEn back translit-
eration, suggesting that ChEn task is somewhat
harder than the EnCh (in which Chinese char-
acters are always limited). The ChEn task is a
one-to-many translation, involving a lot of pos-
sible choices and combinations of English sylla-
bles. This certainly makes it a more challenge-
able task than EnCh. However, looking into the
details of the outputs, we find that, in the ChEn
back transliteration, some characters in the test
corpus are unseen in the training and the devel-
opment data, resulting in incorrect transliterations
for many graphemes. This is another factor affect-
ing our final results for the ChEn task.
5 Conclusion
In this paper, we have presented our work on
multiple feature based reranking for transliteration
3Compared to the results from (Song et al, 2009)
generation. It NEWS2010 results show that this
approach is effective and promising, in the sense
that it ranks the best in EnCh and ChEn tasks. The
reranking used in this work can also be consid-
ered a regeneration process based on an existing
set, as part of our features are always used directly
to generate the initial transliteration output in other
researches. Though, those features are strongly
dependent on the nature of English and Chinese
languages, it is thus not an easy task to transplant
this model for other language pairs. It is an inter-
esting job to turn it into a language independent
model that can be applied to other languages.
Acknowledgments
The research described in this paper was par-
tially supported by City University of Hong Kong
through the Strategic Research Grants (SRG)
7002267 and 7008003. Dr. Hai Zhao was sup-
ported by the Natural Science Foundation of China
(NSFC) through the grant 60903119. We also
thank Mr. Wenbin Jiang for his helpful sugges-
tions on averaged perceptron learning.
References
Michael Collins. 2002. Discriminative training meth-
ods for hidden markov models: Theory and exper-
iments with perceptron algorithms. In Proceedings
of EMNLP-2002, pages 1?8, July.
Haizhou Li, Min Zhang, and Jian Su. 2004. A
joint source-channel model for machine transliter-
ation. In Proceedings of ACL-04, pages 159?166,
Barcelona, Spain, July.
Franz Josef Och. 2003. Minimum error rate training
in statistical machine translation. In Proceedings of
ACL-03, pages 160?167, Sapporo, Japan, July.
Jong-Hoon Oh, Kiyotaka Uchimoto, and Kentaro Tori-
sawa. 2009. Machine transliteration using target-
language grapheme and phoneme: Multi-engine
transliteration approach. In Proceedings of NEWS
2009, pages 36?39, Suntec, Singapore, August.
Yan Song, Chunyu Kit, and Xiao Chen. 2009. Translit-
eration of name entity via improved statistical trans-
lation on character sequences. In Proceedings of
NEWS 2009, pages 57?60, Suntec, Singapore, Au-
gust.
65
