Proceedings of the 14th Conference of the European Chapter of the Association for Computational Linguistics, pages 211?219,
Gothenburg, Sweden, April 26-30 2014.
c?2014 Association for Computational Linguistics
Frame Semantic Tree Kernels for Social Network Extraction from Text
Apoorv Agarwal
Dept. of Computer Science
Columbia University
New York, NY, USA
Sriramkumar Balasubramanian
Dept. of Computer Science
Columbia University
New York, NY, USA
Anup Kotalwar
Microsoft, Inc.
Redmonad, WA, USA
Jiehan Zheng
The Peddie School
Hightstown, NJ, USA
Owen Rambow
CCLS
Columbia University
New York, NY, USA
apoorv@cs.columbia.edu
Abstract
In this paper, we present work on ex-
tracting social networks from unstructured
text. We introduce novel features de-
rived from semantic annotations based on
FrameNet. We also introduce novel se-
mantic tree kernels that help us improve
the performance of the best reported sys-
tem on social event detection and classi-
fication by a statistically significant mar-
gin. We show results for combining the
models for the two aforementioned sub-
tasks into the overall task of social net-
work extraction. We show that a combina-
tion of features from all three levels of ab-
stractions (lexical, syntactic and semantic)
are required to achieve the best performing
system.
1 Introduction
Social network extraction from text has recently
been gaining a considerable amount of attention
(Agarwal and Rambow, 2010; Elson et al., 2010;
Agarwal et al., 2013a; Agarwal et al., 2013b; He
et al., 2013). One of the reason for this attention,
we believe, is that being able to extract social net-
works from unstructured text may provide a pow-
erful new tool for historians, political scientists,
scholars of literature, and journalists to analyze
large collections of texts around entities and their
interactions. The tool would allow researchers to
quickly extract networks and assess their size, na-
ture, and cohesiveness, a task that would otherwise
be impossible with corpora numbering millions of
documents. It would also make it possible to make
falsifiable claims about these networks, bringing
the experimental method to disciplines like his-
tory, where it is still relatively rare.
In our previous work (Agarwal et al., 2010),
we proposed a definition of a network based on
interactions: nodes are entities and links are so-
cial events. We defined two broad types of links:
one-directional links (one person thinking about
or talking about another person) and bi-directional
links (two people having a conversation, a meet-
ing, etc.). For example, in the following sen-
tence, we would add two links to the network: a
one-directional link between Toujan Faisal and
the committee, triggered by the word said (be-
cause Toujan is talking about the committee) and
a bi-directional link between the same entities trig-
gered by the word informed (a mutual interaction).
(1) [Toujan Faisal], 54, said [she] was informed
of the refusal by an [Interior Ministry com-
mittee] overseeing election preparations.
In this paper, we extract networks using the
aforementioned definition of social networks. We
introduce and add tree kernel representations and
features derived from frame-semantic parses to
our previously proposed system. Our results show
that hand-crafted frame semantic features, which
are linguistically motivated, add less value to
the overall performance in comparison with the
frame-semantic tree kernels. We believe this is due
to the fact that hand-crafted features require frame
parses to be highly accurate and complete. In con-
trast, tree kernels are able to find and leverage less
strict patterns without requiring the semantic parse
to be entirely accurate or complete.
Apart from introducing semantic features and
tree structures, we evaluate on the task of social
network extraction, which is a combination of two
sub-tasks: social event detection and social event
classification. In our previous work (Agarwal and
Rambow, 2010), we presented results for the two
211
sub-tasks, but no evaluation was presented for the
task of social network extraction. We experiment
with two different designs of combining models
for the two sub-tasks: 1) One-versus-All and 2)
Hierarchical. We find that the hierarchical de-
sign outperforms the more commonly used One-
versus-All by a statistically significant margin.
Following are the contributions of this paper:
1. We design and propose novel frame semantic
features and tree-based representations and
show that tree kernels are well suited to work
with noisy semantic parses.
2. We show that in order to achieve the best
performing system, we need to include fea-
tures and tree structures from all levels of
abstractions, lexical, syntactic, and semantic,
and that the convolution kernel framework is
well-suited for creating such a combination.
3. We combine the previously proposed sub-
tasks (social event detection and classifica-
tion) into a single task, social network ex-
traction, and show that combining the mod-
els using a hierarchical design is significantly
better than the one-versus-all design.
The rest of the paper is structured as follows:
In Section 2, we give a precise definition of the
task and describe the data. In Section 3, we give
a brief overview of frame semantics and motivate
the need to use frame semantics for the tasks ad-
dressed in this paper. In Section 4, we present
semantic features and tree kernel representations
designed for the tasks. In Section 5, we briefly
review tree kernels and support vector machines
(SVM). In Section 6 we present experiments and
discuss the results. In Section 7 we discuss related
work. We conclude and give future directions of
work in Section 8.
2 Data and Task Definition
In Agarwal et al. (2010), we presented the annota-
tion details of social events on a well-known cor-
pus ? Automated Content Extraction
1
(ACE2005).
We defined a social event to be a happening be-
tween two entities (of type person) E1 and E2
(E1 6= E2), in which at least one entity is cog-
nitively aware of the other and of the happen-
ing taking place. We defined two broad cate-
1
Version: 6.0, Catalog number: LDC2005E18
No-Event INR OBS
# of Examples 1,609 199 199
Table 1: Data distribution; INR are interaction so-
cial events. OBS are observation social events.
gories of social events: Interaction (INR) and Ob-
servation (OBS). In a social event of type INR,
the two participating entities are mutually aware
of each other, i.e., INR is a bi-directional social
event. For example, meetings and dinners are so-
cial events of type interaction. In a social event of
type OBS, only one of the two participating enti-
ties is aware of the other and therefore, OBS is a
one-directional social event, directed from the en-
tity that is aware of the other to the other entity.
For example, thinking about someone, or missing
someone are social events of type OBS. Table 1
shows the distribution of the data. There are 199
INR type of social events, 199 OBS events, and
1,609 pairs of entity mentions have no event be-
tween them.
Task definition : The task is, given a pair of en-
tity mentions in a sentence, to predict if the en-
tities are participating in a social event or not
(social event detection, SED), and if they are, to
further predict the type of social event (INR or
OBS, social event classification, SEC). In this pa-
per, we evaluate our system on the above tasks as
well as a combined task: social network extraction
(SNE): given a sentence and a pair of entity men-
tions, predict the class of the example from one of
the following three categories: {No-Event, INR,
OBS}.
For the purposes of this paper, we use gold
named entity mentions to avoid errors caused due
to named entity recognition systems. This is a
common practice used in the literature for re-
porting relation extraction systems (Zelenko et
al., 2003; Kambhatla, 2004; Zhao and Grishman,
2005; GuoDong et al., 2005; Harabagiu et al.,
2005; Nguyen et al., 2009). We use standard ter-
minology from the literature to refer to the pair of
entities mentions as target entities T
1
and T
2
.
3 Frame Semantics and FrameNet
FrameNet (Baker et al., 1998) is a resource which
associates words of English with their meaning.
Word meanings are based on the notion of ?se-
mantic frame?. A frame is a conceptual descrip-
tion of a type of event, relation, or entity, and it
212
includes a list of possible participants in terms of
the roles they play; these participants are called
?frame elements?. Through the following exam-
ple, we present the terminology and acronyms that
will be used throughout the paper.
Example (2) shows the frame annotations for
the sentence Toujan Faisal said she was informed
of the refusal by an Interior Ministry committee.
One of the semantic frames in the sentence is
Statement. The frame evoking element (FEE) for
this frame is said. It has two frame elements (FE):
one of type Speaker (Toujan Faisal) and the other
of type Message (she was informed ... by an Inte-
rior Ministry committee).
(2) [
FE?Speaker
Toujan Faisal] [
FEE?Statement
said] [
FE?Message
she was informed of the
refusal by an Interior Ministry committee]
In example (2), the speaker of the message (Toujan
Faisal) is mentioning another group of people (the
Interior Ministry committee) in her message. By
definition, this is a social event of type OBS. In
general, there is an OBS social event between any
Speaker and any person mentioned in the frame
element Message of the frame Statement. This
close relation between frames and social events is
the reason for our investigation and use of frame
semantics for the tasks addressed in this paper.
4 Feature space and data representation
We convert examples
2
into two kinds of structured
representations: feature vectors and tree struc-
tures. Each of these structural representations may
broadly be categorized into one or more of the fol-
lowing levels of abstraction: {Lexical, Syntactic,
Semantic}. Table 2 presents this distribution. Our
final results show that all of our top performing
models use a data representation that is a combi-
nation of features and structures from all levels of
abstraction. We review previously proposed fea-
tures and tree structures in subsections 4.1, 4.2,
and 4.3. To the best of our knowledge, the re-
maining features and structures presented in this
section are novel.
4.1 Bag of words (BOW)
We create a vocabulary from our training data
by using the Stanford tokenizer (Klein and Man-
ning, 2003) followed by removal of stop words
2
An input example is a sentence with a pair of entity men-
tions between whom we predict and classify social events.
and Porter Stemming. We convert each example
(~x) to a set of three boolean vectors: {
~
b
1
,
~
b
2
,
~
b
3
}.
~
b
1
is the occurrence of words before the first tar-
get,
~
b
2
between the two targets and
~
b
3
after the sec-
ond target. Here the first target and second target
are defined in terms of the surface order of words.
Though these features have been previously pro-
posed for relation extraction on ACE (GuoDong
et al., 2005), they have not been utilized for the
task we address in this paper.
4.2 Syntactic structures (AR2010)
In Agarwal and Rambow (2010), we explored
a wide range of syntactic structures for the two
tasks of social event detection (SED) and classi-
fication (SEC). All our previous structures were
derived from a variation of two underlying tree
structures: phrase structure trees and depen-
dency trees. The best structure we proposed was
PET_GR_SqGRW, which was a linear combina-
tion of two tree kernels and one word kernel: 1)
a structure derived from a phrase structure tree
(PET); 2) a grammatical role tree (GR), which is
a dependency tree in which words are replaced
with their grammatical roles; and 3) a path from
one entity to the other in a dependency tree, in
which grammatical roles of words are inserted as
additional nodes between the dependent and par-
ent (SqGRW). We refer the reader to Agarwal
and Rambow (2010) for details of these structures.
For the rest of the paper, we refer to this struc-
ture, PET_GR_SqGRW, as ?AR2010?. We use
AR2010 as one of our baselines.
4.3 Bag of frames (BOF)
We use Semafor (Chen et al., 2010) for obtaining
the semantic parse of a sentence. Semafor found
instances of 1,174 different FrameNet frames in
our corpus. Each example (~x) is converted to a
vector of dimension 1,174, in which x
i
(the i
th
component of vector ~x) is 1 if the frame number
i appears in the example, and 0 otherwise.
4.4 Hand-crafted semantic features (RULES)
We use the manual of the FrameNet resource to
hand-craft 199 rules that are intended to detect the
presence and determine the type of social events
between two entities mentioned in a sentence. An
example of one such rule is given in section 3,
which we reformulate here. We also present an-
other example:
213
Feature Vectors Tree Structures
BOW BOF RULES AR2010 FrameForest FrameTree FrameTreeProp
Lexical ! ! !
Syntactic ! !
Semantic (novel) ! ! ! ! !
Table 2: Features and tree structures and the level of abstraction they fall into.
(3) If the frame is Statement, and the first tar-
get entity mention is contained in the FE
Speaker, and the second is contained in the
FE Message, then there is an OBS social
event from the first entity to the second.
(4) If the frame is Commerce_buy, and one tar-
get entity mention is contained in the FE
Buyer, and the other is contained in the FE
Seller, then there is an INR social event be-
tween the two entities.
Each rule corresponds to a binary feature: it
takes a value 1 if the rule fires for an input ex-
ample, and 0 otherwise. Consider the following
sentence:
(5) [Coleman]
T1?Ind
{claimed}
[he]
T1
?
?Ind
{bought} drugs from the
[defendants]
T2?Grp
.
In this sentence, there are two social events:
1) an OBS event triggered by the word claimed
between Coleman and defendants and 2) an INR
event triggered by the word bought between he
(co-referential with Coleman) and the defendants.
Semafor correctly detects two frames in this
sentence: 1) the frame Statement, with Coleman
as Speaker, and he bought ... defendants as Mes-
sage, and 2) the frame Commerce_buy, with he as
the Buyer, drugs as the Goods and the defendants
as the Seller. Both hand-crafted rules (3 and 4)
fire and the corresponding feature values for these
rules is set to 1. Firing of these rules (and thus
the effectiveness these features) is of course highly
dependent on the fact that Semafor provides an ac-
curate frame parse for the sentence.
4.5 Semantic trees (FrameForest,
FrameTree, FrameTreeProp)
Semafor labels text spans in sentences as frame
evoking elements (FEE) or frame elements (FE).
A sentence usually has multiple frames and the
frame annotations may overlap. There may be two
ways in which spans overlap (Figure 1): (a) one
Figure 1: Two overlapping scenarios for frame an-
notations of a sentence, where F1, F2 are frames.
frame annotation is completely embedded in the
other frame annotation and (b) some of the frame
elements overlap (in terms of text spans). We now
present the three frame semantic tree kernel rep-
resentations that handle these overlapping issues,
along with providing a meaningful semantic ker-
nel representation for the tasks addressed in this
paper.
For each of the following representations,
we assume that for each sentence s, we have
the set of semantic frames, F
s
= {F =
?FEE, [FE
1
, FE
2
, . . . , FE
n
]?} with each frame
F having an FEE and a list of FEs. . We illustrate
the structures using sentence (5).
4.5.1 FrameForest Tree Representation
We first create a tree for each frame annota-
tion F in the sentence. Consider a frame,
F = ?FEE, [FE
1
, FE
2
, . . . , FE
n
]?. For the
purposes of tree construction, we treat FEE as
another FE (call it FE
0
) of type Target. For
each FE
i
, we choose the subtree from the de-
pendency parse tree that is the smallest subtree
containing all words annotated as FE
i
by Se-
mafor. Call this subtree extracted from the de-
pendency parse DepTree_FE
i
. We then cre-
ate a larger tree by adding DepTree_FE
i
as
a child of a new node labeled with frame el-
ement FE
i
: (FE
i
DepTree_FE
i
). Call this
resulting tree SubTree_FE
i
. We then connect
all the SubTree_FE
i
(i ? {0, 1, 2, . . . , n}) to
a new root node labeled with the frame F :
(F SubTree_FE
0
. . . SubTree_FE
n
). This
is the tree for a frame F . Since the sentence
could have multiple frames, we connect the for-
est of frame trees to a new node called ROOT .
214
ROOT
Commerce_buy
Target
4
Buyer
T1-Ind
Seller
from
T2-Grp
Statement
Target
claimed
4
Speaker
T1?-Ind
Message
4
Statement
Speaker
T1-Ind
Coleman
Message
Commerce_buy
Buyer
T1?-Ind
he
Seller
T2-Grp
defendants
Figure 2: Semantic trees for the sentence ?Coleman claimed [he]
T1?Ind
bought drugs from the
[defendants]
T2?Grp
.?. The tree on the left is FrameForest and the tree on the right is FrameTree. 4
in FrameForest refers to the subtree (bought (T1-Ind) (from T2-Grp)). Ind refers to individual and Grp
refers to group.
We prune away all subtrees that do not contain
the target entities. We refer to the resulting tree
as FrameForest.
For example, in Figure 2, the left tree is the
FrameForest tree for sentence (5). There are two
frames in this sentence that appear in the final tree
because both these frames contain the target enti-
ties and thus are not pruned away. The two frames
are Commerce_buy and Statement. We first cre-
ate trees for each of the frames. For the Com-
merce_buy frame, there are three frame elements:
Target (the frame evoking element), Buyer and
Seller. For each frame element, we get the sub-
tree from the dependency tree that contains all the
words belonging to that frame element. The sub-
tree for FEE Target is (bought T1-Ind (from T2-
Grp)). The subtree for FE Buyer is (T1-Ind) and
the subtree for FE Seller is (from T2-Grp). We
connect these subtrees to their respective frame el-
ements and connect the resulting subtrees to the
frame (Commerce_buy). Similarly, we create a
tree for the frame Statement. Finally, we connect
all frame trees to the ROOT .
In this representation, we have avoided the
frame overlapping issues by repeating the com-
mon subtrees: the subtree (bought T1-Ind (from
T2-Grp)) is repeated under the FEE Target of the
Statement frame as well as under the FE Message
of the Statement frame.
4.5.2 FrameTree Tree Representation
For the design of this tree, we deal with the two
overlapping conditions shown in Figure 1 differ-
ently. If one frame is fully embedded in another
frame, we add the former as a child of the latter
frame. In Figure 2, the frame Commerce_buy is
fully embedded in the frame element Message of
the frame Statement. Therefore, the frame sub-
tree for Commerce_buy appears as a subtree of
Message.
If the frames overlap partially, we copy over the
overlapping portions of the structures to each of
the frame sub-trees.
For the design of this representation, we remove
all lexical nodes (struck out nodes in Figure 2) and
trees that do not span any of the target entities (not
shown in the figure). As a result, this structure
is the smallest semantic structure that contains the
two target entities. The right tree in Figure 2 is the
FrameTree tree for sentence (5).
4.5.3 FrameTreeProp Tree Representation
We are using a partial tree kernel (PTK) for calcu-
lating the similarity of two trees (as detailed in sec-
tion 5). The PTK does not skip over nodes of the
tree that lie on the same path. For establishing an
OBS social event between Coleman and the defen-
dants, all the structure needs to encode is the fact
that one target appears as a Speaker and the other
appears in the Message (of the speaker). In Frame-
Tree, this information is encoded but in an unclear
manner ? there are two nodes (Commerce_buy
and Seller) that come in between the node Mes-
sage and T2-Grp.
For this reason, we copy the nodes labeled with
the target annotations (T1??, T2??) to all nodes
(that are frame elements of a frame) on the path
from them to the root in FrameTree. We call this
215
variation of FrameTree, in which we propagate
T1 ? ?, T2 ? ? nodes to the root, FrameTreeP-
rop. For the running example, FrameTreeProp
will be: (Statement (Speaker T1-Ind) (Message
(Commerce_buy ...) (T2-Grp))). Using this tree
representation, one of the sub-trees in the implicit
feature space will be (Statement (Speaker T1-Ind)
(Message (T2-Grp)), which encodes the relation
between the two targets in a more direct manner
as compared to FrameTree.
5 Machine Learning
We represent our data in form of feature vectors
and tree structures. We use convolution kernels
(Haussler, 1999) that make use of the dual form
of Support Vector Machines (SVMs). In the dual
form, the optimization problem that SVM solves
is the following (Burges, 1998):
max ?
i
?
i
? ?
i,j
?
i
?
j
y
i
y
j
K(x
i
, x
j
)
s.t. ?
i
?
i
y
i
= 0
?
i
? 0 ?i = 1, 2, . . . , l
Here, x
i
is the input example, y
i
is the class of
the example x
i
, ?
i
is the Lagrange multiplier as-
sociated with example x
i
, l is the number of train-
ing examples, and K is the kernel function that
returns a similarity between two examples. More
formally, K is the function, K : X ? X ? R,
that maps a pair of objects belonging to the set X
to a real number. For example, if we represent our
input examples as feature vectors, the setX would
be the set of feature vectors. For feature vectors,
we use a linear kernel, i.e. K(x
i
, x
j
) = x
i
? x
j
(dot product of the two vectors). For our tree rep-
resentations, we use a Partial Tree Kernel (PTK),
first proposed by Moschitti (2006). PTK is a re-
laxed version of the Subset Tree (SST) kernel pro-
posed by Collins and Duffy (2002). A subset
tree kernel measures the similarity between two
trees by counting all subtrees common to the two
trees. However, there is one constraint: all daugh-
ter nodes of a parent node must be included (in
the sub-trees). In PTK, this constraint is removed.
Therefore, in contrast to SST, PT kernels compare
many more substructures. For a combination of
feature vectors and tree representations, we sim-
ply use the linear combination of their respective
kernels.
6 Experiments and Results
We present 5-fold cross-validation results on the
ACE2005 corpus annotated for social events.
Since the number of types of features and struc-
tures is not large (Table 2), we run an exhaustive
set of 2
7
? 1 = 127 experiments for each of three
tasks: Social Event Detection (SED), Social Event
Classification (SEC) and Social Network Extrac-
tion (SNE). To avoid over-fitting to a particular
partition into folds, we run each 5-fold experi-
ment 50 times, for 50 randomly generated parti-
tions. The results reported in the following tables
are all averaged over these 50 partitions. The ab-
solute standard deviation on an average is less than
0.004. This means that the performance of our
models across 50 random folds does not fluctuate
and hence the system is robust. We use McNe-
mar?s significance test and refer to statistical sig-
nificance as p < 0.05.
6.1 Social event detection (SED) and
classification (SEC)
We report precision (P), recall (R) and F1 measure
for the detection task, and % accuracy for the clas-
sification task. For both these tasks, our previous
best performing system was PET_GR_SqGRW
(which we refer to as AR2010). We use this as
a baseline, and introduce two new baselines: the
bag-of-words (BOW) baseline and a linear com-
bination of BOW and AR2010, referred to as
BOW_AR2010.
Table 3 presents the results for these two tasks
for various features and structures. The results
show that our purely semantic models (RULES,
BOF, FrameTree, FrameTreeProp) do not perform
well alone. FrameForest, which encodes some
lexical and syntactic level features (but is primar-
ily semantic), also performs worse than the base-
lines when used alone. However, a combination
of lexical, syntactic and semantic structures im-
proves the performance by an absolute of 1.1% in
F1-measure for SED (from 0.574 to 0.585). This
gain is statistically significant. For SEC, the abso-
lute gain from our best baseline (BOW_AR2010)
is 0.8% in F1-measure (from 82.3 to 83.1), which
is not statistically significant. However, the gain
of 2% from our previously proposed best system
(AR2010) is statistically significant.
216
SED SEC SNE Hierarchical
Model P R F1 %Acc P R F1
BOW 0.343 0.391 0.365 70.9 0.247 0.277 0.261
AR2010 0.464 0.751 0.574 81.1 0.375 0.611 0.465
BOW_AR2010 0.488 0.645 0.555 82.3 0.399 0.532 0.456
RULES 0.508 0.097 0.164 60.2 0.301 0.059 0.099
BOF 0.296 0.416 0.346 64.4 0.183 0.266 0.217
FrameForest 0.331 0.594 0.425 74.5 0.247 0.442 0.317
FrameTree 0.295 0.594 0.395 68.3 0.206 0.405 0.273
FrameTreeProp 0.308 0.554 0.396 70.7 0.217 0.390 0.279
All 0.494 0.641 0.558 82.5 0.405 0.531 0.460
BOW_AR2010_FrameForest_FrameTreeProp 0.490 0.633 0.552 83.1 0.405 0.528 0.459
AR2010_FrameTreeProp 0.484 0.740 0.585 82.0 0.397 0.608 0.480
Table 3: Results for three tasks: ?SED? is Social Event Detection, ?SEC? is Social Event Classification,
?SNE? is Social Network Extraction. The first three models are the baseline models. The next five
models are the novel semantic features and structures we propose in this paper. ?All? refers to the
model that uses all the listed structures together. ?BOW_AR2010_FrameForest_FrameTreeProp? refers
to the model that uses a linear combination of mentioned structures. AR2010_FrameTreeProp is a linear
combination of AR2010 and FrameTreeProp.
6.2 Social network extraction (SNE)
Social network extraction is a multi-way classifi-
cation task, in which, given an example, we clas-
sify it into one of three categories: {No-Event,
INR, OBS}. A popular technique of performing
multi-way classification using a binary classifier
like SVM, is one-versus-all (OVA). We try this
along with a less commonly used technique, in
which we stack two binary classifiers in a hier-
archy. For the hierarchical design, we train two
models: (1) the SED model ({INR + OBS} ver-
sus No-Event) and (2) the SEC model (INR versus
OBS). Given a test example, it is first classified us-
ing the SED model. If the prediction is less than
zero, we label it as No-Event. Otherwise, the test
example is passed onto SEC and finally classified
into either INR or OBS.
We see that none of the semantic features and
structures alone outperform the baseline. How-
ever, a combination of structures from different
levels of abstraction achieve the best performance:
an absolute gain of 1.5% in F1 (statistically sig-
nificant) when we use a hierarchical design (from
0.465 to 0.480).
Comparing hierarchical verus OVA approaches,
we observe that the hierarchical approach
outperforms the OVA approach for all our
models by a statistically significant margin.
The performance for our best reported model
(AR2010_FrameTreeProp) for OVA in terms
precision, recall, and F1-measure is 0.375, 0.592,
0.459 respectively. This is statistically signifi-
cantly worse than hierarchical approach (0.397,
0.608, 0.480).
6.3 Discussion of results
Performing well on SED is more important than
SEC, because if a social event is not detected in
the first place, the goodness of the SEC model is
irrelevant. Therefore, the best feature and struc-
ture combination we report in this paper is a com-
bination of AR2010 and FrameTreeProp.
To gain insight into the how each type of se-
mantic feature and structure contribute to our
previously proposed lexical and syntactic model
(AR2010), we perform experiments in which we
add one semantic feature/structure at a time to
AR2010. Table 4 presents the results for this
study. We see that the hand-crafted RULES do
not help in the overall task. We investigated the
reason for RULES not being as helpful as we had
expected. We found that when there is no social
event, the rules fire in 7% of the cases. When
there is a social event, they fire in 17% of cases.
So while they fire more often when there is a so-
cial event, the percentage of cases in which they
fire is small. We hypothesize that this is due the
dependence of RULES on the correctness of se-
217
mantic parses. For example, Rule (4) correctly
detects the social event in sentence (5), since Se-
mafor correctly parses the input. In contrast, Se-
mafor does not correctly parse the input sentence
(1): it correctly identifies the Statement frame and
its Message frame element, but it fails to find the
Speaker. As a result, Rule (3) does not fire, even
though the semantic structure is partially identi-
fied. This, we believe, highlights the main strength
of tree kernels ? they are able to learn seman-
tic patterns, without requiring correctness or com-
pleteness of the semantic parse.
Out of the semantic structures we propose,
FrameTreeProp adds the most value to the base-
line system as compared to other semantic features
and structures. This supports our intuition that we
need to reduce unbounded semantic dependencies
between the target entities by propagating the tar-
get entity tags to the top of the semantic tree.
Model SED
(F1)
SEC
(%A)
SNE Hier.
(F1)
AR2010 0.574 81.1 0.465
+ RULES 0.576 80.8 0.465
+ BOF 0.569 80.7 0.459
+ FrameForest 0.571 82.6 0.472
+ FrameTree 0.579 81.5 0.473
+ FrameTreeProp 0.585 82.0 0.480
Table 4: A study to show which semantic features
and structures add the most value to the baseline.
The top row gives the performance of the base-
line. Each consecutive row shows the result of
the baseline plus the feature/structure mentioned
in that row.
7 Related Work
There have been recent efforts to extract net-
works from text (Elson et al., 2010; He et al.,
2013). However, these efforts extract a different
type of network: a network of only bi-directional
links, where the links are triggered by quotation
marks. For example, Elson et al. (2010) and He
et al. (2013) will extract an interaction link be-
tween Emma and Harriet in the following sen-
tence. However, their system will not detect any
interaction links in the other examples mentioned
in this paper.
(6) ?Take it,? said Emma, smiling, and pushing
the paper towards Harriet ?it is for you. Take
your own.?
Our approach to extract and classify social
events builds on our previous work (Agarwal and
Rambow, 2010), which in turn builds on work
from the relation extraction community (Nguyen
et al., 2009). Therefore, the task of relation extrac-
tion is most closely related to the tasks addressed
in this paper. Researchers have used other notions
of semantics in the literature such as latent se-
mantic analysis (Plank and Moschitti, 2013) and
relation-specific semantics (Zelenko et al., 2003;
Culotta and Sorensen, 2004). To the best of our
knowledge, there is only one work that uses frame
semantics for relation extraction (Harabagiu et al.,
2005). Harabagiu et al. (2005) propose a novel se-
mantic kernel that incorporates frame parse infor-
mation in the kernel computation that calculates
similarity between two dependency trees. They,
however, do not propose data representations that
are based on frame parses and the resulting ar-
borescent structures, instead adding features to
syntactic trees. We believe the implicit feature
space of kernels based on our data representation
encode a richer and larger feature space than the
one proposed by Harabagiu et al. (2005).
8 Conclusion and Future Work
This work has only scratched the surface of possi-
bilities for using frame semantic features and tree
structures for the task of social event extraction.
We have shown that tree kernels are well suited to
work with possibly inaccurate semantic parses in
contrast to hand-crafted features that require the
semantic parses to be completely accurate. We
have also extended our previous work by design-
ing and evaluating a full system for social network
extraction.
A more natural data representation for seman-
tic parses is a graph structure. We are actively
exploring the design of semantic graph structures
that may be brought to bear with the use of graph
kernels (Vishwanathan et al., 2010).
Acknowledgments
We would like to thank CCLS?s IT heads, Hatim
Diab and Manoj Pooleery, for providing the infras-
tructure support. This paper is based upon work
supported in part by the DARPA DEFT Program.
The views expressed are those of the authors and
do not reflect the official policy or position of the
Department of Defense or the U.S. Government.
218
References
Apoorv Agarwal and Owen Rambow. 2010. Auto-
matic detection and classification of social events.
In Proceedings of the 2010 Conference on Empiri-
cal Methods in Natural Language Processing, pages
1024?1034, Cambridge, MA, October. Association
for Computational Linguistics.
Apoorv Agarwal, Owen C. Rambow, and Rebecca J.
Passonneau. 2010. Annotation scheme for social
network extraction from text. In Proceedings of the
Fourth Linguistic Annotation Workshop.
Apoorv Agarwal, Anup Kotalwar, and Owen Ram-
bow. 2013a. Automatic extraction of social net-
works from literary text: A case study on alice in
wonderland. In the Proceedings of the 6th Interna-
tional Joint Conference on Natural Language Pro-
cessing (IJCNLP 2013).
Apoorv Agarwal, Anup Kotalwar, Jiehan Zheng, and
Owen Rambow. 2013b. Sinnet: Social interaction
network extractor from text. In Sixth International
Joint Conference on Natural Language Processing,
page 33.
Collin F. Baker, J. Fillmore, and John B. Lowe. 1998.
The Berkeley FrameNet project. In 36th Meet-
ing of the Association for Computational Linguis-
tics and 17th International Conference on Computa-
tional Linguistics (COLING-ACL?98), pages 86?90,
Montr?al.
Chris Burges. 1998. A tutorial on support vector ma-
chines for pattern recognition. Data mining and
knowledge discovery.
Desai Chen, Nathan Schneider, Dipanjan Das, and
Noah A. Smith. 2010. Semafor: Frame argument
resolution with log-linear models. In Proceedings of
the 5th International Workshop on Semantic Evalu-
ation, pages 264?267, Uppsala, Sweden, July. Asso-
ciation for Computational Linguistics.
Michael Collins and Nigel Duffy. 2002. New rank-
ing algorithms for parsing and tagging: Kernels over
discrete structures, and the voted perceptron. In Pro-
ceedings of the 40th annual meeting on association
for computational linguistics, pages 263?270. Asso-
ciation for Computational Linguistics.
Aron Culotta and Jeffrey Sorensen. 2004. Dependency
tree kernels for relation extraction. In Proceedings
of the 42nd Meeting of the Association for Compu-
tational Linguistics (ACL?04), Main Volume, pages
423?429, Barcelona, Spain, July.
David K. Elson, Nicholas Dames, and Kathleen R.
McKeown. 2010. Extracting social networks from
literary fiction. Proceedings of the 48th Annual
Meeting of the Association for Computational Lin-
guistics, pages 138?147.
Zhou GuoDong, Su Jian, Zhang Jie, and Zhang Min.
2005. Exploring various knowledge in relation ex-
traction. In Proceedings of 43th Annual Meeting of
the Association for Computational Linguistics.
Sanda Harabagiu, Cosmin Adrian Bejan, and Paul
Morarescu. 2005. Shallow semantics for relation
extraction. In International Joint Conference On Ar-
tificial Intelligence.
David Haussler. 1999. Convolution kernels on discrete
structures. Technical report, University of Califor-
nia at Santa Cruz.
Hua He, Denilson Barbosa, and Grzegorz Kondrak.
2013. Identification of speakers in novels. The
51st Annual Meeting of the Association for Compu-
tational Linguistics (ACL 2013).
Nanda Kambhatla. 2004. Combining lexical, syntac-
tic, and semantic features with maximum entropy
models for extracting relations. In Proceedings of
the ACL 2004 on Interactive poster and demonstra-
tion sessions, page 22. Association for Computa-
tional Linguistics.
Dan Klein and Christopher D. Manning. 2003. Accu-
rate unlexicalized parsing. Proceedings of the 41st
Meeting of the Association for Computational Lin-
guistics, pages 423?430.
Alessandro Moschitti. 2006. Efficient convolution ker-
nels for dependency and constituent syntactic trees.
In Proceedings of the 17th European Conference on
Machine Learning.
Truc-Vien T. Nguyen, Alessandro Moschitti, and
Giuseppe Riccardi. 2009. Convolution kernels on
constituent, dependency and sequential structures
for relation extraction. Conference on Empirical
Methods in Natural Language Processing.
Barbara Plank and Alessandro Moschitti. 2013. Em-
bedding semantic similarity in tree kernels for do-
main adaptation of relation extraction. In Proceed-
ings of the 51st Annual Meeting of the Association
for Computational Linguistics (Volume 1: Long Pa-
pers), pages 1498?1507, Sofia, Bulgaria, August.
Association for Computational Linguistics.
SVN Vishwanathan, Nicol N Schraudolph, Risi Kon-
dor, and Karsten M Borgwardt. 2010. Graph ker-
nels. The Journal of Machine Learning Research,
11:1201?1242.
Dmitry Zelenko, Chinatsu Aone, and Anthony
Richardella. 2003. Kernel methods for relation
extraction. The Journal of Machine Learning Re-
search, 3:1083?1106.
Shubin Zhao and Ralph Grishman. 2005. Extract-
ing relations with integrated information using ker-
nel methods. In Proceedings of the 43rd Meeting of
the ACL.
219
Proceedings of the 3rd Workshop on Computational Linguistics for Literature (CLfL) @ EACL 2014, pages 50?58,
Gothenburg, Sweden, April 27, 2014.
c?2014 Association for Computational Linguistics
Parsing Screenplays for Extracting Social Networks from Movies
Apoorv Agarwal
?
, Sriramkumar Balasubramanian
?
, Jiehan Zheng
?
, Sarthak Dash
?
?
Dept. of Computer Science
Columbia University
New York, NY, USA
?
Peddie School
Hightstown, NJ, USA
apoorv@cs.columbia.edu jzheng-14@peddie.org
Abstract
In this paper, we present a formalization
of the task of parsing movie screenplays.
While researchers have previously moti-
vated the need for parsing movie screen-
plays, to the best of our knowledge, there
is no work that has presented an evalua-
tion for the task. Moreover, all the ap-
proaches in the literature thus far have
been regular expression based. In this pa-
per, we present an NLP and ML based
approach to the task, and show that this
approach outperforms the regular expres-
sion based approach by a large and statis-
tically significant margin. One of the main
challenges we faced early on was the ab-
sence of training and test data. We pro-
pose a methodology for using well struc-
tured screenplays to create training data
for anticipated anomalies in the structure
of screenplays.
1 Introduction
Social network extraction from unstructured text
has recently gained much attention (Agarwal and
Rambow, 2010; Elson et al., 2010; Agarwal et al.,
2013a; Agarwal et al., 2013b; He et al., 2013). Us-
ing Natural Language Processing (NLP) and Ma-
chine Learning (ML) techniques, researchers are
now able to gain access to networks that are not
associated with any meta-data (such as email links
and self-declared friendship links). Movies, which
can be seen as visual approximations of unstruc-
tured literary works, contain rich social networks
formed by interactions between characters. There
has been some effort in the past to extract social
networks from movies (Weng et al., 2006; Weng
et al., 2007; Weng et al., 2009; Gil et al., 2011).
However, these approaches are primarily regular
expression based with no evaluation of how well
they work.
In this paper we introduce a formalization of the
task of parsing screenplays and present an NLP
and ML based approach to the task. By parsing
a screenplay, we mean assigning each line of the
screenplay one of the following five tags: ?S? for
scene boundary, ?N? for scene description, ?C?
for character name, ?D? for dialogue, and ?M? for
meta-data. We expect screenplays to conform to
a strict grammar but they often do not (Gil et al.,
2011). This disconnect gives rise to the need for
developing a methodology that is able to handle
anomalies in the structure of screenplays. Though
the methodology proposed in this paper is in the
context of movie screenplays, we believe, it is gen-
eral and applicable to parse other kinds of noisy
documents.
One of the earliest challenges we faced was the
absence of training and test data. Screenplays, on
average, have 7,000 lines of text, which limits the
amount of annotated data we can obtain from hu-
mans. We propose a methodology for using well
structured screenplays to create training data for
anticipated anomalies in the structure of screen-
plays. For different types of anomalies, we train
separate classifiers, and combine them using en-
semble learning. We show that our ensemble out-
performs a regular-expression baseline by a large
and statistically significant margin on an unseen
test set (0.69 versus 0.96 macro-F1 measure for the
five classes). Apart from performing an intrinsic
evaluation, we also present an extrinsic evaluation.
We show that the social network extracted from
the screenplay tagged by our ensemble is closer
to the network extracted from a screenplay tagged
50
by a human, as compared to the network extracted
from a screenplay tagged by the baseline.
The rest of the paper is structured as follows: in
section 2, we present common terminology used
to describe screenplays. We survey existing liter-
ature in section 3. Section 4 presents details of
our data collection methodology, along with the
data distribution. Section 5 gives details of our
regular-expression based system, which we use as
a baseline for evaluation purposes. In section 6,
we present our machine learning approach. In sec-
tion 7, we give details of the features we use for
machine learning. In section 8, we present our ex-
periments and results. We conclude and give fu-
ture directions of research in section 9.
2 Terminology
Turetsky and Dimitrova (2004) describe the
structure of a movie screenplay as follows: a
screenplay describes a story, characters, action,
setting and dialogue of a film. Additionally,
they report that the structure of a screenplay
follows a (semi) regular format. Figure 1 shows
a snippet of a screenplay from the film ? The
Silence of the Lambs. A scene (tag ?S?) starts
with what is called the slug line (or scene bound-
ary). The slug line indicates whether the scene
is to take place inside or outside (INT, EXT),
the name of the location (?FBI ACADEMY
GROUNDS, QUANTICO, VIRGINIA?), and
can potentially specify the time of day (e.g.
DAY or NIGHT). Following the scene boundary
is a scene description. A scene description
is followed by a character name (tag ?C?),
which is followed by dialogues (tag ?D?).
Character names are capitalized, with an optional
(V.O.) for ?Voice Over? or (O.S.) for ?Off-screen.?
Dialogues, like scene descriptions, are not asso-
ciated with any explicit indicators (such as INT,
V.O.), but are indented at a unique level (i.e.
nothing else in the screenplay is indented at this
level). Screenplays may also have other elements,
such as ?CUT TO:?, which are directions for the
camera, and text describing the intended mood
of the speaker, which is found within parentheses
in the dialogue. For lack of a name for these
elements, we call them ?Meta-data? (tag ?M?).
3 Literature Survey
One of the earliest works motivating the need for
screenplay parsing is that of Turetsky and Dim-
itrova (2004). Turetsky and Dimitrova (2004)
proposed a system to automatically align written
screenplays with their videos. One of the crucial
steps, they noted, is to parse a screenplay into its
different elements: scene boundaries, scene de-
scriptions, character names, and dialogues. They
proposed a grammar to parse screenplays and
show results for aligning one screenplay with its
video. Weng et al. (2009) motivated the need for
screenplay parsing from a social network analy-
sis perspective. They proposed a set of opera-
tions on social networks extracted from movies
and television shows in order to find what they
called hidden semantic information. They pro-
posed techniques for identifying lead roles in bi-
lateral movies (movies with two main characters),
for performing community analysis, and for au-
tomating the task of story segmentation. Gil et
al. (2011) extracted character interaction networks
from plays and movies. They were interested in
automatically classifying plays and movies into
different genres by making use of social network
analysis metrics. They acknowledged that the
scripts found on the internet are not in consistent
formats, and proposed a regular expression based
system to identify scene boundaries and character
names.
While there is motivation in the literature to
parse screenplays, none of the aforementioned
work addresses the task formally. In this paper, we
formalize the task and propose a machine learning
based approach that is significantly more effec-
tive and tolerant of anomalous structure than the
baseline. We evaluate our models on their ability
to identify scene boundaries and character names,
but also on their ability to identify other important
elements of a screenplay, such as scene descrip-
tions and dialogues.
4 Data
We crawled the Internet Movie Script Database
(IMSDB) website
1
to collect movie screenplays.
We crawled a total of 674 movies. Movies
that are well structured have the property that
scene boundaries and scene descriptions, charac-
ter names, and dialogues are all at different but
fixed levels of indentation.
2
For example, in the
movie in Figure 1, all scene boundaries and scene
1
http://www.imsdb.com
2
By level of indentation we mean the number of spaces
from the start of the line to the first non-space character.
51
Figure 1: Example screenplay: first column shows the tags we assign to each line in the screenplay. M
stands for ?Meta-data?, S stands for ?Scene boundary?, N stands for ?Scene description?, C stands for
?Character name?, and D stands for ?Dialogue.? We also show the lines that are at context -2 and +3 for
the line ?CRAWFORD.?
descriptions are at the same level of indentation,
equal to five spaces. All character names are at
a different but fixed level of indentation, equal to
20 spaces. Dialogues are at an indentation level
of eight spaces. These indentation levels may vary
from one screenplay to the other, but are consis-
tent within a well formatted screenplay. Moreover,
the indentation level of character names is strictly
greater than the indentation level of dialogues,
which is strictly greater than the indentation level
of scene boundaries and scene descriptions. For
each crawled screenplay, we found the frequency
of unique indentation levels in that screenplay. If
the top three unique frequencies constituted 90%
of the total lines of a screenplay, we flagged that
the movie was well-structured, and assigned tags
based on indentation levels. Since scene bound-
aries and scene descriptions are at the same level
of indentation, we disambiguate between them by
utilizing the fact that scene boundaries in well-
formatted screenplays start with tags such as INT.
and EXT. We programmatically checked the sanity
of these automatically tagged screenplays by using
the following procedure: 1) check if scene descrip-
tions are between scene boundaries and character
names, 2) check if dialogues are between charac-
ter names, and 3) check if all character names are
within two scene boundaries. Using this method-
ology, we were able to tag 222 movies that pass
the sanity check.
Data # S # N # C # D # M
TRAIN 2,445 21,619 11,464 23,814 3,339
DEV1 714 7,495 4,431 9,378 467
DEV2 413 5,431 2,126 4,755 762
TEST 164 845 1,582 3,221 308
Table 1: Data distribution
Table 1 gives the distribution of our training, de-
velopment and test sets. We use a random sub-
set of the aforementioned set of 222 movies for
training purposes, and another random subset for
development. We chose 14 movies for the train-
ing set and 9 for the development set. Since hu-
man annotation for the task is expensive, instead of
getting all 23 movies checked for correctness, we
asked an annotator to only look at the development
set (9 movies). The annotator reported that one
out of 9 movies was not correctly tagged. We re-
moved this movie from the development set. From
the remaining 8 movies, we chose 5 as the first de-
velopment set and the remaining 3 as the second
development set. For the test set, we asked our
annotator to annotate a randomly chosen screen-
play (Silver Linings Playbook) from scratch. We
chose this screenplay from the set of movies that
52
we were unable to tag automatically, i.e. not from
the set of 222 movies.
5 Baseline System
Gil et al. (2011) mention the use of regular expres-
sions for tagging screenplays. However, they do
not specify the regular expressions or their exact
methodology. We use common knowledge about
the structure of the screenplay (underlined text in
section 2) to build a baseline system, that uses reg-
ular expressions and takes into account the gram-
mar of screenplays.
Since scene descriptions, characters and dia-
logues are relative to the scene boundary, we do
a first pass on the screenplay to tag scene bound-
aries. We created a dictionary of words that are
expected to indicate scene boundaries. We use
this dictionary for tagging lines in the screenplay
with the tag ?S?. We tag all the lines that con-
tain tags indicating a character (V.O., O.S.) with
?C?. We built a dictionary of meta-data tags that
contains patterns such as ?CUT TO:, DISSOLVE
TO.? We tag all the remaining untagged lines con-
taining these patterns with the tag ?M.? This ex-
hausts the list of regular expression matches that
indicate a certain tag.
In the next pass, we incorporate prior knowl-
edge that scene boundaries and character names
are capitalized. For this, we tag all the untagged
lines that are capitalized, and that have more than
three words as scene boundaries (tag ?S?). We tag
all the untagged lines that are capitalized, and that
have less than four words as character (tag ?C?).
The choice of the number four is not arbitrary;
we examined the set of 222 screenplays that was
tagged using indentation information and found
that less than two percent of the character names
were of length greater than three.
Finally, we incorporate prior knowledge about
relative positions of dialogues and scene descrip-
tions to tag the remaining untagged lines with one
of two tags: ?D? or ?N?. We tag all the untagged
lines between a scene boundary and the first char-
acter occurrence as ?N?. We tag all the lines be-
tween consecutive character occurrences, the last
character occurrence and the scene boundary as
?D?.
We use this baseline system, which incorporates
all of the prior knowledge about the structure of
screenplays, to tag movies in our first development
set DEV1 (section 8). We report a macro-F1 mea-
sure for the five tags as 0.96. This confirms that
our baseline is well suited to parse screenplays that
are well structured.
6 Machine Learning Approach
Note that our baseline system is not dependent on
the level of indentation (it achieves a high macro-
F1 measure without using indentation informa-
tion). Therefore, we have already dealt with one
common problem with screenplays found on the
web: bad indentation. However, there are other
problems, some of which we noticed in the lim-
ited data we manually examined, and others that
we anticipate: (1) missing scene boundary spe-
cific patterns (such as INT./EXT.) from the scene
boundary lines, (2) uncapitalized scene boundaries
and (3) uncapitalized character names. These are
problems that a regular expression based system
is not well equipped to deal with. In this sec-
tion, we discuss a strategy for dealing with screen-
plays, which might have anomalies in their struc-
ture, without requiring additional annotations.
We synthesize training and development data
to learn to handle the aforementioned three types
of anomalies. We create eight copies of our
TRAIN set: one with no anomalies, represented as
TRAIN_000,
3
one in which character names are
uncapitalized, represented as TRAIN_001, one in
which both scene boundaries and character names
are uncapitalized, represented as TRAIN_011,
and so on. Similarly, we create eight copies
of our DEV1 set: {DEV1_000, DEV1_001, ...,
DEV1_111}. Now we have eight training and
eight development sets. We train eight models,
and choose the parameters for each model by tun-
ing on the respective development set. However,
at test time, we require one model. Moreover, our
model should be able to handle all types of anoma-
lies (all of which could be present in a random or-
der). We experiment with three ensemble learning
techniques and choose the one that performs the
best on the second development set, DEV2. We
add all three types of anomalies, randomly, to our
DEV2 set.
For training individual models, we use Support
Vector Machines (SVMs), and represent data as
feature vectors, discussed in the next section.
3
Each bit refers to the one type of anomaly described
in the previous paragraph. If the least significant bit is 1,
this means, the type of anomaly is uncapitalized characters
names.
53
7 Features
We have six sets of features: bag-of-words fea-
tures (BOW), bag-of-punctuation-marks features
(BOP), bag-of-terminology features (BOT), bag-
of-frames features (BOF), bag-of-parts-of-speech
features (POS), and hand-crafted features (HAND).
We convert each line of a screenplay (input ex-
ample) into a feature vector of length 5,497: 3,946
for BOW, 22 for BOP, 2*58 for BOT, 2*45 for
POS, 2*651 for BOF, and 21 for HAND.
BOW, BOP, and BOT are binary features; we
record the presence or absence of elements of each
bag in the input example. The number of ter-
minology features is multiplied by two because
we have one binary vector for ?contains term?,
and another binary vector for ?is term.? We have
two sets of features for POS and BOF. One set
is binary and similar to other binary features that
record the presence or absence of parts-of-speech
and frames in the input example. The other set
is numeric. We record the normalized counts of
each part-of-speech and frame respectively. The
impetus to design this second set of features for
parts-of-speech and frames is the following: we
expect some classes to have a characteristic dis-
tribution of parts-of-speech and frames. For ex-
ample, scene boundaries contain the location and
time of scene. Therefore, we expect them to have
a majority of nouns, and frames that are related to
location and time. For the scene boundary in Fig-
ure 1 (EXT. FBI ACADEMY ... - DAY), we find
the following distribution of parts of speech and
frames: 100% nouns, 50% frame LOCALE (with
frame evoking element grounds), and 50% frame
CALENDRIC_UNIT (with frame evoking element
DAY). Similarly, we expect the character names to
have 100% nouns, and no frames.
We use Stanford part-of-speech tagger
(Toutanova et al., 2003) for obtaining the
part-of-speech tags and Semafor (Chen et al.,
2010) for obtaining the FrameNet (Baker et
al., 1998) frames present in each line of the
screenplay.
We devise 21 hand-crafted features. Six-
teen of these features are binary (0/1). We
list these features here (the feature names
are self-explanatory): has-non-alphabetical-
chars, has-digits-majority, has-alpha-majority,
is-quoted, capitalization (has-all-caps, is-all-
caps), scene boundary (has-INT, has-EXT),
date (has-date, is-date), number (has-number,
is-number), and parentheses (is-parenthesized,
starts-with-parenthesis, ends-with-parenthesis,
contains-parenthesis). We bin the preceding
number of blank lines into four bins: 0 for no
preceding blank lines, 1 for one preceding blank
line, 2 for two preceding blank lines, and so on.
We also bin the percentage of capitalized words
into four bins: 0 for the percentage of capitalized
words lying between 0-25%, 1 for 25-50%, and
so on. We use three numeric features: number of
non-space characters (normalized by the maxi-
mum number of non-space characters in any line
in a screenplay), number of words (normalized
by the maximum number of words in any line in
a screenplay), and number of characters (normal-
ized by the maximum number of characters in any
line in a screenplay).
For each line, say line
i
, we incorporate con-
text up to x lines. Figure 1 shows the lines
at context -2 and +3 for the line contain-
ing the text CRAWFORD. To do so, we ap-
pend the feature vector for line
i
by the fea-
ture vectors of line
i?1
, line
i?2
, . . . line
i?x
and
line
i+1
, line
i+2
, . . . line
i+x
. x is one of the pa-
rameters we tune at the time of training. We refer
to this parameter as CONTEXT.
8 Experiments and Results
In this section, we present experiments and results
for the task of tagging the lines of a screenplay
with one of five tags: {S, N, C, D, M}. Table 1
shows the data distribution. For parameter tun-
ing, we use DEV1 (section 8.1). We train sepa-
rate models on different types of known and antici-
pated anomalies (as discussed in section 6). In sec-
tion 8.2, we present strategies for combining these
models. We select the right combination of mod-
els and features by tuning on DEV2. Finally, we
show results on the test set, TEST. For all our ex-
periments, we use the default parameters of SVM
as implemented by the SMO algorithm of Weka
(Hall et al., 2009). We use a linear kernel.
4
8.1 Tuning learning parameters
We tune two parameters: the amount of train-
ing data and the amount of CONTEXT (section 7)
required for learning. We do this for each of
the eight models (TRAIN_000/DEV1_000, ...,
TRAIN_111/DEV1_111). We merge training
4
We tried the polynomial kernel up to a degree of four and
the RBF kernel. They performed worse than the linear kernel.
54
10 20 30 40 50 60 70 80 90 1000.7
0.75
0.8
0.85
0.9
0.95
1
% TRAINING DATA USED
MAC
RO F
?ME
ASU
RE
TRAIN?DEV1 (000)
 
 
context?0context?1context?2context?3context?4context?5
Figure 2: Learning curve for training on
TRAIN_000 and testing on DEV1_000. X-axis
is the % of training data, in steps of 10%. Y-axis
is the macro-F1 measure for the five classes.
data from all 14 movies into one (TRAIN). We
then randomize the data and split it into 10 pieces
(maintaining the relative proportions of the five
classes). We plot a learning curve by adding 10%
of training data at each step.
Figure 2 shows the learning curve for train-
ing a model on TRAIN_000 and testing on
DEV1_000.
5
The learning curve shows that the
performance of our classifier without any context
is significantly worse than the classifiers trained
on context. Moreover, the learning saturates early,
and stabilizes at about 50% of the training data.
From the learning curves, we pick CONTEXT
equal to 1, and the amount of training data equal
to 50% of the entire training set.
Table 2 shows a comparison of our rule based
baseline with the models trained using machine
learning. For the 000 setting, when there is no
anomaly in the screenplay, our rule based base-
line performs well, achieving a macro-F1 measure
of 0.96. However, our machine learning model
outperforms the baseline by a statistically signif-
icant margin, achieving a macro-F1 measure of
0.99. We calculate statistical significance using
McNemar?s significance test, with significance de-
fined as p < 0.05.
6
Results in Table 2 also show
that while a deterministic regular-expression based
system is not well equipped to handle anomalies,
there is enough value in our feature set, that our
machine learning based models learn to adapt to
any combination of the three types of anomalies,
achieving a high F1-measure of 0.98 on average.
5
Learning curves for all our other models were similar.
6
We use the same test for reporting other statistically sig-
nificance results in the paper.
8.2 Finding the right ensemble and feature
selection
We have trained eight separate models, which
need to be combined into one model that we will
make predictions at the test time. We explore the
following ways of combining these models:
1. MAJ: Given a test example, we get a vote
from each of our eight models, and take a ma-
jority vote. At times of a clash, we pick one
randomly.
2. MAX: We pick the class predicted by the
model that has the highest confidence in its
prediction. Since the confidence values are
real numbers, we do not see any clashes.
3. MAJ-MAX: We use MAJ but at times of a
clash, we pick the class predicted by the clas-
sifier that has the highest confidence (among
the classifiers that clash).
Table 3 shows macro-F1 measures for the three
movies in our DEV2 set. Note, we added the three
types of anomalies (section 6) randomly to the
DEV2 set for tuning the type of ensemble. We
compare the performance of the three ensemble
techniques with the individual classifiers (trained
on TRAIN_000, ... TRAIN_111).
The results show that all our ensembles (ex-
cept MAX for the movie The Last Temptation of
Christ) perform better than the individual models.
Moreover, the MAJ-MAX ensemble outperforms
the other two by a statistically significant margin.
We thus choose MAJ-MAX as our final classifier.
Table 4 shows results for removing one of all
feature sets, one at a time. These results are for our
final model, MAJ-MAX. The row ?All? shows the
results when we use all our features for training.
The consecutive rows show the result when we re-
move the mentioned feature set. For example, the
row ?- BOW? shows the result for our classifier
that was trained without the bag of words feature
set.
Table 4 shows that the performance drops the
most for bag of words (BOW) and for our hand-
crafted features (HAND). The next highest drop
is for the bag of frames feature set (BOF). Er-
ror analysis revealed that the major drop in per-
formance because of the removal of the BOF fea-
tures was not due the drop in the performance
of scene boundaries, counter to our initial intu-
ition. The drop was because the recall of dia-
55
000 001 010 011 100 101 110 111
Rule based 0.96 0.49 0.70 0.23 0.93 0.46 0.70 0.24
ML model 0.99 0.99 0.98 0.99 0.97 0.98 0.98 0.98
Table 2: Comparison of performance (macro-F1 measure) of our rule based baseline with our machine
learning based models on development sets DEV1_000, DEV1_001, ..., DEV1_111. All models are
trained on 50% of the training set, with the feature space including CONTEXT equal to 1.
Movie 000 001 010 011 100 101 110 111 MAJ MAX MAJ-MAX
LTC 0.87 0.83 0.79 0.94 0.91 0.86 0.79 0.96 0.97 0.95 0.98
X-files 0.87 0.84 0.79 0.93 0.86 0.84 0.79 0.92 0.94 0.94 0.96
Titanic 0.87 0.87 0.81 0.94 0.86 0.83 0.82 0.93 0.94 0.95 0.97
Average 0.87 0.85 0.80 0.94 0.88 0.84 0.80 0.94 0.95 0.95 0.97
Table 3: Macro-F1 measure for the five classes for testing on DEV2 set. 000 refers to the model trained
on data TRAIN_000, 001 refers to the model trained on data TRAIN_001, and so on. MAJ, MAX, and
MAJ-MAX are the three ensembles. The first column is the movie name. LTC refers to the movie ?The
Last Temptation of Christ.?
Feature set LTC X-files Titanic
All 0.98 0.96 0.97
- BOW 0.94 0.92 0.94
- BOP 0.98 0.97 0.97
- BOT 0.97 0.95 0.96
- BOF 0.96 0.93 0.96
- POS 0.98 0.96 0.95
- HAND 0.94 0.93 0.93
Table 4: Performance of MAJ-MAX classifier with
feature removal. Statistically significant differ-
ences are in bold.
logues decreases significantly. The BOF features
were helping in disambiguating between the meta-
data, which usually have no frames associated
with them, and dialogues. Removing bag of punc-
tuation (BOP) results in a significant increase in
the performance for the movie X-files, with a small
increase for other two movies. We remove this
feature from our final classifier. Removing parts
of speech (POS) results in a significant drop in the
overall performance for the movie Titanic. Error
analysis revealed that the drop in performance here
was in fact due the drop in performance of scene
boundaries. Scene boundaries almost always have
100% nouns and the POS features help in cap-
turing this characteristic distribution indicative of
scene boundaries. Removing bag of terminology
(BOT) results in a significant drop in the overall
performance of all movies. Our results also show
that though the drop in performance for some fea-
Baseline MAJ-MAX
Tag P R F1 P R F1
S 0.27 1.00 0.43 0.99 1.00 0.99
N 0.21 0.06 0.09 0.88 0.95 0.91
C 0.89 1.00 0.94 1 0.92 0.96
D 0.99 0.94 0.96 0.98 0.998 0.99
M 0.68 0.94 0.79 0.94 0.997 0.97
Avg 0.61 0.79 0.69 0.96 0.97 0.96
Table 5: Performance comparison of our rule
based baseline with our best machine learning
model on the five classes.
N
B
N
MAJ-MAX
N
G
# Nodes 202 37 41
# Links 1252 331 377
Density 0.036 0.276 0.255
Table 6: A comparison of network statistics for
the three networks extracted from the movie Silver
Linings Playbook.
ture sets is larger than the others, it is the conjunc-
tion of all features that is responsible for a high
F1-measure.
8.3 Performance on the test set
Table 5 shows a comparison of the performance
of our rule based baseline with our best machine
learning based model on our test set, TEST. The
results show that our machine learning based mod-
els outperform the baseline with a large and sig-
56
Model Degree Weighted Degree Closeness Betweenness PageRank Eigen
N
B
0.919 0.986 0.913 0.964 0.953 0.806
N
MAJ-MAX
0.997 0.997 0.997 0.997 0.998 0.992
Table 7: A comparison of Pearson?s correlation coefficients of various centrality measures for N
B
and
N
MAJ-MAX
with N
G
.
nificant margin on all five classes (0.96 versus
0.69 macro-F1 measure respectively). Note, as ex-
pected, the recall of the baseline is generally high,
while the precision is low. Moreover, for this test
set, the baseline performs relatively well on tag-
ging character names and dialogues. However, we
believe that the performance of the baseline is un-
predictable. It may get lucky on screenplays that
are well-structured (in one way or the other), but
it is hard to comment on the robustness of its per-
formance. On the contrary, our ensemble is ro-
bust, hedging its bets on eight models, which are
trained to handle different types and combinations
of anomalies.
In tables 6 and 7, we present an extrinsic evalua-
tion on the test set. We extract a network from our
test movie screenplay (Silver Linings Playbook)
by using the tags of the screenplay as follows
(Weng et al., 2009): we connect all characters hav-
ing a dialogue with each other in a scene with
links. Nodes in this network are characters, and
links between two characters signal their partici-
pation in the same scene. We form three such net-
works: 1) based on the gold tags (N
G
), 2) based on
the tags predicted by MAJ-MAX (N
MAJ-MAX
),
and 3) based on the tags predicted by our base-
line (N
B
). Table 6 compares the number of nodes,
number of links, and graph density of the three
networks. It is clear from the table that the net-
work extracted by using the tags predicted by
MAJ-MAX is closer to the gold network.
Centrality measures are one of the most funda-
mental social network analysis metrics used by so-
cial scientists (Wasserman and Faust, 1994). Ta-
ble 7 presents a comparison of Pearson?s correla-
tion coefficient for various centrality measures for
{N
B
, N
G
}, and {N
MAJ-MAX
, N
G
} for the top
ten characters in the movie. The table shows that
across all these measures, the statistics obtained
using the network N
MAJ-MAX
are significantly
more correlated to the gold network (N
G
), as com-
pared the the baseline network (N
B
).
9 Conclusion and Future Work
In this paper, we presented a formalization of the
task of parsing movie screenplays. We presented
an NLP and ML based approach to the task, and
showed that this approach outperforms the regular
expression based approach by a large and signifi-
cant margin. One of the main challenges we faced
early on was the absence of training and test data.
We proposed a methodology for learning to han-
dle anomalies in the structure of screenplays with-
out requiring additional annotations. We believe
that the machine learning approach proposed in
this paper is general, and may be used for parsing
noisy documents outside of the context of movie
screenplays.
In the future, we will apply our approach to
parse other semi-structured sources of social net-
works such as television show series and theatrical
plays.
Acknowledgments
We would like to thank anonymous reviewers for
their useful comments. We would also like to
thank Caronae Howell for her insightful com-
ments. Agarwal was funded by IBM Ph.D. fellow-
ship 2013-2014. This paper is based upon work
supported in part by the DARPA DEFT Program.
The views expressed are those of the authors and
do not reflect the official policy or position of the
Department of Defense or the U.S. Government.
57
References
Apoorv Agarwal and Owen Rambow. 2010. Auto-
matic detection and classification of social events.
In Proceedings of the 2010 Conference on Empiri-
cal Methods in Natural Language Processing, pages
1024?1034, Cambridge, MA, October. Association
for Computational Linguistics.
Apoorv Agarwal, Anup Kotalwar, and Owen Ram-
bow. 2013a. Automatic extraction of social net-
works from literary text: A case study on alice in
wonderland. In the Proceedings of the 6th Interna-
tional Joint Conference on Natural Language Pro-
cessing (IJCNLP 2013).
Apoorv Agarwal, Anup Kotalwar, Jiehan Zheng, and
Owen Rambow. 2013b. Sinnet: Social interaction
network extractor from text. In Sixth International
Joint Conference on Natural Language Processing,
page 33.
C. Baker, C. Fillmore, and J. Lowe. 1998. The berke-
ley framenet project. Proceedings of the 17th inter-
national conference on Computational linguistics, 1.
Desai Chen, Nathan Schneider, Dipanjan Das, and
Noah A. Smith. 2010. Semafor: Frame argument
resolution with log-linear models. In Proceedings of
the 5th International Workshop on Semantic Evalu-
ation, pages 264?267, Uppsala, Sweden, July. Asso-
ciation for Computational Linguistics.
David K. Elson, Nicholas Dames, and Kathleen R.
McKeown. 2010. Extracting social networks from
literary fiction. Proceedings of the 48th Annual
Meeting of the Association for Computational Lin-
guistics, pages 138?147.
Sebastian Gil, Laney Kuenzel, and Suen Caroline.
2011. Extraction and analysis of character interac-
tion networks from plays and movies. Technical re-
port, Stanford University.
Mark Hall, Eibe Frank, Geoffrey Holmes, Bernhard
Pfahringer, Peter Reutemann, and Ian H. Witten.
2009. The weka data mining software: An update.
SIGKDD Explorations, 11.
Hua He, Denilson Barbosa, and Grzegorz Kondrak.
2013. Identification of speakers in novels. The
51st Annual Meeting of the Association for Compu-
tational Linguistics (ACL 2013).
Kristina Toutanova, Dan Klein, Christopher Manning,
and Yoram Singer. 2003. Feature-rich part-of-
speech tagging with a cyclic dependency network.
In Proceedings of HLT-NAACL.
Robert Turetsky and Nevenka Dimitrova. 2004.
Screenplay alignment for closed-system speaker
identification and analysis of feature films. In Mul-
timedia and Expo, 2004. ICME?04. 2004 IEEE In-
ternational Conference on, volume 3, pages 1659?
1662. IEEE.
Stanley Wasserman and Katherine Faust. 1994. Social
Network Analysis: Methods and Applications. New
York: Cambridge University Press.
Chung-Yi Weng, Wei-Ta Chu, and Ja-Ling Wu. 2006.
Movie analysis based on roles? social network. In
Proceedings of IEEE Int. Conference Multimedia
and Expo., pages 1403?1406.
Chung-Yi Weng, Wei-Ta Chu, and Ja-Ling Wu. 2007.
Rolenet: treat a movie as a small society. In Pro-
ceedings of the international workshop on Workshop
on multimedia information retrieval, pages 51?60.
ACM.
Chung-Yi Weng, Wei-Ta Chu, and Ja-Ling Wu. 2009.
Rolenet: Movie analysis from the perspective of so-
cial networks. Multimedia, IEEE Transactions on,
11(2):256?271.
58
