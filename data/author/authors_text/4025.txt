Proceedings of the 12th European Workshop on Natural Language Generation, pages 138?145,
Athens, Greece, 30 ? 31 March 2009. c?2009 Association for Computational Linguistics
Generating clausal coordinate ellipsis multilingually:  A uniform approach based on postediting  Karin Harbusch Computer Science Department University of Koblenz-Landau PO Box 201602, 56016 Koblenz/DE harbusch@uni-koblenz.de 
Gerard Kempen  Max Planck Institute for Psycholinguistics PO Box 310, 6500AH Nijmegen/NL & Cognitive Psychology Unit, Leiden University gerard.kempen@mpi.nl  Abstract Present-day sentence generators are often in-capable of producing a wide variety of well-formed elliptical versions of coordinated clauses, in particular, of combined elliptical phenomena (Gapping, Forward and Back-ward Conjunction Reduction, etc.). The ap-plicability of the various types of clausal co-ordinate ellipsis (CCE) presupposes detailed comparisons of the syntactic properties of the coordinated clauses. These nonlocal comparisons argue against approaches based on local rules that treat CCE structures as special cases of clausal coordination. We advocate an alternative approach where CCE rules take the form of postediting rules ap-plicable to nonelliptical structures. The ad-vantage is not only a higher level of modu-larity but also applicability to languages be-longing to different language families. We describe a language-neutral module (called Elleipo; implemented in JAVA) that gener-ates as output all major CCE versions of co-ordinated clauses. Elleipo takes as input linearly ordered nonelliptical coordinated clauses annotated with lexical identity and coreferentiality relationships between words and word groups in the conjuncts. We dem-onstrate the feasibility of a single set of postediting rules that attains multilingual coverage. 1 Introduction In present-day Natural-Language Generation (NLG) architectures, elision rules typically form part of the Aggregation component, i.e. of the module that decides how to group conceptual messages into a sentence?a module belonging to the Microplanner (cf. Reiter & Dale, 2000, for an authoritative overview of sentence and text generation technology). In such generators, the computation of coordinate structures takes place at a relatively early stage of syntactic processing. However, many types of clausal co-
ordinate ellipsis (CCE) require detailed com-parisons of the final syntactic shape of the coor-dinated clauses (conjuncts). This is even more true when it is desirable to combine elision con-structions, as in German example (1a), where Subgapping?a form of Gapping?combines with Backward Conjunction Reduction (for definitions and examples see Table 1). Example (1) also illustrates that often more than one el-liptical option is available: (1b) shows a variant with Subgapping alone. If the nonelliptical sen-tence generator would choose a different Verb order in the second conjunct (?gestutzt werden sollen? as in (1d)), then Subgapping would be the sole alternative. (1) a. Die B?ume    sollen      gef?llt  werden und           The   trees      should  cut-down   be      and           die Str?ucher   sollen   gestutzt werden           the shrubs        should   pruned   be             'The trees should be cut down and the shrubs  pruned?  b. Die B?ume sollen gef?llt werden und           die Str?ucher sollen gestutzt werden  c. *Die B?ume sollen gef?llt werden und           gestutzt werden sollen die Str?ucher  d. Die B?ume sollen gef?llt werden und           gestutzt werden sollen die Str?ucher The comparisons between the clausal con-juncts mainly pertain to the linear order of their major constituents and to identity relations be-tween the lexical material contained in them. For instance, if a right-peripheral string of lexi-cal items in the anterior conjunct is identical to such a string in the posterior conjunct, then Backward Conjunction Reduction licenses eli-sion of the former string. In (1a), the two one-word strings ?werden? meet this requirement. Language-typological work, e.g. the recent survey by Haspelmath (2007), provides another argument for a ?late? CCE component. The main phenomena can be categorized into a small number of basic types, which have been attested in languages belonging to different language 
138
families. This suggests the possibility of a multi-lingual approach to CCE where the main CCE processes are defined as procedures that are iso-lated from the ?normal? grammar rules for nonelliptical structures, and are independent from each other  (see Section 4). Instead of having an aggregation component where the rules for nonelliptical clausal coordi-nate structures are intermingled with rules for elliptical variants, we consider an alternative approach where the application of the ellipsis rules is deferred until the nonelliptical structures have been completed. That is, the elision options are calculated and executed during a postediting stage, after the strategic and tactic components of the generator have delivered the nonelliptical versions. We claim that this modular approach facilitates the development of multilingual CCE components for different languages by switch-ing on and off the individual CCE procedures (e.g. no Gapping in Japanese). The structure of the paper is as follows. In Section 2, we introduce the four main CCE phe-nomena and informally define their treatment in a procedural manner. Section 3 lays out the ba-sic postediting rules that we implemented in JAVA as a language-neutral algorithm (nick-named Elleipo, which means ?I leave out? in classical Greek). In Section 4, we present some findings from language-typological studies and explore their implications for potential multilin-gual applicability of Elleipo. Finally, in section 5, we draw some conclusions. The Elleipo version described here embodies several important improvements to a version described briefly in Harbusch & Kempen (2006), particularly with respect to Subject Gap in clauses with Finite/Fronted Verbs (SGF). Moreover, the space allowed here enables us to explain Elleipo?s inner workings in more detail, and to demonstrate its multilingual potential. 2 Clausal coordinate ellipsis (CCE) 2.1 Clausal coordinate ellipsis in linguistic theories and in NLG: State of the art Treatments of the phenomena of clausal coordi-nation and CCE are provided by all major grammar formalisms. Some representative stud-ies are Sarkar & Joshi (1996) for Tree Adjoining Grammar; Steedman (2000) for Combinatory Categorial Grammar; Bresnan (2000) and Frank (2002) for Lexical-Functional Grammar; Crys-mann (2003) and Beavers & Sag (2004) for Head-driven Phrase-Structure Grammar; and te 
Velde (2005) for the Minimalist Program. Their treatments of CCE take the form of special de-clarative coordination rules, in contrast with the modular and procedural approach we propose. In the NLG community, modular treatments of CCE?implemented as programs that take unreduced coordinations expressed in the sys-tem?s grammar formalism as input and return elliptical versions as output?have been elabo-rated in several projects (Shaw, 1998; Dalianis, 1999; Hielkema, 2005). These systems are lim-ited in that that they do not cover all of the four CCE processes and are monolingual. 2.2   Clausal coordinate ellipsis types In the linguistic literature on clausal coordinate ellipsis, four main CCE processes are often dis-tinguished, as shown in Table 1. In the theoretical framework by Kempen (2009) and its implementations (Harbusch & Kempen (2006) for German and Dutch; Har-busch et al (2009) for Estonian), the elision process is guided by identity constraints and linear order (cf. column 4 in Table 1). We dis-tinguish three basic types of identity relations between words or word groups (constituents) belonging to different conjuncts1: (1) Lemma identity: two different words be-long to the same inflectional paradigm; e.g. the Verbs ?live? and ?lives? in example (2).  (2) Form identity: two words have the same spelling/sound and are lemma-identical; e.g., two tokens of ?want? are form-identical if they are both Verbs, but not if one is a Verb and the other is a Noun. (3) Coreferentiality: two words/constituents denote the same entity or entities in the ex-ternal context, i.e. have the same reference.
                                            1 Very often, lemma- and form identity coincide with coreference, but not necessarily. For instance, in ?John bought a car in July, and Peter bought a car in August,? the two tokens of ?a car? are not, in all likelihood, corefer-ential. Nevertheless, elision of ?a car? is allowed in this Gapping example. In the semantic literature, this relation is called sloppy identity. On the other hand, in ?Who wants coffee and who wants tea?,? the two tokens of ?who? are not coreferential, and the second token cannot be elided. We assume that the strategic and/or the tactical component of the generator assigns differing identity tags (see Section 3.1) to lemma- or form-identical constituents if and only if their reference is strictly non-identical. Also note that, in the following, the three identity relationships will not only be applied to individual words but also to constituents en-tirely consisting of words that meet the respective criteria (cf. the numerical subscripts in Figure 1 in Section 3).  
139
Table 1. Clausal coordinate ellipsis (CCE) types. Column 2 lists the abbreviations for the types mentioned in column 1 (see Elleipo?s algorithm in Section 3). Column 3 illustrates the CCE types. Column 4 summarizes the elision conditions explained in Section 3. CCE type Abbr. Examples Elision conditions Gapping  g (2) Ulf              lives in Leipzig and        his children liveg in Ulm Lemma identity of Verb & contrastiveness of remnants Long-Distance  Gapping (LDG) g(g)+ (3) My wife wants   to buy      a car and       my son   wantsg [to buy]gg a motorcycle Gapping conditions in su-perclause (Section 3.2.1) Subgapping sg (4) The driver        was     killed and        the passengers weresg severely wounded Gapping conditions & VP remnant in second conjunct Stripping str (5) My sister       lives in Narva and        her children [live in Narva]str too Gapping conditions & only one non-Verb remnant Forward Conjunction Reduction  (FCR) 
f (6) Since two years, my sister  lives in Delft and      [since two years, my sister]f works in Leiden (7) Tokyo is the city [S where Ota lives and                                        wheref Kusuke works] 
Form identity & left-peripherality (within  clause boundaries) of  major clausal constituents Backward  Conjunction  Reduction (BCR) 
b (8) John wrote one  articleb and        Mary edited two articles. (9) Anja   arrived  before three [o?clock]b and        Maria arrivedg after four      o?clock  
Lemma identity & right-peripherality, possibly disregarding major constituent boundaries Subject Gap in clauses with Finite/Fronted Verbs (SGF) 
s (10) Into the wood went the hunter and                                        [the hunter]s shot a hare Form-identical Subject & first conjunct starting with Verb/Modifier/Adjunct &  FCR applied if licensed  As summarized in column 4 of Table 1, all forms of Gapping (i.e. including LDG, Subgap-ping and Stripping) are characterized by elision of the posterior member of a paired lemma-identical Verb. The position of this Verb need not be peripheral but is often medial, as in ex-amples (2) through (5), and (9). Non-elided con-stituents in the posterior conjunct are called remnants. All remnants should pair up with a constituent in the anterior conjunct that has the same grammatical function but is not coreferen-tial. Stated differently, the members of such a pair are contrastive?in (2): the Subjects ?Ulf? vs. ?his children?, and the locative Modifiers ?in Leipzig? vs. ?in Ulm.? (Notice that although two tokens of ?my? in (3) occupy comparable posi-tions in the two conjuncts, it is not possible to elide any of them. On the other hand, ?were? in (4) can be elided from the posterior conjunct although it has no literal anterior counterpart.) In LDG, the remnants originate from different clauses (more precisely: different clauses that belong to the same superclause; term defined in Section 3.2.1). In (3), ?my son? belongs to the main clause but ?a motorcycle? to the infinitival complement clause. In Subgapping, the poste-rior conjunct includes a remnant in the form of a nonfinite complement clause (VP; ?severely wounded? in (4)). In Stripping, the posterior conjunct is left with one non-Verb remnant, of-ten supplemented by the Adverb ?too.? 
In Forward Conjunction Reduction (FCR), elision affects the posterior token of a pair of left-peripheral strings consisting of one or more form-identical major constituents. In (6) and (7), the posterior tokens of ?since two years, my sis-ter? and ?where,? respectively, belong to such pairs and are eligible for FCR. Backward Conjunction Reduction (BCR) is almost the mirror image of FCR as it deletes the anterior member of a pair of right-peripheral lemma-identical word strings (?o?clock? in (9)); however, BCR may elide part of a major con-stituent?e.g. only the part ?article? of the Direct Object in (8) and ?o?clock? of the temporal Modifier ?before three o?clock? in (9). In addi-tion, it requires only lemma identity?witness examples like (8).2 Subject Gap in clauses with Finite/Fronted Verbs (SGF) can elide the Subject of the poste-rior conjunct when in the anterior conjunct the form-identical Subject follows the Verb (Sub-ject-Verb inversion); moreover, the Head Verbs of the conjoined clauses?both with main or interrogative clause word order?are different. (FCR cannot have caused the absence of the posterior Subject since the anterior Subject is not left-peripheral.) The examples in (11)                                             2However, case-identity is required as well, at least in German: ?Hilf [dem Patienten]DAT und reanimier [den Patient]ACC  ?Help and reanimate the patient?. 
140
through (14) show that the first constituents of the unreduced clauses must meet certain special requirements, which extend the rule proposed in our previous publications. In particular, these constituents are allowed to be non-form-identical finite Head Verbs (11) or form-identical Modifiers (12) but not form-identical arguments, e.g. Direct Objects (13) or Comple-ments (14). Additionally, if FCR is licensed, as in (12), it should actually be realized in order to allow SGF.  (11) Stehen  die Leute noch   am    Eingang  und     Stand   the people still  at-the entrance  and    rufen [die Leute]s Parolen?    shout  the people  slogans    ?Are the people still standing at the    entrance (and are they) shouting slogans?? (12) Warum/Gestern   bist   du   gegangen und    Why/Yesterday   have  you  left          and   [warum/gestern]f hast  dus  nichts   gesagt    why/yesterday    have you nothing said   ?Why did you leave and didn?t you tell me         anything?? / ?Yesterday you left and ...? (13) *Diesen Wein  trinke ich nicht mehr      und      This     wine   drink  I     not  anymore and    [diesen Wein]f gie?e  ichs weg     this       wine   throw   I   away    ?I don?t drink this wine anymore and throw     it away? (14) *Das Examen bestehen will er und       The exam      pass       will he and    [das Examen bestehen]f kann ers auch      the    exam    pass          can  he  too/as-well ?He wants to pass the exam and will be able to as well? 3 Language-neutral CCE generation In this Section, we describe Elleipo?s algorithm in more detail than we were able to in Harbusch & Kempen (2006), again using the German ex-ample (15). Moreover, we elaborate on SGF, given the new, more detailed rules. We limit ourselves to ?and?-coordinations of only n=2 conjuncts. Actually, Elleipo can handle n-ary coordinations consisting of n?2 conjuncts by processing n?1 consecutive pairs of conjuncts (1+2, 2+3, etc.), together with an asyndeton rule that replaces non-final ?and?-s by commas. (15)  Heute wird Hans sein Auto putzen und         Today will  Hans  his  car   clean   and      heute wird  Susi ihr  Fahrrad putzen         today  will  Susi her  bike      clean        ?Today, Hans will clean his car and today, Susi                          will clean her bike? Elleipo?s functioning is based on the assump-tion that CCE does not result from the applica-
tion of local declarative grammar rules for clause formation but from a procedural compo-nent that inspects nonelliptical (unreduced) sen-tences produced by the sentence generator and may block the overt expression of certain con-stituents. Due to this feature, Elleipo can be combined, at least in principle, with various generators. However, the module needs a for-malism-dependent interface that converts gen-erator output to a (simple) canonical form. 3.1  Elleipo?s input  Elleipo takes as input nonelliptical syntactic trees in canonical form, supplied with identity tags (cf. Figure 1). Every categorial node of an input tree is immediately dominated by a func-tional node. Each conjunct is rooted in a cate-gorial node whose daughter nodes (immediate constituents) are grammatical functions (Sub-ject, Direct Object, Head, Subordinating Con-junction, Expr(ession), etc.). Within a conjunct, all major constituents are represented at the same hierarchical level (?flat? trees). Categorial nodes are adorned with numerical identity tags (ID-tags) which express lemma identity. In Figure 1, the ID ?2? is attached to the head node of both exemplars of AP ?heute? ?today?, thus marking their lemma identity. In contrast, the Subject NPs ?Hans? and ?Susi? carry different ID-tags, indicating that they are not lemma-identical and cannot be elided by any CCE process. 3.2 The three stages of Elleipo Elleipo is called for every coordination domain within a non-elliptical input clause. We define a coordination domain as a (sub)tree rooting in a grammatical function node that dominates two or more categorial S-nodes separated by coordi-nating conjunctions (?and?). For any given coor-dination domain, Elleipo?s task consists of three consecutive stages: Preparation, Diagnosis, and ReadOut. 3.2.1  Preparation The first job within Preparation is the demarca-tion of superclauses. Kempen (2009) introduced this notion in the treatment of Gapping, in par-ticular LDG. A superclause is either a simple finite or non-finite clause (rooting in an S-node, without any subordinate clauses), or a hierarchy of finite or non-finite clauses where every em-bedded clause is an immediate daughter of an embedding clause; moreover, none of the par-ticipating clauses begins with a subordinating
141
 Figure 1. Non-elliptical input tree in canonical form, underlying sentence (15). Categorial nodes are printed in bold, functional nodes in italics. The numerical subscripted tags denote lemma identity or coreference. conjunction, with the possible exception of the topmost member of the hierarchy.3 Next, Elleipo inspects and compares the con-tent of the conjoined clauses by assembling four lists: FUNC-PAIRS, LI-FUNC-PAIRS, LPERIPH and RPERIPH (see Table 2). The lists FUNC-PAIRS and LI-FUNC-PAIRS are crucial not only in calculating whether a form of Gap-ping is applicable but also in the determination of contrastiveness of Gapping remnants. We presuppose a division of MODifier constituents into MOD types?locative (LMOD), temporal (TMOD, causal (CMOD), etc.?which are re-corded in the two lists of pairs. Gapping requires the set of grammatical functions, including MOD types, in the anterior and posterior con-juncts to be identical. If so, and if FUNC-PAIRS includes at least one pair of non-coreferential members (carrying different ID-tags), the Boo-lean variable CONTRAST is set to true. In the example, FUNC-PAIRS(S0, S11) includes two pairs of non-coreferential major constituents (the Subjects and the Complements); hence, CONTRAST = true. LPERIPH is crucial in FCR, where only complete form-identical major constituents may be elided. RPERIPH is used in BCR, which sometimes leaves incomplete con-stituents behind, as exemplified by (8) and (9).                                             3 The ?embedded? clauses referred to in the definition of superclause fulfill the grammatical function of Subject or Object Complement within the embedding clause, or they are adverbial clauses fulfilling the function of Modifier within the embedding clause. In Figure 1, the Complement clauses S6 and S14 are major constituents of S0 and S11, respectively. The hierarchy spanning S0 and S6 is a super-clause, and so is the hierarchy consisting of S11 and S14. In ?Hans sagte, dass Susi ihr Fahrrad putzen wird? ?Hans said that Susi will clean her bike,? the Complement clause does not belong to the same superclause as the main clause ?Hans sagte ...,? but instead starts up its own superclause. Gapping and its varieties can only be applied to two coor-dinated superclauses. 
3.2.2  Diagnosis For each of the four CCE processes, Elleipo in-spects all coordination domains for elision op-tions. This requires interpreting the lists col-lected during the Preparation stage. Any li-censed elision option for a word or constituent causes the current value of the parameter CCE-TYPE to be added as a tag to that word or con-stituent (cf. the subscripts in examples (2) through (10)). Different elliptical variants (cf. examples (1a/b)) are represented by multiple tags and yield alternative realizations, to be spelled out during the final ReadOut stage. If the Boolean variable CONTRAST is true, Gapping runs recursively within the current coordination domain. Figure 2 shows pseudocode for Gap-ping, with input parameters LC = left conjunct, RC=right conjunct, and CCE-TYPE=g). In the example: GAPPING(S0, S11, ?g?). Lemma identity of the Head Verbs of the clausal conjuncts licenses Gapping. So, the tem-poral Adverbial Modifier and the Head Verb of the posterior conjunct can both be marked for elision: ?Heute wird Hans sein Auto putzen und heuteg wirdg Susi ihr Fahrrad putzen? (steps 8 and 9). Earlier on, in step 3 and 4, Elleipo has already noticed that one of the non-lemma-identical pairs?S6 and S14?consists of Com-plement clauses belonging to the same super-clause as the coordinated main clauses (i.e. they do not start up a new superclause hierarchy). In step 6, Elleipo is called recursively for this co-ordinate subdomain, with argument CCE-TYPE set to ?gg?. As the Head Verbs of these com-plement clauses are lemma-identical and the contrastiveness condition holds (i.e. the gram-matical function DOBJ occurs in both the ante-rior and the posterior complement and the ex-emplars are not lemma-identical), the posterior Verb is marked for elision,  yielding ?Heute wird 
142
Table 2. Definitions of the (possibly empty) lists of paired major clause constituents calculated during Elleipo?s Preparation stage. Column 3 shows the content of the lists for example (15), i.e. the superclauses S0 and S11. List Definition Content of lists for example (15) FUNC-PAIRS All constituent pairs LCAT?RCAT with same gram-matical function, dominated by an S-node pair; if (LCAT, RCAT) is an S-node pair, then FUNC-PAIRS is assembled recursively for this pair as well. 
FUNC-PAIRS(S0,S11)={AP1?AP1,V3?V3,                                        NP4?NP12, S6?S14} Due to recursive application: FUNC-PAIRS(S6,S14)={NP7?NP15,V10?V10} LI-FUNC-PAIRS Lemma-Identical pairs of corresponding FUNC-PAIRS (i.e., LI-FUNC-PAIRS ? FUNC-PAIRS). LI-FUNC-PAIRS(S0,S11)={AP1?AP1,V3?V3} LI-FUNC-PAIRS(S6,S14)={V10?V10}  LPERIPH  Left-peripheral form-identical complete major con-stituents shared by the conjuncts. LPERIPH(S0,S11)={A2,V3} RPERIPH  Right-peripheral lemma-identical lexical string shared by the conjuncts. RPERIPH(S0,S11) ={V10}  1 proc GAPPING(LC, RC, CCE-TYPE) { 2  for all pairs (LCAT, RCAT) in FUNC-PAIRS(LC, RC) { 3    if (LCAT is an S-node) & (LCAT doesn?t begin a new superclause) then {// call GAPPING recursively// 4      if NOT (LCAT and RCAT are lemma-identical) 5             then {attach ?g? to CCE-TYPE; //LDG// 6                   call GAPPING(LCAT, RCAT, CCE-TYPE);} 7             else mark RCAT for elision, with CCE-TYPE} 8    if (LCAT and RCAT are lemma-identical) & NOT(LCAT is an S-node) 9           then mark RCAT for elision, with CCE-TYPE}} Figure 2. Pseudocode for the GAPPING procedure Hans sein Auto putzen und heuteg wirdg Susi ihr Fahrrad putzengg.? FCR and BCR are both executed by one proce-dure, called CR. In FCR mode, CR is called with the value of LPERIPH as input; in BCR mode, it takes RPERIPH?s value as input. Recall that these lists were computed in the Preparation stage and may contain a form-identical (LPERIPH) or a lemma-identical (RPERIPH) lexical string. In calls to CR (see the pseudocode in Figure 3), pa-rameter PERIPH is set to LPERIPH or RPERIPH, and CCE-TYPE to ?b? or ?f? depending on whether BCR or FCR is to be executed. In our example, the main program calls are: CR(S0, S11, LPERIPH(S0, S11), ?f?), and CR(S0, S11, RPERIPH(S0, S11), ?b?). FCR and BCR are attempted after, and fully in-dependently from, Gapping, irrespective of whether the latter was successful or not. As Modi-fier ?heute? and Head Verb ?wird? are both listed in LPERIPH(S0, S11), both major constituents are marked as eligible for elision from the posterior conjunct (line 6 of Figure 3)?an effect which happens to coincide with the effects of Gapping:  ?Heute   wird   Hans sein Auto    putzen und   heuteg-f wirdg-f Susi ihr Fahrrad putzengg?. 
1 proc CR(LC, RC, PERIPH, CCE-TYPE) { 2 while PERIPH ? ? { 3      set (LCAT, RCAT) to PERIPH?s first element; 4      PERIPH =PERIPH minus first element; 5      if CCE-TYPE = ?f? 6          then mark RCAT else LCAT for elision,              with CCE-TYPE}} Figure 3. Pseudocode for procedure CR (executing FCR or BCR). When attempting BCR, Elleipo discovers the lemma-identical ?putzen? (V10), and marks the an-terior exemplar with ?b?: ?Heute wird Hans sein Auto putzenb und heuteg-f wirdg-f Susi ihr Fahrrad putzengg?. Elleipo?s fourth check concerns SGF (Figure 4; see section 2.1 for the rules), here with negative result. In example (15), Subject-Verb-inversion is realized in the first conjunct. However, the two Subjects ?Peter? and ?Susi? are not coreferential. 1 proc SGF(LC, RC) { 2    if (Head Verb precedes SUBJ in LC)             & (coreferential SUBJs in LI-FUNC-PAIRS)             & (Head Verb or MOD in 1st position in LC)             & (1st position in RC is occupied by SUBJ or a                   major constituent already marked for FCR) 3         then mark RC?s SUBJ for elision ?s?;} Figure 4. Pseudocode for SGF 
143
3.2.3  ReadOut The resulting terminal string annotated with eli-sion marks is handed over to the ReadOut stage. As ReadOut assumes that all elisions are optional, it may deliver more than one elliptical output string. However, not every possible combination of elisions is legitimate; certain combinations have to be ruled out. We mention four important restrictions here. First, Gapping and BCR cannot elide both tokens of a lexical item. For instance, if ?putzen? in the anterior conjunct of (15) is elided due to BCR, then its posterior counterpart ?putzen,? which could be Gapped, should re-main?and vice-versa. Second, in LDG, if a Verb with n subscripts ?g? is elided, then all Verbs with m>n subscripts ?g? should be elided as well. Third, in Gapping, if only one non-Head-Verb constituent remains (i.e. Stripping), then (the lan-guage-specific equivalent of) the Adverb ?too? is added. Fourth, SGF requires that FCR, if licensed, is actually executed. Moreover, the ReadOut stage performs certain types of embellishments, e.g. it applies an asyndeton rule that replaces all but the last token of the coordinating conjunction by commas. 3.4 Elleipo evaluated for German A detailed evaluation of Elleipo is currently only available for the German version (Harbusch & Kempen, 2007). In the TIGER corpus with 50,000 sentences, 99 percent of the CCE sentences con-form to Elleipo?s CCE rules. Nevertheless, we are aware that these rules do not handle SGF in con-joined subordinate clauses where the first conjunct has the standard Verb-final word order but the second conjunct (with SGF) embodies Verb-second order. Furthermore, Elleipo does not take into account certain semantic constraints (?one-event semantics?; Reich, in press; see also Frank, 2002; Kempen, 2009). Another insufficiency con-cerns the rules for asyndeton, which are more complicated than simply converting prefinal ?and?-s to commas (see Borsley (2005) for perti-nent examples). 4 Multilingual CCE generation 4.1    CCE rules in typological studies The four CCE processes have been attested in two Germanic languages (German and Dutch) and in a Finno-Ugric language (Estonian; Harbusch et al, 
2009), where they account for a wide range of CCE phenomena. This invites the prediction that CCE obeys the same rules in many other lan-guages as well. However, Haspelmath?s (2007) survey immediately falsifies this prediction: Other CCE processes may be at work in other languages, and/or some of the above four main processes may be absent.  Japanese may provide illustrations of both points. On the one hand, it is uncontroversial that it does not have Gapping. On the other hand, it may have a form of CCE that stands midway be-tween FCR and BCR. Yatabe (2001) interprets (16) as Left Node Raising, i.e. as the mirror image of BCR. Like FCR, it elides a left-peripheral string of the posterior conjunct; like BCR, the elided string need not be a complete major con-stituent. The elided Verb yonde is part of the prenominal Relative clause yonde agenakatta which is a major constituent (immediate daughter) of the NP headed by the Noun hito. But notice that (16) embodies coordination of NPs rather than clauses. If Japanese indeed exhibits partial elision of left-peripheral major constituents at the clausal level, thus violating our FCR definition, then we obviously need to define an additional CCE type. (16) Yonde      ageta      hito      to         readgerund  givepast   person and         yondef     agenakatta  hito      ga      ita          readgerund  giveneg-past   person NOM bepast         ?There were people who gave (him/her) the favor        of reading (it) (to him/her) and people who didn?t? In contrast, Abe & Hoshi (1997) analyze Japa-nese example (17) in terms of Preposition Strand-ing. As far as we can see, this structure does not require a special CCE process because Elleipo treats it as BCR, which allows partial elision of the PP Modifier in the anterior conjunct, hence stranding of the Preposition. (17) John-ga     Bill[-nituite  hanasita]b, sosite         John-Nom Bill -about    talked          and            Mary-ga     Susan-nituite hanasita         Mary-Nom Susan-about  talked        ?John talked about Bill and Mary about Susan? Haspelmath (2007) also discusses certain lan-guages with Subject?Object?Verb (SOV) as basic word order (Turkish and Korean) which allow Object deletion from non-peripheral positions in the posterior conjunct; i.e., they license the pattern SOV&S_V, as in ?The-boy the-cart pulled and the-girl the-cart pushed.? Elleipo cannot handle 
144
this CCE structure: FCR and BCR require pe-ripherality of the elided constituent; SGF only applies to Subjects; and Gapping presupposes eli-sion of the Head Verb. In order to encompass the problematic pattern, we may need to define a new CCE process. However, at least in Turkish SOV&S_V cases, the elision may be due to prag-matic factors. G?ksel & Kerslake (2005) show that major clause constituents fulfilling diverse grammatical functions can be elided as long their referents are recoverable on the basis of the ac-companying linguistic or nonlinguistic context. Because the anterior conjunct may provide such a context, one first needs to rule out contextual re-coverability as the licensing factor.  At the same time, Haspelmath also shows that Elleipo?s four CCE processes cover a high propor-tion of CCE patterns occurring cross-linguisti-cally. (However, he does not discuss SGF.) A typical illustration is the set of nine ?more widely attested patterns? of CCE that he enumerates with respect to elision of Objects or Verbs in four lan-guage groups with different basic word orders of S, O and V (Table 2 in Haspelmath, 2007). All these patterns are covered by our four CCE proc-esses, except SOV&S_V. 5 Discussion We conclude that a software module embodying Elleipo?s four main CCE processes?maybe with relatively minor adjustments?will be able to gen-erate a great deal of CCE structures for many dif-ferent languages. As for possible practical applications, Elleipo?s status as a postprocessor working on input specifi-cations of unreduced syntactic structures facili-tates combinability with sentence generators based on various grammar formalisms. Even template-based message generators, such as used in car navigation and weather forecast systems, can at-tain higher levels of fluency and conciseness if the templates are annotated with syntactic structure and ID-tags. References  Abe, J. & Hoshi, H. 1997. Gapping and P-Stranding. Journal of East Asian Linguistics, 6.  Beavers, J. & Sag, I.A. 2004. Coordinate Ellipsis and Apparent Non-Constituent Coordination Procs. of 11th Int. Conf. on HPSG, Louvain. 
Borsley, R.D. 2005. Against ConjP. Lingua, 115. Bresnan, J.W. 2000. Lexical-Functional Syntax. Blackwell, Oxford, UK. Crysmann, B. 2003. An asymmetric theory of periph-eral sharing in HPSG: Conjunction reduction and coordination of unlikes. Procs. of 8th Conf. on For-mal Grammar, Vienna. Dalianis, H. 1999. Aggregation in natural language generation. Computational Intelligence, 15. G?ksel, A. & Kerslake, C. 2005. Turkish: A compre-hensive Grammar. Routledge, Abington, Oxon, UK.  Frank, A. 2002. A (discourse) functional analysis of asymmetric coordination. Procs. of LFG02 Conf., Athens. Harbusch, K. & Kempen, G. 2006. Elleipo: A module that computes coordinative ellipsis for language generators that don?t. Procs. of 11th EACL, Trento. Harbusch, K. & Kempen, G. 2007. Clausal coordinate ellipsis in German. Procs. of 16th NODALIDA, Tartu. Harbusch, K., Koit, M. & ?im, H. 2009. A comparison of clausal coordinate ellipsis in Estonian and Ger-man. Procs. of 12th EACL, Athens. Hielkema, F. 2005. Performing syntactic aggregation using discourse structures. Unpublished Master?s thesis, AI Unit, University of Groningen. Haspelmath, M. 2007. Coordination. In: Shopen, T. (Ed.), Language typology and linguistic description. Cambridge University Press [2nd Ed.], Cambidge UK. Kempen, G. 2009. Clausal coordination and coordinate ellipsis in a model of the speaker. Linguistics, 47(3). Reich, I. In press. From discourse to ?odd coordina-tions??On Asymmetric Coordination and Subject Gaps in German. In: Fabricius-Hansen, C. & Ramm, W. (Eds.), ?Subordination? vs. ?Coordination? in Sentence and Text. Benjamins, Amsterdam. Reiter, E. & Dale, R. 2000. Building natural language generation systems. Cambridge University Press, Cambridge, UK. Sarkar, A. & Joshi, A. 1996. Coordination in Tree Ad-joining Grammars. Procs. of 16th COLING, Copen-hagen. Shaw, S. 1998. Segregatory coordination and ellipsis in text generation. Procs. of 17th COLING, Montreal. Steedman, M. 2000. The syntactic process. MIT Press, Cambridge MA. te Velde, J.R. 2006. Deriving Coordinate Symmetries. Benjamins, Amsterdam. Yatabe, S. 2001. The syntax and semantics of left-node raising in Japanese. Procs. of the 7th Int. HPSG Conf., Berkeley. CSLI Publications, Stanford CA.
145
A quantitative model of word order and movement  
in English, Dutch and German complement constructions 
KARIN HARBUSCH 
Computer Science Department 
University of Koblenz-Landau 
PB 201602, 56016 Koblenz/DE 
harbusch@uni-koblenz.de 
GERARD KEMPEN 
Cognitive Psychology Unit 
Leiden University, and 
Max Planck Institute, Nijmegen/NL 
kempen@fsw.leidenuniv.nl 
 
Abstract We present a quantitative model of word 
order and movement constraints that enables a 
simple and uniform treatment of a seemingly het-
erogeneous collection of linear order phenomena 
in English, Dutch and German complement con-
structions (Wh-extraction, clause union, extraposi-
tion, verb clustering, particle movement, etc.). Un-
derlying the scheme are central assumptions of the 
psycholinguistically motivated Performance Gram-
mar (PG). Here we describe this formalism in de-
clarative terms based on typed feature unification. 
PG allows a homogenous treatment of both the 
within- and between-language variations of the or-
dering phenomena under discussion, which reduce 
to different settings of a small number of quantita-
tive parameters. 
1. Introduction 
We propose a quantitative model for expressing 
word order and movement constraints that enables 
a simple and uniform treatment of a heterogeneous 
collection of linear ordering phenomena in English, 
Dutch and German complement structures. Under-
lying the scheme are central tenets of the psy-
cholinguistically motivated Performance Grammar 
(PG) formalism, in particular the assumption that 
linear order is realized at a late stage of the gram-
matical encoding process. The model is described 
here in declarative terms based on typed feature 
unification. We show that both the within- and be-
tween-language variations of the ordering phe-
nomena under scrutiny reduce to differences be-
tween a few numerical parameters. 
The paper is organized as follows. In Section 2, 
we sketch PG's hierarchical structures. Section 3, 
the kernel of the paper, describes the linearization 
and movement model. In Section 4, we turn to cen-
tral word order phenomena in the three target lan-
guages. Section 5, finally, contains some conclu-
sions. 
2.    Hierarchical structure in PG 
PG's hierarchical structures consist of unordered 
trees ('mobiles') composed out of elementary build-
ing blocks called lexical frames. These are 3-tiered 
mobiles assembled from branches called segments. 
The top layer of a frame consists of a single 
phrasal node (the 'root'; e.g. Sentence, Noun 
Phrase, ADJectival Phrase, Prepositional Phrase), 
which is connected to one or more functional 
nodes in the second layer (e.g., SUBJect, HeaD). 
At most one exemplar of a functional node is al-
lowed in the same frame. Every functional node 
dominates exactly one phrasal node ('foot') in the 
third layer, except for HD which immediately 
dominates a lexical (part-of-speech) node. Each 
lexical frame is 'anchored' to exactly one lexical 
item: a lemma (printed below the lexical node serv-
ing as the frame's HeaD). A lexical frame encodes 
the word category (part of speech), subcategoriza-
tion features, and morphological diacritics (person, 
gender, case, etc.) of its lexical anchor (cf. the 
elementary trees of Tree Adjoining Grammar 
(TAG; e.g. Joshi & Schabes, 1997). 
Associated with every categorial node (i.e., 
lexical or phrasal node) is a feature matrix, which 
includes two types of features: agreement features 
(not to be discussed here; see Kempen & Harbusch, 
forthcoming) and topological features. The latter 
play a central role in the linear ordering mecha-
nism. Typed feature unification of topological fea-
tures takes place whenever a phrasal foot node of a 
lexical frame is replaced (substituted for) by a lexi-
cal frame. Substitution is PG's sole composition 
operation. Substitution involves unification of the 
feature matrices that are associated with the substi-
tuted phrasal foot node and the root node of the 
substituting lexical frame. Substitution gives rise to 
the derivation tree of a well-formed syntactic struc-
ture iff the phrasal foot node of all obligatory seg-
ments of each lexical frame successfully unifies 
with the root of another frame. The tree in Figure 1 
is well-formed because the MODifier segments are 
not obligatory. 
N P
HD
pro
we
S
SUBJ
N P
HD
v
hate
DOB J
N P
N P
HD
n
D ana
N P
HD
n
Kim
S
SUBJ
N P
HD
v
know
CM P
S
M OD
A P |PP| S
M OD
A P |PP| S
 
Figure 1. Simplified lexical frames underlying the 
sentences We know Dana hates Kim and Kim we know 
Dana hates (example from Sag & Wasow,1999). Or-
der of branches is arbitrary. Filled circles denote sub-
stitution. (The feature matrices unified as part of the 
substitution operations are not shown.) 
3. Linear structure in PG 
The above-mentioned topological features are as-
sociated with the phrasal root nodes of lexical 
frames. Their value is a feature matrix specifying a 
'topology', that is, a one-dimensional array of left-
to-right slots. In this paper we will only be con-
cerned with topological features associated with S-
nodes. They serve to assign a left-to-right order to 
the segments (branches) of verb frames (i.e. lexical 
frames specifying the major constituents of 
clauses). On the basis of empirical-linguistic ar-
guments (which we cannot discuss here), we pro-
pose that S-topologies of English, Dutch and Ger-
man contain exactly nine slots: 
E F1 F2 F3 M1 M2 M3 M4 E1 E2 
D/G F1 M1 M2 M3 M4 M5 M6 E1 E2 
The slots labeled Fi make up the Forefield (from 
Ger. Vorfeld); the Mj slots belong to the Midfield 
(Mittelfeld); the Ek's define the Endfield (Nachfeld; 
terms adapted from traditional German grammar; 
cf. Kathol, 2000). Table 1 illustrates which clause 
constituents select which slot as their 'landing site'. 
Notice, in particular, that the placement conditions 
refer not only to the grammatical function fulfilled 
by a constituent but also to its shape. For instance, 
while the Direct Object takes M3 as its default 
landing site, it selects F1 if it is a Wh-phrase or 
carries focus, and M2 if it is a personal pronoun 
(it). In terms of Figure 1, if Kim carries focus, it 
may occupy slot F1 of the topology associated with 
the complement clause headed by hate. 
Table 1. Examples of topology slot fillers (English). 
MODifier constituents are not shown. Precedence be-
tween constituents landing in the same slot is marked 
by "<". 
Slot Filler 
F1 Declarative main clause: Topic, Focus (one 
constituent only) 
Interrogative main clause: Wh-constituent.  
Complement clause: Wh-constituent (includ-
ing CoMPlementizeR whether/if) 
F2 Complement clause: CoMPLementizeR that 
F3 Subject (iff non-Wh) 
M1 Pre-INFin. to < HeaD (oblig.) < PaRTicle 
M2 Direct OBJect (iff personal pronoun) 
Interrogative main clause: SUBJect (iff 
     non-Wh); SUBJ < DOBJ 
M3 Indirect OBJect < Direct OBJect (non-Wh) 
M4 PaRTicle  
E1 Non-finite CoMPlement of 'Verb Raiser' 
E2 Non-finite CoMP of 'VP Extraposition' verb 
Finite CoMPlement clause 
How is the Direct Object NP Kim 'extracted' 
from the subordinate clause and 'moved' into the 
main clause? Movement of phrases between 
clauses is due to lateral topology sharing. If a sen-
tence contains more than one verb, each of the verb 
frames concerned instantiates its own topology. 
This applies to verbs of any type, whether main, 
auxiliary or copula. In such cases, the topologies 
are allowed to share identically labeled lateral (i.e. 
left- and/or right-peripheral) slots, conditionally 
upon several restrictions to be explained shortly. 
After two slots have been shared, they are no 
longer distinguishable; in fact, they are the same 
object. In the example of Figure 1, the embedded 
topology shares its F1 slot with the F1 slot of the 
matrix clause. This is indicated by the dashed bor-
ders of the bottom F1 slot: 
F1  F3 M1     E2 
?   we know     ?  ?        ? 
Kim  Dana hates      
In sentence generation, the overt surface order 
of a sentence is determined by a Read-out module 
that traverses the hierarchy of topologies in left-to-
right, depth-first manner. Any lexical item it 'sees' 
in a slot, is appended to the output string. E.g., Kim 
is seen while the Reader scans the matrix topology 
rather than during its traversal of the embedded to-
pology. See Figure 2 for the ordered tree corre-
sponding to Kim we know Dana hates1. 
S
SUBJ
NP
we
HD
v
know
CMP
S
SUBJ
NP
Dana
HD
v
hat e
DOBJ
NP
 Kim
F1 F3 M1 E2
F3 M1
 
Figure 2. Fronting of Direct Object NP Kim due to pro-
motion (cf. Figure 1). Rectangles represent (part of) the 
topologies associated with the verb frames. 
The number of lateral slots an embedded topol-
ogy shares with its upstairs neighbor is determined 
by the parameters LS (left-peripherally shared area) 
and RS (right-hand share). The two laterally shared 
areas are separated by a non-shared central area. 
The latter includes at least the slot occupied by the 
HeaD of the lexical frame (i.e., the verb) and usu-
ally additional slots. The language-specific pa-
rameters LS and RS are defined in the lexical en-
tries of complement-taking verbs, and dictate how 
(part of) the feature structure associated with the 
foot of S-CMP-S segments gets instantiated. For 
instance, the lexical entry for know (Figure 1) 
states that LS=1 if the complement clause is finite 
and declarative. This causes the two S-nodes of the 
CoMPlement segment to share one left-peripheral 
slot, i.e. F1. If the complement happens to be inter-
rogative (as in We know who Dana hates), LS=0, 
implying that the F1 slots do not share their con-
tents and who cannot 'escape' from its clause. 
In the remainder of this Section we present a 
rule system for lateral topology that is couched in a 
typed feature logic and uses HPSG terminology. 
The system deals with a broad variety of movement 
phenomena in English, Dutch and German. 
We define a clausal topology as a list of slot 
types serving as the value of the topology ("TPL") 
feature associated with S-nodes: 
  S [TPL ?F1t,F2t,F3t,M1t,M2t,M3t,M4t,E1t,E2t?] 
                                           
1The value of a TPL feature may be a disjunctive set of 
alternative topologies rather than a single topology. 
See the CMP-S node of Figure 3 for an example. 
As for syntactic parsing, in Harbusch & Kempen 
(2000) we describe a modified ID/LP parser that can 
compute all alternative hierarchical PG structures li-
censed by an input string. We show that such a parser 
can fill the slots of the topologies associated with any 
such structure in polynomial time.  
for English, and 
  S [TPL ?F1t,M1t,M2t,M3t,M4t,M5t,M6t,E1t,E2t?] 
for Dutch and German. Slot types are defined as 
attributes that take as value a non-branching list of 
lemmas or phrases (e.g. SUBJect-NP, CoMPle-
ment-S or HeaD-v). They are initialized with the 
value empty list, denoted by "??" (e.g., [F1t F1 ??]). 
Lists of segments can be combined by the ap-
pend operation, represented by the symbol " ?". 
The expression "L1 ?L2" represents the list com-
posed of the members of L1 followed by the mem-
bers of L2. We assume that L2 is non-empty. If L1 
is the empty list, "L1 ?L2" evaluates to L2. Slot 
types may impose constraints on the cardinality 
(number of members) of the list serving as its 
value. Cardinality constraints are expressed as sub-
scripts of the value list. E.g., the subscript "c=1" in 
[F1t F1 ??c=1] states that the list serving as F1's value 
should contain exactly one member. Cardinality 
constraints are checked after all constituents that 
need a place have been appended. 
Depending on the values of sharing parameters 
LS and RS, the list can be divided into a left area 
(comprising zero or more slot types), the central 
area (which includes at least one slot for the HeaD 
verb), and the right area (possibly empty). Topol-
ogy sharing is licensed exclusively to the lateral 
areas. LS and RS are set to zero by default; this ap-
plies to the topologies of main clauses and adver-
bial subclauses. The root S of a complement clause 
obtains its sharing parameter values from the foot 
of the S-CMP-S segment belonging to the lexical 
frame of its governing verb. For example, the lexi-
cal entry for know states that the complement of 
this verb should be instantiated with LS=1 if the 
clause type (CTYP) of the complement is declara-
tive. This causes the first member of the topologies 
associated with the S-nodes to receive a corefer-
ence tag (indicated by boxed numbers): 
S TPL  1 F1,F2,...,E2[ ]
CMP
S TPL 1 F1,F2, ...E2CTYP Decl
? 
? ? 
? 
? ?  
If, as in the example of Figure 1, know's comple-
ment is indeed declarative, the foot of the comple-
ment segment can successfully unify with the root 
of the hate frame. As a consequence, the F1 slot of 
the complement clause is the same object as the F1 
slot of the main clause, and any fillers will seem to 
have moved up one level in the clause hierarchy: 
 
S TPL 1 F1,F2,...E2CTYP Decl
? 
? ? 
? 
? ? 
S TPL F1,F2,...,E2CTYP Decl
? 
? ? 
? 
? ? 
  
? S TPL 1 F1,F2,...,E2CTYP Decl
? 
? ? 
? 
? ? 
 
Filling a slot also involves coreference tags. For 
example, the HeaDs of English verb frames obtain 
their position in the local topology by looking up 
the slot associated with the coreference tag: 
  
 S  TPL F1,...,M1 ? 1 ,...,E2[ ]
HD
 v  1 LEMMA hate[ ]  
The information associated with the foot node of 
the HeaD segment will now be appended to the 
current content, if any, of slot M1. The same 
mechanism serves to allocate the finite comple-
ment clause (or rather its root S-node) to slot E2 of 
the matrix clause: 
   S   TPL 1 F1,...,E1, E2 ? 2[ ]
CMP
   S   2 TPL 1 F1,...,E1, E2CTYP Decl_finite
? 
? ? 
? 
? ?  
Other clause constituents receive their landing site 
(cf. Table 1) in a similar manner. Figure 2 depicts 
the configuration after Fronting of NP Kim. 
Figure 3 below includes a paraphrase where the 
focus on Kim is stressed prosodically rather than 
by Fronting. This is indicated by the disjunctive set 
carrying the tag 4 . In sentence generation, the 
Read-out module selects one alternative, presuma-
bly in response to pragmatic an other context fac-
tors. In parsing mode, one or the alternatives is 
ruled out because it does not match word order in 
the input string. 
The formalism defined so far yields unordered 
hierarchical structures. However, the values of the 
TPL features enable the derivation of ordered out-
put strings of lexical items. As indicated above in 
connection with Figure 2, we assume that this task 
can be delegated to a simple Read-out module that 
traverses the clause hierarchy in a depth-first man-
ner and processes the topologies from left to right2. 
If a slot is empty, the Reader jumps to the next slot. 
If a slot contains a lexical item, it is appended to 
                                           
2 A slot may contain more than one phrase (e.g., Direct 
and Indirect OBJect in slot M3; cf. Table 1). We assume 
they have been ordered as part of the append operation, 
according to the sorting rule associated with the slot. 
the current output string and tagged as already 
processed. It follows that, if a slot happens to be 
shared with a lower topology, its contents are only 
processed at the higher clause level, i.e., undergo 
promotion. 
4. Linearization of complement clauses in 
English, Dutch and German 
The PG formalism developed above provides a 
simple quantitative linearization method capturing 
both within-clause and between-clause phenomena. 
The assignment of constituents to topology slots 
(including, e.g., scrambling in Dutch and German) 
has been dealt with in Kempen & Harbusch (in 
press; forthcoming). In the present paper we focus 
on promotion in complement constructions ? a 
domain where the three target languages exhibit 
rather dissimilar ordering patterns. We highlight 
the fact that PG enables highly similar treatments 
of them, differing only with respect to the settings 
of some quantitative parameters. 
The movement (promotion) phenomena at issue 
here depend primarily on the values assigned to 
sharing parameters LS and RS in five different 
types of complement clauses. These settings are 
shown Table 2. They are imported from the lexi-
con and control the instantiation of the TPL feature 
of the root S-node of the complement. We begin 
with some illustrations from English. 
Table 2. Size of the left- and right-peripheral shared 
topology areas (LS and RS) in diverse complement 
constructions. 
Clause type English Dutch German 
Interrogative LS=0 
RS=0 
LS=0 
RS=1 
LS=0 
RS=1 
Declarative & Finite LS=1 
RS=0 
LS=1 
RS=1 
LS=1 
RS=1 
Decl. & Non-Finite, 
    VP Extraposition 
LS=3 
RS=0 
LS=1 
RS=1 
LS=1 
RS=1 
Decl. & Non-Finite, 
      Verb Raising 
LS=3 
RS=0 
LS=4:6 
RS=1 
LS=5 
RS=1 
Decl. & Non-Finite, 
   Third Construction    n.a. 
LS=1:6 
RS=1 
LS=1:6 
RS=1 
The non-finite complements of do and have in 
sentence (1) below are both declarative. (Cf. the 
paraphrase "For which person x is it the case that I 
have to call x", which highlights the scope of who.) 
It follows that LS=3 in both complements. Notice 
that do is treated as a 'Verb Raiser', have (in have 
to) as a VP Extraposition verb. 
Figure 3. Analysis of Kim we 
know Dana hates (cf. Figure 
1) and We know Dana hates 
Kim. The versions correspond 
to different options of the 
topology  value associated 
with the CoMPlement 
(indicated within curly 
brackets). Empty slots are not 
shown in the TPL features. 
 
(1) Who do I have to call? 
F1   M1    E1 E2 
?    do I   ?   ?       ?  
   have     ?  ?        ? 
who   to call      
In example (2), the lower clause is finite and de-
clarative ?cf. the paraphrase ?For which person x 
is it the case that you said that John saw x?. The 
scope of who exceeds its ?own? clause and includes 
the matrix clause. In (3), on the other hand, the 
scope of the interrogative pronoun does not include 
the main clause (?I know for which person x it is 
the case  that John saw x?). Therefore, the com-
plement is interrogative and cannot share its F1 
slot with that of the main clause. 
 (2) Who did you say John saw?  
F1  F3 M1 M2   E1 E2 
?    did you   ?   ?       ?  
   say     ?  
?        ? 
who  John saw      
 (3) I know who John saw 
F1  F3 M1     E2 
  I know     ?          ? 
who  John saw      
The system predicts 'island effects' as in (4).  
(4) a.  Who did you claim that you saw? 
 b.*Who did you make the claim that you saw? 
The lexical frame of the verb claim includes an 
S-CMP-S segment identical to that of know above 
(repeated here for convenience): 
   S   TPL 1 F1,...,E1, E2 ? 2[ ]
CMP
   S   2 TPL 1 F1,...,E1, E2CTYP Decl_finite
? 
? ? 
? 
? ?  
The feature matrices of root and foot nodes of this 
segment both specify a TPL feature referencing the 
slot F1. This enables insertion of coreference tag 
2  and thus promotion of the filler of slot F1. 
However, the complement segment of the noun 
claim is rooting in an NP node, which cannot have 
a TPL feature with type F1t. 
  
  NP   ...[ ]
CMP
   S   TPL 1 F1CTYP Decl_finite
? 
? ? 
? 
? ?  
So, tag   1  is meaningless here, ruling out promo-
tion in (4b). 
Turning now to Dutch, we first refer to Table 3, 
which specifies some important landing sites for 
major clause constituents. Because of the similarity 
with German, we combine the two languages. First, 
we illustrate question formation. 
Dutch interrogative main clauses feature Sub-
ject-Verb inversion without the equivalent of do-
insertion (cf. 5). 
(5) a. M1 Zag M2 je M3 dat? 
    saw      you      that 
   ?Did you see that?? 
 b. F1 Wie M1 zag M3 dat? 
     who      saw       that 
    ?Who saw that?? 
 c. F1 Wat M1 zagen M2 ze? 
   ?What did they see?? 
Because the complement in (6) is interrogative, 
the sharing rule in Table 2 prohibits left-peripheral 
sharing (LS=0). 
(6)  Zij vroeg of ik hem kende 
  She asked whether I him knew 
 ?She asked whether I knew him? 
F1 M1 M2 M3   M6  E2 
zij vroeg       ?         ? 
of  ik hem   kende   
Table 3. Examples of topology slot fillers (Dutch and 
German). Precedence between constituents landing in 
the same slot is marked by "<". 
Slot Filler 
F1 Declarative main clause: SUBJect, Topic or Focus (one constituent only)  
Interrogative main clause: Wh-constituent, 
including Du. of  and Ger. ob 'whether' 
Complement clause: Wh-constituent 
M1 Main clause: HeaD verb Complement clause: CoMPLementizeR 
     dat/om (Du.), dass (Ger.) 
M2 Subject NP (iff non-Wh), Direct Object     (iff personal pronoun) 
M3 Direct < Indirect OBJect (iff non-Wh) 
M4 PaRTicle (Du. only) 
M5 Non-finite CoMPlement of Verb Raiser 
M6 Subordinate clause:   Du.: Pre-INFinitive te < HeaD verb 
  Ger.: PaRTicle < Pre-INFinitive zu < HeaD 
E1 Non-finite Complement of Verb Raiser (Du. only) 
E2 Non-finite CoMP of VP Extraposition verb Finite Complement 
The subordinate clause in (7) features clause 
union, causing the auxiliary zal to intervene be-
tween   the  Direct hem the latter's governor bellen. 
The left-peripheral sharing area may vary between 
4 and 6 slots (LS=4:6). Because hem lands in M3, 
i.e. in the shared area, it is promoted. The remain-
der of the lower topology, including the HeaD bel-
len itself, occupies E1 ? one of the options of the 
complement of a Verb Raiser. The other option, 
with the complement in M5 (giving bellen zal) is 
also allowed. 
(7) ...dat ik hem zal bellen 
    that I him will phone 
 '...that I will phone him' 
 M1 M2  M3   M6 E1  
 dat ik ?    zal ?      ?    ?  
   hem   bellen   
Sentence (8) illustrates the treatment of 'particle 
hopping'. The positions marked by "?" are gram-
matical alternatives to the particle (op) position 
mentioned in the example; no other positions are 
allowed. Given LS=4:6 for complements of Verb 
Raisers, it follows that hem is obligatorily pro-
moted into the higher topology: 
 (8) ...dat ik hem ? zou ? hebben op gebeld 
    that I  him  would    have  up called 
 '...that I would have called him up' 
 M1 M2 M3 M4  M6 E1  
 dat ik ?    zou ?      ?    ?  
      hebben ?      ?    ?  
   hem op  gebeld   
However, sharing of the fifth slot (M4) is optional. 
If this option is realized in the middle topology, the 
order zou op hebben gebeld ensues. If, in addition, 
the middle topology shares M4 with its governor, 
the string comes out as op zou hebben gebeld. 
The treatment of cross-serial dependencies is 
exemplified in (9). In order to deal with this con-
struction, we need to make an additional assump-
tion about the order of constituents that land in the 
same slot but originate from different levels in the 
clause hierarchy. We stipulate that constituents 
from more deeply embedded clauses trail behind 
constituents belonging to higher clauses. This or-
dering can be determined locally within a slot if we 
equip every constituents in the hierarchy with a 
numerical 'clause depth' index (for instance, a Gorn 
number; Gorn, 1967). Given this index (not shown 
in the topology diagram accompanying (9)), the 
order hem de fiets results. 
 (9)  ... dat ik hem de fiets wil helpen maken 
       that I   him the bike want-to help repair 
  '... that I want to help him to repair the bike' 
 M1 M2 M3   M6 E1  
 dat ik ?  ?    wil ?      ?  ?    ?  
   hem    helpen ?          ?    ?  
   de fiets   maken   
We now turn to German, concentrating on 
structures usually labeled "VP Extraposition" (10) 
and "Third Construction" (11). 
(10)  ... dass er uns zwingt es zu tun 
      that  he us  forces  it  to  do 
  '... that he forces us to do it' 
 M1 M2   M3   M6  E2 
 dass er uns   zwingt  ?          ? 
  es    zu tun   
(11) a. ... dass er uns verspricht es zu tun 
      that  he  us   promises  it  to do 
  '... that he promises us to do it' 
 b.  ... dass er es uns zu tun verspricht 
 M1 M2 M3  M5 M6   
 dass er ?  uns   ?  verspricht        ?   ?    
      es    zu tun   
 c.  ...dass er uns es zu tun verspricht 
 M1 M2 M3  M5 M6   
 dass er uns   ?  verspricht        ?     
     es    zu tun   
 d.  ...dass er es uns verspricht zu tun 
 M1 M2 M3   M6  E2
 dass er ?  uns   verspricht  ?       ?      ? 
    es    zu tun   
 e. ? ...dass er uns es verspricht zu tun 
 M1 M2 M3   M6  E2 
 dass er uns ?    verspricht  ?           ?     ? 
     es   zu tun   
The verb zwingen allows its complement to share 
slot F1 only (LS=1). This prevents promotion of 
the Direct OBJect es. Third Construction verbs like 
versprechen allow a great deal of variation in the 
size of the left-peripherally shared topology area 
(LS=1:6), thereby licensing optional promotion of 
es. However, since es is a personal pronoun, it only 
takes M2 as its landing site (see Table 3). The lat-
ter constraint is violated in (11e). 
5. Discussion 
We have shown that the introduction of topologies 
with a fixed number of slots, in conjunction with 
cross-clause lateral topology sharing, enables a 
simple treatment of word order and movement 
(promotion) in complement structures of the three 
target languages. The considerable within- and be-
tween-language variation typical of these construc-
tions could be analyzed as resulting from different 
settings of a small number of quantitative parame-
ters, in particular the size of shared areas. We 
claim that our approach is conducive to theoretical 
parsimony (and, presumably, computational effi-
ciency). For instance, HPSG-style treatments of 
Wh-movement and Clause Union typically invoke 
very different types of mechanisms (e.g., the 
SLASH or GAP feature for WH-movement, and 
argument composition for Clause Union; cf. Sag & 
Wasow, o.c., and Kathol o.c.). 
  
Elsewhere we have provided a more fine-
grained  discussion of our approach and its psycho-
linguistic motivation (Kempen & Harbusch, in 
press; forthcoming). Future study is needed to find 
out whether the PG approach generalizes to other 
languages. 
Finally, we refer to the PG sentence generator 
for Dutch which was implemented by Camiel van 
Breugel. It covers the ordering phenomena de-
scribed here and in Kempen & Harbusch (forth-
coming) and runs under Java-enabled Internet 
browsers (www.liacs.nl/~cvbreuge/pgw). Vosse & 
Kempen (2000) describe a computational model of 
human syntactic parsing based on a PG-like for-
malism. 
References 
GORN, S. (1967). Explicit Definition and Linguistic 
Dominoes. Systems and Computer Science. To-
ronto: University of Toronto Press. 
HARBUSCH, K. & KEMPEN, G. (2000). Complexity 
of linear order computation in Performance 
Grammar, TAG and HPSG. In: Proceedings of  
Fifth International Workshop on Tree Adjoining 
Grammars and Related Formalisms (TAG+5), 
University of Paris 7, May 2000. 
JOSHI, A.K. & SCHABES, Y. (1997). Tree Adjoin-
ing Grammars. In: Rozenberg, G. & Salomaa, A. 
(Eds.), Handbook of formal languages (Vol. 3). 
Berlin: Springer. 
KATHOL, A. (2000). Linear Syntax. New York: 
Oxford University Press. 
KEMPEN, G. & HARBUSCH, K. (in press). Word 
order scrambling as a consequence of incre-
mental sentence production. In: Haertl, H., Olsen, 
S. & Tappe, H. (Eds.), The syntax-semantics in-
terface: Linguistic structures and processes. Ber-
lin: De Gruyter. 
KEMPEN, G. & HARBUSCH, K. (forthcoming). 
Dutch and German verb clusters in Performance 
Grammar. In: Seuren, P. & Kempen, G. (Eds.), 
Verb clusters in Dutch and German. Amsterdam: 
Benjamins. 
SAG, I.A. & WASOW, T. (1999). Syntactic theory: 
a formal introduction. Stanford CA: CSLI Publi-
cations. 
VOSSE, T. & KEMPEN, G. (2000). Syntactic struc-
ture assembly in human parsing: A computational 
model based on competitive inhibition and a 
lexicalist grammar. Cognition, 75, 105-143. 
ELLEIPO: A module that computes coordinative ellipsis
for language generators that don?t
Karin Harbusch
Computer Science Department
University of Koblenz-Landau
PO Box 201602, 56016 Koblenz/DE
harbusch@uni-koblenz.de
Gerard Kempen
Max Planck Institute for Psycholinguistics &
Cognitive Psychology Unit, Leiden University
PO Box 310, 6500AH Nijmegen /NL
gerard.kempen@mpi.nl
Abstract
Many current sentence generators lack
the ability to compute elliptical versions
of coordinated clauses in accordance with
the rules for Gapping, Forward and
Backward Conjunction Reduction, and
SGF (Subject Gap in clauses with Fi-
nite/Fronted verb). We describe a module
(implemented in JAVA, with German
and Dutch as target languages) that takes
non-elliptical coordinated clauses as in-
put and returns all reduced versions li-
censed by coordinative ellipsis. It is
loosely based on a new psycholinguistic
theory of coordinative ellipsis proposed
by Kempen. In this theory, coordinative
ellipsis is not supposed to result from the
application of declarative grammar rules
for clause formation but from a proce-
dural component that interacts with the
sentence generator and may block the
overt expression of certain constituents.
1 Introduction
Coordination and coordinative ellipsis are essen-
tial tools for the sentence aggregation component
of any language generator. Very often, when the
aggregator chooses to combine several clauses
into a single coordinate structure, the need arises
to eliminate unnatural reduplications of corefer-
ential constituents.
In the literature, one often distinguishes four
major types of clause-level coordinative ellipsis:
? Gapping (as in (1)), with a special variant
called Long-Distance Gapping (LDG). In
LDG, the second conjunct consists of con-
stituents stemming from different clauses ?
in (2), the main clause and the complement.
? Forward Conjunction Reduction (FCR; cf. (3)
and the relative clause in (4)).
? SGF (Subject Gap in clauses with Finite/
Fronted verb; as in (5), and
? Backward Conjunction reduction (BCR, also
termed Right Node Raising; see (6)).
(1)Henk lives in Leiden and Chris livesg in Delft
(2)My wife wants to buy a car, my son wantsg
[to buy]gl a motorcycle.
(3)My sister lives in Utrecht and [my sister]f
works in Amsterdam
(4)Amsterdam is the city [S where Jan lives and
wheref Piet works]
(5)Why did you leave but didn?t yous warn me?
(6)Anne arrived before [three o?clock]b, and Susi
left after three o?clock
The subscripts denote the elliptical mechanism at
work: g=Gapping, gl=LDG, f=FCR, s=SGF,
b=BCR. We will not deal with VP Ellipsis and
VP Anaphora because they generate pro-forms
rather than elisions and are not restricted to coor-
dination (cf. the title of the paper).
In current sentence generators, the coordina-
tive ellipsis rules are often inextricably inter-
twined with the rules for generating non-
elliptical coordinate structures, so that they can-
not easily be ported to other grammar formalisms
? e.g., Sarkar & Joshi (1996) for Tree Adjoin-
ing Grammar; Steedman (2000) for Combinatory
Categorial Grammar; Bateman, Matthiessen &
Zeng (1999) for Functional Grammar. Genera-
tors that do include an autonomous component
for coordinative ellipsis (Dalianis, 1999; Shaw,
2002; Hielkema, 2005), use incomplete rule sets,
thus risking over- or undergeneration, and incor-
rect or unnatural output.
The module (dubbed ELLEIPO, from Greek
?????pi? ?I leave out?) we present here, is less
115
formalism-dependent and, in principle, less liable
to over- or undergeneration than its competitors.
In Section 2, we sketch the theoretical back-
ground. Section 3 and the Appendix describe our
implementation, with examples from German.
Finally, in Section 4, we discuss the prospects of
extending the module to additional constructions.
2 Some theoretical background
ELLEIPO is loosely based on Kempen?s
(subm.) psycholinguistically motivated syntactic
theory of clausal coordination and coordinative
ellipsis. It departs from the assumption that the
generator?s strategic (conceptual, pragmatic)
component is responsible for selecting the con-
cepts and conceptual structures that enable iden-
tification of discourse referents (except in case of
syntactically conditioned pronominalization).
The strategic component may conjoin two or
more clauses into a coordination and deliver as
output a non-reduced sequence of conjuncts.1
The concepts in these conjuncts are adorned with
reference tags, and identical tags express
coreferentiality.2
Structures of this kind serve as input to the
(syn)tactical component of the generator, where
they are grammatically encoded (lexicalized and
given syntactic form) without any form of coor-
dinative ellipsis. The resulting non-elliptical
structures are input to ELLEIPO, which computes
and executes options for coordinative ellipsis.
ELLEIPO?s functioning is based on the as-
sumption that coordinative ellipsis does not re-
sult from the application of declarative grammar
rules for clause formation but from a procedural
component that interacts with the sentence gen-
erator and may block the overt expression of cer-
tain constituents. Due to this feature, ELLEIPO
can be combined, at least in principle, with vari-
ous grammar formalisms. However, this advan-
tage is not entirely gratis: The module needs a
formalism-dependent interface that converts gen-
1The strategic component is also supposed to apply rules of
logical inference yielding the conceptual structures that
underlie ?respectively coordinations.? Hence, the conver-
sion of clausal into NP coordination (such as Anne likes
biking and Susi likes skating into Anne and Susi like bik-
ing and skating, respectively is supposed to arise in the
strategic, not the (syn)tactical component of the generator.
This also applies to simpler cases without respectively,
such as John is skating and Peter is skating versus John
and Peter are skating. The module presented here does
not handle these conversions (see Reiter & Dale (2000,
pp. 133-139) for examples and possible solutions.)
2Coordinative ellipsis is insensitive to the distinction be-
tween ?strict? and ?sloppy? (token- vs. type-)identity.
erator output to a (simple) canonical form.
3 A sketch of the algorithm
This sketch presupposes and-coordinations of
only n=2 conjuncts. Actually, ELLEIPO handles
and-coordinations with n!2 conjuncts if, in every
pair of conjuncts, the major constituents embody
the same pattern of coreferences and contrasts.
ELLEIPO takes as input a non-elliptical syntac-
tic structure that should meet the following four
canonical form criteria (see Fig. 1 for the input
tree corresponding to example (7).
(7) Susi h?rte dass Hans einen Unfall hatte
Susi heard that Hans an accident had
und dassf Hansf sterben k?nnte
and that Hans die might
?Susi heard that Hans had an accident and
might die?
? Categorial (phrasal and lexical) nodes ?
bolded in Fig. 1 ? carry reference tags (pre-
sumably propagated from the generator?s strate-
gic component). E.g., the tag ?7? is attached to
the root and head nodes of both exemplars of NP
Hans in Fig. 1, indicating their coreferentiality.
For the sake of computational uniformity, we
also attach reference tags to non-referring lexical
elements. In such cases, the tags denote lexical
instead of referential identity. For instance, the
fact that the two tokens of subordinating con-
junction dass ?that? in Fig. 1 carry the same tag,
is interpreted by ELLEIPO as indicating lexical
identity. In combination with other properties,
this licenses elision of the second dass (see (7)).
? The conjuncts are sister nodes separated by
coordinating conjunctions; we call these configu-
rations coordination domains. The order of the
conjuncts and their constituents is defined.
? Every categorial node of the input tree is im-
mediately dominated by a functional node.
? Each clausal conjunct is rooted in an S-node
whose daughter nodes (immediate constituents)
are grammatical functions. Within a clausal con-
junct, all functions are represented at the same
hierarchical level. Hence, the trees are ?flat,? as
illustrated in Fig. 1, and similar to the trees in
German treebanks (NEGRA-II, TIGER).
ELLEIPO starts by demarcating ?superclauses.?
Kempen (subm.) introduced this notion in his
treatment of Gapping and LDG. An S-node domi-
nates a superclause iff it dominates the entire
sentence or a clause beginning with a sub-
ordinating conjunction (CNJ). In Fig. 1, the
strings dominated by S1, S5 and S12 are super-
Figure 1. Slightly simplified canonical form of the non-elliptical input tree underlying sentence (7).
clauses. Note that S12 includes clause S13, which
is not a superclause.
Then, ELLEIPO checks all coordination do-
mains for elision options, as follows:
? Testing for forward ellipsis: Gapping (includ-
ing LDG), FCR, or SGF. This involves inspect-
ing (recursively for every S-node) the set of im-
mediate constituents (grammatical functions) of
the two conjuncts, and their reference tags.
Complete constituents of the right-hand conjunct
may get marked for elision, depending on the
specific conditions listed in the Appendix.
? Testing for BCR. ELLEIPO checks ? word-
by-word, going from right to left ? the corefer-
ence tags of the conjuncts. As a result, complete
or partial constituents in the right-hand periphery
of the left conjunct may get marked for elision.
The final step of the module is ReadOut. Af-
ter all coordination domains have been proc-
essed, a (possibly empty) subset of the terminal
leaves of the input tree has been marked for eli-
sion. In the examples below, this is indicated by
subscript marks. E.g., the subscript ?g? attached
to esst ?eat? in (9b) indicates that Gapping is al-
lowed. ReadOut interprets the elision marks and,
in ?standard mode,? produces the shortest ellipti-
cal string(s) as output (e.g. (9c)). In ?demo
mode,? it shows individual and combined ellipti-
cal options on user request. Furthermore, auch
?too? is added in case of ?Stripping,? i.e. when
Gapping leaves only one constituent as remnant.
Example (10) illustrates a combination of
Gapping and BCR, with the three licensed ellip-
tical output strings shown in (10c). In (11), Gap-
ping combines with BCR in the subordinate
clauses. The fact that here, in contrast with (10),
the subordinate clauses do not start their own
superclauses, now licenses LDG. However,
ReadOut prevents LDG to combine with BCR,
which would have yielded the unintended string
Anne versucht B?cher und Susi Artikel.
(9) a. Wir essen ?pfel und ihr esst Birnen
?We eat apples and you(pl.) eat pears?
b.Wir essen ?pfel und ihr esstg
Birnen
c. Elliptical option:
Wir essen ?pfel und ihr Birnen
(10)a. Ich hoffe, dass Hans schl?ft und du hoffst,
dass Peter schl?ft
?I hope that Hans sleeps and you hope that
Peter sleeps?
b. Ich hoffe dass Hans schl?ftb und
du hoffstg dass Peter schl?ft
c. Elliptical options:
Gapping: Ich hoffe, dass Hans schl?ft und
du, dass Peter schl?ft
BCR: Ich hoffe, dass Hans und du hoffst,
dass Peter schl?ft
Gapping and BCR: Ich hoffe, dass Hans
und du, dass Peter schl?ft
(11)a.Anne versucht B?cher zu schreiben and
Susi versucht Artikel zu schreiben
?Anne tries to write books and Susi tries
to write articles?
b. Anne versucht B?cher zub
schreibenb und Susi versuchtg
Artikel zugl schreibengl
c. Elliptical options:
Gapping: Anne versucht B?cher zu
schreiben und Susi Artikel zu schreiben
BCR: Anne versucht B?cher und Susi
versucht Artikel zu schreiben
Gapping and BCR: Anne versucht
B?cher und Susi Artikel zu schreiben
LDG: Anne versucht B?cher zu schreiben
und Susi Artikel
117
4 Conclusion
Currently, ELLEIPO can handle all major types of
clausal coordinative ellipsis in German and
Dutch. However, further finetuning of the rules
is needed, e.g., in order to take subtle semantic
conditions on SGF and Gapping into account.
We expect further improvements by allowing for
interactions between the ellipsis module and the
generator?s pronominalization strategy. Work on
porting ELLEIPO to related languages, in particu-
lar English, and to coordinations of non-clausal
constituents (NP, PP, AP) is in progress.
References
John A. Bateman, Christian M.I.M. Matthiessen
& Licheng Zeng (1999). Multilingual natural
language generation for multilingual software:
a functional linguistic approach. Applied Arti-
ficial Intelligence, 13, 607?639.
Ehud Reiter & Robert Dale (2000). Building
natural language generation systems. Cam-
bridge UK: Cambridge University Press.
Hercules Dalianis, (1999). Aggregation in natu-
ral language generation. Computational Intel-
ligence, 15, 384?414.
Feikje Hielkema (2005). Performing syntactic
aggregation using discourse structures. Un-
published Master?s thesis, Artificial Intelli-
gence Unit, University of Groningen.
Gerard Kempen (subm.). Symmetrical clausal
coordination and coordinative ellipsis as in-
cremental updating. Downloadable from:
www.gerardkempen.nl/publicationfiles
Anoop Sarkar & Aravind Joshi (1996). Coordi-
nation in Tree Adjoining Grammars: Formal-
ization and implementation. In: Procs. of
COLING 1996, Copenhagen, pp. 610?615.
James Shaw (1998). Segregatory coordination
and ellipsis in text generation. In: Procs. of
COLING 1998,Montreal, pp. 1220?1226.
Mark Steedman (2000). The syntactic process.
Cambridge MA: MIT Press.
Appendix: A sketch of the algorithm
1 proc ELLEIPO(SENT) {
2 mark root nodes of all superclauses in SENT;
3 for all coordinators and their left- and right-
neighboring clauses (LCONJ, RCONJ) {
4 call GAP(LCONJ, RCONJ, ?g?); // string ?g?
gets an ?l? attached for any level of LDG; the
resulting string is attached, in line 9 of GAP, to
leaves that ReadOut interprets as elidable//
5 FCRcontrol=TRUE; BCRcontrol=TRUE;
//global variables communicating the end of
left- or right-peripheral identical strings//
6 call FCR(LCONJ, RCONJ);
7 call SGF(LCONJ, RCONJ);
8 call BCR(LCONJ, RCONJ);};
9 call ReadOut();}
1 proc GAP(LC, RC, ELLIM) {//ELLIM records
the ?elliptical mechanism(s)? applied: ?g? for
Gapping; ?gl?, ?gll?, etc., for LDG levels//
2 check whether the HEAD verb of LC and the
HEAD verb of RC have the same reference tag;
3 if not then return; //verbs differ=>no gapping//
4 check whether all other constituents in LC have a
counterpart in RC with same grammatical function,
not necessarily at the same left-to-right position;
modifiers need identical mod-type;
5 if not then return; // no proper set of contrastive
pairs of immediate constituents found//
6 for all pairs (LSIB, RSIB) resulting from (4) {
7 if (LSIB is an S-node) & (LSIB is not a super-
clause root) then {//LSIB = ?left sibling?//
8 if (LSIB and RSIB are not coreferential)
9 then attach ?l? to ELLIM;//LDG variant//
10 call GAP(LSIB, RSIB, ELLIM);}
11 if NOT((LSIB is an S-node) & (LSIB and RSIB
are coreferential))
12 then mark RSIB for elision, with ELLIM;}}
1 proc FCR(LC, RC) {
2 while (FCRcontrol) {
3 set LSIB and RSIB to left-most daughter of LC
and RC, resp.;
4 if (LSIB and RSIB are not coreferential)
5 then {FCRcontrol = FALSE;
6 return;}
7 if (LSIB is an S-node)
8 then call FCR(LSIB, RSIB);
9 call FCR(right neighbor of LSIB, right neigh-
bor of RSIB);
10 mark RSIB for elision by adding ?f?;}}
1 proc SGF(LC, RC) {
2 if (NOT(SUBJ is 1st daughter of LC)) & (HEAD
is 2nd daughter of LC) & (SUBJ is 1st or 2nd
daughter of RC) & (HEAD is 1st or 2nd daughter
of RC)
3 then mark RC?s SUBJ for elision, with ?s?;}
1 proc BCR(LC, RC) {
2 while (BCRcontrol) {
3 set LSIB and RSIB to right-most daughter node
of LC and RC, respectively;
4 if (LSIB and RSIB are not coreferential)
5 then {BCRcontrol = FALSE; return;};
6 call BCR(LSIB, RSIB);
7 call BCR(left neighbor of LSIB, left neighbor
of RSIB);
8 if (RSIB is a terminal node)
9 then mark LSIB for elision, with ?b?;}}
118
Proceedings of the Fourth International Natural Language Generation Conference, pages 9?11,
Sydney, July 2006. c?2006 Association for Computational Linguistics
A generation-oriented workbench for Performance Grammar: Capturing linear order variability in German and Dutch 
Karin Harbusch1, Gerard Kempen2,3, Camiel van Breugel3, Ulrich Koch1 1Universit?t Koblenz- Landau, Koblenz {harbusch, koch} @uni-koblenz.de 
2Max Planck Institute for Psycholinguistics, Nijmegen gerard.kempen@mpi.nl 
3Department of Psychology, Leiden University cvbreuge@liacs.nl 
   
   Abstract We describe a generation-oriented workbench for the Performance Grammar (PG) formalism, highlighting the treatment of certain word order and movement constraints in Dutch and German. PG enables a simple and uni-form treatment of a heterogeneous col-lection of linear order phenomena in the domain of verb constructions (variably known as Cross-serial De-pendencies, Verb Raising, Clause Un-ion, Extraposition, Third Construction, Particle Hopping, etc.). The central data structures enabling this feature are clausal ?topologies?: one-dimensional arrays associated with clauses, whose cells (?slots?) provide landing sites for the constituents of the clause. Move-ment operations are enabled by unifica-tion of lateral slots of topologies at ad-jacent levels of the clause hierarchy. The PGW generator assists the gram-mar developer in testing whether the implemented syntactic knowledge al-lows all and only the well-formed per-mutations of constituents. 1 Introduction Workbenches for natural-language grammar formalisms typically provide a parser to test whether given sentences are treated adequately ? D-PATR for Unification Grammar (Kart-tunen, 1986) or XTAG for Tree-Adjoining Grammars (Paroubek et al, 1992) are early examples. However, a parser is not a conven-ient tool for checking whether the current grammar implementation licenses all and only the strings qualifying as well-formed expres-sions of a given input. Sentence generators that 
try out all possible combinations of grammar rules applicable to the current input, are better suited. Few workbenches in the literature come with such a facility. LinGO (Copestake & Flickinger, 2000), for Head-Driven Phrase Structure Grammar, provides a generator in addition to a parser. For Tree Adjoining Grammars, several workbenches with genera-tion components have been built: InTeGenInE (Harbusch & Woch, 2004) is a recent example.  Finetuning the grammar such that it neither over- nor undergenerates, is a major problem for semi-free word order languages (e.g., Ger-man; cf. Kallmeyer & Yoon, 2004). Working out a satisfactory solution to this problem is logically prior to designing a generator capable of selecting, from the set of all possible para-phrases, those that sound ?natural,? i.e., the ones human speakers/writers would choose in the situation at hand (cf. Kempen & Harbusch, 2004). Verb constructions in German and Dutch exhibit extremely intricate word order patterns (cf. Seuren & Kempen, 2003). One of the fac-tors contributing to this complexity is the phe-nomenon of clause union, which allows con-stituents of a complement clause to be inter-spersed between those of the dominating clause. The resulting sequences exhibit, among other things, cross-serial dependencies and clause-final verb clusters. Further complica-tions arise from all sorts of ?movement? phe-nomena such as fronting, extraction, disloca-tion, extraposition, scrambling, etc. Given the limited space available, we cannot describe the Performance Grammar (PG) formalism and the linearization algorithm that enables generating a broad range of linear order phenomena in Dutch, German, and English verb construc-tions. Instead, we refer to Harbusch & Kempen (2002), and Kempen & Harbusch (2002, 2003). 
9
Here, we present the generation-oriented PG Workbench (PGW), which assists grammar developers, among other things, in testing whether the implemented syntactic and lexical knowledge allows all and only well-formed permutations. In Section 2, we describe PG?s topology-based linearizer implemented in the PGW gen-erator, whose software design is sketched in Section 3. Section 4 shows the PGW at work and draws some conclusions. 2 Linearization in PG and PGW Performance Grammar (PG) is a fully lexical-ized grammar that belongs to the family of tree substitution grammars and deploys disjunctive feature unification as its main structure build-ing mechanism. It adheres to the ID/LP format (Immediate Dominance vs. Linear Precedence) and includes separate components generating the hierarchical and the linear structure of sen-tences. Here, we focus on the linearization component. PG's hierarchical structures consist of unor-dered trees composed of elementary building blocks called lexical frames. Every word is head of a lexical frame, which specifies the subcategorization constraints of the word. As-sociated with every lexical frame is a topology. Topologies serve to assign a left-to-right order to the branches of lexical frames. In this paper, we will only be concerned with topologies for verb frames (clauses). We assume that clausal topologies of Dutch and German contain ex-actly nine slots ? see (1).  (1) Wat wil je dat ik doe? / what want you that I do /?What do you want me to do??   F1 M1 M2 ? M6 E1 E2   ? wil je    ?   ?       ?  Wat dat ik   doe  The slot labeled F1 makes up the Forefield (from Ger. Vorfeld); slots M1-M6 make up the Midfield (Mittelfeld); slots E1 and E2 define the Endfield (Nachfeld). Every constituent (subject, head, direct object, complement, etc.) has a small number of placement options, i.e. slots in the topology associated with its ?own? clause. How is the Direct Object NP wat ?what? 'extracted' from the complement clause and ?promoted? into the main clause? Movement of phrases between clauses is due to lateral to-
pology sharing. If a sentence contains more than one verb, each of their lexical frames in-stantiates its own topology. This applies to verbs of any type ? main, auxiliary or copula. In such cases, the topologies  are allowed to share identically labeled lateral (i.e. left- and/or right-peripheral) slots, conditionally upon several restrictions (not to be explained here; but see Harbusch & Kempen, 2002)). After two slots have been shared, they are no longer distinguishable; in fact, they are unified and become the same object. In example (1), the embedded topology shares its F1 slot with the F1 slot of the matrix clause. This is indi-cated by the dashed borders of the bottom F1 slot. Sharing the F1 slots effectively causes the embedded Direct Object wat to be preposed into the main clause (black dot in F1 above the single arrow in (1)). The dot in E2 above the double arrow marks the position selected by the finite complement clause. The overt surface order is determined by a read-out module that traverses the hierarchy of topologies in left-to-right, depth first manner. E.g., wat is already seen while the reader scans the higher topology. 3    A sketch of PGW?s software design The PGW is a computational grammar devel-opment tool for PG. Written in Java, it comes with an advanced graphical direct-manipulation user interface. All lexical and grammatical data have been encoded in a rela-tional database schema. This contrasts with the predominance of hierarchical databases in present-day computational linguistics. Rela-tional lexical databases tend to be easier to maintain and update than hierarchical ones, especially for linguists with limited program-ming experience. The software was designed with an eye toward easy cross-language port-ability of the encoded information. For German we developed a lexicon converter that maps the German CELEX database automatically to the PGW format (Koch, 2004). 4 Generating verb constructions in Dutch and German In order to convey an impression of the capa-bilities of the PGW, we show it at work in gen-erating verb constructions that involve rather delicate linearization phenomena: ?Particle Hopping? in Dutch (2), and ?Scrambling? in German (3). 
10
The finite complement clause (2) includes the verb meezingen ?sing along with,? where   mee ?with? is a preposition functioning as sepa-rable particle. The three other verbs are auxilia-ries. According to a topology sharing rule for Dutch, clauses headed by auxiliaries are free to share 4, 5 or 6 left-peripheral slots of their own topology with that of its complement. The most restrictive sharing option is shown in (2).  (2) ...  dat   ze    dit  (lied)  zouden kunnen  hebben  meegezongen          ... that they this (song) would be-able-to have       along-sung  ?... that they might have sung along this (song)?  M1 M2 M3   M4    M6  E1   dat  ze ?   zouden ?       ?      ?        kunnen ?       ?      ?        hebben ?      ?      ?     dit lied mee  gezongen   The Direct Object NP dit (lied) ?this (song)? lands in M3 of the lowest topology. As this slot belongs to the four left-peripheral ones, it is always shared and its content gets promoted all the way up into the highest clause (see single arrows). Particle mee always lands in the fifth slot (M4), i.e. in the optionally shared area. Hence, its surface position depends on the ac-tual number of shared left-peripheral slots. In (2), with minimal slot sharing, mee stays in its standard position immediately preceding the head verb. In case of non-minimal topology sharing, the particle may move leftward until (but no farther than) the direct object, thus yielding exactly the set of grammatical place-ment options. The quality of PGW?s treatment of Scram-bling in German can be assessed in terms of a set of 30 word order variations of sentence (3), discussed by Rambow (1994), who also pro-vides grammaticality ratings for all members of the set. Seuren (2003) presents similar gram-maticality judgments obtained from an inde-pendent group of native speakers. As the rating scores appeared to vary considerably (cf. (3a) and (3b)), we checked which permutations are actually generated by the PGW. It turned out easy to find a set of topology sharing values that generates all and only the paraphrases with high or satisfactory grammaticality scores. In conclusion, although the performance data discussed here are very limited, we be-
lieve they justify positive expectations with respect to the potential of a topology-based linearizer to  approximate closely the gram-maticality judgments of native speakers and thus to avoid over- and undergeneration.  (3)  a.  ? weil niemand das Fahrrad zu reparie-ren zu versuchen verspricht        because  nobody  the   bike    to   repair       to     try          promises     ?? because nobody promises to try to re-pair the bike?   b.  *?weil zu versuchen das Fahrrad nie-mand zu reparieren verspricht References Copestake, A. and Flickinger, D. 2000. An open source grammar development environment and broad-coverage English grammar using HPSG. Procs. of the 2nd Internat. Conf. on Language Resources and Evaluation (LREC), Athens. Harbusch, K. and Kempen, G. 2002 A quantitative model of word order and movement in English, Dutch and German complement constructions. Procs. of the 19th Internat. Conf. on Computa-tional Linguistics (COLING), Taipei. Harbusch, K. and Woch, J. 2004. Integrated natural language generation with Schema-TAGs. In: Habel, C., Pechmann, T. (eds.) Language Pro-duction. Berlin: Mouton De Gruyter. Karttunen, L. 1986. D-PATR: A Development En-vironment for Unification Grammars. Tech. Rep. CSLI-86-61. CSLI, Stanford, CA. Kempen, G. and Harbusch, K. 2002 Performance Grammar: A declarative definition. In Nijholt, A., Theune, M., Hondorp, H. (eds.), Computa-tional Linguistics in the Netherlands 2001. Am-sterdam: Rodopi, 146-162. Kempen, G. and Harbusch, K. 2003.  Dutch and German verb constructions in Performance Grammar. In Seuren & Kempen, 2003. Koch, U.  2004. The Specification of a German Per-formance Grammar from CELEX Data in Preparation for a German Performance Gram-mar Workbench,  Master's Thesis at the Com-puter Science Department, U. Koblenz-Landau. Paroubek, P., Schabes, Y., and Joshi, A.K. 1992.  XTAG ? A Graphical Workbench for Develop-ing Tree-Adjoining Grammars. Procs. of the 3rd Applied Natural Language Processing Confer-ence (ANLP), Trento, 216-223. Rambow, O. 1994. Formal and Computational As-pects of Natural Language Syntax. Ph.D. Thesis, U. Pennsylvania, Philadelphia. Seuren, P.A.M. 2003. Verb clusters and branching directionality in German and Dutch. In (Seuren & Kempen, 2003), 247-296. Seuren, P. and Kempen, G. (eds.). 2003. Verb Con-structions in Dutch and German. Amsterdam: Benjamins. 
11
